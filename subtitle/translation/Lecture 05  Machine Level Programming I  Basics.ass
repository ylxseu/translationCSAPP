[Script Info]
; Script generated by Aegisub r8942
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: csapp/Lecture 05  Machine Level Programming I  Basics.mp4
Video File: csapp/Lecture 05  Machine Level Programming I  Basics.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 783
Active Line: 784
Video Position: 57819

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Noto Sans CJK SC Black,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,1.5,1.2,2,10,10,10,1
Style: Chinese,Noto Sans CJK SC Black,40,&H00FFFF00,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.2,1.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:02.82,English,,0,0,0,,Good afternoon everyone
Dialogue: 0,0:00:00.00,0:00:02.82,Chinese,,0,0,0,,大家下午好
Dialogue: 0,0:00:05.48,0:00:10.40,English,,0,0,0,,So now we're going to jump into the part of the course that I'd call the real core of course
Dialogue: 0,0:00:05.48,0:00:10.40,Chinese,,0,0,0,,所以现在我们将跳到课程的真正核心部分
Dialogue: 0,0:00:10.40,0:00:14.32,English,,0,0,0,,Where we go into machine level programming
Dialogue: 0,0:00:10.40,0:00:14.32,Chinese,,0,0,0,,我们将深入学习机器级编程
Dialogue: 0,0:00:14.32,0:00:17.18,English,,0,0,0,,And by the term machine level programming I mean
Dialogue: 0,0:00:14.32,0:00:17.18,Chinese,,0,0,0,,当我说「机器级编程」这个术语时，我的意思是
Dialogue: 0,0:00:17.70,0:00:26.24,English,,0,0,0,,When you're actually considering the individual instructions to get executed by the machine in response to your program
Dialogue: 0,0:00:17.70,0:00:26.24,Chinese,,0,0,0,,你关心计算机为了运行你的程序，所执行的一串独立的指令
Dialogue: 0,0:00:26.54,0:00:29.64,English,,0,0,0,,And there's really two forms of machine programs
Dialogue: 0,0:00:26.54,0:00:29.64,Chinese,,0,0,0,,实际上有两种形式的机器程序
Dialogue: 0,0:00:29.64,0:00:33.44,English,,0,0,0,,One is the actual object code that runs on the computer
Dialogue: 0,0:00:29.64,0:00:33.44,Chinese,,0,0,0,,一个是在计算机上运行的实际目标代码
Dialogue: 0,0:00:33.62,0:00:39.92,English,,0,0,0,,And as we'll see that's a series of bytes that encode instructions that the processor executes
Dialogue: 0,0:00:33.62,0:00:39.92,Chinese,,0,0,0,,正如我们将看到的那样，（目标代码）是一串字节，编码处理器执行的指令
Dialogue: 0,0:00:40.46,0:00:48.40,English,,0,0,0,,But well,because it's hard to look at bytes and understand them there's various text forms to make it more clear
Dialogue: 0,0:00:40.46,0:00:48.40,Chinese,,0,0,0,,但是，因为很难通过观察字节去并理解含义，它有许多更清晰的文本形式
Dialogue: 0,0:00:48.88,0:00:54.86,English,,0,0,0,,And one of  those is assembly code that used to be that's how people program machines
Dialogue: 0,0:00:48.88,0:00:54.86,Chinese,,0,0,0,,其中一种是汇编代码，过去是人们用它对于机器进行编程
Dialogue: 0,0:00:54.86,0:01:00.10,English,,0,0,0,,And nowadays it's what the target of a compiler is to generate assembly code
Dialogue: 0,0:00:54.86,0:01:00.10,Chinese,,0,0,0,,而现在，生成汇编代码是编译器的目标
Dialogue: 0,0:01:00.40,0:01:01.86,English,,0,0,0,,And I'll use those terms
Dialogue: 0,0:01:00.40,0:01:01.86,Chinese,,0,0,0,,我将使用这些专有名词
Dialogue: 0,0:01:01.86,0:01:10.12,English,,0,0,0,,When I say machine code,I sort of interchangeably mean object code the binary form or assembly code the text version of it
Dialogue: 0,0:01:01.86,0:01:10.12,Chinese,,0,0,0,,当我说机器代码时，我有时候指的是目标代码，有时候指的是文本格式的汇编代码
Dialogue: 0,0:01:10.58,0:01:14.58,English,,0,0,0,,Interchangeably because it really is a one-to-one mapping between them
Dialogue: 0,0:01:10.58,0:01:14.58,Chinese,,0,0,0,,这两者可互换，因为它们之间的映射是一对一的
Dialogue: 0,0:01:14.76,0:01:19.56,English,,0,0,0,,But in case,I sort of use a term like assembly code
Dialogue: 0,0:01:14.76,0:01:19.56,Chinese,,0,0,0,,但以防万一，我倾向于使用「汇编代码」
Dialogue: 0,0:01:19.76,0:01:22.76,English,,0,0,0,,When I instead of consistently saying machine code
Dialogue: 0,0:01:19.76,0:01:22.76,Chinese,,0,0,0,,而不是一直说「机器代码」
Dialogue: 0,0:01:22.78,0:01:25.14,English,,0,0,0,,It's because they're really the same general idea
Dialogue: 0,0:01:22.78,0:01:25.14,Chinese,,0,0,0,,这是因为他们真的是同一个概念
Dialogue: 0,0:01:26.12,0:01:29.56,English,,0,0,0,,So this is sort of one place where
Dialogue: 0,0:01:26.12,0:01:29.56,Chinese,,0,0,0,,所以在本节课程中
Dialogue: 0,0:01:29.94,0:01:35.50,English,,0,0,0,,This course 213/513 takes a particular perspective
Dialogue: 0,0:01:29.94,0:01:35.50,Chinese,,0,0,0,,本课程 213/513 采用了特殊的教学角度
Dialogue: 0,0:01:35.50,0:01:38.72,English,,0,0,0,,That's very different from done ever elsewhere
Dialogue: 0,0:01:35.50,0:01:38.72,Chinese,,0,0,0,,与其他地方的做法截然不同
Dialogue: 0,0:01:39.18,0:01:41.54,English,,0,0,0,,In the bad old days of computing
Dialogue: 0,0:01:39.18,0:01:41.54,Chinese,,0,0,0,,在过去的计算机编程的糟糕时期
Dialogue: 0,0:01:42.02,0:01:46.74,English,,0,0,0,,You would be required to take a course it was typically called assembly level programming
Dialogue: 0,0:01:42.02,0:01:46.74,Chinese,,0,0,0,,你必须参加一个通常称为「汇编级编程」的课程
Dialogue: 0,0:01:47.34,0:01:50.26,English,,0,0,0,,The way you actually learn to write programs in assembler
Dialogue: 0,0:01:47.34,0:01:50.26,Chinese,,0,0,0,,在这个课程中学习用汇编语言编写程序的方式
Dialogue: 0,0:01:50.74,0:01:58.52,English,,0,0,0,,And your assignments would be to do things like to sort a array of numbers
Dialogue: 0,0:01:50.74,0:01:58.52,Chinese,,0,0,0,,你的课后作业就是做一些数字排序
Dialogue: 0,0:01:58.52,0:02:03.30,English,,0,0,0,,Who set up some kind of linked list data structure  just sort of low-level programming
Dialogue: 0,0:01:58.52,0:02:03.30,Chinese,,0,0,0,,设置某种链表数据结构，等等的低级编程
Dialogue: 0,0:02:03.30,0:02:06.94,English,,0,0,0,,That nowadays you wouldn't even think of wanting to write an assembly code
Dialogue: 0,0:02:03.30,0:02:06.94,Chinese,,0,0,0,,现在你们（学生）可能都不想要写汇编语言
Dialogue: 0,0:02:07.68,0:02:12.34,English,,0,0,0,,And so people didn't really enjoy those courses very well
Dialogue: 0,0:02:07.68,0:02:12.34,Chinese,,0,0,0,,人们并不十分喜欢这些课程
Dialogue: 0,0:02:12.66,0:02:15.32,English,,0,0,0,,And so they got sort of our we cut out of the curriculum
Dialogue: 0,0:02:12.66,0:02:15.32,Chinese,,0,0,0,,所以他们想让我们取消这些课程
Dialogue: 0,0:02:15.76,0:02:17.88,English,,0,0,0,,But what our version of it is...
Dialogue: 0,0:02:15.76,0:02:17.88,Chinese,,0,0,0,,但我们的版本是什么......
Dialogue: 0,0:02:18.26,0:02:20.78,English,,0,0,0,,This is pretty important stuff to know
Dialogue: 0,0:02:18.26,0:02:20.78,Chinese,,0,0,0,,这（机器级编程）是非常重要的事情，你要了解它
Dialogue: 0,0:02:21.12,0:02:25.98,English,,0,0,0,,As the sort of gateway between what's how you write your programs
Dialogue: 0,0:02:21.12,0:02:25.98,Chinese,,0,0,0,,作为一个桥梁，连接你编写的程序
Dialogue: 0,0:02:25.98,0:02:28.20,English,,0,0,0,,And C or any other language
Dialogue: 0,0:02:25.98,0:02:28.20,Chinese,,0,0,0,,使用 C 语言或任何其他语言
Dialogue: 0,0:02:28.58,0:02:31.40,English,,0,0,0,,And how those programs actually execute on a machine
Dialogue: 0,0:02:28.58,0:02:31.40,Chinese,,0,0,0,,和这些程序如何实际的在机器上运行的
Dialogue: 0,0:02:32.08,0:02:35.30,English,,0,0,0,,So machine code is sort of the intermediate form there
Dialogue: 0,0:02:32.08,0:02:35.30,Chinese,,0,0,0,,所以机器代码就是那种中间形式
Dialogue: 0,0:02:35.30,0:02:39.46,English,,0,0,0,,The intermediate language and you need to understand that to understand better
Dialogue: 0,0:02:35.30,0:02:39.46,Chinese,,0,0,0,,中间语言，你需要了解，以便更好地理解
Dialogue: 0,0:02:39.74,0:02:41.86,English,,0,0,0,,What your programs are trying to do
Dialogue: 0,0:02:39.74,0:02:41.86,Chinese,,0,0,0,,你的程序正在尝试做什么
Dialogue: 0,0:02:42.32,0:02:44.84,English,,0,0,0,,And what the machine is trying to do
Dialogue: 0,0:02:42.32,0:02:44.84,Chinese,,0,0,0,,机器正在尝试做什么
Dialogue: 0,0:02:45.60,0:02:49.18,English,,0,0,0,,So as a result of that our perspective will be
Dialogue: 0,0:02:45.60,0:02:49.18,Chinese,,0,0,0,,作为我们的教学角度的结果，我们的目标是
Dialogue: 0,0:02:49.18,0:02:52.72,English,,0,0,0,,We won't actually write except in very very small amounts
Dialogue: 0,0:02:49.18,0:02:52.72,Chinese,,0,0,0,,除非数量非常少，否则我们实际上不会写代码
Dialogue: 0,0:02:53.22,0:02:57.32,English,,0,0,0,,We're not going to actually sit down and write assembly programs in this course
Dialogue: 0,0:02:53.22,0:02:57.32,Chinese,,0,0,0,,我们不打算在本课程中坐下来编写汇编程序
Dialogue: 0,0:02:57.96,0:03:01.04,English,,0,0,0,,But what you'll do is,you're going to look at a lot of code
Dialogue: 0,0:02:57.96,0:03:01.04,Chinese,,0,0,0,,但你要做的是，你要看很多代码
Dialogue: 0,0:03:01.38,0:03:04.38,English,,0,0,0,,That was generated by a C compiler GCC
Dialogue: 0,0:03:01.38,0:03:04.38,Chinese,,0,0,0,,这是由 C 编译器 GCC 生成的
Dialogue: 0,0:03:05.08,0:03:11.04,English,,0,0,0,,And try to see how does that what came out of that compiler relate to what went into it
Dialogue: 0,0:03:05.08,0:03:11.04,Chinese,,0,0,0,,并试着看看那个编译器产生的结果与输入它的内容有什么关系
Dialogue: 0,0:03:11.04,0:03:18.72,English,,0,0,0,,How does this low-level code implement the higher level constructs
Dialogue: 0,0:03:11.04,0:03:18.72,Chinese,,0,0,0,,低级的代码如何实现更高级别的程序构造
Dialogue: 0,0:03:18.72,0:03:21.70,English,,0,0,0,,That I was trying to express my program in
Dialogue: 0,0:03:18.72,0:03:21.70,Chinese,,0,0,0,,那些我在程序中试图表现的
Dialogue: 0,0:03:22.28,0:03:26.92,English,,0,0,0,,How our procedures functions implemented in machine language
Dialogue: 0,0:03:22.28,0:03:26.92,Chinese,,0,0,0,,我们的过程函数如何在机器语言中实现
Dialogue: 0,0:03:26.92,0:03:29.91,English,,0,0,0,,How our data structures such as arrays and struts
Dialogue: 0,0:03:26.92,0:03:29.91,Chinese,,0,0,0,,我们的数据结构，如数组和结构体
Dialogue: 0,0:03:30.52,0:03:33.92,English,,0,0,0,,How are those implemented in machine codes
Dialogue: 0,0:03:30.52,0:03:33.92,Chinese,,0,0,0,,这些是如何在机器代码中实现的
Dialogue: 0,0:03:33.92,0:03:35.60,English,,0,0,0,,So we're going to learn all of that stuff
Dialogue: 0,0:03:33.92,0:03:35.60,Chinese,,0,0,0,,所以我们将学习所有这些东西
Dialogue: 0,0:03:35.96,0:03:39.14,English,,0,0,0,,And it takes a significant chunk of this course
Dialogue: 0,0:03:35.96,0:03:39.14,Chinese,,0,0,0,,它占据了这个课程的很大一部分
Dialogue: 0,0:03:39.58,0:03:42.38,English,,0,0,0,,And a fair number of lectures to get through all that material
Dialogue: 0,0:03:39.58,0:03:42.38,Chinese,,0,0,0,,还有相当数量的讲座来完成所有这些材料
Dialogue: 0,0:03:42.38,0:03:43.56,English,,0,0,0,,Because it's really quite a bit
Dialogue: 0,0:03:42.38,0:03:43.56,Chinese,,0,0,0,,因为它真的很多
Dialogue: 0,0:03:44.42,0:03:50.52,English,,0,0,0,,But I think it is like I said I think this is the sort of the core of where this course is
Dialogue: 0,0:03:44.42,0:03:50.52,Chinese,,0,0,0,,但我认为这是本课程的核心内容
Dialogue: 0,0:03:52.78,0:04:00.72,English,,0,0,0,,And as you know in this course we only look at one particular class of machines
Dialogue: 0,0:03:52.78,0:04:00.72,Chinese,,0,0,0,,正如你在本课程中所知，我们只基于一类特定的机器
Dialogue: 0,0:04:00.72,0:04:07.12,English,,0,0,0,,Even though there's many more different machine level programming possibilities out there
Dialogue: 0,0:04:00.72,0:04:07.12,Chinese,,0,0,0,,即使那里有许多不同的机器级编程语言的选择
Dialogue: 0,0:04:07.12,0:04:12.72,English,,0,0,0,,And we've chosen the intel the 64-bit version of the intel instruction set
Dialogue: 0,0:04:07.12,0:04:12.72,Chinese,,0,0,0,,我们选择了英特尔 64 位版本的 Intel 指令集
Dialogue: 0,0:04:13.46,0:04:18.50,English,,0,0,0,,So I'll go through a little bit of the history behind intel and how it got to where it is
Dialogue: 0,0:04:13.46,0:04:18.50,Chinese,,0,0,0,,所以我将介绍一下英特尔背后的历史，以及它如何到达现在的位置
Dialogue: 0,0:04:19.74,0:04:25.56,English,,0,0,0,,We'll look at through this idea of how does C code relate to assembly code machine code and so forth
Dialogue: 0,0:04:19.74,0:04:25.56,Chinese,,0,0,0,,我们将通过这个想法来了解 C 代码如何与汇编代码机器代码相关联等等
Dialogue: 0,0:04:26.36,0:04:33.94,English,,0,0,0,,We'll go through set of low-level basics that you need to understand the of what assembly code,machine code looks like
Dialogue: 0,0:04:26.36,0:04:33.94,Chinese,,0,0,0,,我们将介绍一组你需要了解的低级基础知识，机器代码看起来像什么
Dialogue: 0,0:04:34.28,0:04:40.48,English,,0,0,0,,And then we'll actually take on and look at some real code ,focusing specifically on arithmetic operations
Dialogue: 0,0:04:34.28,0:04:40.48,Chinese,,0,0,0,,然后我们将着手去做并查看一些真正的代码，特别是算术运算操作
Dialogue: 0,0:04:42.86,0:04:48.66,English,,0,0,0,,So x86 is sort of a colloquial term for intel processors
Dialogue: 0,0:04:42.86,0:04:48.66,Chinese,,0,0,0,,所以 x86 对于英特尔处理器来说是一个口头的称谓
Dialogue: 0,0:04:48.66,0:04:51.66,English,,0,0,0,,And the reason is that the first one was called the 8086
Dialogue: 0,0:04:48.66,0:04:51.66,Chinese,,0,0,0,,原因是第一个芯片被称为 8086
Dialogue: 0,0:04:52.80,0:05:01.50,English,,0,0,0,,And then they kind of skipped 81, but then they went to 8286 and so forth 8386
Dialogue: 0,0:04:52.80,0:05:01.50,Chinese,,0,0,0,,然后他们跳过了 81，随后推出了 8286 、8386 等等
Dialogue: 0,0:05:01.56,0:05:06.84,English,,0,0,0,,So the one thing in common was 86  and so people just call it x86
Dialogue: 0,0:05:01.56,0:05:06.84,Chinese,,0,0,0,,所以共同点是都有 86，所以人们只称它为 x86
Dialogue: 0,0:05:07.74,0:05:13.78,English,,0,0,0,,And one thing that's important to this and it will have influence on what the programs look like is
Dialogue: 0,0:05:07.74,0:05:13.78,Chinese,,0,0,0,,有一点对此非常重要，它会对程序的外观产生影响
Dialogue: 0,0:05:14.28,0:05:17.06,English,,0,0,0,,x86 is a language like english
Dialogue: 0,0:05:14.28,0:05:17.06,Chinese,,0,0,0,,x86 是一种像英语的语言
Dialogue: 0,0:05:17.18,0:05:24.76,English,,0,0,0,,That it's been an accrual and evolution of different features layered on top of each other
Dialogue: 0,0:05:17.18,0:05:24.76,Chinese,,0,0,0,,它的特性不断发展，进化，不同特性相互叠加
Dialogue: 0,0:05:25.30,0:05:27.84,English,,0,0,0,,And not always the most elegant way
Dialogue: 0,0:05:25.30,0:05:27.84,Chinese,,0,0,0,,并不总是按照最优雅的方式
Dialogue: 0,0:05:28.24,0:05:32.70,English,,0,0,0,,So just like english there's all these sort of quirky things
Dialogue: 0,0:05:28.24,0:05:32.70,Chinese,,0,0,0,,所以就像英语一样，有许多古怪的东西
Dialogue: 0,0:05:32.70,0:05:35.80,English,,0,0,0,,That how you write it is very different from how you pronounce it
Dialogue: 0,0:05:32.70,0:05:35.80,Chinese,,0,0,0,,写出来的方式和发音的方式不同
Dialogue: 0,0:05:36.04,0:05:38.16,English,,0,0,0,,Then there's all these irregular cases
Dialogue: 0,0:05:36.04,0:05:38.16,Chinese,,0,0,0,,然后是许多不规则的情况
Dialogue: 0,0:05:38.50,0:05:41.94,English,,0,0,0,,It doesn't make sense it's not sort of a purpose-designed language
Dialogue: 0,0:05:38.50,0:05:41.94,Chinese,,0,0,0,,这些特性没有意义，它（英文）不是一种专门设计的语言
Dialogue: 0,0:05:42.40,0:05:44.06,English,,0,0,0,,It's the same with x86
Dialogue: 0,0:05:42.40,0:05:44.06,Chinese,,0,0,0,,x86 与它相同
Dialogue: 0,0:05:44.06,0:05:46.32,English,,0,0,0,,It's a language that just got there
Dialogue: 0,0:05:44.06,0:05:46.32,Chinese,,0,0,0,,这是一种刚刚到达那里的语言
Dialogue: 0,0:05:46.32,0:05:50.96,English,,0,0,0,,Because of a bunch of decisions that locally were probably the right thing to do
Dialogue: 0,0:05:46.32,0:05:50.96,Chinese,,0,0,0,,由于一系列公司内部认为可能是正确的决定
Dialogue: 0,0:05:50.96,0:05:52.00,English,,0,0,0,,But globally were not
Dialogue: 0,0:05:50.96,0:05:52.00,Chinese,,0,0,0,,但全球并非如此
Dialogue: 0,0:05:52.52,0:05:56.36,English,,0,0,0,,There's other instruction sets that are much cleaner and easier to understand
Dialogue: 0,0:05:52.52,0:05:56.36,Chinese,,0,0,0,,还有其他更清晰，更易于理解的指令集
Dialogue: 0,0:05:56.70,0:06:04.00,English,,0,0,0,,But we figure it's just the same reason that you learn english instead of learning esperanto or something like that
Dialogue: 0,0:05:56.70,0:06:04.00,Chinese,,0,0,0,,但我们认为这与你学习英语而不是学习世界语或类似的东西的原因相同
Dialogue: 0,0:06:04.46,0:06:06.44,English,,0,0,0,,That it's a much more useful language
Dialogue: 0,0:06:04.46,0:06:06.44,Chinese,,0,0,0,,这是一种更有用的语言
Dialogue: 0,0:06:09.18,0:06:12.28,English,,0,0,0,,x86 is what sometimes was called a CISC
Dialogue: 0,0:06:09.18,0:06:12.28,Chinese,,0,0,0,,x86 有时被称为 CISC
Dialogue: 0,0:06:12.90,0:06:19.84,English,,0,0,0,,There's a big thing in the early 80s.80s in general called RISC vs. CISC
Dialogue: 0,0:06:12.90,0:06:19.84,Chinese,,0,0,0,,在 80 年代早期有一件大事，80 年代又被称作 RISC 和 CISC 大战年代
Dialogue: 0,0:06:20.46,0:06:23.90,English,,0,0,0,,CISC uh well RISC was a relatively new idea
Dialogue: 0,0:06:20.46,0:06:23.90,Chinese,,0,0,0,,RISC 是一个相对较新的想法
Dialogue: 0,0:06:23.90,0:06:28.54,English,,0,0,0,,What they called a reduced instruction set computer and it was all the rage
Dialogue: 0,0:06:23.90,0:06:28.54,Chinese,,0,0,0,,他们称之为精简指令集计算机，它风靡一时
Dialogue: 0,0:06:28.98,0:06:31.54,English,,0,0,0,,And nobody had a name for what came before
Dialogue: 0,0:06:28.98,0:06:31.54,Chinese,,0,0,0,,之前没有人给它们命名
Dialogue: 0,0:06:31.54,0:06:35.40,English,,0,0,0,,But the RSIC people named what came before a CISC
Dialogue: 0,0:06:31.54,0:06:35.40,Chinese,,0,0,0,,但是，RSIC 人员将之前的处理器称作 CISC
Dialogue: 0,0:06:35.96,0:06:41.24,English,,0,0,0,,For complex instruction set computer with the obvious sort of pejorative nature to that title
Dialogue: 0,0:06:35.96,0:06:41.24,Chinese,,0,0,0,,意思是复杂的指令集计算机，具有明显的贬义性质
Dialogue: 0,0:06:41.68,0:06:46.38,English,,0,0,0,,And so intel is sort of the the classic CISC architecture
Dialogue: 0,0:06:41.68,0:06:46.38,Chinese,,0,0,0,,英特尔使用的是经典的 CISC 架构
Dialogue: 0,0:06:46.38,0:06:50.90,English,,0,0,0,,Meaning it has a ton of features we're not going to even scratch the surface
Dialogue: 0,0:06:46.38,0:06:50.90,Chinese,,0,0,0,,这意味着它有很多特性，这节课的内容甚至算不上皮毛
Dialogue: 0,0:06:51.00,0:06:55.42,English,,0,0,0,,If you want it, the manual for it is two big fat books
Dialogue: 0,0:06:51.00,0:06:55.42,Chinese,,0,0,0,,如果你想了解更深入，它的手册是两本大书
Dialogue: 0,0:06:56.04,0:07:00.78,English,,0,0,0,,Which nowadays you do with pdf documents but it's still a huge amount of stuff
Dialogue: 0,0:06:56.04,0:07:00.78,Chinese,,0,0,0,,现在你使用 pdf 文件，但它仍然是一个庞大的东西
Dialogue: 0,0:07:01.18,0:07:04.38,English,,0,0,0,,Some 500 or more instructions
Dialogue: 0,0:07:01.18,0:07:04.38,Chinese,,0,0,0,,大约 500 条或更多条指令
Dialogue: 0,0:07:04.68,0:07:09.98,English,,0,0,0,,Everything from doing decimal arithmetic to even decimal floating point
Dialogue: 0,0:07:04.68,0:07:09.98,Chinese,,0,0,0,,从做十进制整数运算到甚至是十进制浮点数的一切
Dialogue: 0,0:07:09.98,0:07:12.14,English,,0,0,0,,And all kinds of goofy stuff in there
Dialogue: 0,0:07:09.98,0:07:12.14,Chinese,,0,0,0,,那里有各种愚蠢的东西
Dialogue: 0,0:07:13.38,0:07:17.24,English,,0,0,0,,But it turns out that you can kind of get a pretty good handle on it
Dialogue: 0,0:07:13.38,0:07:17.24,Chinese,,0,0,0,,但事实证明，你可以很好地把握它
Dialogue: 0,0:07:17.24,0:07:20.84,English,,0,0,0,,By focusing more on just what does the code look like that
Dialogue: 0,0:07:17.24,0:07:20.84,Chinese,,0,0,0,,通过更多地关注代码看起来是什么样的
Dialogue: 0,0:07:21.08,0:07:25.46,English,,0,0,0,,GCC is generating for the kind of programs that you typically write
Dialogue: 0,0:07:21.08,0:07:25.46,Chinese,,0,0,0,,GCC 正在为你编写的程序生成的代码
Dialogue: 0,0:07:27.62,0:07:30.06,English,,0,0,0,,And it should also realize it
Dialogue: 0,0:07:27.62,0:07:30.06,Chinese,,0,0,0,,并且应该意识到这一点
Dialogue: 0,0:07:30.70,0:07:40.36,English,,0,0,0,,It many levels of this should not have been the successful design
Dialogue: 0,0:07:30.70,0:07:40.36,Chinese,,0,0,0,,它的许多层面没有成为成功的设计
Dialogue: 0,0:07:40.36,0:07:43.30,English,,0,0,0,,Because as I said it's just got lots of stuff on there
Dialogue: 0,0:07:40.36,0:07:43.30,Chinese,,0,0,0,,因为正如我所说，那里有很多东西
Dialogue: 0,0:07:43.78,0:07:48.34,English,,0,0,0,,But intel has been such a powerful company and had so much market
Dialogue: 0,0:07:43.78,0:07:48.34,Chinese,,0,0,0,,但英特尔一直是如此强大的公司，拥有如此多的市场
Dialogue: 0,0:07:48.66,0:07:51.12,English,,0,0,0,,And such better technology
Dialogue: 0,0:07:48.66,0:07:51.12,Chinese,,0,0,0,,和更好的技术
Dialogue: 0,0:07:51.12,0:07:53.54,English,,0,0,0,,As far as semiconductors than its competitors
Dialogue: 0,0:07:51.12,0:07:53.54,Chinese,,0,0,0,,在半导体领域和竞争对手相比
Dialogue: 0,0:07:53.98,0:07:59.56,English,,0,0,0,,That's been able to kind of keep this thing alive for almost 40 years
Dialogue: 0,0:07:53.98,0:07:59.56,Chinese,,0,0,0,,英特尔从事这方面，活跃了 40 年
Dialogue: 0,0:08:00.08,0:08:01.34,English,,0,0,0,,It's pretty admirable
Dialogue: 0,0:08:00.08,0:08:01.34,Chinese,,0,0,0,,这非常令人钦佩
Dialogue: 0,0:08:03.76,0:08:06.12,English,,0,0,0,,So just to give you a sort of timescale
Dialogue: 0,0:08:03.76,0:08:06.12,Chinese,,0,0,0,,接下来给你们展示的是历史时间表
Dialogue: 0,0:08:06.12,0:08:09.30,English,,0,0,0,,As I mentioned the 8086 was the first
Dialogue: 0,0:08:06.12,0:08:09.30,Chinese,,0,0,0,,正如我提到的那样，8086 是第一个
Dialogue: 0,0:08:09.30,0:08:15.10,English,,0,0,0,,One of the first single chip 16-bit microprocessors  came out in (19)78
Dialogue: 0,0:08:09.30,0:08:15.10,Chinese,,0,0,0,,第一个 16 位微处理器之一，它出现在（19）78
Dialogue: 0,0:08:15.48,0:08:20.76,English,,0,0,0,,And it a slight variation on it was a very basis for the original IBM pc
Dialogue: 0,0:08:15.48,0:08:20.76,Chinese,,0,0,0,,它的一个变体，成为了初始 IBM 电脑的基础
Dialogue: 0,0:08:20.78,0:08:24.96,English,,0,0,0,,Which I know predates most of you your lives
Dialogue: 0,0:08:20.78,0:08:24.96,Chinese,,0,0,0,,我知道这比你们大多数人的生日都要早
Dialogue: 0,0:08:24.96,0:08:33.30,English,,0,0,0,,But it was sort of a the the big breakthrough that put computers on the desktops of many people
Dialogue: 0,0:08:24.96,0:08:33.30,Chinese,,0,0,0,,但这是将计算机放在许多人桌面上的重大突破
Dialogue: 0,0:08:35.08,0:08:41.30,English,,0,0,0,,And there's been many many generations I'm just giving you the highlights relevant to this particular class
Dialogue: 0,0:08:35.08,0:08:41.30,Chinese,,0,0,0,,在此之后更新了许多代，我只指出与这节课有关的那一部分
Dialogue: 0,0:08:41.90,0:08:49.60,English,,0,0,0,,The 386 which dates back to 1985 was the one that really made the transition from these being personal computers
Dialogue: 0,0:08:41.90,0:08:49.60,Chinese,,0,0,0,,可以追溯到 1985 年的 386 是真正从那些
Dialogue: 0,0:08:49.60,0:08:52.96,English,,0,0,0,,That could run not very interesting applications
Dialogue: 0,0:08:49.60,0:08:52.96,Chinese,,0,0,0,,不能够运行很多有意思的应用的个人电脑
Dialogue: 0,0:08:53.48,0:08:57.70,English,,0,0,0,,To ones that could actually run something like a unix or linux machine
Dialogue: 0,0:08:53.48,0:08:57.70,Chinese,,0,0,0,,转变成那些实际上可以运行 Unix 或 Linux 机器的东西
Dialogue: 0,0:08:58.42,0:09:01.18,English,,0,0,0,,And the reason is they extended it to 32-bit
Dialogue: 0,0:08:58.42,0:09:01.18,Chinese,,0,0,0,,原因是他们将其扩展到 32 位
Dialogue: 0,0:09:01.46,0:09:06.00,English,,0,0,0,,And they removed some of the weird addressing stuff that used to be in there
Dialogue: 0,0:09:01.46,0:09:06.00,Chinese,,0,0,0,,他们删除了过去常见的一些奇怪的寻址的东西
Dialogue: 0,0:09:06.38,0:09:09.78,English,,0,0,0,,So that these look like sort of a generic, a processor
Dialogue: 0,0:09:06.38,0:09:09.78,Chinese,,0,0,0,,所以它看起来像一个通用的处理器
Dialogue: 0,0:09:10.56,0:09:16.84,English,,0,0,0,,And that was clear back in (19)85 and that was what sometimes called IA32 intel architecture 32
Dialogue: 0,0:09:10.56,0:09:16.84,Chinese,,0,0,0,,我么可以看到是在 (19)85 年，有时也称为 IA32，Intel 32 位架构
Dialogue: 0,0:09:17.48,0:09:25.42,English,,0,0,0,,Which was the dominant way of code up to just even a few years ago
Dialogue: 0,0:09:17.48,0:09:25.42,Chinese,,0,0,0,,它几乎统治了所有的代码形式，即使就是几年前
Dialogue: 0,0:09:25.52,0:09:28.28,English,,0,0,0,,So even up as recently as this past summer
Dialogue: 0,0:09:25.52,0:09:28.28,Chinese,,0,0,0,,所以即使在去年夏天也是如此
Dialogue: 0,0:09:29.14,0:09:31.54,English,,0,0,0,,This course was teaching IA32
Dialogue: 0,0:09:29.14,0:09:31.54,Chinese,,0,0,0,,这门课程在那是教授 IA32
Dialogue: 0,0:09:33.70,0:09:36.70,English,,0,0,0,,And then there and I'll talk about it more later
Dialogue: 0,0:09:33.70,0:09:36.70,Chinese,,0,0,0,,然后我会在稍后讨论它
Dialogue: 0,0:09:36.70,0:09:43.68,English,,0,0,0,,There was a reason in a strange story behind the extension from 32 to 64 bits
Dialogue: 0,0:09:36.70,0:09:43.68,Chinese,,0,0,0,,从 32 位到 64 位的扩展有原因的，背后有一个奇怪的故事
Dialogue: 0,0:09:44.10,0:09:46.62,English,,0,0,0,,Which kind of was sneaked in by intel
Dialogue: 0,0:09:44.10,0:09:46.62,Chinese,,0,0,0,,英特尔好像是偷偷摸摸推出的
Dialogue: 0,0:09:47.22,0:09:50.36,English,,0,0,0,,And an odd model the Pentium 4E
Dialogue: 0,0:09:47.22,0:09:50.36,Chinese,,0,0,0,,奔腾 4E 是一个奇怪的型号
Dialogue: 0,0:09:50.36,0:09:53.74,English,,0,0,0,,But you see it was only about 10 years ago
Dialogue: 0,0:09:50.36,0:09:53.74,Chinese,,0,0,0,,但是你看到它只是大约 10 年前
Dialogue: 0,0:09:54.94,0:10:04.32,English,,0,0,0,,And one of the smart things they did with that is that the machines that can run the 64-bit code can also run 32-bit code
Dialogue: 0,0:09:54.94,0:10:04.32,Chinese,,0,0,0,,关于它他们所做的一件聪明的事情是，运行 64 位代码的机器也可以运行 32 位代码
Dialogue: 0,0:10:04.84,0:10:10.88,English,,0,0,0,,So they were able to sort of bring out all these machines without everybody having to change over their software
Dialogue: 0,0:10:04.84,0:10:10.88,Chinese,,0,0,0,,因此，他们能够在不需要任何人更换软件的情况下更换硬件
Dialogue: 0,0:10:11.20,0:10:20.62,English,,0,0,0,,And it's taken about that amount of time for the software to largely transition away from 32-bit code to 64-bit code
Dialogue: 0,0:10:11.20,0:10:20.62,Chinese,,0,0,0,,大量软件从 32 位代码转换为 64 位代码的过程相当漫长
Dialogue: 0,0:10:22.66,0:10:28.60,English,,0,0,0,,And then for actually fairly interesting reasons
Dialogue: 0,0:10:22.66,0:10:28.60,Chinese,,0,0,0,,然后是实际上相当有趣的原因
Dialogue: 0,0:10:28.92,0:10:32.98,English,,0,0,0,,You could map how fast a single processor would run
Dialogue: 0,0:10:28.92,0:10:32.98,Chinese,,0,0,0,,你可以画出单个处理器的运行速度图
Dialogue: 0,0:10:33.38,0:10:39.26,English,,0,0,0,,And it was climbing up at a pretty steady pace until around 2004
Dialogue: 0,0:10:33.38,0:10:39.26,Chinese,,0,0,0,,在 2004 年之前，它一直保持稳定的增长趋势
Dialogue: 0,0:10:39.72,0:10:44.98,English,,0,0,0,,And then intel got and all the companies got into serious trouble with the power consumption of their chips
Dialogue: 0,0:10:39.72,0:10:44.98,Chinese,,0,0,0,,然后英特尔收到所有公司在芯片功耗方面遇到了严重问题的反馈
Dialogue: 0,0:10:45.68,0:10:47.48,English,,0,0,0,,They're approaching a hundred watts
Dialogue: 0,0:10:45.68,0:10:47.48,Chinese,,0,0,0,,他们的芯片接近百瓦
Dialogue: 0,0:10:47.52,0:10:50.02,English,,0,0,0,,So imagine a hundred watt light bulb
Dialogue: 0,0:10:47.52,0:10:50.02,Chinese,,0,0,0,,想象一下一个一百瓦的灯泡
Dialogue: 0,0:10:50.02,0:10:53.20,English,,0,0,0,,And how much heat that generates inside of a box
Dialogue: 0,0:10:50.02,0:10:53.20,Chinese,,0,0,0,,在盒子内部会产生多少热量
Dialogue: 0,0:10:53.60,0:10:57.66,English,,0,0,0,,That you try to blow a fan on really hard to keep it from getting too hot
Dialogue: 0,0:10:53.60,0:10:57.66,Chinese,,0,0,0,,靠风扇吹风使它不过热相当困难
Dialogue: 0,0:10:58.40,0:11:04.08,English,,0,0,0,,And they were reaching the point where they really couldn't go much beyond a hundred watts
Dialogue: 0,0:10:58.40,0:11:04.08,Chinese,,0,0,0,,他们已经达到了不能超过百瓦的功率瓶颈
Dialogue: 0,0:11:04.10,0:11:06.94,English,,0,0,0,,And so they sort of got into a power budget problem
Dialogue: 0,0:11:04.10,0:11:06.94,Chinese,,0,0,0,,因此他们有点陷入功率预算问题
Dialogue: 0,0:11:07.40,0:11:10.52,English,,0,0,0,,And as a result they haven't been a to scale up the frequency
Dialogue: 0,0:11:07.40,0:11:10.52,Chinese,,0,0,0,,作为结果，他们没有继续增加频率
Dialogue: 0,0:11:10.52,0:11:16.00,English,,0,0,0,,How fast the inner clock that drives this thing is beyond just a few GHz
Dialogue: 0,0:11:10.52,0:11:16.00,Chinese,,0,0,0,,芯片内部的时钟频率仅仅是几个 GHz
Dialogue: 0,0:11:17.42,0:11:21.88,English,,0,0,0,,Since 2004 so what's happened was
Dialogue: 0,0:11:17.42,0:11:21.88,Chinese,,0,0,0,,自 2004 年以来发生了什么事呢
Dialogue: 0,0:11:22.24,0:11:25.32,English,,0,0,0,,They said well we can't make any single processor faster
Dialogue: 0,0:11:22.24,0:11:25.32,Chinese,,0,0,0,,他们说我们不能更快地制造任何单核处理器
Dialogue: 0,0:11:25.32,0:11:28.18,English,,0,0,0,,But we can put a bunch of processors on a single chip
Dialogue: 0,0:11:25.32,0:11:28.18,Chinese,,0,0,0,,但我们可以在一个芯片上放置一堆处理器
Dialogue: 0,0:11:28.64,0:11:31.04,English,,0,0,0,,And those are referred to cores or multi-core
Dialogue: 0,0:11:28.64,0:11:31.04,Chinese,,0,0,0,,那些被称为多核心或多核
Dialogue: 0,0:11:31.58,0:11:36.02,English,,0,0,0,,So most of you with laptops probably have two cores on those
Dialogue: 0,0:11:31.58,0:11:36.02,Chinese,,0,0,0,,因此，大多数人使用的笔记本电脑可能都有两个核心
Dialogue: 0,0:11:36.76,0:11:40.88,English,,0,0,0,,unlike laptop processor and a server might have up to 16 cores
Dialogue: 0,0:11:36.76,0:11:40.88,Chinese,,0,0,0,,与笔记本电脑不同，服务器最多可能有 16 个核心
Dialogue: 0,0:11:42.18,0:11:46.90,English,,0,0,0,,So those are independent processors that are all reside on a single chip
Dialogue: 0,0:11:42.18,0:11:46.90,Chinese,,0,0,0,,这些都是独立的处理器，位于单个芯片上
Dialogue: 0,0:11:48.52,0:11:51.64,English,,0,0,0,,The shark machines date back to 2008
Dialogue: 0,0:11:48.52,0:11:51.64,Chinese,,0,0,0,,鲨鱼机器的历史可以追溯到 2008 年
Dialogue: 0,0:11:52.40,0:11:55.48,English,,0,0,0,,And they are each have four cores on them
Dialogue: 0,0:11:52.40,0:11:55.48,Chinese,,0,0,0,,它们每个都有四个核心
Dialogue: 0,0:11:57.08,0:12:04.10,English,,0,0,0,,The shark machines the one thing about computers haven't really gotten that much faster of in the meantime
Dialogue: 0,0:11:57.08,0:12:04.10,Chinese,,0,0,0,,在鲨鱼机器出来之后，计算机的性能发展并不是很快
Dialogue: 0,0:12:04.10,0:12:10.14,English,,0,0,0,,So there's still fairly and they were in their day a very high-performance machine
Dialogue: 0,0:12:04.10,0:12:10.14,Chinese,,0,0,0,,所以直到今日，它们依然是高性能机器
Dialogue: 0,0:12:10.14,0:12:11.38,English,,0,0,0,,So they're still pretty decent
Dialogue: 0,0:12:10.14,0:12:11.38,Chinese,,0,0,0,,所以他们仍然相当不错
Dialogue: 0,0:12:14.82,0:12:19.22,English,,0,0,0,,This shows a picture of the chip that makes up a...
Dialogue: 0,0:12:14.82,0:12:19.22,Chinese,,0,0,0,,这显示了构成一个...的芯片的图片
Dialogue: 0,0:12:20.88,0:12:25.66,English,,0,0,0,,I think the the shark machines or approximately that same era
Dialogue: 0,0:12:20.88,0:12:25.66,Chinese,,0,0,0,,我认为是鲨鱼机器或差不多时代的东西
Dialogue: 0,0:12:26.02,0:12:31.68,English,,0,0,0,,And you'll see that as the picture shows these four cores are integrated onto one chip
Dialogue: 0,0:12:26.02,0:12:31.68,Chinese,,0,0,0,,你会看到，如图所示，这四个内核集成在一个芯片上
Dialogue: 0,0:12:32.10,0:12:34.94,English,,0,0,0,,And then down at the bottom is what they call a cache
Dialogue: 0,0:12:32.10,0:12:34.94,Chinese,,0,0,0,,然后在底部是他们所谓的缓存
Dialogue: 0,0:12:35.02,0:12:37.06,English,,0,0,0,,And we'll learn a lot about cache memory but it's
Dialogue: 0,0:12:35.02,0:12:37.06,Chinese,,0,0,0,,我们将学习很多关于缓存的知识，但它其实是
Dialogue: 0,0:12:37.62,0:12:44.62,English,,0,0,0,,It's basically a temporary memory used to hold the most recently accessed data
Dialogue: 0,0:12:37.62,0:12:44.62,Chinese,,0,0,0,,它基本上是用于保存最近访问的数据的临时内存
Dialogue: 0,0:12:44.62,0:12:46.62,English,,0,0,0,,So that you can get to it more quickly
Dialogue: 0,0:12:44.62,0:12:46.62,Chinese,,0,0,0,,这样你就可以更快地访问数据
Dialogue: 0,0:12:47.52,0:12:50.08,English,,0,0,0,,And you'll see that that shared across the four cores
Dialogue: 0,0:12:47.52,0:12:50.08,Chinese,,0,0,0,,而且你会看到这四个核心共享缓存
Dialogue: 0,0:12:53.02,0:13:00.22,English,,0,0,0,,So if you look at the latest if you were to go off shopping on in the catalog the latest instance
Dialogue: 0,0:12:53.02,0:13:00.22,Chinese,,0,0,0,,所以如果你想买一个最新的型号，在最新型号列表中
Dialogue: 0,0:13:00.22,0:13:02.06,English,,0,0,0,,And I don't have any chip pictures of it
Dialogue: 0,0:13:00.22,0:13:02.06,Chinese,,0,0,0,,我没有任何新芯片的图片
Dialogue: 0,0:13:02.62,0:13:04.88,English,,0,0,0,,It is a model they called a broadwell model
Dialogue: 0,0:13:02.62,0:13:04.88,Chinese,,0,0,0,,这是一个他们称之为 broadwell 型号的模型
Dialogue: 0,0:13:05.54,0:13:09.70,English,,0,0,0,,And you'll see that on a single chip they have multiple cores
Dialogue: 0,0:13:05.54,0:13:09.70,Chinese,,0,0,0,,而且你会发现在一块芯片上它们有多个内核
Dialogue: 0,0:13:10.74,0:13:16.44,English,,0,0,0,,4 cores a serious standard desktop model eight first a server class machine
Dialogue: 0,0:13:10.74,0:13:16.44,Chinese,,0,0,0,,标准桌面型号有四个核心，服务器类别机器八个核心
Dialogue: 0,0:13:16.88,0:13:22.38,English,,0,0,0,,And then built around the perimeter there are various connections to the rest of the world
Dialogue: 0,0:13:16.88,0:13:22.38,Chinese,,0,0,0,,在芯片的边缘有许多接口连接其余的设备
Dialogue: 0,0:13:22.88,0:13:28.52,English,,0,0,0,,So DDR is the way you connect to the main memory what's called DRAM dynamic RAM
Dialogue: 0,0:13:22.88,0:13:28.52,Chinese,,0,0,0,,因此，DDR 是连接到主存储器的方式，即所谓的 DRAM 动态 RAM
Dialogue: 0,0:13:29.32,0:13:32.64,English,,0,0,0,,PCI is the connection to peripheral devices
Dialogue: 0,0:13:29.32,0:13:32.64,Chinese,,0,0,0,,PCI 是与外围设备的连接
Dialogue: 0,0:13:34.34,0:13:37.38,English,,0,0,0,,SATA is a connection to different types of discs
Dialogue: 0,0:13:34.34,0:13:37.38,Chinese,,0,0,0,,SATA 是与不同类型盘的连接
Dialogue: 0,0:13:38.82,0:13:42.61,English,,0,0,0,,And USB well you know USB is
Dialogue: 0,0:13:38.82,0:13:42.61,Chinese,,0,0,0,,和 USB，你肯定知道 USB 是什么
Dialogue: 0,0:13:44.34,0:13:48.20,English,,0,0,0,,And then the ethernet is the connection also to a network connection
Dialogue: 0,0:13:44.34,0:13:48.20,Chinese,,0,0,0,,然后以太网接口，连接到一个网络
Dialogue: 0,0:13:48.44,0:13:55.74,English,,0,0,0,,So that's all integrated onto a single chip is not just the processor itself
Dialogue: 0,0:13:48.44,0:13:55.74,Chinese,,0,0,0,,因此，所有集成到单个芯片上的不仅仅是处理器本身
Dialogue: 0,0:13:56.22,0:14:01.76,English,,0,0,0,,But a lot of logic that glues that processor into a larger system
Dialogue: 0,0:13:56.22,0:14:01.76,Chinese,,0,0,0,,而是有很多逻辑单元粘在一起所组成的更大的系统
Dialogue: 0,0:14:02.78,0:14:08.24,English,,0,0,0,,And one interesting thing you'll notice is that the desktop model is a higher power 65 watts
Dialogue: 0,0:14:02.78,0:14:08.24,Chinese,,0,0,0,,你会注意到一个有趣的事情是桌面型号的功率更高，为 65 瓦
Dialogue: 0,0:14:08.84,0:14:10.80,English,,0,0,0,,Versus the server is 45 watts
Dialogue: 0,0:14:08.84,0:14:10.80,Chinese,,0,0,0,,相比服务器是 45 瓦
Dialogue: 0,0:14:10.90,0:14:13.20,English,,0,0,0,,When you put a lot of computers in a room
Dialogue: 0,0:14:10.90,0:14:13.20,Chinese,,0,0,0,,当你把很多电脑放在一个房间里时
Dialogue: 0,0:14:13.76,0:14:16.58,English,,0,0,0,,Turns out power is the biggest issue you have to deal with
Dialogue: 0,0:14:13.76,0:14:16.58,Chinese,,0,0,0,,功率是你必须处理的最大问题
Dialogue: 0,0:14:21.22,0:14:23.90,English,,0,0,0,,So intel isn't the only company in this game
Dialogue: 0,0:14:21.22,0:14:23.90,Chinese,,0,0,0,,所以英特尔并不是这场比赛中唯一的公司
Dialogue: 0,0:14:24.02,0:14:27.76,English,,0,0,0,,They're sort of historic competitors a company called AMD
Dialogue: 0,0:14:24.02,0:14:27.76,Chinese,,0,0,0,,有一家名为 AMD 的历史性竞争对手
Dialogue: 0,0:14:28.32,0:14:33.64,English,,0,0,0,,And AMD was always sort of NO.2 behind intel
Dialogue: 0,0:14:28.32,0:14:33.64,Chinese,,0,0,0,,而 AMD 在英特尔方面总是排名第二
Dialogue: 0,0:14:34.52,0:14:37.58,English,,0,0,0,,In all the just so I gave is his NO.2 behind hertz
Dialogue: 0,0:14:34.52,0:14:37.58,Chinese,,0,0,0,,在所有的情况下，我给出的是主频后面的 NO.2
Dialogue: 0,0:14:38.36,0:14:42.22,English,,0,0,0,,But they are...
Dialogue: 0,0:14:38.36,0:14:42.22,Chinese,,0,0,0,,但他们是......
Dialogue: 0,0:14:43.58,0:14:48.04,English,,0,0,0,,But they had a little burst in time when they kind of got out ahead of intel
Dialogue: 0,0:14:43.58,0:14:48.04,Chinese,,0,0,0,,但是当他们有点超越英特尔时，他们有点爆发了
Dialogue: 0,0:14:48.04,0:14:52.38,English,,0,0,0,,Because intel had wasted their time on some bad ideas
Dialogue: 0,0:14:48.04,0:14:52.38,Chinese,,0,0,0,,因为英特尔浪费了他们的时间在一些坏主意上
Dialogue: 0,0:14:53.08,0:14:58.26,English,,0,0,0,,And they actually were the one that came up with the 64-bit extension to intel that we use
Dialogue: 0,0:14:53.08,0:14:58.26,Chinese,,0,0,0,,他们实际上提出了我们使用的 64 位英特尔扩展程序
Dialogue: 0,0:15:00.48,0:15:03.28,English,,0,0,0,,Right now though AMD is not doing very well
Dialogue: 0,0:15:00.48,0:15:03.28,Chinese,,0,0,0,,目前虽然 AMD 表现不佳
Dialogue: 0,0:15:03.36,0:15:07.74,English,,0,0,0,,Intel sort of realized that it had to get its act together and it did
Dialogue: 0,0:15:03.36,0:15:07.74,Chinese,,0,0,0,,英特尔意识到必须采取行动，而且确实如此
Dialogue: 0,0:15:08.20,0:15:10.00,English,,0,0,0,,And is more or less crushed AMD
Dialogue: 0,0:15:08.20,0:15:10.00,Chinese,,0,0,0,,而且或多或少都是粉碎了AMD
Dialogue: 0,0:15:12.18,0:15:16.98,English,,0,0,0,,But and I should mention that they had these ferocious patent suits
Dialogue: 0,0:15:12.18,0:15:16.98,Chinese,,0,0,0,,但我应该提到他们之间有凶猛的专利诉讼
Dialogue: 0,0:15:17.60,0:15:24.72,English,,0,0,0,,Many years ago and the result of that was a cross licensing deal that allows AMD to produce x86 processors
Dialogue: 0,0:15:17.60,0:15:24.72,Chinese,,0,0,0,,许多年前，其结果是允许 AMD 生产 x86 处理器的交叉许可协议
Dialogue: 0,0:15:26.50,0:15:29.58,English,,0,0,0,,Now it's an interesting story behind intel in 64-bit
Dialogue: 0,0:15:26.50,0:15:29.58,Chinese,,0,0,0,,有一个 64 位年代，英特尔公司背后的有趣故事
Dialogue: 0,0:15:30.20,0:15:34.94,English,,0,0,0,,They decided to make this radical shift to an architecture that they called the...
Dialogue: 0,0:15:30.20,0:15:34.94,Chinese,,0,0,0,,他们决定将架构进行一个激进的改变，并称全新架构为...
Dialogue: 0,0:15:38.10,0:15:40.96,English,,0,0,0,,They called IA64 at the time
Dialogue: 0,0:15:38.10,0:15:40.96,Chinese,,0,0,0,,他们当时叫它 IA64
Dialogue: 0,0:15:41.22,0:15:43.70,English,,0,0,0,,And it was based on a whole new concept
Dialogue: 0,0:15:41.22,0:15:43.70,Chinese,,0,0,0,,它基于一个全新的概念
Dialogue: 0,0:15:44.36,0:15:48.98,English,,0,0,0,,That looked really good on paper and initial results look promising
Dialogue: 0,0:15:44.36,0:15:48.98,Chinese,,0,0,0,,这在纸上看起来非常好，初步结果看起来很有希望
Dialogue: 0,0:15:49.28,0:15:51.18,English,,0,0,0,,They invested a lot of money in this stuff
Dialogue: 0,0:15:49.28,0:15:51.18,Chinese,,0,0,0,,他们在这些东西上投入了大量资金
Dialogue: 0,0:15:51.40,0:15:56.28,English,,0,0,0,,They formed a joint operation with packed on this and it turned out not to work
Dialogue: 0,0:15:51.40,0:15:56.28,Chinese,,0,0,0,,他们组成了一个联合行动，并且结果却没有成功
Dialogue: 0,0:15:56.50,0:16:03.98,English,,0,0,0,,It was much too aggressive it assumed miraculous optimization capabilities by the compiler
Dialogue: 0,0:15:56.50,0:16:03.98,Chinese,,0,0,0,,它过于激进，它假设编译器具有奇迹般的优化功能
Dialogue: 0,0:16:03.98,0:16:08.94,English,,0,0,0,,And so it was a from a technical idea it was very interesting technology
Dialogue: 0,0:16:03.98,0:16:08.94,Chinese,,0,0,0,,因此，从技术理念来看，这是非常有趣的技术
Dialogue: 0,0:16:08.94,0:16:10.86,English,,0,0,0,,But in the marketplace it didn't work
Dialogue: 0,0:16:08.94,0:16:10.86,Chinese,,0,0,0,,但在市场上它没有用
Dialogue: 0,0:16:11.46,0:16:14.16,English,,0,0,0,,And this was sort of a branch off
Dialogue: 0,0:16:11.46,0:16:14.16,Chinese,,0,0,0,,这是一个分支
Dialogue: 0,0:16:14.84,0:16:19.42,English,,0,0,0,,The intel pursued and felt obligated to keep it up because they'd invested so much in it
Dialogue: 0,0:16:14.84,0:16:19.42,Chinese,,0,0,0,,英特尔追求并感到有义务坚持下去，因为他们投入了大量资金
Dialogue: 0,0:16:19.86,0:16:23.34,English,,0,0,0,,And along came AMD and they said well we don't have to do this radical shift
Dialogue: 0,0:16:19.86,0:16:23.34,Chinese,,0,0,0,,随之而来的是 AMD，他们说我们不必做这种彻底的转变
Dialogue: 0,0:16:23.46,0:16:26.62,English,,0,0,0,,We'll just sort of do the obvious thing of adding
Dialogue: 0,0:16:23.46,0:16:26.62,Chinese,,0,0,0,,我们只会做一些简单的事情
Dialogue: 0,0:16:27.34,0:16:32.20,English,,0,0,0,,Making the registers bigger making things go from 32 to 64 bits
Dialogue: 0,0:16:27.34,0:16:32.20,Chinese,,0,0,0,,使寄存器更大，使东西从 32 位变为 64 位
Dialogue: 0,0:16:32.66,0:16:37.08,English,,0,0,0,,And they came along with that and were successful
Dialogue: 0,0:16:32.66,0:16:37.08,Chinese,,0,0,0,,他们采用了这种办法，也随之而来并取得了成功
Dialogue: 0,0:16:37.16,0:16:43.46,English,,0,0,0,,And so intel kind of had to just sheepishly follow behind AMD on this
Dialogue: 0,0:16:37.16,0:16:43.46,Chinese,,0,0,0,,因此英特尔不得不羞怯地跟在 AMD 后面推出自己的产品
Dialogue: 0,0:16:43.86,0:16:46.08,English,,0,0,0,,But they could because of their cross licensing deal
Dialogue: 0,0:16:43.86,0:16:46.08,Chinese,,0,0,0,,但他们可能因为他们的交叉许可协议
Dialogue: 0,0:16:47.06,0:16:54.76,English,,0,0,0,,So nowadays as I mentioned hardware wise just about every processor that is in a laptop,in a desktop
Dialogue: 0,0:16:47.06,0:16:54.76,Chinese,,0,0,0,,所以现在我提到硬件方面只是关于笔记本电脑，台式机中的每个处理器
Dialogue: 0,0:16:54.76,0:16:59.12,English,,0,0,0,,Even your cell phones of recent generation are all 64-bit processors
Dialogue: 0,0:16:54.76,0:16:59.12,Chinese,,0,0,0,,而甚至你最近一代的手机都是 64 位处理器
Dialogue: 0,0:17:03.90,0:17:08.06,English,,0,0,0,,So what we'll talk about then we used to teach IA32
Dialogue: 0,0:17:03.90,0:17:08.06,Chinese,,0,0,0,,那么我们将谈论的是那时我们曾经教过 IA32
Dialogue: 0,0:17:08.06,0:17:12.42,English,,0,0,0,,But that's gone this is the first term where we're skipping it all together
Dialogue: 0,0:17:08.06,0:17:12.42,Chinese,,0,0,0,,但它已经消失了，这是我们一起跳过的第一个术语
Dialogue: 0,0:17:13.04,0:17:16.82,English,,0,0,0,,So we're using what we'll call x86-64
Dialogue: 0,0:17:13.04,0:17:16.82,Chinese,,0,0,0,,与之替代的是我们称作 x86-64
Dialogue: 0,0:17:16.82,0:17:21.46,English,,0,0,0,,There's various ways this is named,but this is sort of the Linux way of naming it
Dialogue: 0,0:17:16.82,0:17:21.46,Chinese,,0,0,0,,这有多种方式命名，但这是 Linux 命名方式
Dialogue: 0,0:17:22.60,0:17:27.64,English,,0,0,0,,If you're interested in IA32 there's a document on the web associated with the book
Dialogue: 0,0:17:22.60,0:17:27.64,Chinese,,0,0,0,,如果你对 IA32 感兴趣，那么与该书相关的网站上有一份文档
Dialogue: 0,0:17:27.78,0:17:31.50,English,,0,0,0,,Called a website that goes through at least some of the basics of
Dialogue: 0,0:17:27.78,0:17:31.50,Chinese,,0,0,0,,名字是 IA32 的基础知识
Dialogue: 0,0:17:31.94,0:17:37.34,English,,0,0,0,,But to really read that you need to learn the 64-bit, because it assumes you kind of already know that
Dialogue: 0,0:17:31.94,0:17:37.34,Chinese,,0,0,0,,但要读懂它的话，你需要学习 64 位，因为它假设你已经知道了
Dialogue: 0,0:17:39.76,0:17:43.76,English,,0,0,0,,Okay so let's go in,and I should mention to just for general interest
Dialogue: 0,0:17:39.76,0:17:43.76,Chinese,,0,0,0,,好吧，让我们开始吧，我先提一句
Dialogue: 0,0:17:44.26,0:17:48.84,English,,0,0,0,,The other major class of processor and common use today are called ARM
Dialogue: 0,0:17:44.26,0:17:48.84,Chinese,,0,0,0,,目前处理器和常用的另一大类是 ARM
Dialogue: 0,0:17:49.48,0:17:53.82,English,,0,0,0,,So ARM actually is an acronym for Acorn RISC Machine
Dialogue: 0,0:17:49.48,0:17:53.82,Chinese,,0,0,0,,所以 ARM 实际上是 Acorn RISC Machine 的首字母缩写
Dialogue: 0,0:17:54.66,0:17:58.58,English,,0,0,0,,I just told you what RISC means. It means reduced instruction set computer
Dialogue: 0,0:17:54.66,0:17:58.58,Chinese,,0,0,0,,我刚刚告诉你 RISC 的含义。它意味着精简指令集计算机
Dialogue: 0,0:17:59.04,0:18:04.64,English,,0,0,0,,An acorn means like you know the seed of an oak tree, it was a British company
Dialogue: 0,0:17:59.04,0:18:04.64,Chinese,,0,0,0,,Acron 意味着，你知道它是橡树的种子，是一家英国公司
Dialogue: 0,0:18:04.86,0:18:10.96,English,,0,0,0,,That decided to make its own personal computers in the early days of it and they said
Dialogue: 0,0:18:04.86,0:18:10.96,Chinese,,0,0,0,,他们说在早期决定制造自己的个人电脑，并说
Dialogue: 0,0:18:11.58,0:18:13.18,English,,0,0,0,,We're not going to buy those chips from intel
Dialogue: 0,0:18:11.58,0:18:13.18,Chinese,,0,0,0,,我们不打算从英特尔购买这些芯片
Dialogue: 0,0:18:13.18,0:18:16.42,English,,0,0,0,,We're going to make them ourselves so they designed and manufactured their own chips
Dialogue: 0,0:18:13.18,0:18:16.42,Chinese,,0,0,0,,我们将自己制作它们，以便于设计和生产自己的芯片
Dialogue: 0,0:18:17.10,0:18:20.62,English,,0,0,0,,Well as a company a computer manufacturer it was a complete bust
Dialogue: 0,0:18:17.10,0:18:20.62,Chinese,,0,0,0,,最后作为一家公司的计算机制造商，它彻底的破产了
Dialogue: 0,0:18:21.32,0:18:26.24,English,,0,0,0,,But it turned out that they'd come up with a fairly good instruction set
Dialogue: 0,0:18:21.32,0:18:26.24,Chinese,,0,0,0,,但事实证明他们提出了一个相当不错的指令集
Dialogue: 0,0:18:26.32,0:18:32.60,English,,0,0,0,,That was sufficiently simple that it could be put on chips and better yet
Dialogue: 0,0:18:26.32,0:18:32.60,Chinese,,0,0,0,,非常高效并且简单，可以放在芯片上，而且更好的是
Dialogue: 0,0:18:32.60,0:18:33.84,English,,0,0,0,,It could be customized
Dialogue: 0,0:18:32.60,0:18:33.84,Chinese,,0,0,0,,它可以定制
Dialogue: 0,0:18:34.32,0:18:39.04,English,,0,0,0,,So ARM is now a company of its own headquartered in Cambridge England
Dialogue: 0,0:18:34.32,0:18:39.04,Chinese,,0,0,0,,因此，ARM 现在是一家总部位于英国剑桥的公司
Dialogue: 0,0:18:39.64,0:18:43.06,English,,0,0,0,,And the reason why part of the reason they're successful therefore is
Dialogue: 0,0:18:39.64,0:18:43.06,Chinese,,0,0,0,,这也是他们成功的部分原因所在
Dialogue: 0,0:18:43.58,0:18:49.70,English,,0,0,0,,Because it tends to be a lower power processor requirement than an x86 machine because it's simpler
Dialogue: 0,0:18:43.58,0:18:49.70,Chinese,,0,0,0,,因为它比 x86 机器功耗更低，因为它更简单
Dialogue: 0,0:18:50.20,0:18:52.86,English,,0,0,0,,But the other is that they don't actually sell processors
Dialogue: 0,0:18:50.20,0:18:52.86,Chinese,,0,0,0,,但另一个事实是他们实际上并没有销售处理器
Dialogue: 0,0:18:52.86,0:18:58.86,English,,0,0,0,,They sell companies the rights the licensing rights to use their designs
Dialogue: 0,0:18:52.86,0:18:58.86,Chinese,,0,0,0,,他们向公司出售使用其设计的许可权利
Dialogue: 0,0:18:59.34,0:19:07.56,English,,0,0,0,,And so if you look at like a a cell phone processor,the actual arm processor is a little tiny part of it on the chip
Dialogue: 0,0:18:59.34,0:19:07.56,Chinese,,0,0,0,,因此，如果你看一下像手机处理器，实际的 ARM 处理器只是它在芯片上的一小部分
Dialogue: 0,0:19:08.20,0:19:14.80,English,,0,0,0,,And then they'll have other stuff to make the graphics go better to improve your phone calls and so forth
Dialogue: 0,0:19:08.20,0:19:14.80,Chinese,,0,0,0,,然后他们会有其他东西，让图形更好，改善你的通话等等
Dialogue: 0,0:19:14.84,0:19:19.36,English,,0,0,0,,And so they're really selling what intellectual property is as opposed to chips
Dialogue: 0,0:19:14.84,0:19:19.36,Chinese,,0,0,0,,所以他们真正卖的是知识产权而不是芯片
Dialogue: 0,0:19:20.10,0:19:23.66,English,,0,0,0,,And so people we've gotten various enquiries
Dialogue: 0,0:19:20.10,0:19:23.66,Chinese,,0,0,0,,所以我们得到了别人各种各样的询问
Dialogue: 0,0:19:23.66,0:19:28.08,English,,0,0,0,,When are you going to start talking about ARM in your book or your course or something and we go
Dialogue: 0,0:19:23.66,0:19:28.08,Chinese,,0,0,0,,你什么时候开始在你的书或你的课程中谈论 ARM，我们就说
Dialogue: 0,0:19:28.46,0:19:31.74,English,,0,0,0,,It would be another book to write to do justice to ARM
Dialogue: 0,0:19:28.46,0:19:31.74,Chinese,,0,0,0,,将有另一本书来介绍 ARM
Dialogue: 0,0:19:31.74,0:19:34.24,English,,0,0,0,,It would be like a whole redo of the thing
Dialogue: 0,0:19:31.74,0:19:34.24,Chinese,,0,0,0,,这就像是推倒重新讲
Dialogue: 0,0:19:34.58,0:19:37.74,English,,0,0,0,,And we were not inclined to do that right now
Dialogue: 0,0:19:34.58,0:19:37.74,Chinese,,0,0,0,,我们现在并不倾向于这样做
Dialogue: 0,0:19:39.32,0:19:44.16,English,,0,0,0,,But just so you know there's sort of a two worlds out there x86
Dialogue: 0,0:19:39.32,0:19:44.16,Chinese,,0,0,0,,但就是你知道，目前有两个世界
Dialogue: 0,0:19:44.16,0:19:46.06,English,,0,0,0,, x86 ARM are the dominant players right now
Dialogue: 0,0:19:44.16,0:19:46.06,Chinese,,0,0,0,,x86 ARM 现在是主要的活跃者
Dialogue: 0,0:19:49.46,0:19:54.36,English,,0,0,0,,So let's talk some terminology,if you've probably heard some of these terms before but let's make it clear
Dialogue: 0,0:19:49.46,0:19:54.36,Chinese,,0,0,0,,所以，让我们谈谈术语，你之前可能已经听过其中的一些术语，我们要弄清楚
Dialogue: 0,0:19:54.91,0:19:58.40,English,,0,0,0,,So when we talk about the instructions the instruction set
Dialogue: 0,0:19:54.91,0:19:58.40,Chinese,,0,0,0,,所以当我们谈论指令和指令集时
Dialogue: 0,0:19:58.96,0:20:06.76,English,,0,0,0,,That's the the target of a compiler to give you a series of instructions that tell the machine exactly what to do
Dialogue: 0,0:19:58.96,0:20:06.76,Chinese,,0,0,0,,这是编译器的目标，为你提供一系列指令，告诉机器确切地做什么
Dialogue: 0,0:20:08.92,0:20:11.50,English,,0,0,0,,But it turns out that the hardware people have figured out
Dialogue: 0,0:20:08.92,0:20:11.50,Chinese,,0,0,0,,但事实证明，发明硬件的人们已经想到了
Dialogue: 0,0:20:11.50,0:20:14.60,English,,0,0,0,,All kinds of clever ways to implement instructions
Dialogue: 0,0:20:11.50,0:20:14.60,Chinese,,0,0,0,,各种巧妙的实施指令方式
Dialogue: 0,0:20:15.26,0:20:18.96,English,,0,0,0,,Some of them are really fast but take a lot of hardware
Dialogue: 0,0:20:15.26,0:20:18.96,Chinese,,0,0,0,,其中一些非常快，但需要大量的硬件
Dialogue: 0,0:20:19.48,0:20:22.16,English,,0,0,0,,Some are pretty slow but don't take much hardware at all
Dialogue: 0,0:20:19.48,0:20:22.16,Chinese,,0,0,0,,有些很慢，但根本不需要太多硬件
Dialogue: 0,0:20:22.64,0:20:28.70,English,,0,0,0,,And so they managed to create this abstraction that's called the instruction set architecture
Dialogue: 0,0:20:22.64,0:20:28.70,Chinese,,0,0,0,,因此他们设法创建了这种称为「指令集」架构的抽象
Dialogue: 0,0:20:28.70,0:20:31.84,English,,0,0,0,,Which is what the target of a compiler should be
Dialogue: 0,0:20:28.70,0:20:31.84,Chinese,,0,0,0,,编译器的目标就是他们
Dialogue: 0,0:20:32.12,0:20:35.18,English,,0,0,0,,And then let the hardware people figure out how best to implement it
Dialogue: 0,0:20:32.12,0:20:35.18,Chinese,,0,0,0,,而如何最好地实现它是硬件研究者的工作
Dialogue: 0,0:20:35.84,0:20:40.52,English,,0,0,0,,And then the low,so that that's a concept actually it came along in the 1960s
Dialogue: 0,0:20:35.84,0:20:40.52,Chinese,,0,0,0,,所以这个概念实际上是在 20 世纪 60 年代出现的
Dialogue: 0,0:20:41.66,0:20:48.30,English,,0,0,0,,So that's even before my time as far as a computer person,but...
Dialogue: 0,0:20:41.66,0:20:48.30,Chinese,,0,0,0,,那甚至在我的时间之前，在我研究计算机之前，但......
Dialogue: 0,0:20:49.10,0:20:52.98,English,,0,0,0,,It's a very important concept in the world of computers
Dialogue: 0,0:20:49.10,0:20:52.98,Chinese,,0,0,0,,这是计算机世界中一个非常重要的概念
Dialogue: 0,0:20:53.50,0:20:55.92,English,,0,0,0,,And then what they call the lower level stuff
Dialogue: 0,0:20:53.50,0:20:55.92,Chinese,,0,0,0,,然后他们称之为低级别的东西
Dialogue: 0,0:20:55.92,0:20:58.80,English,,0,0,0,,How it actually gets implement is called the microarchitecture
Dialogue: 0,0:20:55.92,0:20:58.80,Chinese,,0,0,0,,实际上如何实现它被称为微结构
Dialogue: 0,0:20:59.12,0:21:02.50,English,,0,0,0,,And we will talk very very little about microarchitecture in this course
Dialogue: 0,0:20:59.12,0:21:02.50,Chinese,,0,0,0,,我们将在本课程中谈论非常非常少的微结构知识
Dialogue: 0,0:21:03.54,0:21:07.82,English,,0,0,0,,And as I mentioned machine code is sort of a generic term that incorporates both
Dialogue: 0,0:21:03.54,0:21:07.82,Chinese,,0,0,0,,正如我所提到的，机器代码是一种包含两者的通用术语
Dialogue: 0,0:21:08.26,0:21:14.20,English,,0,0,0,,The actual bytes that are operated executing as well as the assembly level version of it
Dialogue: 0,0:21:08.26,0:21:14.20,Chinese,,0,0,0,,执行的实际字节以及它的汇编版本
Dialogue: 0,0:21:18.26,0:21:22.12,English,,0,0,0,,And as I mentioned you can think of from instruction set point of view
Dialogue: 0,0:21:18.26,0:21:22.12,Chinese,,0,0,0,,正如我所提到的，你可以从指令集的角度来思考
Dialogue: 0,0:21:22.88,0:21:27.74,English,,0,0,0,,So IA32,x86-64 and what's called Itanium
Dialogue: 0,0:21:22.88,0:21:27.74,Chinese,,0,0,0,,所以 IA32，x86-64 以及所谓的 Itanium
Dialogue: 0,0:21:28.46,0:21:31.20,English,,0,0,0,,This not very successful intel thing
Dialogue: 0,0:21:28.46,0:21:31.20,Chinese,,0,0,0,,那个不非常成功的英特尔的玩意儿
Dialogue: 0,0:21:31.46,0:21:37.28,English,,0,0,0,,Those are all in some ways different instruction set architectures
Dialogue: 0,0:21:31.46,0:21:37.28,Chinese,,0,0,0,,这些都是在某些方面不同的指令集架构
Dialogue: 0,0:21:37.28,0:21:42.02,English,,0,0,0,,ARM actually similar to intel has gone through various different generations
Dialogue: 0,0:21:37.28,0:21:42.02,Chinese,,0,0,0,,ARM 实际上类似于 Intel 经历了各种不同的世代
Dialogue: 0,0:21:42.02,0:21:45.42,English,,0,0,0,,So there's various different generations of its instruction set
Dialogue: 0,0:21:42.02,0:21:45.42,Chinese,,0,0,0,,所以它的指令集有各种不同的代
Dialogue: 0,0:21:47.82,0:21:51.32,English,,0,0,0,,So from a programmer machine level programmers perspective
Dialogue: 0,0:21:47.82,0:21:51.32,Chinese,,0,0,0,,所以从程序员机器级程序员的角度来看
Dialogue: 0,0:21:51.74,0:21:55.00,English,,0,0,0,,Things are a bit different than you see when you write C code
Dialogue: 0,0:21:51.74,0:21:55.00,Chinese,,0,0,0,,（写汇编代码）与编写 C 代码时的情况有一点不同
Dialogue: 0,0:21:56.24,0:22:01.38,English,,0,0,0,,First of all there is some very visible parts of the instruction the machine state
Dialogue: 0,0:21:56.24,0:22:01.38,Chinese,,0,0,0,,首先，机器状态指令中有一些非常明显的部分
Dialogue: 0,0:22:02.12,0:22:06.32,English,,0,0,0,,That you can examine and test and operate on and you must in fact
Dialogue: 0,0:22:02.12,0:22:06.32,Chinese,,0,0,0,,你可以检查，测试和操作，事实上你必须这样做
Dialogue: 0,0:22:06.82,0:22:10.92,English,,0,0,0,,You would never understand what those are if you're just thinking in terms of C
Dialogue: 0,0:22:06.82,0:22:10.92,Chinese,,0,0,0,,如果你只是用 C 语言来思考，你永远不会明白那些是什么
Dialogue: 0,0:22:11.88,0:22:17.50,English,,0,0,0,,So in particular there's some sort of a program counter to tells you what
Dialogue: 0,0:22:11.88,0:22:17.50,Chinese,,0,0,0,,所以特别是有某种程序计数器可以告诉你什么
Dialogue: 0,0:22:17.66,0:22:22.62,English,,0,0,0,,What address is the instruction that you're going to execute next
Dialogue: 0,0:22:17.66,0:22:22.62,Chinese,,0,0,0,,你接下来要执行的指令是什么地址
Dialogue: 0,0:22:22.66,0:22:24.38,English,,0,0,0,,Where is that located in memory
Dialogue: 0,0:22:22.66,0:22:24.38,Chinese,,0,0,0,,它位于内存中的哪个位置
Dialogue: 0,0:22:25.40,0:22:33.38,English,,0,0,0,,And then there's a set of registers which are part of that the programmer actually makes use of
Dialogue: 0,0:22:25.40,0:22:33.38,Chinese,,0,0,0,,然后有一系列寄存器，它们是程序员实际使用的一部分
Dialogue: 0,0:22:33.38,0:22:38.14,English,,0,0,0,,You can think of them as as a very small number of memory locations
Dialogue: 0,0:22:33.38,0:22:38.14,Chinese,,0,0,0,,你可以将它们视为非常小的内存的位置
Dialogue: 0,0:22:38.14,0:22:43.28,English,,0,0,0,,But rather than giving an address from 0 up to n-1 or something
Dialogue: 0,0:22:38.14,0:22:43.28,Chinese,,0,0,0,,但并通过从 0 到 n-1 或其他地址指定
Dialogue: 0,0:22:43.50,0:22:47.38,English,,0,0,0,,You actually give them by name as specifically
Dialogue: 0,0:22:43.50,0:22:47.38,Chinese,,0,0,0,,你实际上通过专门的名字指定它们
Dialogue: 0,0:22:48.22,0:22:50.34,English,,0,0,0,,And then there's another sort of state
Dialogue: 0,0:22:48.22,0:22:50.34,Chinese,,0,0,0,,然后还有另一种状态寄存器
Dialogue: 0,0:22:50.54,0:22:53.64,English,,0,0,0,,That's just a few bits worth of state that talked about
Dialogue: 0,0:22:50.54,0:22:53.64,Chinese,,0,0,0,,只有几个位的状态寄存器，显示了
Dialogue: 0,0:22:54.10,0:22:59.26,English,,0,0,0,,What are the results of some recent instructions
Dialogue: 0,0:22:54.10,0:22:59.26,Chinese,,0,0,0,,最近的一些指令的运行结果是什么？
Dialogue: 0,0:22:59.76,0:23:04.26,English,,0,0,0,,Where they did it produce a value of 0,did it produce a negative or a positive value
Dialogue: 0,0:22:59.76,0:23:04.26,Chinese,,0,0,0,,它产生的值为 0？是否产生负值或正值？
Dialogue: 0,0:23:04.60,0:23:06.66,English,,0,0,0,,And those are used to implement conditional branching
Dialogue: 0,0:23:04.60,0:23:06.66,Chinese,,0,0,0,,这些值用于实现条件分支
Dialogue: 0,0:23:06.66,0:23:08.82,English,,0,0,0,,Which we'll look at later as we go
Dialogue: 0,0:23:06.66,0:23:08.82,Chinese,,0,0,0,,我们稍后会讨论它们
Dialogue: 0,0:23:10.12,0:23:11.60,English,,0,0,0,,And then the other part of it
Dialogue: 0,0:23:10.12,0:23:11.60,Chinese,,0,0,0,,然后是其他部分
Dialogue: 0,0:23:11.86,0:23:15.64,English,,0,0,0,,So that's sort of the processor and then the other part of is the memory
Dialogue: 0,0:23:11.86,0:23:15.64,Chinese,,0,0,0,,刚才的部分是处理器，然后另一部分是内存
Dialogue: 0,0:23:16.20,0:23:21.78,English,,0,0,0,,And as I mentioned in the one of the first lectures
Dialogue: 0,0:23:16.20,0:23:21.78,Chinese,,0,0,0,,正如我在第一次讲座中提到的那样
Dialogue: 0,0:23:21.78,0:23:25.56,English,,0,0,0,,The memory is you can think of logically as just an array of bytes
Dialogue: 0,0:23:21.78,0:23:25.56,Chinese,,0,0,0,,内存是你可以逻辑地认为只是一个字节数组
Dialogue: 0,0:23:26.72,0:23:30.50,English,,0,0,0,,And that's what the machine level programmer sees
Dialogue: 0,0:23:26.72,0:23:30.50,Chinese,,0,0,0,,这就是机器级程序员所看到的
Dialogue: 0,0:23:31.36,0:23:35.88,English,,0,0,0,,And it's actually kind of a fiction in different ways as I mentioned before
Dialogue: 0,0:23:31.36,0:23:35.88,Chinese,,0,0,0,,如前所述，它实际上是一种用不同方式实现的虚构对象
Dialogue: 0,0:23:35.90,0:23:39.24,English,,0,0,0,,There's sort of a collaboration between the operating system and the hardware
Dialogue: 0,0:23:35.90,0:23:39.24,Chinese,,0,0,0,,操作系统和硬件之间存在一种协作
Dialogue: 0,0:23:39.68,0:23:45.08,English,,0,0,0,,What they call virtual memory to make it look like each program running on the processor
Dialogue: 0,0:23:39.68,0:23:45.08,Chinese,,0,0,0,,他们称之为虚拟内存，使处理器上运行的每个程序都看起来像
Dialogue: 0,0:23:45.56,0:23:50.14,English,,0,0,0,,Has its own independent array of bytes that it can access
Dialogue: 0,0:23:45.56,0:23:50.14,Chinese,,0,0,0,,拥有自己独立的字节数组，它们可以访问
Dialogue: 0,0:23:51.20,0:23:56.70,English,,0,0,0,,Even though they actually share values within the the physical memory itself
Dialogue: 0,0:23:51.20,0:23:56.70,Chinese,,0,0,0,,即使它们实际上在物理内存内部都是共享这些字节数组的
Dialogue: 0,0:23:57.24,0:23:59.40,English,,0,0,0,,And furthermore you heard the term cache
Dialogue: 0,0:23:57.24,0:23:59.40,Chinese,,0,0,0,,此外，你听到了术语「缓存（Cache）」
Dialogue: 0,0:24:00.06,0:24:02.76,English,,0,0,0,,The idea of a cache is not visible here at all
Dialogue: 0,0:24:00.06,0:24:02.76,Chinese,,0,0,0,,这里根本看不到缓存的意义
Dialogue: 0,0:24:03.28,0:24:06.84,English,,0,0,0,,Because it just is automatically loaded with recent stuff
Dialogue: 0,0:24:03.28,0:24:06.84,Chinese,,0,0,0,,因为它只是自动加载最近的东西
Dialogue: 0,0:24:08.16,0:24:13.14,English,,0,0,0,,And the only thing that will look different is if you re-access that memory it will go faster
Dialogue: 0,0:24:08.16,0:24:13.14,Chinese,,0,0,0,,唯一看起来不同的是，如果你重新访问那个内存，就会更快
Dialogue: 0,0:24:13.18,0:24:15.18,English,,0,0,0,,Than it would if it hadn't been cached
Dialogue: 0,0:24:13.18,0:24:15.18,Chinese,,0,0,0,,这在没有缓存的情况下是不会发生的
Dialogue: 0,0:24:15.82,0:24:17.72,English,,0,0,0,,But it's not visible in terms of
Dialogue: 0,0:24:15.82,0:24:17.72,Chinese,,0,0,0,,但就程序而言，它并不可见
Dialogue: 0,0:24:18.04,0:24:20.62,English,,0,0,0,,There's no instructions to manipulate the cache
Dialogue: 0,0:24:18.04,0:24:20.62,Chinese,,0,0,0,,没有操作缓存的指令
Dialogue: 0,0:24:20.72,0:24:24.92,English,,0,0,0,,There's no way you can directly access the cache
Dialogue: 0,0:24:20.72,0:24:24.92,Chinese,,0,0,0,,你无法直接访问缓存
Dialogue: 0,0:24:26.94,0:24:33.08,English,,0,0,0,,So you already see that it's already abstract it's got some more details of real hardware
Dialogue: 0,0:24:26.94,0:24:33.08,Chinese,,0,0,0,,所以你已经看到处理器是抽象的，它有许多与真实硬件有关的细节
Dialogue: 0,0:24:33.50,0:24:39.28,English,,0,0,0,,But underneath it the sort of micro architecture level has some features built into it
Dialogue: 0,0:24:33.50,0:24:39.28,Chinese,,0,0,0,,但在其下面，微架构级别具有内置的一些功能
Dialogue: 0,0:24:39.64,0:24:45.38,English,,0,0,0,,That you're not operating on you're not making use of directly
Dialogue: 0,0:24:39.64,0:24:45.38,Chinese,,0,0,0,,你没有在操作中直接使用它们
Dialogue: 0,0:24:47.30,0:24:49.14,English,,0,0,0,,Yeah when you write machine level programs
Dialogue: 0,0:24:47.30,0:24:49.14,Chinese,,0,0,0,,是的，当你编写机器级程序时
Dialogue: 0,0:24:52.84,0:24:57.38,English,,0,0,0,,So if you have a program then say and C
Dialogue: 0,0:24:52.84,0:24:57.38,Chinese,,0,0,0,,所以，如果你有一个程序例如是 C 程序
Dialogue: 0,0:24:57.38,0:25:01.58,English,,0,0,0,,It would typically on a larger program that will include multiple files
Dialogue: 0,0:24:57.38,0:25:01.58,Chinese,,0,0,0,,它通常会包含一个包含多个文件的大型程序
Dialogue: 0,0:25:02.30,0:25:05.20,English,,0,0,0,,And it will make use of some library code
Dialogue: 0,0:25:02.30,0:25:05.20,Chinese,,0,0,0,,它将使用一些库代码
Dialogue: 0,0:25:05.72,0:25:09.92,English,,0,0,0,,And so the process of compilation is actually a series of steps
Dialogue: 0,0:25:05.72,0:25:09.92,Chinese,,0,0,0,,因此编译过程实际上是一系列步骤
Dialogue: 0,0:25:10.68,0:25:12.82,English,,0,0,0,,That will take what you've written for code
Dialogue: 0,0:25:10.68,0:25:12.82,Chinese,,0,0,0,,将你写的代码中的内容
Dialogue: 0,0:25:13.34,0:25:17.24,English,,0,0,0,,Turn it into machine code,combine it with the compiled
Dialogue: 0,0:25:13.34,0:25:17.24,Chinese,,0,0,0,,转换为机器代码，并将其与编译后的
Dialogue: 0,0:25:18.00,0:25:24.16,English,,0,0,0,,Compiler generated code for the libraries and produce finally a in a file
Dialogue: 0,0:25:18.00,0:25:24.16,Chinese,,0,0,0,,编译器为库生成代码合并，并最终生成一个文件
Dialogue: 0,0:25:24.56,0:25:26.76,English,,0,0,0,,That's your actual executable program
Dialogue: 0,0:25:24.56,0:25:26.76,Chinese,,0,0,0,,那才是你真正的可执行程序
Dialogue: 0,0:25:27.52,0:25:34.24,English,,0,0,0,,And there's shown here in this picture that the first step is to take C and actually generate assembly code from it
Dialogue: 0,0:25:27.52,0:25:34.24,Chinese,,0,0,0,,这张照片中显示的是，第一步是采用 C 并实际生成汇编代码
Dialogue: 0,0:25:35.20,0:25:38.04,English,,0,0,0,,And then the next is to run that through an assembler
Dialogue: 0,0:25:35.20,0:25:38.04,Chinese,,0,0,0,,接下来是通过汇编程序运行它
Dialogue: 0,0:25:38.04,0:25:44.84,English,,0,0,0,,Which takes the text representation of instructions and turns it into the actual byte level representation
Dialogue: 0,0:25:38.04,0:25:44.84,Chinese,,0,0,0,,它接受文本表示的指令并将其转换为实际的字节形式
Dialogue: 0,0:25:45.06,0:25:46.66,English,,0,0,0,,We'll look at all this shortly
Dialogue: 0,0:25:45.06,0:25:46.66,Chinese,,0,0,0,,我们很快就会看到这一切
Dialogue: 0,0:25:47.56,0:25:50.98,English,,0,0,0,,And then there's a program called a linker
Dialogue: 0,0:25:47.56,0:25:50.98,Chinese,,0,0,0,,然后有一个叫做链接器的程序
Dialogue: 0,0:25:51.28,0:25:57.28,English,,0,0,0,,Which merges together all the different files for both your individual file
Dialogue: 0,0:25:51.28,0:25:57.28,Chinese,,0,0,0,,它将不同的文件融合在一起，包含你的单独的文件
Dialogue: 0,0:25:57.72,0:26:01.99,English,,0,0,0,,Their compiled versions and for the library code
Dialogue: 0,0:25:57.72,0:26:01.99,Chinese,,0,0,0,,他们的已编译版本和库代码
Dialogue: 0,0:26:02.78,0:26:06.28,English,,0,0,0,,And then finally there's a even once you run a program
Dialogue: 0,0:26:02.78,0:26:06.28,Chinese,,0,0,0,,最后，甚至你当运行某个程序的时候
Dialogue: 0,0:26:06.28,0:26:12.62,English,,0,0,0,,There's actually some libraries that get imported dynamically when the program first begins
Dialogue: 0,0:26:06.28,0:26:12.62,Chinese,,0,0,0,,实际上有一些库在程序首次开始时动态导入
Dialogue: 0,0:26:14.16,0:26:17.36,English,,0,0,0,,So it's a sort of many layered set of activities
Dialogue: 0,0:26:14.16,0:26:17.36,Chinese,,0,0,0,,所以它是一种多层次的活动
Dialogue: 0,0:26:17.84,0:26:21.10,English,,0,0,0,,And I'll go through some of these one-by-one for you
Dialogue: 0,0:26:17.84,0:26:21.10,Chinese,,0,0,0,,我将逐一介绍其中的部分内容
Dialogue: 0,0:26:22.58,0:26:28.84,English,,0,0,0,,So for example here's a not very interesting function in terms of doing anything useful
Dialogue: 0,0:26:22.58,0:26:28.84,Chinese,,0,0,0,,例如，在做任何有用的事情方面来说，这是一个不是很有趣的函数
Dialogue: 0,0:26:28.84,0:26:33.22,English,,0,0,0,,But it sort of demonstrates the basic ideas of compilation
Dialogue: 0,0:26:28.84,0:26:33.22,Chinese,,0,0,0,,但它初步展示了编译的基本思想
Dialogue: 0,0:26:33.68,0:26:36.34,English,,0,0,0,,And if I run this through a C compiler
Dialogue: 0,0:26:33.68,0:26:36.34,Chinese,,0,0,0,,如果我通过 C 编译器运行它
Dialogue: 0,0:26:37.02,0:26:42.10,English,,0,0,0,,I get something that looks like what's shown on the right and that's assembly code
Dialogue: 0,0:26:37.02,0:26:42.10,Chinese,,0,0,0,,我得到了一些看起来像右边的东西，那就是汇编代码
Dialogue: 0,0:26:43.12,0:26:45.36,English,,0,0,0,,And just to give you an idea of what it is
Dialogue: 0,0:26:43.12,0:26:45.36,Chinese,,0,0,0,,只是为了让你知道它是什么
Dialogue: 0,0:26:45.36,0:26:48.50,English,,0,0,0,,It looks like a sort of strange language the first time you see it
Dialogue: 0,0:26:45.36,0:26:48.50,Chinese,,0,0,0,,第一次看到它时，它看起来像一种奇怪的语言
Dialogue: 0,0:26:49.06,0:26:51.44,English,,0,0,0,,But you'll see those percent are
Dialogue: 0,0:26:49.06,0:26:51.44,Chinese,,0,0,0,,但你会看到那些百分号
Dialogue: 0,0:26:51.88,0:26:54.54,English,,0,0,0,,Something those are the actual names of registers
Dialogue: 0,0:26:51.88,0:26:54.54,Chinese,,0,0,0,,这些是寄存器的实际名称
Dialogue: 0,0:26:54.66,0:26:57.58,English,,0,0,0,,Remember I told you there's registers that you give by name
Dialogue: 0,0:26:54.66,0:26:57.58,Chinese,,0,0,0,,我刚才告诉过你寄存器是通过名字给出的
Dialogue: 0,0:26:59.28,0:27:02.06,English,,0,0,0,,And then those instructions are telling it to do something
Dialogue: 0,0:26:59.28,0:27:02.06,Chinese,,0,0,0,,然后那些指令告诉它做某事
Dialogue: 0,0:27:02.16,0:27:04.98,English,,0,0,0,,Pushq means push something onto a stack
Dialogue: 0,0:27:02.16,0:27:04.98,Chinese,,0,0,0,,pushq 意味着将东西推到栈上
Dialogue: 0,0:27:05.72,0:27:09.10,English,,0,0,0,,Mov means move copy it from one place to another
Dialogue: 0,0:27:05.72,0:27:09.10,Chinese,,0,0,0,,mov 意味着将它从一个地方复制到另一个地方
Dialogue: 0,0:27:09.56,0:27:11.86,English,,0,0,0,,Call means to call some procedure
Dialogue: 0,0:27:09.56,0:27:11.86,Chinese,,0,0,0,,call 意味着调用一些过程
Dialogue: 0,0:27:12.70,0:27:15.12,English,,0,0,0,,Pop is the counterpart to push
Dialogue: 0,0:27:12.70,0:27:15.12,Chinese,,0,0,0,,pop 是 push 的对应指令
Dialogue: 0,0:27:15.74,0:27:20.32,English,,0,0,0,,And then ret is exit return out of this particular function
Dialogue: 0,0:27:15.74,0:27:20.32,Chinese,,0,0,0,,然后 ret 是从一个特定的函数返回
Dialogue: 0,0:27:20.32,0:27:24.82,English,,0,0,0,,So you see each of those is an instruction and it's written in text
Dialogue: 0,0:27:20.32,0:27:24.82,Chinese,,0,0,0,,所以你看到每一个都是一个指令，它是用文本写的
Dialogue: 0,0:27:24.82,0:27:30.74,English,,0,0,0,,But each of those will turn into one actual instruction in the object code representation
Dialogue: 0,0:27:24.82,0:27:30.74,Chinese,,0,0,0,,但是每条都将变成目标代码文件中的一个实际指令
Dialogue: 0,0:27:32.38,0:27:37.58,English,,0,0,0,,So I should tell you that this is actually a slightly cleaned up version of what really happens
Dialogue: 0,0:27:32.38,0:27:37.58,Chinese,,0,0,0,,所以我应该告诉你，这实际上是一个稍微整理过的版本
Dialogue: 0,0:27:37.60,0:27:41.80,English,,0,0,0,,So let me show you the reality because you'll be experiencing that a bit more too
Dialogue: 0,0:27:37.60,0:27:41.80,Chinese,,0,0,0,,所以让我来告诉你实际编译结果，你也会体验到更多
Dialogue: 0,0:27:47.60,0:28:04.68,English,,0,0,0,,They had this bigger before let me make it bigger
Dialogue: 0,0:27:47.60,0:28:04.68,Chinese,,0,0,0,,这个变大前要先把这个变大
Dialogue: 0,0:28:04.72,0:28:10.42,English,,0,0,0,,And blow this up so that you can see it
Dialogue: 0,0:28:04.72,0:28:10.42,Chinese,,0,0,0,,然后把它放大让你们能够看到
Dialogue: 0,0:28:10.48,0:28:12.02,English,,0,0,0,,Can you see it in the back there?
Dialogue: 0,0:28:10.48,0:28:12.02,Chinese,,0,0,0,,你能在那里看到它吗？
Dialogue: 0,0:28:13.82,0:28:23.70,English,,0,0,0,,Bigger?better?
Dialogue: 0,0:28:13.82,0:28:23.70,Chinese,,0,0,0,,更大？好点了？
Dialogue: 0,0:28:23.82,0:28:29.16,English,,0,0,0,,And let me get the other one
Dialogue: 0,0:28:23.82,0:28:29.16,Chinese,,0,0,0,,让我把另一个也弄大
Dialogue: 0,0:28:29.20,0:28:50.42,English,,0,0,0,,It's not anyone
Dialogue: 0,0:28:29.20,0:28:50.42,Chinese,,0,0,0,,这里不是任何人
Dialogue: 0,0:28:50.44,0:28:56.18,English,,0,0,0,,And they've already logged into a fish machine to get here
Dialogue: 0,0:28:50.44,0:28:56.18,Chinese,,0,0,0,,他们已经登录了一台鱼机来到这里
Dialogue: 0,0:28:56.18,0:29:01.80,English,,0,0,0,,So this is a file then you see it's called some .c
Dialogue: 0,0:28:56.18,0:29:01.80,Chinese,,0,0,0,,所以这是一个文件然后你看到它被称为一些 .c
Dialogue: 0,0:29:02.26,0:29:07.14,English,,0,0,0,,And I mention that all of these programs are available you can see the whole
Dialogue: 0,0:29:02.26,0:29:07.14,Chinese,,0,0,0,,我提到所有这些程序都可用，你可以看到整体
Dialogue: 0,0:29:08.26,0:29:14.62,English,,0,0,0,,Well slash afs is my own personal and all that first stuff is my own personal links
Dialogue: 0,0:29:08.26,0:29:14.62,Chinese,,0,0,0,,/afs/ 是我自己的个人路径，最开始的就是我自己的个人路径
Dialogue: 0,0:29:15.18,0:29:17.56,English,,0,0,0,,But once you get to the class webpage
Dialogue: 0,0:29:15.18,0:29:17.56,Chinese,,0,0,0,,但是一旦你进入课堂网页
Dialogue: 0,0:29:18.10,0:29:24.34,English,,0,0,0,,Or www slash code slash and then it's all given by which particular lecture it
Dialogue: 0,0:29:18.10,0:29:24.34,Chinese,,0,0,0,,或者 www/code/ 然后，后面内容是由哪个特定讲座给出的
Dialogue: 0,0:29:25.20,0:29:27.86,English,,0,0,0,,I think these are linked on the home page too
Dialogue: 0,0:29:25.20,0:29:27.86,Chinese,,0,0,0,,我认为这些链接在主页上也有
Dialogue: 0,0:29:28.38,0:29:30.04,English,,0,0,0,,And you can see various files there
Dialogue: 0,0:29:28.38,0:29:30.04,Chinese,,0,0,0,,你可以在那里看到各种文件
Dialogue: 0,0:29:30.90,0:29:37.54,English,,0,0,0,,That are used for the demonstration the C files are obviously the programs that we typed in
Dialogue: 0,0:29:30.90,0:29:37.54,Chinese,,0,0,0,,这用于演示，里面的 C 文件显然是我们码出来的
Dialogue: 0,0:29:37.54,0:29:41.72,English,,0,0,0,,And then once it have an s at the end that's assembly code
Dialogue: 0,0:29:37.54,0:29:41.72,Chinese,,0,0,0,,然后，后面有个 s 的文件，那是汇编文件
Dialogue: 0,0:29:41.72,0:29:44.16,English,,0,0,0,,One that end of d what's called disassembly
Dialogue: 0,0:29:41.72,0:29:44.16,Chinese,,0,0,0,,一个后缀是 d 的文件就是所谓的反汇编代码
Dialogue: 0,0:29:44.94,0:29:57.24,English,,0,0,0,,So anyways if I say gcc -o2 ,I'm sorry. -og -s sum.c
Dialogue: 0,0:29:44.94,0:29:57.24,Chinese,,0,0,0,,所以无论如何，如果我说 gcc -O2，说错了。 -Og -S sum.c
Dialogue: 0,0:29:58.80,0:30:05.68,English,,0,0,0,,That what I did was just tell the compiler to take the C code and turn it into assembly code
Dialogue: 0,0:29:58.80,0:30:05.68,Chinese,,0,0,0,,我所做的只是告诉编译器将 C 代码转换为汇编代码
Dialogue: 0,0:30:06.14,0:30:10.90,English,,0,0,0,,So when you invoke GCC you're actually invoking it's not just one program
Dialogue: 0,0:30:06.14,0:30:10.90,Chinese,,0,0,0,,所以当你调用 GCC 时，实际上你调用的不仅仅是一个程序
Dialogue: 0,0:30:10.90,0:30:12.50,English,,0,0,0,,But a whole sequence of programs
Dialogue: 0,0:30:10.90,0:30:12.50,Chinese,,0,0,0,,但整个程序序列
Dialogue: 0,0:30:13.36,0:30:16.52,English,,0,0,0,,That do various stages of the compilation
Dialogue: 0,0:30:13.36,0:30:16.52,Chinese,,0,0,0,,来完成编译的不同阶段
Dialogue: 0,0:30:16.88,0:30:20.34,English,,0,0,0,,And by giving it this -s which I'm saying stop
Dialogue: 0,0:30:16.88,0:30:20.34,Chinese,,0,0,0,,通过给它 -S 我的意思是 Stop 停止
Dialogue: 0,0:30:21.42,0:30:24.20,English,,0,0,0,,I'll just do the first part C to assembly code
Dialogue: 0,0:30:21.42,0:30:24.20,Chinese,,0,0,0,,只做第一部分，把 C 转换成汇编代码
Dialogue: 0,0:30:25.66,0:30:33.56,English,,0,0,0,,And the -og is a specification of what kind of optimization I want the compiler to do
Dialogue: 0,0:30:25.66,0:30:33.56,Chinese,,0,0,0,,-Og 是我希望编译器做什么样的优化的规范
Dialogue: 0,0:30:34.22,0:30:36.02,English,,0,0,0,,So if you don't say anything
Dialogue: 0,0:30:34.22,0:30:36.02,Chinese,,0,0,0,,所以，如果你什么也不加
Dialogue: 0,0:30:36.64,0:30:44.38,English,,0,0,0,,If you just don't give any directive, it will generate completely unoptimized code and it's actually very hard to read that code
Dialogue: 0,0:30:36.64,0:30:44.38,Chinese,,0,0,0,,如果你不给它指示，它将生成完全未经优化的代码，实际上很难读该代码
Dialogue: 0,0:30:44.38,0:30:47.92,English,,0,0,0,,It's very tedious the way it works
Dialogue: 0,0:30:44.38,0:30:47.92,Chinese,,0,0,0,,它的运行过程非常繁琐
Dialogue: 0,0:30:48.56,0:30:51.56,English,,0,0,0,,You say -o1
Dialogue: 0,0:30:48.56,0:30:51.56,Chinese,,0,0,0,,你说 -O1
Dialogue: 0,0:30:51.56,0:30:55.76,English,,0,0,0,,Which is what you used to do to turn on the optimizer
Dialogue: 0,0:30:51.56,0:30:55.76,Chinese,,0,0,0,,这是过去打开优化器的过程
Dialogue: 0,0:30:55.96,0:30:59.44,English,,0,0,0,,It turns out that as GCC as they've gotten more advanced
Dialogue: 0,0:30:55.96,0:30:59.44,Chinese,,0,0,0,,事实证明，因为 GCC 变得更先进了
Dialogue: 0,0:30:59.90,0:31:02.22,English,,0,0,0,,It does a lot of optimizations now
Dialogue: 0,0:30:59.90,0:31:02.22,Chinese,,0,0,0,,它现在做了很多优化
Dialogue: 0,0:31:02.66,0:31:07.34,English,,0,0,0,,That for the purpose of this course make the code pretty hard to understand
Dialogue: 0,0:31:02.66,0:31:07.34,Chinese,,0,0,0,,为了优化的目的，使代码很难理解
Dialogue: 0,0:31:07.90,0:31:16.46,English,,0,0,0,,So just with one of the most recent generations of GCC came out with this level called g for debugging
Dialogue: 0,0:31:07.90,0:31:16.46,Chinese,,0,0,0,,因此，最近几代 GCC 中的一个出现了这个名为 g 的调试级别
Dialogue: 0,0:31:16.88,0:31:19.46,English,,0,0,0,,That's a nice for this course
Dialogue: 0,0:31:16.88,0:31:19.46,Chinese,,0,0,0,,这对于这门课程来说很不错
Dialogue: 0,0:31:20.22,0:31:26.92,English,,0,0,0,,Purpose of this course a nice level that sort of does the obvious kind of optimizations to make the code readable
Dialogue: 0,0:31:20.22,0:31:26.92,Chinese,,0,0,0,,这个选项使得代码更可读，在这层面进行明显的优化
Dialogue: 0,0:31:27.16,0:31:30.90,English,,0,0,0,,Without being sort of extravagant and trying to
Dialogue: 0,0:31:27.16,0:31:30.90,Chinese,,0,0,0,,没有那种竭尽全力试图
Dialogue: 0,0:31:31.30,0:31:36.68,English,,0,0,0,,Rewrite your whole program in a way that would make it a lot different  and hopefully more efficient
Dialogue: 0,0:31:31.30,0:31:36.68,Chinese,,0,0,0,,重写整个程序，使它与众不同并希望更有效率
Dialogue: 0,0:31:37.06,0:31:38.62,English,,0,0,0,,So that's what we'll use in this course
Dialogue: 0,0:31:37.06,0:31:38.62,Chinese,,0,0,0,,这就是我们将在本课程中使用的内容
Dialogue: 0,0:31:39.16,0:31:44.30,English,,0,0,0,,It's only exists in the recent versions of GCC it's non-standard across other compilers
Dialogue: 0,0:31:39.16,0:31:44.30,Chinese,,0,0,0,,它仅存在于最近的 GCC 版本中，非标准的并与其他编译器不同
Dialogue: 0,0:31:44.32,0:31:45.16,English,,0,0,0,,Question
Dialogue: 0,0:31:44.32,0:31:45.16,Chinese,,0,0,0,,请问
Dialogue: 0,0:31:45.16,0:31:48.36,English,,0,0,0,,[sutdent speaking]
Dialogue: 0,0:31:45.16,0:31:48.36,Chinese,,0,0,0,,[学生发言]
Dialogue: 0,0:31:48.38,0:31:53.02,English,,0,0,0,,No it's an o capital o,it stands for optimized
Dialogue: 0,0:31:48.38,0:31:53.02,Chinese,,0,0,0,,不，它是一个 O，大写 O，它代表 Optimize 优化
Dialogue: 0,0:31:55.84,0:32:00.76,English,,0,0,0,,So what that command just did was produce a file called sum.s
Dialogue: 0,0:31:55.84,0:32:00.76,Chinese,,0,0,0,,所以刚刚的命令生成了一个名为 sum.s 的文件
Dialogue: 0,0:32:02.08,0:32:03.38,English,,0,0,0,,So let me show you
Dialogue: 0,0:32:02.08,0:32:03.38,Chinese,,0,0,0,,所以，让我告诉你
Dialogue: 0,0:32:07.28,0:32:11.26,English,,0,0,0,,What sum.s is and let me show you the function sumstore
Dialogue: 0,0:32:07.28,0:32:11.26,Chinese,,0,0,0,,sum.s 是什么，让我告诉你里面的函数 sumstore
Dialogue: 0,0:32:16.24,0:32:28.58,English,,0,0,0,,Can you see that then? okay
Dialogue: 0,0:32:16.24,0:32:28.58,Chinese,,0,0,0,,那你能看到吗？好的
Dialogue: 0,0:32:28.58,0:32:32.10,English,,0,0,0,,So this is the code it says sumstore
Dialogue: 0,0:32:28.58,0:32:32.10,Chinese,,0,0,0,,所以这里写的是 sumstore 的代码
Dialogue: 0,0:32:33.12,0:32:36.74,English,,0,0,0,,And then you'll see, you'll recognize those instructions I mentioned before
Dialogue: 0,0:32:33.12,0:32:36.74,Chinese,,0,0,0,,然后你会看到，你会认出我之前提到的那些指令
Dialogue: 0,0:32:36.74,0:32:41.36,English,,0,0,0,,The push,the mov, the call, the mov, the pop and the ret
Dialogue: 0,0:32:36.74,0:32:41.36,Chinese,,0,0,0,,push，mov，call，mov，pop 和 ret
Dialogue: 0,0:32:41.68,0:32:43.44,English,,0,0,0,,But you also see other junk there
Dialogue: 0,0:32:41.68,0:32:43.44,Chinese,,0,0,0,,但你也看到那里有一些乱七八糟的东西
Dialogue: 0,0:32:47.32,0:32:52.02,English,,0,0,0,,Than that we edited out for the presentation and even in the book it got edited out
Dialogue: 0,0:32:47.32,0:32:52.02,Chinese,,0,0,0,,和我们为演示文稿编辑的，甚至在编辑出来的书中不同
Dialogue: 0,0:32:52.66,0:32:57.74,English,,0,0,0,,And the reason is these are various directives that aren't really directly part of the code itself
Dialogue: 0,0:32:52.66,0:32:57.74,Chinese,,0,0,0,,原因是这些是各种指令，并不是代码本身的直接部分
Dialogue: 0,0:32:58.20,0:33:04.44,English,,0,0,0,,The fact they start with a period is an indication that these aren't actually instructions they're something else
Dialogue: 0,0:32:58.20,0:33:04.44,Chinese,,0,0,0,,他们以一个句点开头，这些实际上指示他们是别的东西
Dialogue: 0,0:33:04.66,0:33:10.40,English,,0,0,0,,And they all are related to what the information that needs to be fed
Dialogue: 0,0:33:04.66,0:33:10.40,Chinese,,0,0,0,,它们与某些被需要的信息有关，要给
Dialogue: 0,0:33:10.98,0:33:16.22,English,,0,0,0,,To a debugger for it to be able to locate various parts of the program
Dialogue: 0,0:33:10.98,0:33:16.22,Chinese,,0,0,0,,调试器提供，使它能够定位程序的各个部分
Dialogue: 0,0:33:16.76,0:33:22.16,English,,0,0,0,,And some information for the linker to tell it that this is a globally defined function
Dialogue: 0,0:33:16.76,0:33:22.16,Chinese,,0,0,0,,一些信息告诉链接器，这是一个全局定义的函数
Dialogue: 0,0:33:22.56,0:33:27.42,English,,0,0,0,,And various other things that you don't really need to at least think about initially
Dialogue: 0,0:33:22.56,0:33:27.42,Chinese,,0,0,0,,还有其他的不同信息，你在一开始的时候不需要考虑他们太多
Dialogue: 0,0:33:27.78,0:33:32.88,English,,0,0,0,,So we sort of take those out of the program just to make them more readable
Dialogue: 0,0:33:27.78,0:33:32.88,Chinese,,0,0,0,,因此，我们将这些从程序中删除，以使它们更具可读性
Dialogue: 0,0:33:33.26,0:33:37.22,English,,0,0,0,,But if you ever do this yourself you'll find this crud in there
Dialogue: 0,0:33:33.26,0:33:37.22,Chinese,,0,0,0,,但如果你做了这件事，你会在那里发现这个问题
Dialogue: 0,0:33:37.22,0:33:41.48,English,,0,0,0,,And we don't want you to get like, oh my gosh this wasn't in the book I don't know what to do with it
Dialogue: 0,0:33:37.22,0:33:41.48,Chinese,,0,0,0,,我们不希望你这样，哦，我的天哪，书上没写，我不知道该怎么做
Dialogue: 0,0:33:46.72,0:33:48.44,English,,0,0,0,,So let's go back
Dialogue: 0,0:33:46.72,0:33:48.44,Chinese,,0,0,0,,让我们言归正传
Dialogue: 0,0:33:58.04,0:34:04.32,English,,0,0,0,,The other thing is people are learning on data lab is shark versus non shark it makes a difference
Dialogue: 0,0:33:58.04,0:34:04.32,Chinese,,0,0,0,,另一件事是正在学习的数据实验室，有鲨鱼机和非鲨鱼机两种，他们之间有区别
Dialogue: 0,0:34:04.56,0:34:11.32,English,,0,0,0,,And even like this is a MAC computer and I can run got gcc installed
Dialogue: 0,0:34:04.56,0:34:11.32,Chinese,,0,0,0,,这是一台 MAC 计算机，我可以安装运行 GCC
Dialogue: 0,0:34:11.92,0:34:14.62,English,,0,0,0,,And it generates its intel processor in there
Dialogue: 0,0:34:11.92,0:34:14.62,Chinese,,0,0,0,,它生产的代码也是运行在 Intel 处理器上的
Dialogue: 0,0:34:15.18,0:34:19.00,English,,0,0,0,,But it's not directly compatible with linux code so
Dialogue: 0,0:34:15.18,0:34:19.00,Chinese,,0,0,0,,但它并不直接与 Linux 代码兼容
Dialogue: 0,0:34:19.44,0:34:21.22,English,,0,0,0,,It's pretty important for this course
Dialogue: 0,0:34:19.44,0:34:21.22,Chinese,,0,0,0,,这对于这门课程来说非常重要
Dialogue: 0,0:34:21.22,0:34:24.60,English,,0,0,0,,We're saying just stick with the shark machines for everything you do
Dialogue: 0,0:34:21.22,0:34:24.60,Chinese,,0,0,0,,我们坚持只使用鲨鱼机器来做你所做的一切
Dialogue: 0,0:34:29.32,0:34:32.06,English,,0,0,0,,So what are some characteristics that have assembly code
Dialogue: 0,0:34:29.32,0:34:32.06,Chinese,,0,0,0,,那么具有汇编代码的一些特性是什么呢？
Dialogue: 0,0:34:32.06,0:34:34.72,English,,0,0,0,,Especially how do they differ from C
Dialogue: 0,0:34:32.06,0:34:34.72,Chinese,,0,0,0,,特别是它们与 C 有什么不同
Dialogue: 0,0:34:35.38,0:34:39.54,English,,0,0,0,,Well first of all there is a number of different sort of integer data types
Dialogue: 0,0:34:35.38,0:34:39.54,Chinese,,0,0,0,,首先，有许多不同类型的整数数据类型
Dialogue: 0,0:34:40.02,0:34:42.96,English,,0,0,0,,Of size 1,2,4 and 8 bytes
Dialogue: 0,0:34:40.02,0:34:42.96,Chinese,,0,0,0,,大小为 1,2,4 和 8 字节
Dialogue: 0,0:34:43.32,0:34:51.54,English,,0,0,0,,In integer data types they don't distinguish sign versus unsigned in how in how it gets stored
Dialogue: 0,0:34:43.32,0:34:51.54,Chinese,,0,0,0,,在整数数据类型中，它们不区分符号与无符号的存储方式
Dialogue: 0,0:34:51.86,0:34:57.26,English,,0,0,0,,And even at an address or a pointer is just stored as a number in a computer
Dialogue: 0,0:34:51.86,0:34:57.26,Chinese,,0,0,0,,甚至地址或指针，都是以数字形式存储在计算机中
Dialogue: 0,0:34:57.78,0:35:01.10,English,,0,0,0,,And doesn't have any special significance to it
Dialogue: 0,0:34:57.78,0:35:01.10,Chinese,,0,0,0,,并没有任何特殊意义
Dialogue: 0,0:35:02.16,0:35:04.74,English,,0,0,0,,A floating-point is handled in a very different way
Dialogue: 0,0:35:02.16,0:35:04.74,Chinese,,0,0,0,,浮点以非常不同的方式处理
Dialogue: 0,0:35:04.74,0:35:07.20,English,,0,0,0,,On the other hand with a different set of registers
Dialogue: 0,0:35:04.74,0:35:07.20,Chinese,,0,0,0,,另一方面，使用不同的寄存器组
Dialogue: 0,0:35:07.68,0:35:11.82,English,,0,0,0,,That I think I'll talk about very briefly in one of the later lectures
Dialogue: 0,0:35:07.68,0:35:11.82,Chinese,,0,0,0,,我想在后面的一个讲座中非常简短地谈一下
Dialogue: 0,0:35:12.50,0:35:16.68,English,,0,0,0,,The program itself is in x86 it's just a series of bytes
Dialogue: 0,0:35:12.50,0:35:16.68,Chinese,,0,0,0,,程序本身在 x86 中，它只是一系列字节
Dialogue: 0,0:35:16.68,0:35:18.48,English,,0,0,0,,And I'll show you some examples of those
Dialogue: 0,0:35:16.68,0:35:18.48,Chinese,,0,0,0,,我会告诉你一些这方面的例子
Dialogue: 0,0:35:19.30,0:35:21.88,English,,0,0,0,,And things like arrays and structs
Dialogue: 0,0:35:19.30,0:35:21.88,Chinese,,0,0,0,,像数组和结构这样的东西
Dialogue: 0,0:35:22.32,0:35:25.34,English,,0,0,0,,And things that you think of as fundamental datatypes
Dialogue: 0,0:35:22.32,0:35:25.34,Chinese,,0,0,0,,你认为是基本数据类型的东西
Dialogue: 0,0:35:26.00,0:35:27.82,English,,0,0,0,,Don't exist at the machine level
Dialogue: 0,0:35:26.00,0:35:27.82,Chinese,,0,0,0,,不存在于机器级别
Dialogue: 0,0:35:27.82,0:35:31.74,English,,0,0,0,,They're sort of constructed artificially by the compiler
Dialogue: 0,0:35:27.82,0:35:31.74,Chinese,,0,0,0,,它们是由编译器人工构造的
Dialogue: 0,0:35:31.78,0:35:37.52,English,,0,0,0,,And later in the course in these lectures we'll cross over into how that's actually done as well
Dialogue: 0,0:35:31.78,0:35:37.52,Chinese,,0,0,0,,在这些讲座的后续课程中，我们将讨论如何实际实现这些
Dialogue: 0,0:35:38.52,0:35:42.50,English,,0,0,0,,So some of the things you know about and see exist here
Dialogue: 0,0:35:38.52,0:35:42.50,Chinese,,0,0,0,,所以你知道和看到的一些东西都存在于此
Dialogue: 0,0:35:42.86,0:35:49.42,English,,0,0,0,,And some of them are sort of have to be built up in layers on top of the assembly level program
Dialogue: 0,0:35:42.86,0:35:49.42,Chinese,,0,0,0,,其中一些必须在汇编级别程序的上层构建
Dialogue: 0,0:35:52.54,0:35:59.02,English,,0,0,0,,So the other thing about assembly level programming is each instruction is very very limited in what it can do it
Dialogue: 0,0:35:52.54,0:35:59.02,Chinese,,0,0,0,,所以关于汇编级编程的另一件事是每条指令在它能做到的事情上都非常有限
Dialogue: 0,0:35:59.08,0:36:03.04,English,,0,0,0,,Can move data from a register to memory, from...
Dialogue: 0,0:35:59.08,0:36:03.04,Chinese,,0,0,0,,可以将数据从寄存器移动到内存，从......
Dialogue: 0,0:36:03.56,0:36:08.52,English,,0,0,0,,Or can do an addition or a multiplication
Dialogue: 0,0:36:03.56,0:36:08.52,Chinese,,0,0,0,,或者可以进行加法或乘法
Dialogue: 0,0:36:09.30,0:36:12.68,English,,0,0,0,,Or something like that but it can really basically only do one thing
Dialogue: 0,0:36:09.30,0:36:12.68,Chinese,,0,0,0,,或类似的东西，但它基本上只能做一件事
Dialogue: 0,0:36:13.64,0:36:19.68,English,,0,0,0,,And so you have to write a whole if you were writing it by hand
Dialogue: 0,0:36:13.64,0:36:19.68,Chinese,,0,0,0,,所以如果你手工编写，你必须完成全部工作
Dialogue: 0,0:36:19.68,0:36:23.22,English,,0,0,0,,And you'd have to write a whole series of instructions to get anything done
Dialogue: 0,0:36:19.68,0:36:23.22,Chinese,,0,0,0,,你必须编写一系列指令来完成任何事情
Dialogue: 0,0:36:23.66,0:36:26.84,English,,0,0,0,,And that's part of the reason why it's really much better to what the compiler do that
Dialogue: 0,0:36:23.66,0:36:26.84,Chinese,,0,0,0,,这就是为什么编译器做得更好的部分原因
Dialogue: 0,0:36:28.72,0:36:39.42,English,,0,0,0,,And we'll also see,they're sort of how things like do loops,while loops,conditionals,switch statements
Dialogue: 0,0:36:28.72,0:36:39.42,Chinese,,0,0,0,,而且我们也会看到，类似于 do 循环 while 循环，条件语句，切换语句等是什么样的
Dialogue: 0,0:36:39.42,0:36:45.84,English,,0,0,0,,Those are all built up on top of some other on lower level features in the instructions
Dialogue: 0,0:36:39.42,0:36:45.84,Chinese,,0,0,0,,这些都是在指令中的低级功能之上构建的
Dialogue: 0,0:36:47.54,0:36:54.36,English,,0,0,0,,So for this function of sumstore actually it gets encoded by a total of 14 bytes
Dialogue: 0,0:36:47.54,0:36:54.36,Chinese,,0,0,0,,因此对于 sumstore 函数，实际上它被编码了总共 14 个字节
Dialogue: 0,0:36:55.38,0:37:00.14,English,,0,0,0,,And so one thing about x86 is some instructions are as short as one byte
Dialogue: 0,0:36:55.38,0:37:00.14,Chinese,,0,0,0,,所以关于 x86 的一个事实是，一些指令只有一个字节
Dialogue: 0,0:37:00.84,0:37:07.10,English,,0,0,0,,But others can be as long as 15 bytes in the encoding and
Dialogue: 0,0:37:00.84,0:37:07.10,Chinese,,0,0,0,,但是其他指令在编码后可能最多有 15 个字节
Dialogue: 0,0:37:13.74,0:37:18.22,English,,0,0,0,,Like I said each instruction really typically only does one thing
Dialogue: 0,0:37:13.74,0:37:18.22,Chinese,,0,0,0,,就像我说的每条指令通常只做一件事
Dialogue: 0,0:37:18.82,0:37:22.46,English,,0,0,0,,So for example and see if you see *dest=t
Dialogue: 0,0:37:18.82,0:37:22.46,Chinese,,0,0,0,,例如，看看你是否看到 *dest = t
Dialogue: 0,0:37:23.32,0:37:26.86,English,,0,0,0,,What that will typically and not always but this sort of way to
Dialogue: 0,0:37:23.32,0:37:26.86,Chinese,,0,0,0,,这通常会是什么情况，而并不总是一种情况
Dialogue: 0,0:37:26.86,0:37:28.86,English,,0,0,0,,Think about that at the machine level is its
Dialogue: 0,0:37:26.86,0:37:28.86,Chinese,,0,0,0,,想想机器级别就是它
Dialogue: 0,0:37:29.30,0:37:33.54,English,,0,0,0,,T or some local value would be typically stored in a register
Dialogue: 0,0:37:29.30,0:37:33.54,Chinese,,0,0,0,,T 或某些本地值通常存储在寄存器中
Dialogue: 0,0:37:34.22,0:37:38.64,English,,0,0,0,,And as you know in C, if you put star in front of it you want it referenced as a pointer
Dialogue: 0,0:37:34.22,0:37:38.64,Chinese,,0,0,0,,正如你在 C 中所知，如果你把星号放在它前面，你希望它被引用作为指针
Dialogue: 0,0:37:39.04,0:37:40.62,English,,0,0,0,,And if that reference is on the left
Dialogue: 0,0:37:39.04,0:37:40.62,Chinese,,0,0,0,,如果那个引用在左边
Dialogue: 0,0:37:41.06,0:37:47.24,English,,0,0,0,,You want to store a number of value at that place where you're pointing to
Dialogue: 0,0:37:41.06,0:37:47.24,Chinese,,0,0,0,,你希望在指向的位置存储这个数值
Dialogue: 0,0:37:47.90,0:37:50.64,English,,0,0,0,,So what would typically happen is
Dialogue: 0,0:37:47.90,0:37:50.64,Chinese,,0,0,0,,那么通常会发生什么
Dialogue: 0,0:37:51.04,0:37:57.40,English,,0,0,0,,Dest the the actual pointer value would also be stored in a register here it's in register %rbx
Dialogue: 0,0:37:51.04,0:37:57.40,Chinese,,0,0,0,,Dest 实际的指针值也将存储在寄存器中，它位于寄存器 ％rbx 中
Dialogue: 0,0:37:58.58,0:38:04.92,English,,0,0,0,,And I use a move instruction to say take the value from one register which is called %rax here
Dialogue: 0,0:37:58.58,0:38:04.92,Chinese,,0,0,0,,我使用 mov 指令来说明从一个寄存器中取值，这里称为 ％rax
Dialogue: 0,0:38:05.18,0:38:08.04,English,,0,0,0,,And store it in the memory location
Dialogue: 0,0:38:05.18,0:38:08.04,Chinese,,0,0,0,,并将其存储在内存位置
Dialogue: 0,0:38:08.34,0:38:10.42,English,,0,0,0,,That's specified by another register
Dialogue: 0,0:38:08.34,0:38:10.42,Chinese,,0,0,0,,由另一个寄存器指定的
Dialogue: 0,0:38:10.82,0:38:14.70,English,,0,0,0,,So you see the idea we'll go into more detail about
Dialogue: 0,0:38:10.82,0:38:14.70,Chinese,,0,0,0,,所以你明白了这个概念，我们将详细介绍的细节
Dialogue: 0,0:38:14.70,0:38:17.36,English,,0,0,0,,All these register names and what the parentheses mean
Dialogue: 0,0:38:14.70,0:38:17.36,Chinese,,0,0,0,,所有这些寄存器名称和括号的含义
Dialogue: 0,0:38:17.36,0:38:26.16,English,,0,0,0,,But you get the rough idea that a move instruction is saying can refer to either a register or a memory location
Dialogue: 0,0:38:17.36,0:38:26.16,Chinese,,0,0,0,,但是你得到了 mov 指令的粗略概念，它可以引用寄存器或存储器位置
Dialogue: 0,0:38:27.72,0:38:31.78,English,,0,0,0,,And the actual object code representation of this is just a three bytes
Dialogue: 0,0:38:27.72,0:38:31.78,Chinese,,0,0,0,,而实际的目标代码形式只是三个字节
Dialogue: 0,0:38:32.00,0:38:38.48,English,,0,0,0,,Where the first byte tells it that it
Dialogue: 0,0:38:32.00,0:38:38.48,Chinese,,0,0,0,,第一个字节告诉它的
Dialogue: 0,0:38:38.56,0:38:41.10,English,,0,0,0,,And we would even talk much in this course about
Dialogue: 0,0:38:38.56,0:38:41.10,Chinese,,0,0,0,,我们甚至会在这个课程中谈论很多
Dialogue: 0,0:38:41.26,0:38:46.98,English,,0,0,0,,How the instructions are encoded won't generally let programs do that for us
Dialogue: 0,0:38:41.26,0:38:46.98,Chinese,,0,0,0,,如何编码指令，通常情况下我们让程序为我们这样做
Dialogue: 0,0:38:47.94,0:38:51.98,English,,0,0,0,,But in this case it only takes three bytes to write that particular instruction
Dialogue: 0,0:38:47.94,0:38:51.98,Chinese,,0,0,0,,但在这种情况下，只需要三个字节来编写该特定指令
Dialogue: 0,0:38:53.26,0:38:57.64,English,,0,0,0,,So how can we know that kind of stuff how can we figure out that level of detail
Dialogue: 0,0:38:53.26,0:38:57.64,Chinese,,0,0,0,,那么我们怎么能知道那种东西，我们怎样才能弄清楚那个细节水平呢
Dialogue: 0,0:38:58.02,0:39:02.70,English,,0,0,0,,Well there's some really useful tools that let you examine machine code
Dialogue: 0,0:38:58.02,0:39:02.70,Chinese,,0,0,0,,那有一些非常有用的工具可以让你检查机器代码
Dialogue: 0,0:39:03.10,0:39:09.74,English,,0,0,0,,Even if you don't have a copy of the original C file or even the assembly code file ahead of time
Dialogue: 0,0:39:03.10,0:39:09.74,Chinese,,0,0,0,,即使你没有提供原始 C 文件，或者甚至没有汇编代码文件
Dialogue: 0,0:39:10.14,0:39:12.02,English,,0,0,0,,And there's one called a disassembler
Dialogue: 0,0:39:10.14,0:39:12.02,Chinese,,0,0,0,,有一个叫做反汇编器
Dialogue: 0,0:39:12.46,0:39:20.36,English,,0,0,0,,So an assembler goes from this text version of instructions to a byte level representation
Dialogue: 0,0:39:12.46,0:39:20.36,Chinese,,0,0,0,,因此汇编器将指令的文本版本转换为字节级表示
Dialogue: 0,0:39:20.80,0:39:24.94,English,,0,0,0,,And the disassembler just reverses that it says here is a series of bytes
Dialogue: 0,0:39:20.80,0:39:24.94,Chinese,,0,0,0,,并且反汇编器只是倒推它，这里是一系列字节
Dialogue: 0,0:39:26.08,0:39:34.08,English,,0,0,0,,And I the disassembler know that this particular byte sequence refers is a move instruction
Dialogue: 0,0:39:26.08,0:39:34.08,Chinese,,0,0,0,,反汇编程序知道这个特定的字节序列引用的是一个移动指令
Dialogue: 0,0:39:34.08,0:39:39.82,English,,0,0,0,,And so it will now print out on the screen to say,oh that was a move instruction
Dialogue: 0,0:39:34.08,0:39:39.82,Chinese,,0,0,0,,所以它现在将在屏幕上打印出来，哦，这是一个移动指令
Dialogue: 0,0:39:39.82,0:39:45.34,English,,0,0,0,,And so it basically reverse engineers from the object code back to the assembly code
Dialogue: 0,0:39:39.82,0:39:45.34,Chinese,,0,0,0,,因此它基本上就是将工程从目标代码转回到汇编代码
Dialogue: 0,0:39:45.34,0:39:48.26,English,,0,0,0,,Or something sort of like the assembly code
Dialogue: 0,0:39:45.34,0:39:48.26,Chinese,,0,0,0,,或者类似于汇编代码的东西
Dialogue: 0,0:39:48.26,0:39:56.54,English,,0,0,0,,You'll see it lost...it's very slightly different
Dialogue: 0,0:39:48.26,0:39:56.54,Chinese,,0,0,0,,你会看到它丢失了......它有点不同
Dialogue: 0,0:39:57.12,0:40:01.36,English,,0,0,0,,One thing also to notice I should mention about assembly code is
Dialogue: 0,0:39:57.12,0:40:01.36,Chinese,,0,0,0,,还有一点需要注意，我应该提一下，汇编代码中
Dialogue: 0,0:40:02.18,0:40:05.14,English,,0,0,0,,All those you know all the names I used
Dialogue: 0,0:40:02.18,0:40:05.14,Chinese,,0,0,0,,所有你知道我所用的名字
Dialogue: 0,0:40:05.14,0:40:12.08,English,,0,0,0,,All the names of variables are completely lost at the assembly code level,at the machine code level
Dialogue: 0,0:40:05.14,0:40:12.08,Chinese,,0,0,0,,变量的所有名称，在汇编代码级别，机器代码级别完全丢失
Dialogue: 0,0:40:12.16,0:40:15.10,English,,0,0,0,,Things are just during registers they're somewhere in memory
Dialogue: 0,0:40:12.16,0:40:15.10,Chinese,,0,0,0,,东西都变成了寄存器和内存中的某个位置
Dialogue: 0,0:40:15.50,0:40:20.16,English,,0,0,0,,The program has no understanding of your original source code at that level
Dialogue: 0,0:40:15.50,0:40:20.16,Chinese,,0,0,0,,该程序不了解你在该级别的原始源代码
Dialogue: 0,0:40:21.72,0:40:24.92,English,,0,0,0,,And so the disassembled is just a way to go backward
Dialogue: 0,0:40:21.72,0:40:24.92,Chinese,,0,0,0,,因此反汇编只是一种回退的方式
Dialogue: 0,0:40:25.40,0:40:26.90,English,,0,0,0,,And you can do that yourself
Dialogue: 0,0:40:25.40,0:40:26.90,Chinese,,0,0,0,,你可以自己做
Dialogue: 0,0:40:27.94,0:40:37.73,English,,0,0,0,,And you'll find that useful in various contexts and to do that yourself
Dialogue: 0,0:40:27.94,0:40:37.73,Chinese,,0,0,0,,而且你会发现它在各种环境中都很有用，并且可以自己做
Dialogue: 0,0:40:38.32,0:40:40.70,English,,0,0,0,,That's some kind of monkeying around with it
Dialogue: 0,0:40:38.32,0:40:40.70,Chinese,,0,0,0,,就当是闲暇之余的消遣
Dialogue: 0,0:40:43.14,0:41:02.34,English,,0,0,0,,So if I compile the sum program
Dialogue: 0,0:40:43.14,0:41:02.34,Chinese,,0,0,0,,所以，如果我编译 sum 程序
Dialogue: 0,0:41:02.34,0:41:05.40,English,,0,0,0,,So if I do the more standard thing you doing
Dialogue: 0,0:41:02.34,0:41:05.40,Chinese,,0,0,0,,所以，如果我做更标准的事情
Dialogue: 0,0:41:06.30,0:41:11.34,English,,0,0,0,,Using a compiler you say run the compiler give it some optimization
Dialogue: 0,0:41:06.30,0:41:11.34,Chinese,,0,0,0,,使用编译器，告诉编译器给它一些优化
Dialogue: 0,0:41:11.86,0:41:16.22,English,,0,0,0,,Tell it what the source files are until it where to put the final executable code
Dialogue: 0,0:41:11.86,0:41:16.22,Chinese,,0,0,0,,告诉它源文件是什么，在哪里放置最终的可执行代码
Dialogue: 0,0:41:16.22,0:41:19.42,English,,0,0,0,,And I'm terribly clever I call the function sum
Dialogue: 0,0:41:16.22,0:41:19.42,Chinese,,0,0,0,,而且我聪明绝顶，我将这个函数命名为 sum
Dialogue: 0,0:41:20.22,0:41:22.08,English,,0,0,0,,And so sum is a binary file
Dialogue: 0,0:41:20.22,0:41:22.08,Chinese,,0,0,0,,所以 sum 是一个二进制文件
Dialogue: 0,0:41:25.74,0:41:32.36,English,,0,0,0,,Of 8663 bytes, you see off on the left its mark is executable
Dialogue: 0,0:41:25.74,0:41:32.36,Chinese,,0,0,0,,一共有 8663 个字节，你在左侧可以看到它的标记是可执行的
Dialogue: 0,0:41:33.04,0:41:34.80,English,,0,0,0,,And it actually works
Dialogue: 0,0:41:33.04,0:41:34.80,Chinese,,0,0,0,,它确实有效
Dialogue: 0,0:41:35.34,0:41:37.24,English,,0,0,0,,I can add numbers together with it
Dialogue: 0,0:41:35.34,0:41:37.24,Chinese,,0,0,0,,我可以加上数字
Dialogue: 0,0:41:37.40,0:41:42.22,English,,0,0,0,,So that's the year two standard executable programs
Dialogue: 0,0:41:37.40,0:41:42.22,Chinese,,0,0,0,,这就是今年的两个标准可执行程序
Dialogue: 0,0:41:43.38,0:41:44.60,English,,0,0,0,,Excuse me
Dialogue: 0,0:41:43.38,0:41:44.60,Chinese,,0,0,0,,抱歉
Dialogue: 0,0:41:46.12,0:41:48.98,English,,0,0,0,,And if I run a program called object dump
Dialogue: 0,0:41:46.12,0:41:48.98,Chinese,,0,0,0,,如果我运行一个名为 objdump 的程序
Dialogue: 0,0:41:50.88,0:41:53.68,English,,0,0,0,,And ask it to disassemble it can do various things
Dialogue: 0,0:41:50.88,0:41:53.68,Chinese,,0,0,0,,并要求它反汇编程序，它可以做各种事情
Dialogue: 0,0:41:54.62,0:42:00.44,English,,0,0,0,,It will spit out a disassembled version of the program it will fly by on the screen
Dialogue: 0,0:41:54.62,0:42:00.44,Chinese,,0,0,0,,它会在屏幕上输出程序的反汇编结果
Dialogue: 0,0:42:00.44,0:42:05.06,English,,0,0,0,,But if I redirect that to some a file
Dialogue: 0,0:42:00.44,0:42:05.06,Chinese,,0,0,0,,但是，如果我将其重定向到某个文件
Dialogue: 0,0:42:08.12,0:42:11.42,English,,0,0,0,,Which I already did I'll remove the old one
Dialogue: 0,0:42:08.12,0:42:11.42,Chinese,,0,0,0,,我过去已经输出到文件了，我把老的删了
Dialogue: 0,0:42:18.30,0:42:19.36,English,,0,0,0,,And now I look at that
Dialogue: 0,0:42:18.30,0:42:19.36,Chinese,,0,0,0,,现在我看一下
Dialogue: 0,0:42:22.02,0:42:28.12,English,,0,0,0,,You'll see that it has what I described as is the disassembled representation of the program
Dialogue: 0,0:42:22.02,0:42:28.12,Chinese,,0,0,0,,你会看到它有我所描述的程序的反汇编表示
Dialogue: 0,0:42:28.64,0:42:32.26,English,,0,0,0,,Including some files that you didn't some functions that you didn't write
Dialogue: 0,0:42:28.64,0:42:32.26,Chinese,,0,0,0,,包括一些你没有写过的函数
Dialogue: 0,0:42:32.58,0:42:41.12,English,,0,0,0,,Has ones that are sort of the low-level functions that are used in the initial startup of a program called in it
Dialogue: 0,0:42:32.58,0:42:41.12,Chinese,,0,0,0,,有一些是在其中调用的程序的初始启动中使用的底层函数
Dialogue: 0,0:42:48.52,0:42:52.22,English,,0,0,0,,But here somewhere in the middle of it you'll see go and behold is
Dialogue: 0,0:42:48.52,0:42:52.22,Chinese,,0,0,0,,但是在这个中间的某个地方，你会看到
Dialogue: 0,0:42:52.58,0:42:57.38,English,,0,0,0,,That program,that function sumstore that got compiled
Dialogue: 0,0:42:52.58,0:42:57.38,Chinese,,0,0,0,,那个程序，包含程序里面的一些编译过的函数
Dialogue: 0,0:42:58.12,0:43:08.56,English,,0,0,0,,And you can see that what it did was it took this 14 bytes from the original that the object code
Dialogue: 0,0:42:58.12,0:43:08.56,Chinese,,0,0,0,,你可以看到它所做的是它从原始目标代码中取出 14 个字节
Dialogue: 0,0:43:09.22,0:43:14.57,English,,0,0,0,,And it picked those apart and came back with what instructions those bytes in code
Dialogue: 0,0:43:09.22,0:43:14.57,Chinese,,0,0,0,,然后反汇编器取出它们，和这些字节对应的指令一起
Dialogue: 0,0:43:14.88,0:43:18.18,English,,0,0,0,,So for example the push instruction only takes a single byte
Dialogue: 0,0:43:14.88,0:43:18.18,Chinese,,0,0,0,,例如 mov 指令仅占用一个字节
Dialogue: 0,0:43:19.06,0:43:21.92,English,,0,0,0,,The move as you saw before takes three bytes
Dialogue: 0,0:43:19.06,0:43:21.92,Chinese,,0,0,0,,你之前看到的 mov 指令需要三个字节
Dialogue: 0,0:43:22.88,0:43:31.64,English,,0,0,0,,This callq because it has to give the location of where to call is a five byte instruction and so forth
Dialogue: 0,0:43:22.88,0:43:31.64,Chinese,,0,0,0,,这个 callq 因为它必须给出调用位置的位置，所以是一个五字节指令，依此类推
Dialogue: 0,0:43:34.28,0:43:37.54,English,,0,0,0,,But again the disassembler didn't have access to the source code
Dialogue: 0,0:43:34.28,0:43:37.54,Chinese,,0,0,0,,但是再说一遍，反汇编程序无法访问源代码
Dialogue: 0,0:43:37.54,0:43:39.46,English,,0,0,0,,It didn't have access even to the assembly code
Dialogue: 0,0:43:37.54,0:43:39.46,Chinese,,0,0,0,,它甚至无法访问汇编代码
Dialogue: 0,0:43:39.46,0:43:43.92,English,,0,0,0,,It figured this out just by the bytes in the actual object code file
Dialogue: 0,0:43:39.46,0:43:43.92,Chinese,,0,0,0,,它只是通过实际目标代码文件中的字节来辨别出来的
Dialogue: 0,0:43:45.78,0:43:51.02,English,,0,0,0,,So this is the way if you ever want to know actually the byte level encoding
Dialogue: 0,0:43:45.78,0:43:51.02,Chinese,,0,0,0,,因此，如果你想要实际知道字节级别的编码形式
Dialogue: 0,0:43:51.40,0:43:52.80,English,,0,0,0,,This is how you figure it out
Dialogue: 0,0:43:51.40,0:43:52.80,Chinese,,0,0,0,,这就是你如何去弄清楚的方式
Dialogue: 0,0:43:53.58,0:44:02.09,English,,0,0,0,,Is to run a program,run it through an assembler get object code and then come back out with
Dialogue: 0,0:43:53.58,0:44:02.09,Chinese,,0,0,0,,运行程序，通过汇编器获取目标代码运行它，然后反过来
Dialogue: 0,0:44:03.64,0:44:05.12,English,,0,0,0,,It there's another way you can do it
Dialogue: 0,0:44:03.64,0:44:05.12,Chinese,,0,0,0,,它还有另一种方法可以做到
Dialogue: 0,0:44:07.50,0:44:13.28,English,,0,0,0,,Using the debugging program which you'll get to know very well in the next lab you're going to do
Dialogue: 0,0:44:07.50,0:44:13.28,Chinese,,0,0,0,,使用你将在下一个实验室中要用到的调试程序
Dialogue: 0,0:44:15.66,0:44:17.09,English,,0,0,0,,And it's called GDB
Dialogue: 0,0:44:15.66,0:44:17.09,Chinese,,0,0,0,,它被称为 GDB
Dialogue: 0,0:44:20.26,0:44:24.86,English,,0,0,0,,And GDB is a very powerful debugging program that
Dialogue: 0,0:44:20.26,0:44:24.86,Chinese,,0,0,0,,而 GDB 是一个非常强大的调试程序
Dialogue: 0,0:44:25.10,0:44:29.83,English,,0,0,0,,You can examine step through and operate on programs in
Dialogue: 0,0:44:25.10,0:44:29.83,Chinese,,0,0,0,,你可以单步检查程序并对其中的程序进行一些操作
Dialogue: 0,0:44:30.04,0:44:36.72,English,,0,0,0,,And again you can,if the source code for it's available it will make use of it
Dialogue: 0,0:44:30.04,0:44:36.72,Chinese,,0,0,0,,如果它的源代码可用，它将会用它（来调试）
Dialogue: 0,0:44:37.24,0:44:40.92,English,,0,0,0,,But it also can be used on programs for which there's no source available
Dialogue: 0,0:44:37.24,0:44:40.92,Chinese,,0,0,0,,但它也可用于，没有源代码的程序
Dialogue: 0,0:44:41.34,0:44:45.12,English,,0,0,0,,But one of the features is the ability to disassemble functions in there
Dialogue: 0,0:44:41.34,0:44:45.12,Chinese,,0,0,0,,其中一个功能是能够在它里面反汇编
Dialogue: 0,0:44:45.14,0:44:50.60,English,,0,0,0,,So if I say disassemble sumstore
Dialogue: 0,0:44:45.14,0:44:50.60,Chinese,,0,0,0,,所以，如果我说反汇编 sumstore
Dialogue: 0,0:44:52.50,0:44:56.98,English,,0,0,0,,It'll come back with something that looks a lot like what you saw from object dump
Dialogue: 0,0:44:52.50,0:44:56.98,Chinese,,0,0,0,,它返回的东西很像你在 objdump 中看到的
Dialogue: 0,0:44:57.76,0:45:02.48,English,,0,0,0,,A listing of the instructions and here it just shows in hex
Dialogue: 0,0:44:57.76,0:45:02.48,Chinese,,0,0,0,,一个指令列表，在这里是按照十六进制的地址排列的
Dialogue: 0,0:45:02.56,0:45:07.36,English,,0,0,0,,What the addresses of those different instructions are it doesn't show the byte level encoding
Dialogue: 0,0:45:02.56,0:45:07.36,Chinese,,0,0,0,,这些不同指令的地址是什么，它并不显示字节级编码
Dialogue: 0,0:45:08.80,0:45:16.34,English,,0,0,0,,So there's my point here is there's various tools that let you look at a program
Dialogue: 0,0:45:08.80,0:45:16.34,Chinese,,0,0,0,,所以我的观点是，有各种工具可以让你检查一个程序
Dialogue: 0,0:45:16.82,0:45:21.98,English,,0,0,0,,Even if it's actual representation is a binary file that you don't want to examine directly
Dialogue: 0,0:45:16.82,0:45:21.98,Chinese,,0,0,0,,即使它的实际形式是一个你不想直接检查的二进制文件
Dialogue: 0,0:45:34.84,0:45:36.36,English,,0,0,0,,I just put this in
Dialogue: 0,0:45:34.84,0:45:36.36,Chinese,,0,0,0,,我把它放进去
Dialogue: 0,0:45:43.42,0:45:47.28,English,,0,0,0,,So what this slide shows is what I just showed you on the screen
Dialogue: 0,0:45:43.42,0:45:47.28,Chinese,,0,0,0,,所以这张幻灯片显示的是我刚刚在屏幕上显示的内容
Dialogue: 0,0:45:47.28,0:45:51.08,English,,0,0,0,,Which is what the object dump program produces for this function
Dialogue: 0,0:45:47.28,0:45:51.08,Chinese,,0,0,0,,这是 objdump 为此函数生成的内容
Dialogue: 0,0:45:53.36,0:45:57.09,English,,0,0,0,,And this is a version showing what GDB would show you for it
Dialogue: 0,0:45:53.36,0:45:57.09,Chinese,,0,0,0,,这是 GDB 会向你展示的版本
Dialogue: 0,0:45:57.70,0:46:01.06,English,,0,0,0,,And with GDB if you want to actually get the bytes out
Dialogue: 0,0:45:57.70,0:46:01.06,Chinese,,0,0,0,,如果你想实际获取字节数，请使用 GDB
Dialogue: 0,0:46:01.30,0:46:06.08,English,,0,0,0,,You can do that, you can basically for any address
Dialogue: 0,0:46:01.30,0:46:06.08,Chinese,,0,0,0,,你可以这样做，基本上对于任何地址
Dialogue: 0,0:46:06.08,0:46:10.68,English,,0,0,0,,You can just give an address and tell it to display some number of bytes
Dialogue: 0,0:46:06.08,0:46:10.68,Chinese,,0,0,0,,你可以给一个地址并告诉它显示一些字节数
Dialogue: 0,0:46:11.16,0:46:19.02,English,,0,0,0,,And so this rather cryptic command to GDB says examine 14 bytes in hex format
Dialogue: 0,0:46:11.16,0:46:19.02,Chinese,,0,0,0,,因此，这个相当神秘的命令对 GDB 说，检查十六进制格式的 14 个字节
Dialogue: 0,0:46:20.00,0:46:23.40,English,,0,0,0,,Starting at the address of the function sumstore
Dialogue: 0,0:46:20.00,0:46:23.40,Chinese,,0,0,0,,从函数 sumstore 的地址开始
Dialogue: 0,0:46:25.66,0:46:28.82,English,,0,0,0,,And it produced something that looks like what you see on the left
Dialogue: 0,0:46:25.66,0:46:28.82,Chinese,,0,0,0,,它产生的东西看起来就像你在左边看到的那样
Dialogue: 0,0:46:32.88,0:46:39.02,English,,0,0,0,,In fact disassembly is a tool that can be used as part of any reverse engineering tools
Dialogue: 0,0:46:32.88,0:46:39.02,Chinese,,0,0,0,,实际上，反汇编是一种可以用作任何逆向工程工具的工具
Dialogue: 0,0:46:39.40,0:46:46.33,English,,0,0,0,,And I used to demo this by showing a disassembly of the windows of Microsoft Word
Dialogue: 0,0:46:39.40,0:46:46.33,Chinese,,0,0,0,,我曾经展示反汇编 Microsoft Word 的结果
Dialogue: 0,0:46:46.70,0:46:49.94,English,,0,0,0,,I had a pc back then not a mac
Dialogue: 0,0:46:46.70,0:46:49.94,Chinese,,0,0,0,,我过去有一台电脑，不是 Mac 而是 Windows 系统
Dialogue: 0,0:46:49.94,0:46:57.94,English,,0,0,0,,But some people and you know our slides are online and so we got some nasty grams from people saying
Dialogue: 0,0:46:49.94,0:46:57.94,Chinese,,0,0,0,,但是你知道我们的幻灯片在线提供，\n我们从别人那里得到了一些不好的投诉
Dialogue: 0,0:46:58.28,0:47:02.42,English,,0,0,0,,You know you're violating the Microsoft end-user license agreement when you do that
Dialogue: 0,0:46:58.28,0:47:02.42,Chinese,,0,0,0,,你知道在执行此操作时违反了 Microsoft 最终用户许可协议
Dialogue: 0,0:47:02.42,0:47:05.78,English,,0,0,0,,Because you're supposed to you don't know this
Dialogue: 0,0:47:02.42,0:47:05.78,Chinese,,0,0,0,,因为你应该知道，但并不知道这一点
Dialogue: 0,0:47:05.92,0:47:09.30,English,,0,0,0,,But remember all those click through I agree things
Dialogue: 0,0:47:05.92,0:47:09.30,Chinese,,0,0,0,,但请回忆所有那些点击「我同意」的时刻
Dialogue: 0,0:47:10.00,0:47:11.02,English,,0,0,0,,But you never read
Dialogue: 0,0:47:10.00,0:47:11.02,Chinese,,0,0,0,,其实你永远不会读的
Dialogue: 0,0:47:11.22,0:47:17.90,English,,0,0,0,,One of them is I agree not to try to reverse engineer any Microsoft product so
Dialogue: 0,0:47:11.22,0:47:17.90,Chinese,,0,0,0,,其中一个条款是：我同意不尝试对任何 Microsoft 产品进行逆向工程
Dialogue: 0,0:47:19.68,0:47:24.62,English,,0,0,0,,So this is would technically so I've served just for modesty I blanked this out
Dialogue: 0,0:47:19.68,0:47:24.62,Chinese,,0,0,0,,所以逆汇编在技术上是可行的，我只是为了低调，把它抹掉了
Dialogue: 0,0:47:24.62,0:47:25.78,English,,0,0,0,,But you can actually do it
Dialogue: 0,0:47:24.62,0:47:25.78,Chinese,,0,0,0,,但你实际上可以做到这一点
Dialogue: 0,0:47:26.10,0:47:29.22,English,,0,0,0,,If you can find where the file is it's sort of obscure where
Dialogue: 0,0:47:26.10,0:47:29.22,Chinese,,0,0,0,,如果你能找到文件的位置，它有点难找
Dialogue: 0,0:47:29.50,0:47:32.82,English,,0,0,0,,the actual executable files of an application
Dialogue: 0,0:47:29.50,0:47:32.82,Chinese,,0,0,0,,应用程序的实际可执行文件的位置
Dialogue: 0,0:47:33.90,0:47:36.84,English,,0,0,0,,My point is that word like any other
Dialogue: 0,0:47:33.90,0:47:36.84,Chinese,,0,0,0,,我的意思是 Word 跟其他任何程序一样
Dialogue: 0,0:47:39.42,0:47:42.30,English,,0,0,0,,Application you run is just a executable file
Dialogue: 0,0:47:39.42,0:47:42.30,Chinese,,0,0,0,,你运行的应用程序一样，只是一个可执行文件
Dialogue: 0,0:47:42.30,0:47:46.54,English,,0,0,0,,And that executable file is just a bunch of bytes that encode instructions
Dialogue: 0,0:47:42.30,0:47:46.54,Chinese,,0,0,0,,而那个可执行文件只是一堆编码指令的字节
Dialogue: 0,0:47:48.82,0:47:53.80,English,,0,0,0,,Okay so let's go a little bit further into this assembly level programming basics
Dialogue: 0,0:47:48.82,0:47:53.80,Chinese,,0,0,0,,好的，让我们进一步了解这个汇编级编程基础
Dialogue: 0,0:47:55.16,0:47:57.16,English,,0,0,0,,So I keep talking about registers
Dialogue: 0,0:47:55.16,0:47:57.16,Chinese,,0,0,0,,我一直在谈论寄存器
Dialogue: 0,0:47:57.98,0:48:03.18,English,,0,0,0,,And x86-64 has this totally quirky set of registers
Dialogue: 0,0:47:57.98,0:48:03.18,Chinese,,0,0,0,,x86-64 拥有这套完全奇特的寄存器
Dialogue: 0,0:48:03.58,0:48:07.42,English,,0,0,0,,And it's a reflection again of this sort of evolutionary history to it
Dialogue: 0,0:48:03.58,0:48:07.42,Chinese,,0,0,0,,这再次反映了这种进化史
Dialogue: 0,0:48:08.18,0:48:12.82,English,,0,0,0,,But you'll see that there's sixteen registers that
Dialogue: 0,0:48:08.18,0:48:12.82,Chinese,,0,0,0,,但是你会看到有十六个寄存器
Dialogue: 0,0:48:12.82,0:48:15.52,English,,0,0,0,,You can use to hold integers and pointers
Dialogue: 0,0:48:12.82,0:48:15.52,Chinese,,0,0,0,,你可以使用来保存整数和指针
Dialogue: 0,0:48:16.44,0:48:22.34,English,,0,0,0,,And some of them have these sort of alphabetic names and some of them have numeric names
Dialogue: 0,0:48:16.44,0:48:22.34,Chinese,,0,0,0,,其中一些有这些字母名称，其中一些有数字名称
Dialogue: 0,0:48:23.18,0:48:24.38,English,,0,0,0,,I'll show you why in a minute
Dialogue: 0,0:48:23.18,0:48:24.38,Chinese,,0,0,0,,我会马上告诉你原因
Dialogue: 0,0:48:24.88,0:48:29.60,English,,0,0,0,,And also for each register if you use the sort of %r name of it
Dialogue: 0,0:48:24.88,0:48:29.60,Chinese,,0,0,0,,如果你使用它的 ％r 名称
Dialogue: 0,0:48:30.04,0:48:31.40,English,,0,0,0,,You'll get 64 bits
Dialogue: 0,0:48:30.04,0:48:31.40,Chinese,,0,0,0,,你会得到 64 位
Dialogue: 0,0:48:32.42,0:48:35.98,English,,0,0,0,,But if you use the %e version of it.you'll get 32 bits
Dialogue: 0,0:48:32.42,0:48:35.98,Chinese,,0,0,0,,但是如果你使用它的 ％e 版本，你将得到 32 位
Dialogue: 0,0:48:36.54,0:48:43.26,English,,0,0,0,,And what you'll find in programs that manipulate long int.you'll see the use of %r
Dialogue: 0,0:48:36.54,0:48:43.26,Chinese,,0,0,0,,你会在操作 long int 的程序中找到什么。你会看到使用 ％r
Dialogue: 0,0:48:43.72,0:48:48.36,English,,0,0,0,,And if they're just in 32-bit things you'll see code saying %e
Dialogue: 0,0:48:43.72,0:48:48.36,Chinese,,0,0,0,,如果他们只是在 32 位的东西，你会看到代码说 ％e
Dialogue: 0,0:48:48.42,0:48:50.04,English,,0,0,0,,So you'll see both of these show up
Dialogue: 0,0:48:48.42,0:48:50.04,Chinese,,0,0,0,,所以你会看到这两个都出现了
Dialogue: 0,0:48:50.82,0:48:53.54,English,,0,0,0,,But and it's fairly important to remember
Dialogue: 0,0:48:50.82,0:48:53.54,Chinese,,0,0,0,,但是记住这一点非常重要
Dialogue: 0,0:48:54.04,0:49:00.92,English,,0,0,0,,%e version is just the low-order 32 bits of a larger %r entity
Dialogue: 0,0:48:54.04,0:49:00.92,Chinese,,0,0,0,,％e 版本只是较大 ％r 实体的低 32 位
Dialogue: 0,0:49:02.90,0:49:09.08,English,,0,0,0,,And in fact it goes beyond that you can also reference the lower order 16 bits
Dialogue: 0,0:49:02.90,0:49:09.08,Chinese,,0,0,0,,实际上的用法更多，你也可以引用低阶 16 位
Dialogue: 0,0:49:09.66,0:49:12.32,English,,0,0,0,,And the low order 2 bit,I'm sorry, 1 byte
Dialogue: 0,0:49:09.66,0:49:12.32,Chinese,,0,0,0,,和低位 2 位，说错了，1 个字节
Dialogue: 0,0:49:12.72,0:49:17.70,English,,0,0,0,,16 2 bytes and 1 byte within each of these registers as well
Dialogue: 0,0:49:12.72,0:49:17.70,Chinese,,0,0,0,,可以使用 16 位也就是 2 字节，或者是 1 字节，在这些寄存器里
Dialogue: 0,0:49:19.48,0:49:22.28,English,,0,0,0,,But again think of these as like named
Dialogue: 0,0:49:19.48,0:49:22.28,Chinese,,0,0,0,,但再次想想，这些命名的寄存器
Dialogue: 0,0:49:23.20,0:49:28.46,English,,0,0,0,,Locations where you can store values and you can retrieve values from them
Dialogue: 0,0:49:23.20,0:49:28.46,Chinese,,0,0,0,,这些位置里，你可以存储值，你可以从中取出值
Dialogue: 0,0:49:29.32,0:49:35.84,English,,0,0,0,,And you have to you the I'm sort of personifying machine level programming here
Dialogue: 0,0:49:29.32,0:49:35.84,Chinese,,0,0,0,,而且你必须，我这里指将某个机器特定化了的机器级编程
Dialogue: 0,0:49:36.08,0:49:43.94,English,,0,0,0,,You personally will actually have to explicitly name those registers for the most part
Dialogue: 0,0:49:36.08,0:49:43.94,Chinese,,0,0,0,,个人实际上必须在大多数情况下明确地指名这些寄存器
Dialogue: 0,0:49:44.48,0:49:47.02,English,,0,0,0,,To say where things should go where they should come out of
Dialogue: 0,0:49:44.48,0:49:47.02,Chinese,,0,0,0,,说值应该去哪个寄存器，或者是从哪个寄存器取出
Dialogue: 0,0:49:47.08,0:49:53.02,English,,0,0,0,,It's not like a memory where you just give a number to tell where to look for
Dialogue: 0,0:49:47.08,0:49:53.02,Chinese,,0,0,0,,这不像是内存，你只需要给出一个数字来告诉在哪里寻找
Dialogue: 0,0:49:53.04,0:49:57.04,English,,0,0,0,,You could compute a number there actually each one is identified separately
Dialogue: 0,0:49:53.04,0:49:57.04,Chinese,,0,0,0,,你可以计算一个数字，实际上每个数字都是单独识别的
Dialogue: 0,0:49:58.30,0:50:05.18,English,,0,0,0,,So just as a little bit of history with IA32 so back
Dialogue: 0,0:49:58.30,0:50:05.18,Chinese,,0,0,0,,所以就像 IA32 的历史一样
Dialogue: 0,0:50:05.98,0:50:11.92,English,,0,0,0,,We just talked about other being 8 registers all the %e versions
Dialogue: 0,0:50:05.98,0:50:11.92,Chinese,,0,0,0,,我们刚刚讨论了所有 ％e 版本的 8 个寄存器
Dialogue: 0,0:50:12.66,0:50:19.62,English,,0,0,0,,And one of the changes that went from IA32 to x86-64 was to double the number of registers
Dialogue: 0,0:50:12.66,0:50:19.62,Chinese,,0,0,0,,从 IA32 到 x86-64 的变化之一是将寄存器数量增加一倍
Dialogue: 0,0:50:20.24,0:50:22.78,English,,0,0,0,,By the way this is a really helpful thing because
Dialogue: 0,0:50:20.24,0:50:22.78,Chinese,,0,0,0,,顺便说一句，这是一个非常有用的东西，因为
Dialogue: 0,0:50:23.26,0:50:29.44,English,,0,0,0,,It was very frustrating how few registers there were in the old IA32 machines
Dialogue: 0,0:50:23.26,0:50:29.44,Chinese,,0,0,0,,令人非常沮丧的是，旧的 IA32 机器中的寄存器很少
Dialogue: 0,0:50:32.34,0:50:35.14,English,,0,0,0,,And then the as I mentioned
Dialogue: 0,0:50:32.34,0:50:35.14,Chinese,,0,0,0,,然后就像我提到的那样
Dialogue: 0,0:50:37.50,0:50:44.86,English,,0,0,0,,You could actually in the old machine refer to the lower order 16 bytes of these registers
Dialogue: 0,0:50:37.50,0:50:44.86,Chinese,,0,0,0,,实际上，旧机器可以访问这些寄存器的低 16 位字节
Dialogue: 0,0:50:44.86,0:50:48.50,English,,0,0,0,,And that was a legacy from the 8086 days
Dialogue: 0,0:50:44.86,0:50:48.50,Chinese,,0,0,0,,这是 8086 年代的遗产
Dialogue: 0,0:50:49.82,0:50:57.66,English,,0,0,0,,And within the first four you could even refer to the individual two lower order or bytes in those
Dialogue: 0,0:50:49.82,0:50:57.66,Chinese,,0,0,0,,在前四个中，你甚至可以访问不同的低位 2 字节
Dialogue: 0,0:50:58.52,0:51:03.18,English,,0,0,0,,So nowadays you can actually get to the low order byte of all of them
Dialogue: 0,0:50:58.52,0:51:03.18,Chinese,,0,0,0,,所以现在你可以实际访问所有寄存器的低位 1 字节
Dialogue: 0,0:51:03.48,0:51:08.12,English,,0,0,0,,And we just sort of got...that's covered in the book actually
Dialogue: 0,0:51:03.48,0:51:08.12,Chinese,,0,0,0,,而我们只是......实际上这本书已经涵盖了
Dialogue: 0,0:51:08.58,0:51:13.92,English,,0,0,0,,We don't talk about how you can get to these bytes because  that's really a legacy from back
Dialogue: 0,0:51:08.58,0:51:13.92,Chinese,,0,0,0,,我们不讨论如何获得这些字节，因为这真的是后来的遗产
Dialogue: 0,0:51:14.56,0:51:25.58,English,,0,0,0,,Before the 8086 was one called the 8080 which was an 8 byte machine
Dialogue: 0,0:51:14.56,0:51:25.58,Chinese,,0,0,0,,在 8086 之前，一台名为 8080 的机器是 8 字节机器
Dialogue: 0,0:51:30.10,0:51:38.32,English,,0,0,0,,So anyways you can see then how you got from this kind of weird state of affairs to the even weirder state
Dialogue: 0,0:51:30.10,0:51:38.32,Chinese,,0,0,0,,所以无论如何你可以看到你是如何从这种奇怪的状态到甚至更奇怪的状态的
Dialogue: 0,0:51:38.34,0:51:39.66,English,,0,0,0,,That we are in today
Dialogue: 0,0:51:38.34,0:51:39.66,Chinese,,0,0,0,,我们今天在
Dialogue: 0,0:51:40.10,0:51:43.86,English,,0,0,0,,Where some of them have names and some of them have numbers
Dialogue: 0,0:51:40.10,0:51:43.86,Chinese,,0,0,0,,它们其中一些有名字，有些有数字
Dialogue: 0,0:51:45.88,0:51:50.22,English,,0,0,0,,And those names by the way had a reason back in ancient days
Dialogue: 0,0:51:45.88,0:51:50.22,Chinese,,0,0,0,,顺便提一下，这些命名有一个远古时代的原因
Dialogue: 0,0:51:50.90,0:51:57.40,English,,0,0,0,,They had very specific purposes and so they were given names that sort of reflected those purposes
Dialogue: 0,0:51:50.90,0:51:57.40,Chinese,,0,0,0,,它们具有非常特定的用途，因此它们被赋予了那些反映这些目的的名称
Dialogue: 0,0:51:58.00,0:52:02.06,English,,0,0,0,,But that,that all went away years and years ago
Dialogue: 0,0:51:58.00,0:52:02.06,Chinese,,0,0,0,,但是，这一切都在几年前消失了
Dialogue: 0,0:52:02.50,0:52:07.38,English,,0,0,0,,And so now these names are just legacy names have nothing to do with their purpose
Dialogue: 0,0:52:02.50,0:52:07.38,Chinese,,0,0,0,,所以现在这些名字只是遗留名称，与他们的目的无关
Dialogue: 0,0:52:08.38,0:52:13.42,English,,0,0,0,,Now I should mention these only there are some special ...there's one special register nowadays
Dialogue: 0,0:52:08.38,0:52:13.42,Chinese,,0,0,0,,现在我应该提到这些只有一些特别的...目前有一个特殊的寄存器
Dialogue: 0,0:52:15.92,0:52:19.20,English,,0,0,0,,As shown in pink here and that's called the stack pointer
Dialogue: 0,0:52:15.92,0:52:19.20,Chinese,,0,0,0,,如此处粉红色所示，这称为栈指针
Dialogue: 0,0:52:19.70,0:52:25.02,English,,0,0,0,,And that register you don't just use any old way you please it has a very specific purpose
Dialogue: 0,0:52:19.70,0:52:25.02,Chinese,,0,0,0,,那个寄存器，你不把他用作任何旧的用途，它有一个非常具体的目的
Dialogue: 0,0:52:25.84,0:52:29.58,English,,0,0,0,,And all the other registers there's some that are slightly different than the other
Dialogue: 0,0:52:25.84,0:52:29.58,Chinese,,0,0,0,,而所有其他寄存器中有一些与另一些略有不同
Dialogue: 0,0:52:29.58,0:52:33.68,English,,0,0,0,,But for the most part they're all usable for holding program data
Dialogue: 0,0:52:29.58,0:52:33.68,Chinese,,0,0,0,,但在大多数情况下，它们都可用于保存程序数据
Dialogue: 0,0:52:35.08,0:52:39.72,English,,0,0,0,,Back in the IA32 days there was a register called the base pointer
Dialogue: 0,0:52:35.08,0:52:39.72,Chinese,,0,0,0,,回到 IA32 时代，有一个名为基指针的寄存器
Dialogue: 0,0:52:39.72,0:52:41.94,English,,0,0,0,,That also got used for procedures
Dialogue: 0,0:52:39.72,0:52:41.94,Chinese,,0,0,0,,这也用于程序
Dialogue: 0,0:52:42.50,0:52:46.88,English,,0,0,0,,But that no longer gets used anymore either at least not usually
Dialogue: 0,0:52:42.50,0:52:46.88,Chinese,,0,0,0,,但是至少通常不再使用它了
Dialogue: 0,0:52:48.30,0:52:53.44,English,,0,0,0,,So anyways I didn't want to i don't want to spend a lot of time on historic legacy stuff
Dialogue: 0,0:52:48.30,0:52:53.44,Chinese,,0,0,0,,所以无论如何我不想，我不想花很多时间在历史遗留物上
Dialogue: 0,0:52:53.90,0:52:58.82,English,,0,0,0,,And have you memorized you know what feature was added and what model of processor
Dialogue: 0,0:52:53.90,0:52:58.82,Chinese,,0,0,0,,你有没有记住，你是不是知道添加了什么功能，以及处理器的型号
Dialogue: 0,0:52:58.82,0:53:04.04,English,,0,0,0,,But just in case you're wondering why there's these weird names for these things
Dialogue: 0,0:52:58.82,0:53:04.04,Chinese,,0,0,0,,但是，万一你想知道为什么这些东西有这些奇怪的名字
Dialogue: 0,0:53:04.04,0:53:07.20,English,,0,0,0,,Just so you appreciate the fact that this is a legacy thing
Dialogue: 0,0:53:04.04,0:53:07.20,Chinese,,0,0,0,,正因为如此，你知道这是出于传统的事实
Dialogue: 0,0:53:09.68,0:53:16.10,English,,0,0,0,,Okay so now we can think of it then that there's eight registers with names
Dialogue: 0,0:53:09.68,0:53:16.10,Chinese,,0,0,0,,好的，现在我们知道了有八个带名字的寄存器
Dialogue: 0,0:53:16.26,0:53:19.52,English,,0,0,0,,And there's eight registers that are indicated by some number
Dialogue: 0,0:53:16.26,0:53:19.52,Chinese,,0,0,0,,并且有八个寄存器由一些数字表示
Dialogue: 0,0:53:20.58,0:53:23.90,English,,0,0,0,,And let's look at some of the instructions that operate on those registers
Dialogue: 0,0:53:20.58,0:53:23.90,Chinese,,0,0,0,,让我们看一下对这些寄存器进行操作的一些指令
Dialogue: 0,0:53:27.84,0:53:30.70,English,,0,0,0,,And there's sort of three different some mov
Dialogue: 0,0:53:27.84,0:53:30.70,Chinese,,0,0,0,,有三种不同的 mov
Dialogue: 0,0:53:31.02,0:53:35.30,English,,0,0,0,,The mov instruction in x86 is actually can do a lot of things
Dialogue: 0,0:53:31.02,0:53:35.30,Chinese,,0,0,0,,x86 中的 mov 指令实际上可以做很多事情
Dialogue: 0,0:53:38.20,0:53:43.22,English,,0,0,0,,Because it can take different types of information or what they call operands
Dialogue: 0,0:53:38.20,0:53:43.22,Chinese,,0,0,0,,因为它可以采用不同类型的信息或他们称之为操作数的信息
Dialogue: 0,0:53:43.98,0:53:49.46,English,,0,0,0,,So the source is some where you're copying from the source to the destination
Dialogue: 0,0:53:43.98,0:53:49.46,Chinese,,0,0,0,,因此，源是，你从一个源复制数据到目标
Dialogue: 0,0:53:51.04,0:53:53.42,English,,0,0,0,,The source can be some what's called an immediate
Dialogue: 0,0:53:51.04,0:53:53.42,Chinese,,0,0,0,,源可以是一些所谓的立即数
Dialogue: 0,0:53:53.42,0:53:56.28,English,,0,0,0,,It's actually a number that's baked into the program
Dialogue: 0,0:53:53.42,0:53:56.28,Chinese,,0,0,0,,它实际上是一个被编入程序的数字
Dialogue: 0,0:53:56.78,0:53:59.82,English,,0,0,0,,That you want to copy into some other location
Dialogue: 0,0:53:56.78,0:53:59.82,Chinese,,0,0,0,,你想要复制到其他位置
Dialogue: 0,0:54:00.74,0:54:06.76,English,,0,0,0,,A register we've talked about is one a specially named memory of locations
Dialogue: 0,0:54:00.74,0:54:06.76,Chinese,,0,0,0,,我们谈到的一个寄存器是一个特别命名的储存位置
Dialogue: 0,0:54:07.10,0:54:12.38,English,,0,0,0,,And memory is the array of bytes that you typically you have to specify what's the address
Dialogue: 0,0:54:07.10,0:54:12.38,Chinese,,0,0,0,,内存是一个字节数组，通常你必须指定地址是什么
Dialogue: 0,0:54:12.94,0:54:19.96,English,,0,0,0,,That you're either reading from if it's the source are you writing to if it's the destination
Dialogue: 0,0:54:12.94,0:54:19.96,Chinese,,0,0,0,,它可能是源，你在读它，或者是目标，你要写入
Dialogue: 0,0:54:22.62,0:54:25.96,English,,0,0,0,,And so the mov instruction gives you all these possibilities
Dialogue: 0,0:54:22.62,0:54:25.96,Chinese,,0,0,0,,因此 mov 指令为你提供了所有这些可能性
Dialogue: 0,0:54:26.90,0:54:33.30,English,,0,0,0,,An immediate value can be written to a register or directly to memory
Dialogue: 0,0:54:26.90,0:54:33.30,Chinese,,0,0,0,,立即值可以写入寄存器或直接写入内存
Dialogue: 0,0:54:34.18,0:54:38.26,English,,0,0,0,,A register value can be copied to another register or written to memory
Dialogue: 0,0:54:34.18,0:54:38.26,Chinese,,0,0,0,,寄存器值可以复制到另一个寄存器或写入内存
Dialogue: 0,0:54:39.14,0:54:44.36,English,,0,0,0,,Or you can take a value from memory read it from memory and copy it to a register
Dialogue: 0,0:54:39.14,0:54:44.36,Chinese,,0,0,0,,或者你可以从内存中取一个值，从内存中读取它并将其复制到寄存器中
Dialogue: 0,0:54:45.20,0:54:50.24,English,,0,0,0,,So if you think of wait shouldn't there be nine different combinations here well
Dialogue: 0,0:54:45.20,0:54:50.24,Chinese,,0,0,0,,所以，如果你想，等一下，那么这里不应该有九种不同的组合
Dialogue: 0,0:54:50.52,0:54:51.04,English,,0,0,0,,No
Dialogue: 0,0:54:50.52,0:54:51.04,Chinese,,0,0,0,,没有
Dialogue: 0,0:54:51.44,0:54:56.52,English,,0,0,0,,Because it doesn't make sense to have an immediate value as a destination right, it's a constant
Dialogue: 0,0:54:51.44,0:54:56.52,Chinese,,0,0,0,,因为将立即值作为目的地没有意义，它是常数
Dialogue: 0,0:54:57.16,0:55:02.38,English,,0,0,0,,And also just for sort of the sake of convenience for the hardware designers
Dialogue: 0,0:54:57.16,0:55:02.38,Chinese,,0,0,0,,而且出于硬件设计者的方便
Dialogue: 0,0:55:02.84,0:55:06.54,English,,0,0,0,,It doesn't let you directly copy from one memory location to another
Dialogue: 0,0:55:02.84,0:55:06.54,Chinese,,0,0,0,,它不允许你直接从一个内存位置复制到另一个内存位置
Dialogue: 0,0:55:07.00,0:55:09.20,English,,0,0,0,,What you have to do is use two instructions
Dialogue: 0,0:55:07.00,0:55:09.20,Chinese,,0,0,0,,你要做的是使用两个指令
Dialogue: 0,0:55:09.40,0:55:13.82,English,,0,0,0,,One to copy from memory to read it from memory copy it to a register
Dialogue: 0,0:55:09.40,0:55:13.82,Chinese,,0,0,0,,一个从内存中读取值，将其复制到寄存器
Dialogue: 0,0:55:15.72,0:55:19.36,English,,0,0,0,,And the second to take that value in the register and write it to memory
Dialogue: 0,0:55:15.72,0:55:19.36,Chinese,,0,0,0,,第二个是在寄存器中取值并将其写入内存
Dialogue: 0,0:55:20.32,0:55:24.90,English,,0,0,0,,So that's why there's this only five possibilities
Dialogue: 0,0:55:20.32,0:55:24.90,Chinese,,0,0,0,,所以这就是为什么这只有五种可能性
Dialogue: 0,0:55:26.40,0:55:31.84,English,,0,0,0,,And so each of these actual five combinations you'll see in some form or another
Dialogue: 0,0:55:26.40,0:55:31.84,Chinese,,0,0,0,,所以这些实际的五种组合中的每一种都会以某种形式或其他形式出现
Dialogue: 0,0:55:32.64,0:55:37.00,English,,0,0,0,,So for example if I take a constant value and copy it to a register
Dialogue: 0,0:55:32.64,0:55:37.00,Chinese,,0,0,0,,因此，例如这里，我取一个常量值并将其复制到寄存器
Dialogue: 0,0:55:37.72,0:55:43.56,English,,0,0,0,,It's a little like you can think of register as a sort of the temporary data that You're operating on right now
Dialogue: 0,0:55:37.72,0:55:43.56,Chinese,,0,0,0,,你可以将寄存器当作你正在处理的临时数据
Dialogue: 0,0:55:44.38,0:55:48.30,English,,0,0,0,,So it's a way of sort of of assigning a constant value to a temporary
Dialogue: 0,0:55:44.38,0:55:48.30,Chinese,,0,0,0,,所以这是一种为常量值赋给临时数据的方法
Dialogue: 0,0:55:50.08,0:55:54.04,English,,0,0,0,,Similarly if you're have a memory as your destination
Dialogue: 0,0:55:50.08,0:55:54.04,Chinese,,0,0,0,,同样，如果你有一个内存位置作为你的目的地
Dialogue: 0,0:55:54.04,0:55:58.04,English,,0,0,0,,It's like storing a constant value in memory somewhere
Dialogue: 0,0:55:54.04,0:55:58.04,Chinese,,0,0,0,,这就像在某个地方存储一个常量值
Dialogue: 0,0:55:59.80,0:56:02.54,English,,0,0,0,,If you're copying from one register to another
Dialogue: 0,0:55:59.80,0:56:02.54,Chinese,,0,0,0,,如果你从一个寄存器复制到另一个寄存器
Dialogue: 0,0:56:02.54,0:56:08.44,English,,0,0,0,,It's sort of like copying one temporary value to another one  register to memory
Dialogue: 0,0:56:02.54,0:56:08.44,Chinese,,0,0,0,,这有点像将一个临时值复制到另一个中，到内存
Dialogue: 0,0:56:08.56,0:56:13.64,English,,0,0,0,,It's as if you it's sort of like storing to an address
Dialogue: 0,0:56:08.56,0:56:13.64,Chinese,,0,0,0,,这就像你有点像存储到一个内存地址
Dialogue: 0,0:56:14.04,0:56:17.92,English,,0,0,0,,So a pointer dereference where the pointer is on the left side the dereference
Dialogue: 0,0:56:14.04,0:56:17.92,Chinese,,0,0,0,,所以这里一个指针解除引用，其中指针位于式子的左侧
Dialogue: 0,0:56:19.34,0:56:22.34,English,,0,0,0,,And memory to register is the opposite
Dialogue: 0,0:56:19.34,0:56:22.34,Chinese,,0,0,0,,而内存到寄存器正好相反
Dialogue: 0,0:56:22.44,0:56:27.64,English,,0,0,0,,You're reading from some location into a temporary position
Dialogue: 0,0:56:22.44,0:56:27.64,Chinese,,0,0,0,,你正在从某个地方读到一个临时位置
Dialogue: 0,0:56:30.06,0:56:34.38,English,,0,0,0,,So these you see all five versions get used in some form or another
Dialogue: 0,0:56:30.06,0:56:34.38,Chinese,,0,0,0,,所以这些你看到所有五个版本都以某种形式使用
Dialogue: 0,0:56:36.62,0:56:40.20,English,,0,0,0,,So now let's talk about how we write these up pointers
Dialogue: 0,0:56:36.62,0:56:40.20,Chinese,,0,0,0,,那么现在让我们谈谈我们如何编写这些指针
Dialogue: 0,0:56:40.78,0:56:46.55,English,,0,0,0,,How we specify either a source or a destination for a memory reference
Dialogue: 0,0:56:40.78,0:56:46.55,Chinese,,0,0,0,,我们如何指定内存引用的源或目标
Dialogue: 0,0:56:47.41,0:56:51.82,English,,0,0,0,,And you already saw one version of this in fact in some of the code
Dialogue: 0,0:56:47.41,0:56:51.82,Chinese,,0,0,0,,而且你已经在一些代码中看到过这个版本
Dialogue: 0,0:56:52.06,0:56:54.80,English,,0,0,0,,When you put the name of a register in parentheses
Dialogue: 0,0:56:52.06,0:56:54.80,Chinese,,0,0,0,,当你将寄存器的名称放在括号中时
Dialogue: 0,0:56:55.64,0:57:00.32,English,,0,0,0,,That's just saying use this register whatever is in that that's an address
Dialogue: 0,0:56:55.64,0:57:00.32,Chinese,,0,0,0,,那就是说使用这个寄存器，不管那是什么地址
Dialogue: 0,0:57:00.88,0:57:03.92,English,,0,0,0,,And use that address to reference some memory location
Dialogue: 0,0:57:00.88,0:57:03.92,Chinese,,0,0,0,,并使用该地址来引用一些内存位置
Dialogue: 0,0:57:06.42,0:57:12.58,English,,0,0,0,,And so you'll see something like this is equivalent of dereferencing a pointer and putting it in a temporary
Dialogue: 0,0:57:06.42,0:57:12.58,Chinese,,0,0,0,,所以你会看到这样的东西等同于解除引用指针并将其置于临时状态
Dialogue: 0,0:57:13.60,0:57:16.10,English,,0,0,0,,You're also allowed to do a little bit of arithmetic
Dialogue: 0,0:57:13.60,0:57:16.10,Chinese,,0,0,0,,你也可以做一点运算
Dialogue: 0,0:57:16.82,0:57:22.48,English,,0,0,0,,To derive an address from some collection of registers and other constant values
Dialogue: 0,0:57:16.82,0:57:22.48,Chinese,,0,0,0,,从某些寄存器集合和其他常量值派生地址
Dialogue: 0,0:57:23.22,0:57:26.18,English,,0,0,0,,So if you see a number it's called the displacement D
Dialogue: 0,0:57:23.22,0:57:26.18,Chinese,,0,0,0,,所以，如果你看到一个数字，它就叫做位移 D
Dialogue: 0,0:57:27.02,0:57:33.68,English,,0,0,0,,In front of this parenthesis it means to offset not use the address that's in the register
Dialogue: 0,0:57:27.02,0:57:33.68,Chinese,,0,0,0,,在这个括号前面，它表示将地址偏移 D，而不是直接使用寄存器中的地址
Dialogue: 0,0:57:34.06,0:57:36.18,English,,0,0,0,,But add or subtract some number from it
Dialogue: 0,0:57:34.06,0:57:36.18,Chinese,,0,0,0,,从中添加或减去一些数字
Dialogue: 0,0:57:36.56,0:57:40.34,English,,0,0,0,,To get an address that's just slightly off of it by some fixed amount
Dialogue: 0,0:57:36.56,0:57:40.34,Chinese,,0,0,0,,获得一个稍微偏离一定位置的地址
Dialogue: 0,0:57:40.94,0:57:44.76,English,,0,0,0,,And that we'll see is fairly useful for accessing different data structures
Dialogue: 0,0:57:40.94,0:57:44.76,Chinese,,0,0,0,,我们将看到，这对于访问不同的数据结构非常有用
Dialogue: 0,0:57:47.92,0:57:50.58,English,,0,0,0,,So here's an example of a very simple function that
Dialogue: 0,0:57:47.92,0:57:50.58,Chinese,,0,0,0,,所以这是一个非常简单的函数的例子
Dialogue: 0,0:57:50.84,0:57:55.90,English,,0,0,0,,We can understand everything about it already
Dialogue: 0,0:57:50.84,0:57:55.90,Chinese,,0,0,0,,我们已经可以了解它的一切
Dialogue: 0,0:57:56.32,0:57:58.60,English,,0,0,0,,Because we know what the mov instruction does
Dialogue: 0,0:57:56.32,0:57:58.60,Chinese,,0,0,0,,因为我们知道 mov 指令的作用
Dialogue: 0,0:57:59.08,0:58:05.28,English,,0,0,0,,And that's the sort of classic swapping of two values that are stored in memory
Dialogue: 0,0:57:59.08,0:58:05.28,Chinese,,0,0,0,,这就是存储在内存中的两个值的经典交换
Dialogue: 0,0:58:05.90,0:58:10.62,English,,0,0,0,,So my point my arguments are two pointers called xp and yp
Dialogue: 0,0:58:05.90,0:58:10.62,Chinese,,0,0,0,,所以我的观点是，两个叫做 xp 和 yp 的指针
Dialogue: 0,0:58:11.26,0:58:15.62,English,,0,0,0,,And I'm going to dereference those pointers I'm going to read from memory into registers
Dialogue: 0,0:58:11.26,0:58:15.62,Chinese,,0,0,0,,我将解除引用它们，我要从内存中读取值到寄存器中
Dialogue: 0,0:58:16.76,0:58:20.82,English,,0,0,0,,And then I'm going to copy back to to memory
Dialogue: 0,0:58:16.76,0:58:20.82,Chinese,,0,0,0,,然后我要复制回内存
Dialogue: 0,0:58:20.82,0:58:24.64,English,,0,0,0,,But reversing the the two destinations
Dialogue: 0,0:58:20.82,0:58:24.64,Chinese,,0,0,0,,但扭转了两个目的地
Dialogue: 0,0:58:25.76,0:58:30.46,English,,0,0,0,,And so as you can imagine it,it lines up to be four mov instructions
Dialogue: 0,0:58:25.76,0:58:30.46,Chinese,,0,0,0,,因此，你可以构想到，它是一列 4 个 mov 指令
Dialogue: 0,0:58:30.54,0:58:33.16,English,,0,0,0,,That correspond to these four references
Dialogue: 0,0:58:30.54,0:58:33.16,Chinese,,0,0,0,,对应于这四个内存引用
Dialogue: 0,0:58:34.58,0:58:40.00,English,,0,0,0,,And the final one ret just we will learn more about functions and how they're called
Dialogue: 0,0:58:34.58,0:58:40.00,Chinese,,0,0,0,,而最后一个 ret，我们会学习更多关于函数和它们如何被调用的
Dialogue: 0,0:58:40.00,0:58:47.50,English,,0,0,0,,But just think of the read is it gets you it returns from wherever the calling position was
Dialogue: 0,0:58:40.00,0:58:47.50,Chinese,,0,0,0,,但只要想一下，ret 会返回之前 call 的位置
Dialogue: 0,0:58:51.92,0:58:57.00,English,,0,0,0,,And so let's look at more detail at the actual code then
Dialogue: 0,0:58:51.92,0:58:57.00,Chinese,,0,0,0,,那么让我们看一下实际代码的更多细节
Dialogue: 0,0:58:58.04,0:59:09.26,English,,0,0,0,,And so it turns out with the (64)x86-64 the arguments always come in some specific registers
Dialogue: 0,0:58:58.04,0:59:09.26,Chinese,,0,0,0,,事实证明，使用（64）x86-64，函数参数总是出现在某些特定的寄存器中
Dialogue: 0,0:59:09.74,0:59:11.58,English,,0,0,0,,And the ones to remember for today is
Dialogue: 0,0:59:09.74,0:59:11.58,Chinese,,0,0,0,,而今天要记住的是
Dialogue: 0,0:59:11.62,0:59:17.00,English,,0,0,0,,%rdi will be the first argument register and %rsi will be the second argument register
Dialogue: 0,0:59:11.62,0:59:17.00,Chinese,,0,0,0,,％rdi 将是第一个参数寄存器，％rsi 将是第二个参数寄存器
Dialogue: 0,0:59:17.42,0:59:20.56,English,,0,0,0,,There can be up to six of these and we'll go into more of that later
Dialogue: 0,0:59:17.42,0:59:20.56,Chinese,,0,0,0,,最多可以有六个，我们稍后会详细介绍
Dialogue: 0,0:59:21.62,0:59:25.40,English,,0,0,0,,So those two registers represent the values of xp and yp
Dialogue: 0,0:59:21.62,0:59:25.40,Chinese,,0,0,0,,所以这两个寄存器代表 xp 和 yp 的值
Dialogue: 0,0:59:25.40,0:59:31.38,English,,0,0,0,,Those are set before when this before the function is actually begins executing
Dialogue: 0,0:59:25.40,0:59:31.38,Chinese,,0,0,0,,这两个寄存器的值是在函数实际开始执行之前就设置好的
Dialogue: 0,0:59:31.40,0:59:34.42,English,,0,0,0,,That's set by the part of the code that calls this function
Dialogue: 0,0:59:31.40,0:59:34.42,Chinese,,0,0,0,,这是由调用者函数的代码部分设置的
Dialogue: 0,0:59:36.10,0:59:41.68,English,,0,0,0,,And those will be pointers so what they are is they contain addresses that specifying locations in memory
Dialogue: 0,0:59:36.10,0:59:41.68,Chinese,,0,0,0,,那些是指针，所以它们是什么，它们包含指定内存中位置的地址
Dialogue: 0,0:59:43.34,0:59:47.42,English,,0,0,0,,And then within the code the compiler just came up with its own ideas
Dialogue: 0,0:59:43.34,0:59:47.42,Chinese,,0,0,0,,然后在代码中，编译器就提出了自己的想法
Dialogue: 0,0:59:47.44,0:59:52.74,English,,0,0,0,,How to use different registers for temporary data by whatever
Dialogue: 0,0:59:47.44,0:59:52.74,Chinese,,0,0,0,,如何使用不同的寄存器来处理临时数据
Dialogue: 0,0:59:53.24,0:59:57.40,English,,0,0,0,,What's known as the register allocation algorithm it uses
Dialogue: 0,0:59:53.24,0:59:57.40,Chinese,,0,0,0,,它所使用的寄存器分配算法就是所谓的
Dialogue: 0,0:59:58.00,1:00:02.52,English,,0,0,0,,And we don't really care,we just want to what...we'll want to do is figure out what it's doing
Dialogue: 0,0:59:58.00,1:00:02.52,Chinese,,0,0,0,,而我们并不在乎，我们只想要...我们想要做的就是弄清楚它在做什么
Dialogue: 0,1:00:03.82,1:00:11.40,English,,0,0,0,,And we'll see that a register is %rax is being used to hold the value t0 and %rdx the value t1
Dialogue: 0,1:00:03.82,1:00:11.40,Chinese,,0,0,0,,我们将看到寄存器 ％rax 用于保持值 t0 而 ％rdx 用于保存值t1
Dialogue: 0,1:00:14.50,1:00:19.94,English,,0,0,0,,Now so let's get actually concrete here and this is very detailed
Dialogue: 0,1:00:14.50,1:00:19.94,Chinese,,0,0,0,,现在让我们在这里具体描述，这是非常详细的
Dialogue: 0,1:00:20.18,1:00:22.78,English,,0,0,0,,But I think it's important that you understand
Dialogue: 0,1:00:20.18,1:00:22.78,Chinese,,0,0,0,,但我认为你明白这一点很重要
Dialogue: 0,1:00:23.62,1:00:28.54,English,,0,0,0,,Sort of you can almost simulate the execution of some instructions by yourself
Dialogue: 0,1:00:23.62,1:00:28.54,Chinese,,0,0,0,,你几乎可以自己模拟一些指令的执行
Dialogue: 0,1:00:29.18,1:00:31.20,English,,0,0,0,,You're going to really have to know this stuff
Dialogue: 0,1:00:29.18,1:00:31.20,Chinese,,0,0,0,,你真的要知道这些东西
Dialogue: 0,1:00:31.86,1:00:34.62,English,,0,0,0,,So what each of these instructions is doing
Dialogue: 0,1:00:31.86,1:00:34.62,Chinese,,0,0,0,,那么每条指令都在做什么
Dialogue: 0,1:00:34.62,1:00:38.20,English,,0,0,0,,And how it works and really have that wired into you pretty well
Dialogue: 0,1:00:34.62,1:00:38.20,Chinese,,0,0,0,,它是如何工作的，直到这些概念很好地融入了你的大脑
Dialogue: 0,1:00:38.96,1:00:49.38,English,,0,0,0,,So let's make up an example let's imagine that the two addresses that are used for these two pointers are in 0x120 and 0x100
Dialogue: 0,1:00:38.96,1:00:49.38,Chinese,,0,0,0,,让我们编写一个例子，我们假设用于这两个指针的两个地址是 0x120 和 0x100
Dialogue: 0,1:00:49.78,1:00:53.04,English,,0,0,0,,By the way those would not be typical addresses
Dialogue: 0,1:00:49.78,1:00:53.04,Chinese,,0,0,0,,顺便说一下这两个不是典型的地址
Dialogue: 0,1:00:53.54,1:00:58.00,English,,0,0,0,,They're way too small a number but it's much easier to use them as an illustration
Dialogue: 0,1:00:53.54,1:00:58.00,Chinese,,0,0,0,,它们的数值太小，但使用它们在插图中比较方便
Dialogue: 0,1:00:59.12,1:01:03.30,English,,0,0,0,,And let's suppose that one of them held the value 123 and the other 456
Dialogue: 0,1:00:59.12,1:01:03.30,Chinese,,0,0,0,,让我们假设其中一个持有值 123 而另一个持有 456
Dialogue: 0,1:01:05.74,1:01:10.27,English,,0,0,0,,So the first instruction says use %rdi as an address
Dialogue: 0,1:01:05.74,1:01:10.27,Chinese,,0,0,0,,所以第一条指令说使用 ％rdi 作为地址
Dialogue: 0,1:01:11.02,1:01:15.22,English,,0,0,0,,Copy from that memory location and store the result in register %rax
Dialogue: 0,1:01:11.02,1:01:15.22,Chinese,,0,0,0,,从该内存位置复制并将结果存储在寄存器 ％rax 中
Dialogue: 0,1:01:16.04,1:01:18.54,English,,0,0,0,,So %rdi is 0x120
Dialogue: 0,1:01:16.04,1:01:18.54,Chinese,,0,0,0,,所以 ％rdi 是 0x120
Dialogue: 0,1:01:19.02,1:01:24.44,English,,0,0,0,,I'll read from that address I'll read the value 123 and store it and register %rax
Dialogue: 0,1:01:19.02,1:01:24.44,Chinese,,0,0,0,,我将从该地址读取，我将读取值 123 并将其存储在寄存器 ％rax
Dialogue: 0,1:01:24.86,1:01:26.76,English,,0,0,0,,These are all by the way 8 byte values
Dialogue: 0,1:01:24.86,1:01:26.76,Chinese,,0,0,0,,这些都是 8 字节值
Dialogue: 0,1:01:28.14,1:01:30.54,English,,0,0,0,,And I'm just sort of glossing over that part of it
Dialogue: 0,1:01:28.14,1:01:30.54,Chinese,,0,0,0,,而我只是略去讲那一部分
Dialogue: 0,1:01:30.54,1:01:37.18,English,,0,0,0,,But the q refers to what in intel terminology is a quad word
Dialogue: 0,1:01:30.54,1:01:37.18,Chinese,,0,0,0,,但 q 指的是英特尔术语中的四字
Dialogue: 0,1:01:37.88,1:01:43.06,English,,0,0,0,,A word because it goes back to the 8086 is 16 bits 2 bytes
Dialogue: 0,1:01:37.88,1:01:43.06,Chinese,,0,0,0,,回到 8086 年代，一个字是 16 位 2 字节
Dialogue: 0,1:01:44.18,1:01:53.14,English,,0,0,0,,A long word is 32 bits and a quad word is 64 bits
Dialogue: 0,1:01:44.18,1:01:53.14,Chinese,,0,0,0,,长字是 32 位，四字是 64 位
Dialogue: 0,1:01:53.30,1:01:56.94,English,,0,0,0,,That's just their terminology and we're stuck with it
Dialogue: 0,1:01:53.30,1:01:56.94,Chinese,,0,0,0,,这只是他们的术语，一直延续至今
Dialogue: 0,1:01:58.42,1:02:01.54,English,,0,0,0,,Ok so that one instruction had that effect
Dialogue: 0,1:01:58.42,1:02:01.54,Chinese,,0,0,0,,好的，第一条指令具有这样的结果
Dialogue: 0,1:02:02.30,1:02:09.38,English,,0,0,0,,The second instruction does the same thing but using %rsi which holds 0x100 as an address
Dialogue: 0,1:02:02.30,1:02:09.38,Chinese,,0,0,0,,第二条指令执行相同的操作，但使用 ％rsi，其中包含 0x100 作为地址
Dialogue: 0,1:02:09.38,1:02:12.80,English,,0,0,0,,And so it copies for 456 into %rdx
Dialogue: 0,1:02:09.38,1:02:12.80,Chinese,,0,0,0,,因此它将 456 复制到 ％rdx
Dialogue: 0,1:02:14.52,1:02:19.54,English,,0,0,0,,And then the third instruction is writing back to memory
Dialogue: 0,1:02:14.52,1:02:19.54,Chinese,,0,0,0,,然后第三条指令写回内存
Dialogue: 0,1:02:19.68,1:02:21.76,English,,0,0,0,,So its source is register %rdx
Dialogue: 0,1:02:19.68,1:02:21.76,Chinese,,0,0,0,,它的源是寄存器 ％rdx
Dialogue: 0,1:02:22.98,1:02:27.68,English,,0,0,0,,The destination has the address of %rdi which is 0x120
Dialogue: 0,1:02:22.98,1:02:27.68,Chinese,,0,0,0,,目的地的地址为 ％rdi，即 0x120
Dialogue: 0,1:02:28.24,1:02:29.98,English,,0,0,0,,It's storing that back in memory
Dialogue: 0,1:02:28.24,1:02:29.98,Chinese,,0,0,0,,它将它存储在内存中
Dialogue: 0,1:02:30.64,1:02:35.90,English,,0,0,0,,And finally the this fourth instruction does the other part of the right
Dialogue: 0,1:02:30.64,1:02:35.90,Chinese,,0,0,0,,最后，这第四条指令执行了右边的另一部分
Dialogue: 0,1:02:36.58,1:02:40.66,English,,0,0,0,,So you see these four instructions to read from memory into registers
Dialogue: 0,1:02:36.58,1:02:40.66,Chinese,,0,0,0,,所以你看到这四条指令从内存读入寄存器
Dialogue: 0,1:02:40.82,1:02:44.60,English,,0,0,0,,Two of them wrote from registers back to memory and that's the whole function
Dialogue: 0,1:02:40.82,1:02:44.60,Chinese,,0,0,0,,其中两个从寄存器写回内存，这就是整个函数
Dialogue: 0,1:02:47.62,1:02:52.14,English,,0,0,0,,And you can see it this move instruction is doing all the work here
Dialogue: 0,1:02:47.62,1:02:52.14,Chinese,,0,0,0,,你可以看到这个 mov 指令在这里做了所有的工作
Dialogue: 0,1:02:55.24,1:03:00.18,English,,0,0,0,,So we've shown that example just showed this very simple memory referencing
Dialogue: 0,1:02:55.24,1:03:00.18,Chinese,,0,0,0,,所以我们已经证明这个例子只是展示了这个非常简单的内存引用
Dialogue: 0,1:03:00.72,1:03:03.10,English,,0,0,0,,That's designated by the parentheses
Dialogue: 0,1:03:00.72,1:03:03.10,Chinese,,0,0,0,,这是由括号指定的
Dialogue: 0,1:03:03.90,1:03:07.96,English,,0,0,0,,And as I mentioned you can do a version where you put a displacement there too
Dialogue: 0,1:03:03.90,1:03:07.96,Chinese,,0,0,0,,正如我所提到的，你可以做一个带有位移的版本
Dialogue: 0,1:03:09.10,1:03:11.96,English,,0,0,0,,And in fact there's a much more elaborate form and
Dialogue: 0,1:03:09.10,1:03:11.96,Chinese,,0,0,0,,事实上，有一个更精细的形式，并且
Dialogue: 0,1:03:11.96,1:03:15.56,English,,0,0,0,,We'll see that this is useful for implementing array references
Dialogue: 0,1:03:11.96,1:03:15.56,Chinese,,0,0,0,,我们将看到这对于实现数组引用很有用
Dialogue: 0,1:03:16.32,1:03:18.86,English,,0,0,0,,Where there can be actually two registers involved
Dialogue: 0,1:03:16.32,1:03:18.86,Chinese,,0,0,0,,实际上可能涉及两个寄存器
Dialogue: 0,1:03:22.14,1:03:26.04,English,,0,0,0,,And there can be a displacement which is a constant offset
Dialogue: 0,1:03:22.14,1:03:26.04,Chinese,,0,0,0,,并且可以存在一个固定偏移量的位移 D
Dialogue: 0,1:03:26.54,1:03:29.66,English,,0,0,0,,And a scale factor which will be 1,2,4,8
Dialogue: 0,1:03:26.54,1:03:29.66,Chinese,,0,0,0,,和一个比例因子 1,2,4,8
Dialogue: 0,1:03:30.58,1:03:35.68,English,,0,0,0,,And the general idea of it is to take Ri register
Dialogue: 0,1:03:30.58,1:03:35.68,Chinese,,0,0,0,,而它的通常用法是采用 Ri 寄存器
Dialogue: 0,1:03:35.98,1:03:40.42,English,,0,0,0,,That I'm referring to &*%&(实在听不懂了), that's known as an index register
Dialogue: 0,1:03:35.98,1:03:40.42,Chinese,,0,0,0,,我指的是 XXX，它被称为索引寄存器
Dialogue: 0,1:03:40.84,1:03:43.14,English,,0,0,0,,You multiply it by the scale factor
Dialogue: 0,1:03:40.84,1:03:43.14,Chinese,,0,0,0,,你将它乘以比例因子
Dialogue: 0,1:03:45.16,1:03:50.12,English,,0,0,0,,you add the value of Rb register Rb
Dialogue: 0,1:03:45.16,1:03:50.12,Chinese,,0,0,0,,你将他加上寄存器 Rb 的值
Dialogue: 0,1:03:50.64,1:03:53.30,English,,0,0,0,,And you also add the constant displacement
Dialogue: 0,1:03:50.64,1:03:53.30,Chinese,,0,0,0,,而且你还加了恒定位移量 D
Dialogue: 0,1:03:53.86,1:04:00.12,English,,0,0,0,,And these have a Rb refers to base our Ri index and S is scale
Dialogue: 0,1:03:53.86,1:04:00.12,Chinese,,0,0,0,,而这些中 Rb 指的是基地址，Ri 指的是索引，和 S 尺度
Dialogue: 0,1:04:00.42,1:04:04.04,English,,0,0,0,,And it turns out this will be the sort of natural way to implement array referencing
Dialogue: 0,1:04:00.42,1:04:04.04,Chinese,,0,0,0,,事实证明，这是实现数组引用的一种自然方式
Dialogue: 0,1:04:04.12,1:04:07.16,English,,0,0,0,,It will make a lot more sense when we talk about arrays
Dialogue: 0,1:04:04.12,1:04:07.16,Chinese,,0,0,0,,当我们谈论数组时，它会更有意义
Dialogue: 0,1:04:07.86,1:04:11.46,English,,0,0,0,,But basically you can think of is if this is an array index
Dialogue: 0,1:04:07.86,1:04:11.46,Chinese,,0,0,0,,但基本上你可以想到的是，如果这是一个数组索引
Dialogue: 0,1:04:12.96,1:04:17.92,English,,0,0,0,,I have to typically scale it by however many bytes my data type is
Dialogue: 0,1:04:12.96,1:04:17.92,Chinese,,0,0,0,,我必须通过我的数据类型的字节数来缩放索引值
Dialogue: 0,1:04:17.94,1:04:23.52,English,,0,0,0,,So if it's an int i have to scale it by four if it's a long i have to scale it by eight
Dialogue: 0,1:04:17.94,1:04:23.52,Chinese,,0,0,0,,因此，如果它是一个 int 我必须将索引缩放四倍，如果它是 long，我必须将其缩放八倍
Dialogue: 0,1:04:24.04,1:04:26.08,English,,0,0,0,,So that's where these scale factors will come in
Dialogue: 0,1:04:24.04,1:04:26.08,Chinese,,0,0,0,,这就是这些比例因素的存在原因
Dialogue: 0,1:04:30.22,1:04:33.92,English,,0,0,0,,And basically the the format in the assembly code
Dialogue: 0,1:04:30.22,1:04:33.92,Chinese,,0,0,0,,汇编代码中的内存引用的基本格式
Dialogue: 0,1:04:33.92,1:04:39.60,English,,0,0,0,,Lets you eliminate some of these fields if they're not being used
Dialogue: 0,1:04:33.92,1:04:39.60,Chinese,,0,0,0,,如果不使用某些字段，可以删除其中的一些字段
Dialogue: 0,1:04:40.26,1:04:44.94,English,,0,0,0,,So you'll and we already saw the single parenthesis a sort of a reduced version of this form
Dialogue: 0,1:04:40.26,1:04:44.94,Chinese,,0,0,0,,你和我已经看到，只有小括号这种形式的精简版本
Dialogue: 0,1:04:46.98,1:04:50.84,English,,0,0,0,,So let's just do some examples of these address computations
Dialogue: 0,1:04:46.98,1:04:50.84,Chinese,,0,0,0,,那么让我们来做一些这些地址计算的练习
Dialogue: 0,1:04:52.22,1:04:57.08,English,,0,0,0,,And let's imagine that register %rdx hold text f with three zeros(0xf000)
Dialogue: 0,1:04:52.22,1:04:57.08,Chinese,,0,0,0,,让我们假设寄存器 ％rdx 储存有 f 和三个 0 的数据（0xf000）
Dialogue: 0,1:04:57.68,1:05:00.56,English,,0,0,0,,And %rcx holds a one with two zeros (0x0100)
Dialogue: 0,1:04:57.68,1:05:00.56,Chinese,,0,0,0,,％rcx 保存 0x0100
Dialogue: 0,1:05:01.48,1:05:06.58,English,,0,0,0,,So if I rather than doing one at a time
Dialogue: 0,1:05:01.48,1:05:06.58,Chinese,,0,0,0,,所以，如果我不是一个个来
Dialogue: 0,1:05:06.58,1:05:12.18,English,,0,0,0,,You can see each of these I'm taking %rdx which is 0xf000 + 0x8
Dialogue: 0,1:05:06.58,1:05:12.18,Chinese,,0,0,0,,你可以看到我正在使用 ％rdx，即 0xf000 + 0x8
Dialogue: 0,1:05:12.72,1:05:14.48,English,,0,0,0,,And so that's 0xf008
Dialogue: 0,1:05:12.72,1:05:14.48,Chinese,,0,0,0,,那就是 0xf008
Dialogue: 0,1:05:15.30,1:05:18.92,English,,0,0,0,,Here iI'm adding together registers %rdx and %rcx
Dialogue: 0,1:05:15.30,1:05:18.92,Chinese,,0,0,0,,这里我将寄存器 ％rdx 和 ％rcx 加在一起
Dialogue: 0,1:05:19.44,1:05:21.66,English,,0,0,0,,And that gives me 0xf100
Dialogue: 0,1:05:19.44,1:05:21.66,Chinese,,0,0,0,,这给了我 0xf100
Dialogue: 0,1:05:22.38,1:05:25.90,English,,0,0,0,,I'm doing the same here except that I'm scaling %rcx by 4
Dialogue: 0,1:05:22.38,1:05:25.90,Chinese,,0,0,0,,我在这里也是这样做的，除了我将 ％rcx 缩放为四倍
Dialogue: 0,1:05:26.52,1:05:32.16,English,,0,0,0,,So 4*0x100 is 0x400 and I'm adding that to 0xf000
Dialogue: 0,1:05:26.52,1:05:32.16,Chinese,,0,0,0,,所以 4 * 0x100 是 0x400，我将其添加到 0xf000
Dialogue: 0,1:05:34.04,1:05:38.64,English,,0,0,0,,And here I'm taking %rdx which is 0xf000
Dialogue: 0,1:05:34.04,1:05:38.64,Chinese,,0,0,0,,在这里，我采用的是 ％rdx，即 0xf000
Dialogue: 0,1:05:39.14,1:05:43.32,English,,0,0,0,,If I double that I get 0x1e000
Dialogue: 0,1:05:39.14,1:05:43.32,Chinese,,0,0,0,,如果我将其加倍，我得到 0x1e000
Dialogue: 0,1:05:43.32,1:05:47.86,English,,0,0,0,,If you think about shifting an 0xf to the left 1 you get a 1
Dialogue: 0,1:05:43.32,1:05:47.86,Chinese,,0,0,0,,如果你考虑将 0xf000 左移 1 位，你得到 1
Dialogue: 0,1:05:48.28,1:05:50.74,English,,0,0,0,,And then it goes 1110
Dialogue: 0,1:05:48.28,1:05:50.74,Chinese,,0,0,0,,然后 0xf 变成二进制 1110
Dialogue: 0,1:05:51.90,1:05:52.84,English,,0,0,0,,And that's an 0xe
Dialogue: 0,1:05:51.90,1:05:52.84,Chinese,,0,0,0,,那是 0xe
Dialogue: 0,1:05:53.82,1:05:57.40,English,,0,0,0,,Ok and then I'm adding this displacement of 0x80 to it
Dialogue: 0,1:05:53.82,1:05:57.40,Chinese,,0,0,0,,好的，然后我加上这个位移 0x80
Dialogue: 0,1:05:58.00,1:06:03.14,English,,0,0,0,,So the point of this is all of this is arithmetic it's all using whatever is in the register
Dialogue: 0,1:05:58.00,1:06:03.14,Chinese,,0,0,0,,所以关键是所有这些运算指令，都是使用寄存器中的值
Dialogue: 0,1:06:04.06,1:06:07.66,English,,0,0,0,,And there's some rules for how you combine this and get an address
Dialogue: 0,1:06:04.06,1:06:07.66,Chinese,,0,0,0,,如何将这个结合起来并得到一个地址，是有一些规则的
Dialogue: 0,1:06:08.20,1:06:11.66,English,,0,0,0,,And then that's being used to either read or write some memory location
Dialogue: 0,1:06:08.20,1:06:11.66,Chinese,,0,0,0,,然后用于读取或写入一些内存位置
Dialogue: 0,1:06:15.18,1:06:18.20,English,,0,0,0,,Okay so now what is a final part of that today
Dialogue: 0,1:06:15.18,1:06:18.20,Chinese,,0,0,0,,好的，现在，今天的最后一部分是什么
Dialogue: 0,1:06:19.02,1:06:21.40,English,,0,0,0,,I'll go through some arithmetic
Dialogue: 0,1:06:19.02,1:06:21.40,Chinese,,0,0,0,,我会复习一下运算过程
Dialogue: 0,1:06:22.40,1:06:26.50,English,,0,0,0,,And one of the things that will be sure to confuse you and drive you crazy
Dialogue: 0,1:06:22.40,1:06:26.50,Chinese,,0,0,0,,其中一件事肯定会让你感到困惑并让你发疯
Dialogue: 0,1:06:26.56,1:06:30.36,English,,0,0,0,,Make you be sending email to the staff for explanation
Dialogue: 0,1:06:26.56,1:06:30.36,Chinese,,0,0,0,,让你向工作人员发送电子邮件以获得解释
Dialogue: 0,1:06:30.88,1:06:33.22,English,,0,0,0,,Is an instruction called load effective address
Dialogue: 0,1:06:30.88,1:06:33.22,Chinese,,0,0,0,,是一个称为 lea 的指令
Dialogue: 0,1:06:34.84,1:06:37.56,English,,0,0,0,,And the reason is its purpose in life is to do
Dialogue: 0,1:06:34.84,1:06:37.56,Chinese,,0,0,0,,而原因是它的目标就是去
Dialogue: 0,1:06:38.20,1:06:42.28,English,,0,0,0,,Basically the ampersand operation of C to compute an address
Dialogue: 0,1:06:38.20,1:06:42.28,Chinese,,0,0,0,,基本上是利用 C 的 ＆ 符号操作，来计算地址
Dialogue: 0,1:06:43.00,1:06:46.96,English,,0,0,0,,Based on some whatever you want to compute an address from
Dialogue: 0,1:06:43.00,1:06:46.96,Chinese,,0,0,0,,基于你想要计算地址的一些东西
Dialogue: 0,1:06:48.56,1:06:54.58,English,,0,0,0,,But it also turns out to be a pretty handy way to do arithmetic and the C compiler likes to use it
Dialogue: 0,1:06:48.56,1:06:54.58,Chinese,,0,0,0,,但它也是一种非常方便的算术运算方式，C 编译器喜欢使用它
Dialogue: 0,1:06:55.52,1:07:05.38,English,,0,0,0,,So in particular,it looks the the format of it looks like a mov instruction there's a source and a destination
Dialogue: 0,1:06:55.52,1:07:05.38,Chinese,,0,0,0,,所以特别是，看起来它的格式看起来像一个有源和目的地的 mov 指令
Dialogue: 0,1:07:06.34,1:07:08.54,English,,0,0,0,,But the destination has to be a register
Dialogue: 0,1:07:06.34,1:07:08.54,Chinese,,0,0,0,,但目的地必须是寄存器
Dialogue: 0,1:07:09.64,1:07:12.94,English,,0,0,0,,And the source will be one of these memory references
Dialogue: 0,1:07:09.64,1:07:12.94,Chinese,,0,0,0,,源是上面这些内存引用之一
Dialogue: 0,1:07:15.00,1:07:16.80,English,,0,0,0,,So it looks like a mov instruction
Dialogue: 0,1:07:15.00,1:07:16.80,Chinese,,0,0,0,,所以它看起来像一个 mov 指令
Dialogue: 0,1:07:16.82,1:07:20.18,English,,0,0,0,,It looks like you're doing some address computation
Dialogue: 0,1:07:16.82,1:07:20.18,Chinese,,0,0,0,,看起来你正在做一些地址计算
Dialogue: 0,1:07:20.18,1:07:23.50,English,,0,0,0,,Then you're reading from memory and storing it to a register
Dialogue: 0,1:07:20.18,1:07:23.50,Chinese,,0,0,0,,然后你从内存中读取并将其存储到寄存器中
Dialogue: 0,1:07:24.02,1:07:28.06,English,,0,0,0,,But what it actually does is it does that address computation
Dialogue: 0,1:07:24.02,1:07:28.06,Chinese,,0,0,0,,但它实际上做的是，地址的运算过程
Dialogue: 0,1:07:28.56,1:07:33.64,English,,0,0,0,,And then it actually writes that address not the memory value
Dialogue: 0,1:07:28.56,1:07:33.64,Chinese,,0,0,0,,然后它实际上写入寄存器的是地址值而不是内存值
Dialogue: 0,1:07:33.64,1:07:38.26,English,,0,0,0,,But the value of got that got computed directly to the register
Dialogue: 0,1:07:33.64,1:07:38.26,Chinese,,0,0,0,,得到的计算后的地址值直接送到寄存器
Dialogue: 0,1:07:39.08,1:07:42.38,English,,0,0,0,,Which is what you want to do here remember the ampersand operation is
Dialogue: 0,1:07:39.08,1:07:42.38,Chinese,,0,0,0,,也是你想要做的地址运算，记住 ＆ 符号操作的意思是
Dialogue: 0,1:07:42.96,1:07:45.96,English,,0,0,0,,Give me the address of some place give me a pointer
Dialogue: 0,1:07:42.96,1:07:45.96,Chinese,,0,0,0,,给我一些位置的地址，给我一个指针
Dialogue: 0,1:07:46.38,1:07:50.04,English,,0,0,0,,That designates some location
Dialogue: 0,1:07:46.38,1:07:50.04,Chinese,,0,0,0,,这指定了一些位置
Dialogue: 0,1:07:51.00,1:07:56.96,English,,0,0,0,,So for example this is fairly typical in C code if you say multiply x by 12
Dialogue: 0,1:07:51.00,1:07:56.96,Chinese,,0,0,0,,因此，例如，如果你说 x 乘以 12，这在 C 代码中是相当典型的
Dialogue: 0,1:07:57.76,1:08:04.44,English,,0,0,0,,It will turn it into a address computation
Dialogue: 0,1:07:57.76,1:08:04.44,Chinese,,0,0,0,,它会把它变成一个地址计算
Dialogue: 0,1:08:04.50,1:08:08.62,English,,0,0,0,,And this is just a clever way to compute three times %rdi
Dialogue: 0,1:08:04.50,1:08:08.62,Chinese,,0,0,0,,这只是计算三倍 ％rdi 的聪明方法
Dialogue: 0,1:08:09.58,1:08:13.24,English,,0,0,0,,It adds %rdi + 2 * %rdi
Dialogue: 0,1:08:09.58,1:08:13.24,Chinese,,0,0,0,,它将 ％rdi 加上 2 倍的 ％rdi
Dialogue: 0,1:08:13.30,1:08:16.74,English,,0,0,0,,So that's 3 * %rdi and stores it in %rax
Dialogue: 0,1:08:13.30,1:08:16.74,Chinese,,0,0,0,,所以这是 3*％rdi 并将其存储在 ％rax 中
Dialogue: 0,1:08:17.96,1:08:24.68,English,,0,0,0,,And then salq means shift left by two
Dialogue: 0,1:08:17.96,1:08:24.68,Chinese,,0,0,0,,然后 salq 意味着左移两位
Dialogue: 0,1:08:25.18,1:08:28.80,English,,0,0,0,,And so you remember shifting left by two is like multiplying by four
Dialogue: 0,1:08:25.18,1:08:28.80,Chinese,,0,0,0,,你记得左移两个就等价于乘以四
Dialogue: 0,1:08:29.44,1:08:36.90,English,,0,0,0,,So the first value computed 3*x. i shift that left four by two positions and i have 12*x
Dialogue: 0,1:08:29.44,1:08:36.90,Chinese,,0,0,0,,所以第一个值计算为 3 * x。我左移了两位，我有 12 * x
Dialogue: 0,1:08:39.84,1:08:45.80,English,,0,0,0,,So that's a very special the lea,but you'll see it all over the place so you need to be ready for it
Dialogue: 0,1:08:39.84,1:08:45.80,Chinese,,0,0,0,,所以这是一个非常特别的 lea 指令，但你会在许多地方看到它，所以你需要做好准备
Dialogue: 0,1:08:46.40,1:08:50.48,English,,0,0,0,,These other ones look more like what you'd expect for arithmetic instructions
Dialogue: 0,1:08:46.40,1:08:50.48,Chinese,,0,0,0,,这些其他的指令看起来更像你对算术指令的期望
Dialogue: 0,1:08:50.48,1:08:55.28,English,,0,0,0,,They have names like add and subtract and multiply and so forth
Dialogue: 0,1:08:50.48,1:08:55.28,Chinese,,0,0,0,,它们具有加，减，乘等名称
Dialogue: 0,1:08:55.76,1:08:59.10,English,,0,0,0,,And they all have the same general format that they have two arguments
Dialogue: 0,1:08:55.76,1:08:59.10,Chinese,,0,0,0,,它们都有相同的通用格式，它们有两个参数
Dialogue: 0,1:09:00.24,1:09:04.15,English,,0,0,0,,And what's called the destination is actually also a source
Dialogue: 0,1:09:00.24,1:09:04.15,Chinese,,0,0,0,,所谓的目的地实际上也是运算数的一个来源
Dialogue: 0,1:09:05.04,1:09:08.74,English,,0,0,0,,It's a little like in c if you say x += y
Dialogue: 0,1:09:05.04,1:09:08.74,Chinese,,0,0,0,,它有点像 c，当你写 x += y 的时候
Dialogue: 0,1:09:09.50,1:09:15.44,English,,0,0,0,,It's saying take the value of x add the value of y and then store the result in x
Dialogue: 0,1:09:09.50,1:09:15.44,Chinese,,0,0,0,,它是说取 x 的值加上 y 的值然后将结果存储在 x 中
Dialogue: 0,1:09:15.78,1:09:18.30,English,,0,0,0,,And now the destination is like that
Dialogue: 0,1:09:15.78,1:09:18.30,Chinese,,0,0,0,,这里的目的地就是这样
Dialogue: 0,1:09:19.28,1:09:24.86,English,,0,0,0,,The other thing that's weird is that the operands are in the inverse order from where you'd expect them to be
Dialogue: 0,1:09:19.28,1:09:24.86,Chinese,,0,0,0,,另一件奇怪的事情是，操作数的顺序与你期望它们的顺序相反
Dialogue: 0,1:09:25.58,1:09:29.96,English,,0,0,0,,So the source comes first in the destination comes last and that's important to remember
Dialogue: 0,1:09:25.58,1:09:29.96,Chinese,,0,0,0,,所以源在前，目的地在后，记住它非常重要
Dialogue: 0,1:09:33.22,1:09:37.50,English,,0,0,0,,And other thing you'll see that there's nothing special here whether it's a...
Dialogue: 0,1:09:33.22,1:09:37.50,Chinese,,0,0,0,,还有其他的东西，你会发现这里没有什么特别的，不管它是 ......
Dialogue: 0,1:09:37.98,1:09:41.64,English,,0,0,0,,Except that this is a arithmetic shift and this is a logical shift
Dialogue: 0,1:09:37.98,1:09:41.64,Chinese,,0,0,0,,除了这有一个算术移位，还有一个逻辑右移
Dialogue: 0,1:09:42.42,1:09:44.54,English,,0,0,0,,Of whether it's a signed or unsigned value
Dialogue: 0,1:09:42.42,1:09:44.54,Chinese,,0,0,0,,是对应与被位移的数是有符号值还是无符号值
Dialogue: 0,1:09:44.54,1:09:49.16,English,,0,0,0,,Because you remember the bit level behavior of these two instructions is the same
Dialogue: 0,1:09:44.54,1:09:49.16,Chinese,,0,0,0,,因为你记得这两条指令的位级行为是一样的
Dialogue: 0,1:09:52.44,1:09:54.82,English,,0,0,0,,And then there's a series of instructions that are used
Dialogue: 0,1:09:52.44,1:09:54.82,Chinese,,0,0,0,,这里是一系列指令的使用方式
Dialogue: 0,1:09:55.24,1:10:01.74,English,,0,0,0,,That are just take one operand increment decrement a negate and not
Dialogue: 0,1:09:55.24,1:10:01.74,Chinese,,0,0,0,,这些指令取一个操作数，自增或者自减
Dialogue: 0,1:10:02.52,1:10:07.18,English,,0,0,0,,Not is not is like the tilde operation and see not the exclamation
Dialogue: 0,1:10:02.52,1:10:07.18,Chinese,,0,0,0,,not 像 ~ 运算，而不是 ！运算
Dialogue: 0,1:10:09.28,1:10:10.92,English,,0,0,0,,So those are the basic instructions
Dialogue: 0,1:10:09.28,1:10:10.92,Chinese,,0,0,0,,所以那些是基本的指令
Dialogue: 0,1:10:11.52,1:10:14.60,English,,0,0,0,,And again now we can actually look at some programs and understand them
Dialogue: 0,1:10:11.52,1:10:14.60,Chinese,,0,0,0,,现在我们再次可以看一些程序并理解它们
Dialogue: 0,1:10:14.62,1:10:19.66,English,,0,0,0,,And here's one that just does a bunch of junk of arithmetic instructions
Dialogue: 0,1:10:14.62,1:10:19.66,Chinese,,0,0,0,,而这里程序只是做了一些乱七八糟的算术运算
Dialogue: 0,1:10:20.30,1:10:23.12,English,,0,0,0,,And it converts into the following assembly code
Dialogue: 0,1:10:20.30,1:10:23.12,Chinese,,0,0,0,,它转换为以下汇编代码
Dialogue: 0,1:10:23.82,1:10:29.52,English,,0,0,0,,And you see it's using this lea instruction multiple times to do addition in various forms
Dialogue: 0,1:10:23.82,1:10:29.52,Chinese,,0,0,0,,并且你看到它多次使用这个 lea 指令以各种形式进行添加
Dialogue: 0,1:10:31.20,1:10:35.52,English,,0,0,0,,And it also has shifting and it has multiplication
Dialogue: 0,1:10:31.20,1:10:35.52,Chinese,,0,0,0,,它也有左移和右移，它有乘法运算
Dialogue: 0,1:10:36.06,1:10:39.58,English,,0,0,0,,You saw in the original code I just have addition and multiplication
Dialogue: 0,1:10:36.06,1:10:39.58,Chinese,,0,0,0,,你在原始代码中看到，只有加法和乘法
Dialogue: 0,1:10:40.80,1:10:46.64,English,,0,0,0,,Here I have various instructions, I only have one multiply here whereas, I had two there
Dialogue: 0,1:10:40.80,1:10:46.64,Chinese,,0,0,0,,在这里我有各种各样的指令，只有一个在这里相乘，而原来在那里有两个
Dialogue: 0,1:10:46.64,1:10:52.26,English,,0,0,0,,So the compiler is sort of scrambling things around trying to find clever ways to implement
Dialogue: 0,1:10:46.64,1:10:52.26,Chinese,,0,0,0,,所以编译器不断的尝试去找到更聪明的汇编实现方式
Dialogue: 0,1:10:52.70,1:10:59.94,English,,0,0,0,,What you're asking for using less complex expensive less time-consuming instructions
Dialogue: 0,1:10:52.70,1:10:59.94,Chinese,,0,0,0,,你要求使用不那么复杂的，且耗时较少的指令
Dialogue: 0,1:11:03.12,1:11:08.00,English,,0,0,0,,And if you sort of go through this code carefully what you'll find is
Dialogue: 0,1:11:03.12,1:11:08.00,Chinese,,0,0,0,,如果你仔细阅读这些代码，你会发现它是什么
Dialogue: 0,1:11:09.64,1:11:14.74,English,,0,0,0,,That this instruction here corresponds to this computation of t1
Dialogue: 0,1:11:09.64,1:11:14.74,Chinese,,0,0,0,,这里的指令对应于 t1 的这个计算
Dialogue: 0,1:11:14.82,1:11:19.50,English,,0,0,0,,It's adding two values and giving it a new name it's putting in %rax
Dialogue: 0,1:11:14.82,1:11:19.50,Chinese,,0,0,0,,它将两个值相加，并为它提供了一个新的名称，它放在 ％rax 中
Dialogue: 0,1:11:20.06,1:11:27.74,English,,0,0,0,,Similarly this one is adding z to t1 and storing it back in %rax
Dialogue: 0,1:11:20.06,1:11:27.74,Chinese,,0,0,0,,类似地，这个是将 z 加到 t1 并将其存储在 ％rax 中
Dialogue: 0,1:11:28.66,1:11:31.92,English,,0,0,0,,The x+4 doesn't show up directly here
Dialogue: 0,1:11:28.66,1:11:31.92,Chinese,,0,0,0,,x + 4 没有直接显示在此处
Dialogue: 0,1:11:32.66,1:11:35.64,English,,0,0,0,,It turns out what it does is it jumps right at head to here
Dialogue: 0,1:11:32.66,1:11:35.64,Chinese,,0,0,0,,事实证明它的作用是，它向前跳到这里
Dialogue: 0,1:11:35.74,1:11:37.96,English,,0,0,0,,And multiply y by 48
Dialogue: 0,1:11:35.74,1:11:37.96,Chinese,,0,0,0,,并将 y 乘以 48
Dialogue: 0,1:11:38.66,1:11:43.00,English,,0,0,0,,It does it by first computing 3y like we saw
Dialogue: 0,1:11:38.66,1:11:43.00,Chinese,,0,0,0,,它是通过首先像我们之前那样计算 3y 来实现的
Dialogue: 0,1:11:44.24,1:11:47.76,English,,0,0,0,,And computing shifting that left by 4
Dialogue: 0,1:11:44.24,1:11:47.76,Chinese,,0,0,0,,然后将它左移 4 位
Dialogue: 0,1:11:48.04,1:11:50.36,English,,0,0,0,,Because 3 *16=48
Dialogue: 0,1:11:48.04,1:11:50.36,Chinese,,0,0,0,,因为 3 * 16 = 48
Dialogue: 0,1:11:51.18,1:11:54.90,English,,0,0,0,,And then the 4 here that x + 4 actually shows up here
Dialogue: 0,1:11:51.18,1:11:54.90,Chinese,,0,0,0,,然后是 x + 4 这里的 4 实际在这里
Dialogue: 0,1:11:55.62,1:12:02.42,English,,0,0,0,,It just uses the displacement field of this computation to add 4 to some other values
Dialogue: 0,1:11:55.62,1:12:02.42,Chinese,,0,0,0,,它只使用此计算的位移字段将 4 添加到其他值上
Dialogue: 0,1:12:04.00,1:12:06.30,English,,0,0,0,,And so this is label then these comments show
Dialogue: 0,1:12:04.00,1:12:06.30,Chinese,,0,0,0,,所以这是标签，这些注释显示
Dialogue: 0,1:12:06.32,1:12:09.46,English,,0,0,0,,How these correspond to the program and these registers show it
Dialogue: 0,1:12:06.32,1:12:09.46,Chinese,,0,0,0,,这些寄存器，如何与程序对应
Dialogue: 0,1:12:10.14,1:12:12.36,English,,0,0,0,,So the important thing to get from here
Dialogue: 0,1:12:10.14,1:12:12.36,Chinese,,0,0,0,,所以从这里获得重要的东西是
Dialogue: 0,1:12:12.42,1:12:15.70,English,,0,0,0,,You will want to actually go back through this and make sure you believe
Dialogue: 0,1:12:12.42,1:12:15.70,Chinese,,0,0,0,,你会想要真正回过头来确保你相信
Dialogue: 0,1:12:16.32,1:12:19.22,English,,0,0,0,,That the comments are correct
Dialogue: 0,1:12:16.32,1:12:19.22,Chinese,,0,0,0,,注释是正确的
Dialogue: 0,1:12:20.92,1:12:24.18,English,,0,0,0,,But it's very important for you to figure out this lea instruction
Dialogue: 0,1:12:20.92,1:12:24.18,Chinese,,0,0,0,,但是你必须弄清楚这个 lea 指令
Dialogue: 0,1:12:24.26,1:12:26.70,English,,0,0,0,,Otherwise you're just going to be hopelessly confused
Dialogue: 0,1:12:24.26,1:12:26.70,Chinese,,0,0,0,,否则你只会毫无希望地感到困惑
Dialogue: 0,1:12:27.48,1:12:34.82,English,,0,0,0,,And it's also important to understand that the code that gets generated will correctly implement your function
Dialogue: 0,1:12:27.48,1:12:34.82,Chinese,,0,0,0,,并且了解生成的代码将正确实现你的功能也很重要
Dialogue: 0,1:12:35.14,1:12:41.34,English,,0,0,0,,But it might not exactly replicate at a low level the the exact sequence of operations
Dialogue: 0,1:12:35.14,1:12:41.34,Chinese,,0,0,0,,但它可能无法在较低级别完全复制操作的确切顺序
Dialogue: 0,1:12:41.34,1:12:42.70,English,,0,0,0,,You specified at a high level
Dialogue: 0,1:12:41.34,1:12:42.70,Chinese,,0,0,0,,你指定的是高级别运算
Dialogue: 0,1:12:45.08,1:12:53.46,English,,0,0,0,,So that will just to summarize then you've already gotten a glimpse then of what this very odd a world of machine programming is
Dialogue: 0,1:12:45.08,1:12:53.46,Chinese,,0,0,0,,那么这只是总结，你已经看到了这个奇怪的机器编程世界是什么
Dialogue: 0,1:12:53.46,1:12:56.08,English,,0,0,0,,And how different it is from C code already
Dialogue: 0,1:12:53.46,1:12:56.08,Chinese,,0,0,0,,它与 C 代码有多么不同
Dialogue: 0,1:12:57.46,1:13:03.82,English,,0,0,0,,It's all so you've already seen that x86 is weird like I said it's English
Dialogue: 0,1:12:57.46,1:13:03.82,Chinese,,0,0,0,,你已经看到 x86 很奇怪，就像我说的那样像是英语
Dialogue: 0,1:13:04.44,1:13:11.40,English,,0,0,0,,It's not a latin, it's not well designed and but you just got to deal with that
Dialogue: 0,1:13:04.44,1:13:11.40,Chinese,,0,0,0,,它不是拉丁语，它的设计不是很好，但你只需处理它
Dialogue: 0,1:13:12.74,1:13:19.22,English,,0,0,0,,So that's your beginning to machine level programming.Thanks a lot
Dialogue: 0,1:13:12.74,1:13:19.22,Chinese,,0,0,0,,这就是你开始进行机器级编程的开始。谢谢你们
