[Script Info]
; Script generated by Aegisub r8942
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: csapp/Lecture 14  Exceptional Control Flow  Exceptions and Processes.mp4
Video File: csapp/Lecture 14  Exceptional Control Flow  Exceptions and Processes.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.843750
Scroll Position: 1568
Active Line: 1584
Video Position: 128997

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Noto Sans CJK SC Black,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,1.5,1.2,2,10,10,10,1
Style: Chinese,Noto Sans CJK SC Black,40,&H00FFFF00,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.2,1.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:01.96,English,,0,0,0,,All right good afternoon everybody
Dialogue: 0,0:00:00.00,0:00:01.96,Chinese,,0,0,0,,各位同学，下午好
Dialogue: 0,0:00:03.44,0:00:04.66,English,,0,0,0,,Welcome to see you
Dialogue: 0,0:00:03.44,0:00:04.66,Chinese,,0,0,0,,很高兴见到你们
Dialogue: 0,0:00:06.62,0:00:13.46,English,,0,0,0,,So today we're going to look at an idea called exceptional control flow
Dialogue: 0,0:00:06.62,0:00:13.46,Chinese,,0,0,0,,今天我们要介绍「异常控制流」
Dialogue: 0,0:00:14.22,0:00:18.56,English,,0,0,0,,That's a very important part of making modern systems
Dialogue: 0,0:00:14.22,0:00:18.56,Chinese,,0,0,0,,它是现代系统非常重要的一个组成部分
Dialogue: 0,0:00:19.18,0:00:26.32,English,,0,0,0,,And it exists at all levels of the system from the lowest level hardware,all the way up to software
Dialogue: 0,0:00:19.18,0:00:26.32,Chinese,,0,0,0,,它存在于操作系统的各个层次，从最底层的硬件，直到软件
Dialogue: 0,0:00:30.62,0:00:38.22,English,,0,0,0,,So the idea is when you turn on a computer (from the very) from the very first time you turn it on
Dialogue: 0,0:00:30.62,0:00:38.22,Chinese,,0,0,0,,当你从第一次打开计算机时，
Dialogue: 0,0:00:38.92,0:00:43.16,English,,0,0,0,,On it just does execute one instruction after another until that you turn it off
Dialogue: 0,0:00:38.92,0:00:43.16,Chinese,,0,0,0,,它只是执行一个接一个的指令，直到你关闭计算机
Dialogue: 0,0:00:43.96,0:00:50.08,English,,0,0,0,,Okay and if each core if you have multiple cores then each of those cores are executing instructions one after the other
Dialogue: 0,0:00:43.96,0:00:50.08,Chinese,,0,0,0,,如果你的计算机有多个 cpu 核心，那么每个核心会依次交替 执行指令
Dialogue: 0,0:00:51.52,0:00:56.20,English,,0,0,0,,Now the sequence of instructions is called the control flow
Dialogue: 0,0:00:51.52,0:00:56.20,Chinese,,0,0,0,,指令序列称为「控制流」
Dialogue: 0,0:00:57.04,0:01:03.62,English,,0,0,0,,Okay and the actual sequence of instructions that the hardware is executing is called the physical control flow
Dialogue: 0,0:00:57.04,0:01:03.62,Chinese,,0,0,0,,硬件正在执行的实际指令序列称为「物理控制流」
Dialogue: 0,0:01:04.76,0:01:05.60,English,,0,0,0,,Now normally
Dialogue: 0,0:01:04.76,0:01:05.60,Chinese,,0,0,0,,现在通常
Dialogue: 0,0:01:07.52,0:01:15.18,English,,0,0,0,,Normally,this control flow that executes just one instruction after another just sequentially in memory
Dialogue: 0,0:01:07.52,0:01:15.18,Chinese,,0,0,0,,通常，此控制流在内存中按顺序执行单条指令
Dialogue: 0,0:01:16.12,0:01:21.32,English,,0,0,0,,And we've so far we've seen two mechanisms for altering the control flow
Dialogue: 0,0:01:16.12,0:01:21.32,Chinese,,0,0,0,,目前为止，我们已经学习了两种改变控制流的机制
Dialogue: 0,0:01:21.32,0:01:22.46,English,,0,0,0,,So that it's not
Dialogue: 0,0:01:21.32,0:01:22.46,Chinese,,0,0,0,,事实不是如此，
Dialogue: 0,0:01:22.92,0:01:25.68,English,,0,0,0,,So that we're not executing just the next instruction
Dialogue: 0,0:01:22.92,0:01:25.68,Chinese,,0,0,0,,这样，我们可以不仅仅只是执行下一条指令了
Dialogue: 0,0:01:26.32,0:01:31.32,English,,0,0,0,,So that's branches and jumps and procedure call and return
Dialogue: 0,0:01:26.32,0:01:31.32,Chinese,,0,0,0,,这就是「分支和跳转」以及「过程调用和返回」
Dialogue: 0,0:01:32.76,0:01:37.42,English,,0,0,0,,Okay now jumps and call... branches jumps call and return
Dialogue: 0,0:01:32.76,0:01:37.42,Chinese,,0,0,0,,现在跳转并调用...分支跳转调用然后返回
Dialogue: 0,0:01:38.22,0:01:41.16,English,,0,0,0,,Those are reacting to changes in program state
Dialogue: 0,0:01:38.22,0:01:41.16,Chinese,,0,0,0,,这些都是对程序状态变化的处理
Dialogue: 0,0:01:41.96,0:01:45.70,English,,0,0,0,,So when you do a branch you check the control condition codes
Dialogue: 0,0:01:41.96,0:01:45.70,Chinese,,0,0,0,,当你执行分支时，请检查条件控制代码
Dialogue: 0,0:01:46.18,0:01:50.82,English,,0,0,0,,And then based on some the results of that comparison then you do the branch
Dialogue: 0,0:01:46.18,0:01:50.82,Chinese,,0,0,0,,基于该比较的一些结果，然后你做相应的分支处理
Dialogue: 0,0:01:52.28,0:01:57.48,English,,0,0,0,,Okay but its real system needs to be able to adapt to changes in the system state
Dialogue: 0,0:01:52.28,0:01:57.48,Chinese,,0,0,0,,但真正的操作系统需要能够处理系统级的变化
Dialogue: 0,0:01:59.36,0:02:01.86,English,,0,0,0,,Okay so for example data arrives from a disk
Dialogue: 0,0:01:59.36,0:02:01.86,Chinese,,0,0,0,,例如数据从磁盘到达
Dialogue: 0,0:02:04.56,0:02:10.10,English,,0,0,0,,Or some network use types Ctrl-C
Dialogue: 0,0:02:04.56,0:02:10.10,Chinese,,0,0,0,,或者某些网络通信遇到 Ctrl-C 类型中断
Dialogue: 0,0:02:10.92,0:02:13.90,English,,0,0,0,,Okay the program executes an illegal instruction
Dialogue: 0,0:02:10.92,0:02:13.90,Chinese,,0,0,0,,还有，程序执行了非法指令
Dialogue: 0,0:02:14.30,0:02:20.60,English,,0,0,0,,Okay all of these represent some change, some kind of change in the system state
Dialogue: 0,0:02:14.30,0:02:20.60,Chinese,,0,0,0,,所有这些代表了系统级的某种变化
Dialogue: 0,0:02:21.18,0:02:23.82,English,,0,0,0,,And we need some way to react to that
Dialogue: 0,0:02:21.18,0:02:23.82,Chinese,,0,0,0,,于是，我们需要一些方法来对此做出反应
Dialogue: 0,0:02:24.90,0:02:25.42,English,,0,0,0,,So this...
Dialogue: 0,0:02:24.90,0:02:25.42,Chinese,,0,0,0,,这...
Dialogue: 0,0:02:26.90,0:02:29.60,English,,0,0,0,,So what we need is we call this exceptional control flow
Dialogue: 0,0:02:26.90,0:02:29.60,Chinese,,0,0,0,,我们需要的是称之为「异常控制流」的机制
Dialogue: 0,0:02:30.04,0:02:34.20,English,,0,0,0,,Because it's sort of outside of the normal control flow that we see in our programs
Dialogue: 0,0:02:30.04,0:02:34.20,Chinese,,0,0,0,,因为它不同与在我们的程序中看到的正常控制序列
Dialogue: 0,0:02:36.20,0:02:41.22,English,,0,0,0,,Now exceptional control flow(ECF) exists at all levels in the system
Dialogue: 0,0:02:36.20,0:02:41.22,Chinese,,0,0,0,,系统中的所有级别都存在「异常控制流（ECF）」
Dialogue: 0,0:02:42.66,0:02:45.18,English,,0,0,0,,From the very lowest level of hardware
Dialogue: 0,0:02:42.66,0:02:45.18,Chinese,,0,0,0,,从最底层的硬件
Dialogue: 0,0:02:48.64,0:02:51.52,English,,0,0,0,,At the very lowest level we have what are called exceptions
Dialogue: 0,0:02:48.64,0:02:51.52,Chinese,,0,0,0,,在最底层，我们有所谓的「异常」
Dialogue: 0,0:02:52.26,0:02:58.16,English,,0,0,0,,And these are changes in the control flow in response to some low level system event
Dialogue: 0,0:02:52.26,0:02:58.16,Chinese,,0,0,0,,响应某些来自底层系统事件的控制流的变化
Dialogue: 0,0:02:59.32,0:03:04.18,English,,0,0,0,,So this is a...or and by event we mean a change in the state
Dialogue: 0,0:02:59.32,0:03:04.18,Chinese,,0,0,0,,这是...或者我们指的是事件引起状态的变化
Dialogue: 0,0:03:05.24,0:03:11.38,English,,0,0,0,,Now exceptions are implemented using a combination of hardware and OS software which we'll see in it in a minute
Dialogue: 0,0:03:05.24,0:03:11.38,Chinese,,0,0,0,,使用硬件和操作系统软件的组合实现异常，等一会儿我们将会看到
Dialogue: 0,0:03:12.08,0:03:16.58,English,,0,0,0,,But these exceptional control flow exists at higher levels too
Dialogue: 0,0:03:12.08,0:03:16.58,Chinese,,0,0,0,,但这些异常控制流也存在于更高的层次
Dialogue: 0,0:03:17.44,0:03:23.08,English,,0,0,0,,So in the a process context switch is an example of exceptional control flow
Dialogue: 0,0:03:17.44,0:03:23.08,Chinese,,0,0,0,,在一个进程中，「上下文切换」就是是一个异常控制流的典型示例
Dialogue: 0,0:03:23.66,0:03:28.58,English,,0,0,0,,That's also it's implemented by a hardware and the operating system kernel
Dialogue: 0,0:03:23.66,0:03:28.58,Chinese,,0,0,0,,这也是由硬件和操作系统内核共同实现的
Dialogue: 0,0:03:29.42,0:03:34.94,English,,0,0,0,,And it so a process context switches we'll see later later today
Dialogue: 0,0:03:29.42,0:03:34.94,Chinese,,0,0,0,,这样一个进程上下文切换，我们将在待会晚些时候看到
Dialogue: 0,0:03:35.62,0:03:40.66,English,,0,0,0,,You're executing your code in the current in your current process
Dialogue: 0,0:03:35.62,0:03:40.66,Chinese,,0,0,0,,你正在当前进程中执行当前代码
Dialogue: 0,0:03:42.32,0:03:47.82,English,,0,0,0,,And then all of a sudden this the system is executing code from another process
Dialogue: 0,0:03:42.32,0:03:47.82,Chinese,,0,0,0,,随即，系统执行另一个进程的代码
Dialogue: 0,0:03:48.14,0:03:50.38,English,,0,0,0,,Right so your process gets like suspended
Dialogue: 0,0:03:48.14,0:03:50.38,Chinese,,0,0,0,,是的，你的进程就应该处于「挂起」状态
Dialogue: 0,0:03:51.34,0:03:55.74,English,,0,0,0,,And so there's a...so that's a form of exceptional control flow
Dialogue: 0,0:03:51.34,0:03:55.74,Chinese,,0,0,0,,有一个...这是一种异常控制流
Dialogue: 0,0:03:55.74,0:04:01.82,English,,0,0,0,,Where you're executing statements instructions within one process
Dialogue: 0,0:03:55.74,0:04:01.82,Chinese,,0,0,0,,你在一个进程中执行语句指令
Dialogue: 0,0:04:01.82,0:04:06.54,English,,0,0,0,,And then all of a sudden you're executing statements instructions in another process
Dialogue: 0,0:04:01.82,0:04:06.54,Chinese,,0,0,0,,然后你突然在另一个进程中执行语句指令
Dialogue: 0,0:04:08.56,0:04:11.22,English,,0,0,0,,At a higher level are totally in software
Dialogue: 0,0:04:08.56,0:04:11.22,Chinese,,0,0,0,,在更高的层次上就是在软件层次了
Dialogue: 0,0:04:11.60,0:04:13.18,English,,0,0,0,,We have the idea of a signal
Dialogue: 0,0:04:11.60,0:04:13.18,Chinese,,0,0,0,,我们介绍一下「信号」的定义
Dialogue: 0,0:04:13.82,0:04:19.40,English,,0,0,0,,And this is implemented by operating system software and we'll learn all about signals next lecture
Dialogue: 0,0:04:13.82,0:04:19.40,Chinese,,0,0,0,,这是通过操作系统软件实现的，我们将在下一讲中学习所有关于信号的知识
Dialogue: 0,0:04:20.60,0:04:25.08,English,,0,0,0,,And then even higher,at an even higher level you have nonlocal jumps in C
Dialogue: 0,0:04:20.60,0:04:25.08,Chinese,,0,0,0,,然后甚至更高，在更高的水平，你有 C 的「非本地跳转」
Dialogue: 0,0:04:25.60,0:04:28.26,English,,0,0,0,,Which are just implemented by the C run time library
Dialogue: 0,0:04:25.60,0:04:28.26,Chinese,,0,0,0,,这些只是由 C 运行库实现的
Dialogue: 0,0:04:28.76,0:04:33.68,English,,0,0,0,,So this allows you nonlocal jumps allow you to break the normal call and return pattern
Dialogue: 0,0:04:28.76,0:04:33.68,Chinese,,0,0,0,,这允许你非本地跳转，允许你违背正常的调用和返回模式
Dialogue: 0,0:04:33.68,0:04:34.54,English,,0,0,0,,So from one...
Dialogue: 0,0:04:33.68,0:04:34.54,Chinese,,0,0,0,,从一个......
Dialogue: 0,0:04:35.18,0:04:40.82,English,,0,0,0,,So from within a function normally you can only return to the function that calls that called you
Dialogue: 0,0:04:35.18,0:04:40.82,Chinese,,0,0,0,,在一个函数中，通常你只能返回到那个调用你的函数
Dialogue: 0,0:04:41.46,0:04:50.12,English,,0,0,0,,Nonlocal jumps allow you to within a function break that and return to some other function or some other part of the code
Dialogue: 0,0:04:41.46,0:04:50.12,Chinese,,0,0,0,,非本地跳转允许你在函数中断，并返回跳转到其他的函数或代码
Dialogue: 0,0:04:51.16,0:04:54.38,English,,0,0,0,,So we'll look at signals and nonlocal jumps next lecture
Dialogue: 0,0:04:51.16,0:04:54.38,Chinese,,0,0,0,,我们将在下一章讲述信号和非本地跳跃
Dialogue: 0,0:04:54.84,0:04:57.62,English,,0,0,0,,Today we're going to look at exceptions and processes
Dialogue: 0,0:04:54.84,0:04:57.62,Chinese,,0,0,0,,今天我们将看看「异常」和「进程」
Dialogue: 0,0:05:00.12,0:05:07.08,English,,0,0,0,,So an exception is a transfer of control to the operating systems kernel
Dialogue: 0,0:05:00.12,0:05:07.08,Chinese,,0,0,0,,异常是将控制权转移到操作系统内核
Dialogue: 0,0:05:07.70,0:05:13.32,English,,0,0,0,,Where the kernel is the memory resident part of the operating system you know
Dialogue: 0,0:05:07.70,0:05:13.32,Chinese,,0,0,0,,你知道的，操作系统在内存中驻留的部分称之为「内核」
Dialogue: 0,0:05:13.34,0:05:23.86,English,,0,0,0,,So an operating system provides all kinds of programs like to list files,to change directories,to list the current processes
Dialogue: 0,0:05:13.34,0:05:23.86,Chinese,,0,0,0,,操作系统提供各种程序，如列出文件，更改目录，列出当前进程
Dialogue: 0,0:05:24.48,0:05:27.68,English,,0,0,0,,So all of that stuff constitutes the operating system
Dialogue: 0,0:05:24.48,0:05:27.68,Chinese,,0,0,0,,所有这些构成了操作系统
Dialogue: 0,0:05:27.68,0:05:33.20,English,,0,0,0,,The kernel is the part of the operating system that's always resident in memory
Dialogue: 0,0:05:27.68,0:05:33.20,Chinese,,0,0,0,,内核是操作系统中始终驻留在内存中的一部分
Dialogue: 0,0:05:34.98,0:05:40.64,English,,0,0,0,,So an exception is really low-level transfer of control to the operating system
Dialogue: 0,0:05:34.98,0:05:40.64,Chinese,,0,0,0,,异常实际上是低级别的转移,将控制权转移到操作系统
Dialogue: 0,0:05:40.64,0:05:42.66,English,,0,0,0,,Because something happened in the system
Dialogue: 0,0:05:40.64,0:05:42.66,Chinese,,0,0,0,,因为系统中发生了一些情况
Dialogue: 0,0:05:43.48,0:05:46.66,English,,0,0,0,,So you're executing your code,user code
Dialogue: 0,0:05:43.48,0:05:46.66,Chinese,,0,0,0,,而你正在执行代码，用户代码
Dialogue: 0,0:05:47.70,0:05:53.32,English,,0,0,0,,And then something happens some event, so by event we mean there's some change in the system state
Dialogue: 0,0:05:47.70,0:05:53.32,Chinese,,0,0,0,,然后一些情况发生在某些「事件」上，我们称为事件引起了系统状态的变化
Dialogue: 0,0:05:54.96,0:06:04.34,English,,0,0,0,,In response to that there the exception transfers control from your user code to code in the kernel
Dialogue: 0,0:05:54.96,0:06:04.34,Chinese,,0,0,0,,为此，异常将控制权从用户代码转移到内核态中的代码
Dialogue: 0,0:06:04.82,0:06:06.42,English,,0,0,0,,Which is called an exception handler
Dialogue: 0,0:06:04.82,0:06:06.42,Chinese,,0,0,0,,这称为「异常处理程序」
Dialogue: 0,0:06:07.18,0:06:10.58,English,,0,0,0,,And then the kernel responds to that change in some way
Dialogue: 0,0:06:07.18,0:06:10.58,Chinese,,0,0,0,,然后内核以某种方式响应这种变化
Dialogue: 0,0:06:12.72,0:06:14.50,English,,0,0,0,,This is called the exception processing
Dialogue: 0,0:06:12.72,0:06:14.50,Chinese,,0,0,0,,这称为「异常处理」
Dialogue: 0,0:06:15.66,0:06:21.98,English,,0,0,0,,And then there's three things that can happen after the kernel handles the exception
Dialogue: 0,0:06:15.66,0:06:21.98,Chinese,,0,0,0,,在内核处理异常后可能会发生三种情况
Dialogue: 0,0:06:22.74,0:06:25.92,English,,0,0,0,,It can return and reexecute that the current instruction
Dialogue: 0,0:06:22.74,0:06:25.92,Chinese,,0,0,0,,第一种，它返回并重新执行当前指令
Dialogue: 0,0:06:27.86,0:06:33.88,English,,0,0,0,,Okay and we'll see this is useful for things like page faults allows us to implement virtual memory
Dialogue: 0,0:06:27.86,0:06:33.88,Chinese,,0,0,0,,我们会发现这对于「页缺失」很有用，我们用以实现虚拟内存
Dialogue: 0,0:06:35.76,0:06:37.86,English,,0,0,0,,It could return to the next instruction
Dialogue: 0,0:06:35.76,0:06:37.86,Chinese,,0,0,0,,第二种情况，它返回到下一条指令
Dialogue: 0,0:06:39.04,0:06:43.00,English,,0,0,0,,Which I've shown here or it could abort
Dialogue: 0,0:06:39.04,0:06:43.00,Chinese,,0,0,0,,这如在这里展示的。最后一种是「终止」
Dialogue: 0,0:06:46.64,0:06:49.56,English,,0,0,0,,Now exceptions are implemented by hardware and software
Dialogue: 0,0:06:46.64,0:06:49.56,Chinese,,0,0,0,,异常由硬件和软件共同实现
Dialogue: 0,0:06:49.56,0:06:53.30,English,,0,0,0,,So the actual transfer of control
Dialogue: 0,0:06:49.56,0:06:53.30,Chinese,,0,0,0,,实际上控制权的转移
Dialogue: 0,0:06:54.26,0:07:00.16,English,,0,0,0,,You know the change in the program counter or %rip is done by the hardware
Dialogue: 0,0:06:54.26,0:07:00.16,Chinese,,0,0,0,,你知道程序计数器或 %rip 的更改是由硬件完成的
Dialogue: 0,0:07:01.22,0:07:09.80,English,,0,0,0,,But the code that executes as a result of that exception is set up and determined by the operating system kernel
Dialogue: 0,0:07:01.22,0:07:09.80,Chinese,,0,0,0,,但是由于该异常而执行的代码是由操作系统内核设置和确定的
Dialogue: 0,0:07:10.44,0:07:15.26,English,,0,0,0,,So every type of event has a unique exception number
Dialogue: 0,0:07:10.44,0:07:15.26,Chinese,,0,0,0,,每种类型的事件都有一个唯一的「异常编号」
Dialogue: 0,0:07:15.78,0:07:19.48,English,,0,0,0,,Which serves as an index into a jump table called an exception table
Dialogue: 0,0:07:15.78,0:07:19.48,Chinese,,0,0,0,,它用作跳转表的索引，称为「异常表」
Dialogue: 0,0:07:20.66,0:07:24.24,English,,0,0,0,,Okay and so when event k happens
Dialogue: 0,0:07:20.66,0:07:24.24,Chinese,,0,0,0,,当事件 k 发生时
Dialogue: 0,0:07:25.36,0:07:30.42,English,,0,0,0,,Then the hardware looks uses k as in as an index into this table
Dialogue: 0,0:07:25.36,0:07:30.42,Chinese,,0,0,0,,硬件使用 k 作为此表的索引
Dialogue: 0,0:07:30.90,0:07:36.10,English,,0,0,0,,And gets the address of the exception handler for that exception
Dialogue: 0,0:07:30.90,0:07:36.10,Chinese,,0,0,0,,然后得到该异常的处理程序的地址
Dialogue: 0,0:07:38.02,0:07:43.82,English,,0,0,0,,And so every time that event k happens that handler handler k is invoked
Dialogue: 0,0:07:38.02,0:07:43.82,Chinese,,0,0,0,,每次事件 k 发生时，都会调用处理程序 k
Dialogue: 0,0:07:45.36,0:07:52.84,English,,0,0,0,,Now there's a different kinds of exceptions we distinguish them as being asynchronous or synchronous
Dialogue: 0,0:07:45.36,0:07:52.84,Chinese,,0,0,0,,现在有一种关于异常的分类方法，我们依此将它们区分为「异步」或「同步」
Dialogue: 0,0:07:53.46,0:08:03.12,English,,0,0,0,,Asynchronous exceptions happen as a result of changes in state that are occurred outside of the processor
Dialogue: 0,0:07:53.46,0:08:03.12,Chinese,,0,0,0,,异步异常是由于处理器外部发生的状态变化而引起的
Dialogue: 0,0:08:03.92,0:08:06.28,English,,0,0,0,,So these are called interrupts
Dialogue: 0,0:08:03.92,0:08:06.28,Chinese,,0,0,0,,这些被称为「中断」
Dialogue: 0,0:08:07.20,0:08:09.64,English,,0,0,0,,And those changes in state are...
Dialogue: 0,0:08:07.20,0:08:09.64,Chinese,,0,0,0,,那些状态的变化是......
Dialogue: 0,0:08:10.44,0:08:17.06,English,,0,0,0,,The processor is notified about those changes in state by setting a pin on the processor
Dialogue: 0,0:08:10.44,0:08:17.06,Chinese,,0,0,0,,通过在处理器上设置引脚，向处理器通知这些状态变化
Dialogue: 0,0:08:17.06,0:08:20.28,English,,0,0,0,,An external pin called the interrupt pin
Dialogue: 0,0:08:17.06,0:08:20.28,Chinese,,0,0,0,,外部引脚称为中断引脚
Dialogue: 0,0:08:21.37,0:08:28.56,English,,0,0,0,,So this is the kind of when see a disk controller finishes doing a direct memory access
Dialogue: 0,0:08:21.37,0:08:28.56,Chinese,,0,0,0,,这是看到磁盘控制器完成「直接内存访问」的情形
Dialogue: 0,0:08:28.78,0:08:31.62,English,,0,0,0,,And copying data from the disk into memory
Dialogue: 0,0:08:28.78,0:08:31.62,Chinese,,0,0,0,,首先将数据从磁盘复制到内存中
Dialogue: 0,0:08:32.02,0:08:39.72,English,,0,0,0,,It notifies the processor that it's finished that copy by setting the interrupt pin hi okay
Dialogue: 0,0:08:32.02,0:08:39.72,Chinese,,0,0,0,,它通过设置中断引脚来通知处理器它已完成复制
Dialogue: 0,0:08:42.58,0:08:48.38,English,,0,0,0,,And so after an interrupt happens the handler returns to the next instruction
Dialogue: 0,0:08:42.58,0:08:48.38,Chinese,,0,0,0,,在发生中断后，处理程序返回到下一条指令
Dialogue: 0,0:08:48.52,0:08:55.42,English,,0,0,0,,So an interrupt typically it's the so you're running your program,you're running your program and then there's like this little
Dialogue: 0,0:08:48.52,0:08:55.42,Chinese,,0,0,0,,中断通常是因为你正在运行你的程序，然后就像这样，
Dialogue: 0,0:08:57.28,0:09:01.78,English,,0,0,0,,There's like this little pause while the interrupt handler runs and then your program just continues to run okay
Dialogue: 0,0:08:57.28,0:09:01.78,Chinese,,0,0,0,,当中断处理程序运行时，就像这个小暂停，然后你的程序继续运行正常
Dialogue: 0,0:09:02.22,0:09:11.52,English,,0,0,0,,So it's usually sort of done behind the scenes and doesn't affect your execution of your program
Dialogue: 0,0:09:02.22,0:09:11.52,Chinese,,0,0,0,,它通常在后台完成，不会影响你的程序执行
Dialogue: 0,0:09:12.28,0:09:18.74,English,,0,0,0,,Now the most common...a common example of a interrupt is the timer interrupts
Dialogue: 0,0:09:12.28,0:09:18.74,Chinese,,0,0,0,,现在最常见的......中断的一个常见例子是定时器中断
Dialogue: 0,0:09:19.66,0:09:25.44,English,,0,0,0,,So you're all systems have a built-in timer that goes off every few milliseconds
Dialogue: 0,0:09:19.66,0:09:25.44,Chinese,,0,0,0,,所有系统都有一个内置计时器，每隔几毫秒就会关闭一次
Dialogue: 0,0:09:26.36,0:09:29.76,English,,0,0,0,,And when it,when the timer goes off it sets the interrupts pin high
Dialogue: 0,0:09:26.36,0:09:29.76,Chinese,,0,0,0,,当定时器关闭时时，它将中断引脚设置为高电平
Dialogue: 0,0:09:30.38,0:09:34.02,English,,0,0,0,,And there's a special exception number for timer interrupts
Dialogue: 0,0:09:30.38,0:09:34.02,Chinese,,0,0,0,,并且有一个特殊的异常编号用于定时器中断
Dialogue: 0,0:09:34.88,0:09:37.54,English,,0,0,0,,And this is we need this in order for the
Dialogue: 0,0:09:34.88,0:09:37.54,Chinese,,0,0,0,,我们需要这个以便
Dialogue: 0,0:09:37.96,0:09:43.20,English,,0,0,0,,This allows we need this to allow the kernel to get control of the system again
Dialogue: 0,0:09:37.96,0:09:43.20,Chinese,,0,0,0,,我们需要它来允许内核再次获得对系统的控制
Dialogue: 0,0:09:43.20,0:09:47.38,English,,0,0,0,,Otherwise a user program could just run forever in an infinite loop
Dialogue: 0,0:09:43.20,0:09:47.38,Chinese,,0,0,0,,否则，用户程序可能会陷入无限循环中永远运行
Dialogue: 0,0:09:47.74,0:09:52.50,English,,0,0,0,,And no one...there be no way for the operating system to get control
Dialogue: 0,0:09:47.74,0:09:52.50,Chinese,,0,0,0,,无法让操作系统获得控制权
Dialogue: 0,0:09:52.50,0:10:00.40,English,,0,0,0,,So every few milliseconds this timer goes off that causes a transient exception into the kernel
Dialogue: 0,0:09:52.50,0:10:00.40,Chinese,,0,0,0,,此计时器每隔几毫秒就会关闭，从而导致内核发生瞬态异常
Dialogue: 0,0:10:00.86,0:10:05.24,English,,0,0,0,,And then the kernel can...as we see the kernel can decide what to do
Dialogue: 0,0:10:00.86,0:10:05.24,Chinese,,0,0,0,,然后内核可以......正如我们所看到的，内核可以决定做什么
Dialogue: 0,0:10:05.70,0:10:09.48,English,,0,0,0,,Maybe maybe schedule a new process or let the current process run
Dialogue: 0,0:10:05.70,0:10:09.48,Chinese,,0,0,0,,也许可以安排新进程或让当前进程运行
Dialogue: 0,0:10:12.46,0:10:17.64,English,,0,0,0,,And then this an i/o interrupt from an external devices is also a common example
Dialogue: 0,0:10:12.46,0:10:17.64,Chinese,,0,0,0,,然后来自外部设备的这种 i/o 中断也是一个常见的例子
Dialogue: 0,0:10:18.44,0:10:21.22,English,,0,0,0,,Now the other class of exceptions are synchronous exceptions
Dialogue: 0,0:10:18.44,0:10:21.22,Chinese,,0,0,0,,现在另一类异常是「同步异常」
Dialogue: 0,0:10:21.66,0:10:23.32,English,,0,0,0,,And there are three classes of those
Dialogue: 0,0:10:21.66,0:10:23.32,Chinese,,0,0,0,,它有三类
Dialogue: 0,0:10:25.76,0:10:32.54,English,,0,0,0,,One is that,one class is called the trap,a trap is a intentional exception
Dialogue: 0,0:10:25.76,0:10:32.54,Chinese,,0,0,0,,一类称之为「陷阱」，陷阱是故意的异常
Dialogue: 0,0:10:32.54,0:10:35.52,English,,0,0,0,,So this is an exception that's caused intentionally by the program
Dialogue: 0,0:10:32.54,0:10:35.52,Chinese,,0,0,0,,这是由程序故意引起的异常
Dialogue: 0,0:10:36.32,0:10:40.08,English,,0,0,0,,And the most common form of a trap is a system call
Dialogue: 0,0:10:36.32,0:10:40.08,Chinese,,0,0,0,,最常见的陷阱形式是「系统调用」
Dialogue: 0,0:10:41.42,0:10:46.58,English,,0,0,0,,So you know the operating system kernel provides all kinds of services to a program
Dialogue: 0,0:10:41.42,0:10:46.58,Chinese,,0,0,0,,你知道操作系统内核为程序提供各种服务
Dialogue: 0,0:10:46.58,0:10:48.62,English,,0,0,0,,But your program doesn't have direct access
Dialogue: 0,0:10:46.58,0:10:48.62,Chinese,,0,0,0,,但是你的程序没有直接访问权限
Dialogue: 0,0:10:49.86,0:10:54.25,English,,0,0,0,,Your program can't call functions in the kernel,can't access data directly in the kernel
Dialogue: 0,0:10:49.86,0:10:54.25,Chinese,,0,0,0,,你的程序无法在内核中调用函数，无法直接在内核中访问数据
Dialogue: 0,0:10:54.54,0:10:58.68,English,,0,0,0,,Because that memory is protected and unavailable to user programs
Dialogue: 0,0:10:54.54,0:10:58.68,Chinese,,0,0,0,,因为该内存区域受到保护，且对用户程序不可用
Dialogue: 0,0:10:59.66,0:11:08.42,English,,0,0,0,,So what the kernel does is they provide a interface that allows programs to make requests to effectively
Dialogue: 0,0:10:59.66,0:11:08.42,Chinese,,0,0,0,,内核所做的是提供一个响应程序请求的接口
Dialogue: 0,0:11:08.92,0:11:12.80,English,,0,0,0,,Call functions within the kernel and to make requests for various services
Dialogue: 0,0:11:08.92,0:11:12.80,Chinese,,0,0,0,,调用内核中的函数并发出对各种服务的请求
Dialogue: 0,0:11:13.32,0:11:15.82,English,,0,0,0,,And this interface is called a system call
Dialogue: 0,0:11:13.32,0:11:15.82,Chinese,,0,0,0,,此接口称为「系统调用」
Dialogue: 0,0:11:17.28,0:11:19.24,English,,0,0,0,,Ok so a program makes a system call
Dialogue: 0,0:11:17.28,0:11:19.24,Chinese,,0,0,0,,程序进行系统调用
Dialogue: 0,0:11:20.16,0:11:25.60,English,,0,0,0,,And requests various functions from the kernel
Dialogue: 0,0:11:20.16,0:11:25.60,Chinese,,0,0,0,,并从内核请求各种功能
Dialogue: 0,0:11:26.02,0:11:30.30,English,,0,0,0,,The kernel provides those sort of reacts to that request
Dialogue: 0,0:11:26.02,0:11:30.30,Chinese,,0,0,0,,内核为该请求提供了对应的响应
Dialogue: 0,0:11:30.30,0:11:34.62,English,,0,0,0,,And then returns control back to the the function there the calling program
Dialogue: 0,0:11:30.30,0:11:34.62,Chinese,,0,0,0,,然后将控制权返回给调用程序的函数
Dialogue: 0,0:11:35.24,0:11:38.70,English,,0,0,0,,So you can think of a system call as kind of it's a...
Dialogue: 0,0:11:35.24,0:11:38.70,Chinese,,0,0,0,,你可以把系统调用想象成一种......
Dialogue: 0,0:11:39.56,0:11:43.88,English,,0,0,0,,It looks like a function call but it's really transferring control into the kernel
Dialogue: 0,0:11:39.56,0:11:43.88,Chinese,,0,0,0,,它看起来像一个函数调用，但它却是将控制权转移到内核中
Dialogue: 0,0:11:47.42,0:11:54.26,English,,0,0,0,,Okay then there's some so traps are intentional faults are unintentional but may be recoverable
Dialogue: 0,0:11:47.42,0:11:54.26,Chinese,,0,0,0,,有一些陷阱是故意的，而「故障」是无意的，但可能是可以恢复的
Dialogue: 0,0:11:54.72,0:11:59.86,English,,0,0,0,,Okay so things like page faults which
Dialogue: 0,0:11:54.72,0:11:59.86,Chinese,,0,0,0,,就像「页缺失」一样
Dialogue: 0,0:12:01.50,0:12:04.64,English,,0,0,0,,When we will learn more about these when we study virtual memory
Dialogue: 0,0:12:01.50,0:12:04.64,Chinese,,0,0,0,,当我们研究虚拟内存时，我们将更多地了解这些内容
Dialogue: 0,0:12:04.64,0:12:08.88,English,,0,0,0,,But something like a page fault it's actually recoverable
Dialogue: 0,0:12:04.64,0:12:08.88,Chinese,,0,0,0,,但是像页缺失这样的东西，实际上是可以恢复的
Dialogue: 0,0:12:08.88,0:12:16.70,English,,0,0,0,,It just that the kernel has to it means that the the data the portion of the address space that your program referenced isn't actually in memory
Dialogue: 0,0:12:08.88,0:12:16.70,Chinese,,0,0,0,,它只是意味着程序引用的一部分地址空间、数据部分实际上不在内存或者内核当中
Dialogue: 0,0:12:17.92,0:12:21.80,English,,0,0,0,,It needs to be copied from disk where it's stored into memory
Dialogue: 0,0:12:17.92,0:12:21.80,Chinese,,0,0,0,,它需要从磁盘复制到它应该存储在内存中的地址上
Dialogue: 0,0:12:22.28,0:12:27.42,English,,0,0,0,,And then the instruction that that caused a fault needs is just restarted and then it works
Dialogue: 0,0:12:22.28,0:12:27.42,Chinese,,0,0,0,,接着，重新启动导致故障所需的指令，然后它就能正常工作
Dialogue: 0,0:12:28.50,0:12:33.58,English,,0,0,0,,That the memory is there and then the instruction works properly
Dialogue: 0,0:12:28.50,0:12:33.58,Chinese,,0,0,0,,内存在那里，然后指令正常工作
Dialogue: 0,0:12:33.88,0:12:38.70,English,,0,0,0,,But other faults are unrecoverable like protection fault
Dialogue: 0,0:12:33.88,0:12:38.70,Chinese,,0,0,0,,但其他故障是不可恢复的，如保护故障
Dialogue: 0,0:12:38.70,0:12:43.78,English,,0,0,0,,So if you try to access a portion of memory that's not allocated
Dialogue: 0,0:12:38.70,0:12:43.78,Chinese,,0,0,0,,如果你尝试访问未分配的内存部分
Dialogue: 0,0:12:44.14,0:12:49.96,English,,0,0,0,,Or floating-point exceptions often times those can be recoverable
Dialogue: 0,0:12:44.14,0:12:49.96,Chinese,,0,0,0,,或者通常是可以恢复的异常：浮点数异常
Dialogue: 0,0:12:51.84,0:12:59.16,English,,0,0,0,,So in either case when there's a fault it either re-execute the current instruction or the aborts
Dialogue: 0,0:12:51.84,0:12:59.16,Chinese,,0,0,0,,在任何一种情况下，当出现故障时，要么重新执行当前指令，要么「终止」
Dialogue: 0,0:13:00.82,0:13:08.26,English,,0,0,0,,And then there's unintentional and unrecoverable exceptions which are called the aborts and those those always abort
Dialogue: 0,0:13:00.82,0:13:08.26,Chinese,,0,0,0,,然后是无意和不可恢复的异常，称为「终止」,即那些总是终止的异常
Dialogue: 0,0:13:08.80,0:13:14.74,English,,0,0,0,,So if you execute an illegal instruction,if there's a problem with your memory,memory and it's it's corrupted
Dialogue: 0,0:13:08.80,0:13:14.74,Chinese,,0,0,0,,如果你执行非法指令，如果你的内存存在问题，那么它就会被破坏
Dialogue: 0,0:13:15.86,0:13:21.36,English,,0,0,0,,There's some problem with the machine those creative aborts that always...
Dialogue: 0,0:13:15.86,0:13:21.36,Chinese,,0,0,0,,机器存在一些问题，就总会是终止......
Dialogue: 0,0:13:22.34,0:13:26.92,English,,0,0,0,,That are unrecoverable and never return back to the program
Dialogue: 0,0:13:22.34,0:13:26.92,Chinese,,0,0,0,,这是不可恢复的，永远不会回到该程序
Dialogue: 0,0:13:28.68,0:13:30.40,English,,0,0,0,,Now system calls there's...
Dialogue: 0,0:13:28.68,0:13:30.40,Chinese,,0,0,0,,「系统调用」
Dialogue: 0,0:13:32.02,0:13:35.28,English,,0,0,0,,Many different kinds of system calls and they all have their own unique number
Dialogue: 0,0:13:32.02,0:13:35.28,Chinese,,0,0,0,,许多不同类型的系统调用都有自己唯一的编号
Dialogue: 0,0:13:35.76,0:13:38.16,English,,0,0,0,,Which is assigned by Linux
Dialogue: 0,0:13:35.76,0:13:38.16,Chinese,,0,0,0,,这是由 Linux 分配的
Dialogue: 0,0:13:39.84,0:13:46.38,English,,0,0,0,,So for example to read a file,there's a system call called read
Dialogue: 0,0:13:39.84,0:13:46.38,Chinese,,0,0,0,,例如，为了读取文件，有一个名为 read 的系统调用
Dialogue: 0,0:13:46.38,0:13:53.40,English,,0,0,0,,Which is number 0, opening a file, a system call number 2 and so on
Dialogue: 0,0:13:46.38,0:13:53.40,Chinese,,0,0,0,,这是编号0，打开文件，系统调用编码 2 等等
Dialogue: 0,0:13:56.14,0:14:01.58,English,,0,0,0,,And there's an instruction called syscall
Dialogue: 0,0:13:56.14,0:14:01.58,Chinese,,0,0,0,,还有一个名为 syscall 的指令
Dialogue: 0,0:14:01.58,0:14:06.34,English,,0,0,0,,Which actually performs the system call
Dialogue: 0,0:14:01.58,0:14:06.34,Chinese,,0,0,0,,实际执行系统调用
Dialogue: 0,0:14:07.04,0:14:12.44,English,,0,0,0,,Now you usually don't use this system call and strike the syscall instruction directly in your program the
Dialogue: 0,0:14:07.04,0:14:12.44,Chinese,,0,0,0,,你通常不需要在你自己的程序中直接使用系统调用，并触发 syscall 指令
Dialogue: 0,0:14:12.96,0:14:17.98,English,,0,0,0,,Linux wraps those in system level functions which actually call it for you
Dialogue: 0,0:14:12.96,0:14:17.98,Chinese,,0,0,0,,Linux 将这些函数包装在系统级函数中，这些函数实际上会为你调用的
Dialogue: 0,0:14:18.74,0:14:22.28,English,,0,0,0,,But it's interesting in C how it actually works
Dialogue: 0,0:14:18.74,0:14:22.28,Chinese,,0,0,0,,但它在 C 中的实际工作方式很有意思
Dialogue: 0,0:14:22.28,0:14:27.58,English,,0,0,0,,So opposed you want to open a file you call the system level function called open
Dialogue: 0,0:14:22.28,0:14:27.58,Chinese,,0,0,0,,假设你想打开一个文件，你调用称为 open 的系统级函数
Dialogue: 0,0:14:28.46,0:14:32.10,English,,0,0,0,,With a file name and some options say read only write only
Dialogue: 0,0:14:28.46,0:14:32.10,Chinese,,0,0,0,,使用文件名和一些选项指定为：只读写
Dialogue: 0,0:14:36.10,0:14:42.66,English,,0,0,0,,And so in at the syscall instruction takes the first the syscall number is %rax
Dialogue: 0,0:14:36.10,0:14:42.66,Chinese,,0,0,0,,在 syscall 指令中，第一个系统调用编号是 %rax
Dialogue: 0,0:14:44.12,0:14:50.60,English,,0,0,0,,And then other arguments are %rdi,%rsi,%rdx, %r10, %r9, %r8
Dialogue: 0,0:14:44.12,0:14:50.60,Chinese,,0,0,0,,然后其他参数是 ％rdi，％rsi，％rdx，％r10，％r9，％r8
Dialogue: 0,0:14:51.36,0:14:57.72,English,,0,0,0,,So you can see if we look in the the open function calls the __open function which actually invokes
Dialogue: 0,0:14:51.36,0:14:57.72,Chinese,,0,0,0,,你可以看看，我们是否在open函数中调用了 __open 函数
Dialogue: 0,0:14:58.22,0:15:02.04,English,,0,0,0,,The syscall so if you look at that code you see it moves the 0x2
Dialogue: 0,0:14:58.22,0:15:02.04,Chinese,,0,0,0,,系统调用，如果你查看该代码，你会看到它移动 $0x2
Dialogue: 0,0:15:02.04,0:15:07.52,English,,0,0,0,,which is the syscall number for read into %eax and then it does the syscall
Dialogue: 0,0:15:02.04,0:15:07.52,Chinese,,0,0,0,,这是读入 ％eax 的系统调用号，然后是系统调用
Dialogue: 0,0:15:09.72,0:15:15.54,English,,0,0,0,,And then the the syscall returns its status in %rax
Dialogue: 0,0:15:09.72,0:15:15.54,Chinese,,0,0,0,,系统调用在 ％rax 中返回其状态
Dialogue: 0,0:15:16.30,0:15:19.80,English,,0,0,0,,If it's a negative number then that means something some error occurred
Dialogue: 0,0:15:16.30,0:15:19.80,Chinese,,0,0,0,,如果它是负数，那么这意味着发生了一些错误 
Dialogue: 0,0:15:20.76,0:15:25.40,English,,0,0,0,,If it's a positive number then that means something that no error occurred
Dialogue: 0,0:15:20.76,0:15:25.40,Chinese,,0,0,0,,如果它是正数，那么这意味着没有发生错误
Dialogue: 0,0:15:26.32,0:15:30.42,English,,0,0,0,,So in this case and in the open it's returning a file descriptor
Dialogue: 0,0:15:26.32,0:15:30.42,Chinese,,0,0,0,,在这种情况下，在 open 中它返回一个「文件描述符」
Dialogue: 0,0:15:30.42,0:15:36.74,English,,0,0,0,,A small integer called the file descriptor which then you can use in subsequent calls to read and write
Dialogue: 0,0:15:30.42,0:15:36.74,Chinese,,0,0,0,,一个称为文件描述符的小整数，然后可以在后续的读写调用中使用
Dialogue: 0,0:15:37.34,0:15:40.64,English,,0,0,0,,And then you can see the code is checking for this negative return value
Dialogue: 0,0:15:37.34,0:15:40.64,Chinese,,0,0,0,,然后你可以看到代码正在检查负的返回值
Dialogue: 0,0:15:40.96,0:15:43.26,English,,0,0,0,,And there's a whole series of these compares
Dialogue: 0,0:15:40.96,0:15:43.26,Chinese,,0,0,0,,还有一系列的比较
Dialogue: 0,0:15:50.18,0:15:53.36,English,,0,0,0,,So let's look at an example of a fault
Dialogue: 0,0:15:50.18,0:15:53.36,Chinese,,0,0,0,,那么让我们看一个故障的例子
Dialogue: 0,0:15:54.28,0:16:00.54,English,,0,0,0,,So here suppose we have this program that we're writing into a valid region of memory
Dialogue: 0,0:15:54.28,0:16:00.54,Chinese,,0,0,0,,这里假设我们有个程序，我们写入一个有效的内存区域
Dialogue: 0,0:16:00.54,0:16:07.70,English,,0,0,0,,But it's not actually stored on...it's not actually in the memory,it needs to be loaded from disk into into memory
Dialogue: 0,0:16:00.54,0:16:07.70,Chinese,,0,0,0,,但它实际上并没有存储在内存中，而是需要从磁盘加载到内存中
Dialogue: 0,0:16:07.70,0:16:10.88,English,,0,0,0,,So this is a...so called page fault
Dialogue: 0,0:16:07.70,0:16:10.88,Chinese,,0,0,0,,这是......所谓的页缺失
Dialogue: 0,0:16:12.52,0:16:14.82,English,,0,0,0,,So this instruction this movl
Dialogue: 0,0:16:12.52,0:16:14.82,Chinese,,0,0,0,,这个指令这个 movl
Dialogue: 0,0:16:15.40,0:16:22.82,English,,0,0,0,,Because this because the memory at this address isn't available triggers a page fault
Dialogue: 0,0:16:15.40,0:16:22.82,Chinese,,0,0,0,,因为这为此地址的内存不可用，会触发页缺失
Dialogue: 0,0:16:24.60,0:16:30.92,English,,0,0,0,,So that creates an exception a transfer of control into the the page fault handler in the kernel
Dialogue: 0,0:16:24.60,0:16:30.92,Chinese,,0,0,0,,这样就创建了一个异常，即将控制权转移到内核中的页缺失处理程序中
Dialogue: 0,0:16:31.64,0:16:34.32,English,,0,0,0,,Which copies that page from disk to memory
Dialogue: 0,0:16:31.64,0:16:34.32,Chinese,,0,0,0,,决定哪个页从磁盘复制到内存
Dialogue: 0,0:16:36.24,0:16:40.98,English,,0,0,0,,And then it returns and when it returns it reacts acutes the movl instruction
Dialogue: 0,0:16:36.24,0:16:40.98,Chinese,,0,0,0,,然后它返回，当它返回时，它会对 movl 指令产生反应
Dialogue: 0,0:16:41.52,0:16:42.24,English,,0,0,0,,So that's kind of cool
Dialogue: 0,0:16:41.52,0:16:42.24,Chinese,,0,0,0,,这很酷
Dialogue: 0,0:16:42.24,0:16:44.88,English,,0,0,0,,So now the memory is available
Dialogue: 0,0:16:42.24,0:16:44.88,Chinese,,0,0,0,,现在可以使用内存了
Dialogue: 0,0:16:45.58,0:16:52.02,English,,0,0,0,,And now that the movl this movl instruction when it's reacts acute completes
Dialogue: 0,0:16:45.58,0:16:52.02,Chinese,,0,0,0,,当它的响应快速完成时，执行这个 movl 指令
Dialogue: 0,0:16:53.66,0:16:54.68,English,,0,0,0,,And then we continue
Dialogue: 0,0:16:53.66,0:16:54.68,Chinese,,0,0,0,,我们继续
Dialogue: 0,0:16:55.66,0:16:58.80,English,,0,0,0,,Now another type of fault is an invalid memory reference
Dialogue: 0,0:16:55.66,0:16:58.80,Chinese,,0,0,0,,现在另一种类型的故障是无效的内存引用
Dialogue: 0,0:16:58.80,0:17:02.46,English,,0,0,0,,So here we have a...we're accessing an element of a
Dialogue: 0,0:16:58.80,0:17:02.46,Chinese,,0,0,0,,我们在这里......我们正在访问一个数组元素
Dialogue: 0,0:17:03.24,0:17:07.74,English,,0,0,0,,Which doesn't exist and it's an illegal,it's an invalid reference
Dialogue: 0,0:17:03.24,0:17:07.74,Chinese,,0,0,0,,这是不存在而且是非法的，这是一个无效的引用
Dialogue: 0,0:17:09.22,0:17:12.16,English,,0,0,0,,So in this case the movl instruction
Dialogue: 0,0:17:09.22,0:17:12.16,Chinese,,0,0,0,,在这种情况下是 movl 指令
Dialogue: 0,0:17:12.90,0:17:15.36,English,,0,0,0,,It looks like a...it looks like a page fault
Dialogue: 0,0:17:12.90,0:17:15.36,Chinese,,0,0,0,,它看起来像......它看起来像一个页缺失
Dialogue: 0,0:17:16.72,0:17:21.74,English,,0,0,0,,But the kernel detects that it's an invalid address that there isn't anything that can be loaded from disk
Dialogue: 0,0:17:16.72,0:17:21.74,Chinese,,0,0,0,,但内核检测到它是一个无效的地址，没有任何东西可以从磁盘加载
Dialogue: 0,0:17:21.74,0:17:25.70,English,,0,0,0,,This is an invalid region of the the virtual address space
Dialogue: 0,0:17:21.74,0:17:25.70,Chinese,,0,0,0,,这是虚拟地址空间的无效区域
Dialogue: 0,0:17:27.38,0:17:34.24,English,,0,0,0,,So it sends a signal to the to the process and then never returns
Dialogue: 0,0:17:27.38,0:17:34.24,Chinese,,0,0,0,,它向进程发送信号，然后永远不会返回
Dialogue: 0,0:17:35.96,0:17:40.06,English,,0,0,0,,So the signal that sends is the SIGSEGV
Dialogue: 0,0:17:35.96,0:17:40.06,Chinese,,0,0,0,,发送的信号是 SIGSEGV
Dialogue: 0,0:17:40.06,0:17:46.90,English,,0,0,0,,The signal that causes the SIGSEGV fault message to print out
Dialogue: 0,0:17:40.06,0:17:46.90,Chinese,,0,0,0,,信号导致 SIGSEGV 错误 并打印相关错误信息
Dialogue: 0,0:17:47.94,0:17:52.28,English,,0,0,0,,And we'll see you next lecture,we'll see how these signals actually work
Dialogue: 0,0:17:47.94,0:17:52.28,Chinese,,0,0,0,,我们将在下一次课中看到，这些信号具体是如何工作的
Dialogue: 0,0:17:56.26,0:18:01.88,English,,0,0,0,,Okay so I said we've seen exceptions or very low-level transfers of control
Dialogue: 0,0:17:56.26,0:18:01.88,Chinese,,0,0,0,,我们已经看到异常，非常低层的控制转移
Dialogue: 0,0:18:02.36,0:18:06.58,English,,0,0,0,,That are implemented by both hardware and the operating system software...it could sue
Dialogue: 0,0:18:02.36,0:18:06.58,Chinese,,0,0,0,,这是由硬件和操作系统软件实现的...
Dialogue: 0,0:18:08.58,0:18:12.84,English,,0,0,0,,At the higher level is another form of exceptional control flow called
Dialogue: 0,0:18:08.58,0:18:12.84,Chinese,,0,0,0,,在更高层次上是另一种形式的异常控制流
Dialogue: 0,0:18:14.28,0:18:18.72,English,,0,0,0,,And we see it in the context of a process context switch
Dialogue: 0,0:18:14.28,0:18:18.72,Chinese,,0,0,0,,我们将会在进程的上下文切换中看到
Dialogue: 0,0:18:21.00,0:18:25.34,English,,0,0,0,,So let's look at and let's look at what a process is
Dialogue: 0,0:18:21.00,0:18:25.34,Chinese,,0,0,0,,那么让我们看一下「进程」是什么
Dialogue: 0,0:18:26.64,0:18:32.38,English,,0,0,0,,So a process,the idea of a process is one of the most fundamental and important ideas in computer science
Dialogue: 0,0:18:26.64,0:18:32.38,Chinese,,0,0,0,,进程的思想是计算机科学中最基本、最重要的思想之一
Dialogue: 0,0:18:33.34,0:18:39.22,English,,0,0,0,,And this classical definition of is that a process is an instance of a running program
Dialogue: 0,0:18:33.34,0:18:39.22,Chinese,,0,0,0,,这个经典定义是，进程是正在运行的程序的实例
Dialogue: 0,0:18:40.88,0:18:43.20,English,,0,0,0,,Okay it's different from a program
Dialogue: 0,0:18:40.88,0:18:43.20,Chinese,,0,0,0,,是的，它与程序不同
Dialogue: 0,0:18:43.68,0:18:47.18,English,,0,0,0,,A program exists can exist in many different places right
Dialogue: 0,0:18:43.68,0:18:47.18,Chinese,,0,0,0,,存在的程序可以存在于许多不同的地方
Dialogue: 0,0:18:47.18,0:18:51.38,English,,0,0,0,,A program exists in you save as text in a C file
Dialogue: 0,0:18:47.18,0:18:51.38,Chinese,,0,0,0,,你在 .C 文件中以文本形式保存的程序
Dialogue: 0,0:18:51.98,0:18:57.24,English,,0,0,0,,It can exist as the .text section of a binary
Dialogue: 0,0:18:51.98,0:18:57.24,Chinese,,0,0,0,,它可以作为二进制文件的 .text 部分存在
Dialogue: 0,0:18:58.38,0:19:01.86,English,,0,0,0,,It can exist as bytes that have been loaded into memory
Dialogue: 0,0:18:58.38,0:19:01.86,Chinese,,0,0,0,,它可以作为已加载到内存中的字节存在
Dialogue: 0,0:19:02.26,0:19:06.96,English,,0,0,0,,A process is an instance of a program that's running,that's in execution
Dialogue: 0,0:19:02.26,0:19:06.96,Chinese,,0,0,0,,进程是正在运行的程序的实例，它是处于正在执行中
Dialogue: 0,0:19:13.40,0:19:16.92,English,,0,0,0,,And a process provides two key abstractions
Dialogue: 0,0:19:13.40,0:19:16.92,Chinese,,0,0,0,,进程提供了两个关键的抽象
Dialogue: 0,0:19:17.80,0:19:24.36,English,,0,0,0,,Okay it's the first abstraction is that it gives it gives you the illusion that you have
Dialogue: 0,0:19:17.80,0:19:24.36,Chinese,,0,0,0,,第一个抽象就是，它给你带来的幻觉
Dialogue: 0,0:19:25.88,0:19:29.66,English,,0,0,0,,Exclusive access to the CPU and registers
Dialogue: 0,0:19:25.88,0:19:29.66,Chinese,,0,0,0,,独占使用CPU和寄存器
Dialogue: 0,0:19:30.60,0:19:31.58,English,,0,0,0,,Okay so when you're running
Dialogue: 0,0:19:30.60,0:19:31.58,Chinese,,0,0,0,,当你运行的时候
Dialogue: 0,0:19:31.98,0:19:33.90,English,,0,0,0,,When you're running your program in a process
Dialogue: 0,0:19:31.98,0:19:33.90,Chinese,,0,0,0,,当你在一个进程中运行程序时
Dialogue: 0,0:19:34.58,0:19:39.20,English,,0,0,0,,You never have to worry about any other programs modifying your registers
Dialogue: 0,0:19:34.58,0:19:39.20,Chinese,,0,0,0,,你永远不必担心其他程序修改你的寄存器
Dialogue: 0,0:19:39.86,0:19:45.46,English,,0,0,0,,And you can't even tell that there's even other processes running on the system
Dialogue: 0,0:19:39.86,0:19:45.46,Chinese,,0,0,0,,而你甚至无法告知系统上还有其他进程在运行
Dialogue: 0,0:19:45.76,0:19:51.86,English,,0,0,0,,Right it looks except for occasional delays like an instruction that just takes a little longer to run
Dialogue: 0,0:19:45.76,0:19:51.86,Chinese,,0,0,0,,它看起来很正常，除了偶尔的延迟，比如需要更长时间运行的指令
Dialogue: 0,0:19:53.16,0:20:01.06,English,,0,0,0,,Except for that it looks like you have unique exclusive use of the of the processor and it's registers
Dialogue: 0,0:19:53.16,0:20:01.06,Chinese,,0,0,0,,除了看起来你有独占的处理器和它的寄存器以外
Dialogue: 0,0:20:02.36,0:20:06.50,English,,0,0,0,,The the other abstraction that it provides is the illusion that you have your own address space
Dialogue: 0,0:20:02.36,0:20:06.50,Chinese,,0,0,0,,它提供的另一个抽象是你感觉拥有独自的地址空间
Dialogue: 0,0:20:08.70,0:20:09.84,English,,0,0,0,,Okay so you have
Dialogue: 0,0:20:08.70,0:20:09.84,Chinese,,0,0,0,,你有
Dialogue: 0,0:20:10.12,0:20:13.58,English,,0,0,0,,And this is provided by a mechanism called virtual memory
Dialogue: 0,0:20:10.12,0:20:13.58,Chinese,,0,0,0,,这是由一种称为「虚拟内存」的机制提供的
Dialogue: 0,0:20:14.28,0:20:20.58,English,,0,0,0,,So each running program has its own code data heap stack
Dialogue: 0,0:20:14.28,0:20:20.58,Chinese,,0,0,0,,每个运行的程序都有自己的代码、数据、堆栈
Dialogue: 0,0:20:21.20,0:20:24.06,English,,0,0,0,,And you never see that the code...
Dialogue: 0,0:20:21.20,0:20:24.06,Chinese,,0,0,0,,你永远不会察觉到......
Dialogue: 0,0:20:24.68,0:20:27.72,English,,0,0,0,,And you never see the memory that's being used by other processes
Dialogue: 0,0:20:24.68,0:20:27.72,Chinese,,0,0,0,,而且你永远不会察觉到其他进程正在使用的内存
Dialogue: 0,0:20:28.54,0:20:33.68,English,,0,0,0,,Okay so it looks for all intents and purposes process gives you this illusion that
Dialogue: 0,0:20:28.54,0:20:33.68,Chinese,,0,0,0,,出于这个目的，进程给你这种错觉
Dialogue: 0,0:20:33.68,0:20:39.82,English,,0,0,0,,You have access to the exclusive access to all the memory and the and the processor
Dialogue: 0,0:20:33.68,0:20:39.82,Chinese,,0,0,0,,你可以拥有所有内存和处理器的独占访问权限
Dialogue: 0,0:20:42.88,0:20:46.64,English,,0,0,0,,Now that the system runs many of these processes simultaneously
Dialogue: 0,0:20:42.88,0:20:46.64,Chinese,,0,0,0,,现在系统同时运行了许多这些进程
Dialogue: 0,0:20:49.06,0:20:58.86,English,,0,0,0,,Even on a system with a single core,many of these multiple processes are actually running at the same time concurrently
Dialogue: 0,0:20:49.06,0:20:58.86,Chinese,,0,0,0,,即使在具有单核的系统上，这些进程中的许多个实际上是在同一时间并发运行
Dialogue: 0,0:20:59.16,0:21:03.92,English,,0,0,0,,And you can see this if you look at this here I ran top on my mac
Dialogue: 0,0:20:59.16,0:21:03.92,Chinese,,0,0,0,,你可以看这个，我的 Mac 运行 top 程序
Dialogue: 0,0:21:04.60,0:21:13.18,English,,0,0,0,,And you can see it's running 123 total processes, 5 of which are actually running
Dialogue: 0,0:21:04.60,0:21:13.18,Chinese,,0,0,0,,你可以看到它运行了 123 个进程，其中 5 个是处于实际运行状态
Dialogue: 0,0:21:13.94,0:21:19.60,English,,0,0,0,,And each one of these processes has its own unique process id,this is integer
Dialogue: 0,0:21:13.94,0:21:19.60,Chinese,,0,0,0,,并且这些进程中的每一个都有自己唯一的进程 ID，这是整数类型
Dialogue: 0,0:21:24.04,0:21:30.80,English,,0,0,0,,Now the way so it looks like you have unique access or exclusive access to the system
Dialogue: 0,0:21:24.04,0:21:30.80,Chinese,,0,0,0,,看来你对系统有独特的访问权限，或独占访问权限
Dialogue: 0,0:21:31.96,0:21:39.14,English,,0,0,0,,But in reality on a suppose we have a single core on a you're actually sharing the system
Dialogue: 0,0:21:31.96,0:21:39.14,Chinese,,0,0,0,,但实际上，假设我们共享使用的系统只有一个核心
Dialogue: 0,0:21:39.14,0:21:43.42,English,,0,0,0,,And the operating system is is sort of managing that sharing
Dialogue: 0,0:21:39.14,0:21:43.42,Chinese,,0,0,0,,操作系统就是管理共享
Dialogue: 0,0:21:44.20,0:21:45.24,English,,0,0,0,,So what it does is it
Dialogue: 0,0:21:44.20,0:21:45.24,Chinese,,0,0,0,,它的作用是什么呢
Dialogue: 0,0:21:49.32,0:21:51.04,English,,0,0,0,,We have a process that's running
Dialogue: 0,0:21:49.32,0:21:51.04,Chinese,,0,0,0,,我们有一个正在运行的进程
Dialogue: 0,0:21:52.72,0:21:57.16,English,,0,0,0,,And it has its own...it has its own address space
Dialogue: 0,0:21:52.72,0:21:57.16,Chinese,,0,0,0,,它有自己的地址空间
Dialogue: 0,0:21:58.26,0:22:02.50,English,,0,0,0,,And it has its own registers
Dialogue: 0,0:21:58.26,0:22:02.50,Chinese,,0,0,0,,有自己的寄存器
Dialogue: 0,0:22:03.18,0:22:04.62,English,,0,0,0,,And at some point either
Dialogue: 0,0:22:03.18,0:22:04.62,Chinese,,0,0,0,,在某些时候也是
Dialogue: 0,0:22:05.42,0:22:10.56,English,,0,0,0,,Because...at some point an exception occurs either because of a timer interrupt
Dialogue: 0,0:22:05.42,0:22:10.56,Chinese,,0,0,0,,在某些时候由于定时器中断而发生异常
Dialogue: 0,0:22:11.18,0:22:14.40,English,,0,0,0,,Or a fault of some kind or a trap
Dialogue: 0,0:22:11.18,0:22:14.40,Chinese,,0,0,0,,或某种故障或陷阱
Dialogue: 0,0:22:15.00,0:22:18.86,English,,0,0,0,,At some point the operating system gets control of the system
Dialogue: 0,0:22:15.00,0:22:18.86,Chinese,,0,0,0,,在某些时候，操作系统可以控制系统
Dialogue: 0,0:22:19.42,0:22:23.82,English,,0,0,0,,And in this case let's say it decides that it wants to run another process
Dialogue: 0,0:22:19.42,0:22:23.82,Chinese,,0,0,0,,在这种情况下，我们说它决定它是否想要运行另一个进程
Dialogue: 0,0:22:25.28,0:22:31.94,English,,0,0,0,,So it copies the registers,the current register values into memory and saves them
Dialogue: 0,0:22:25.28,0:22:31.94,Chinese,,0,0,0,,它将寄存器，当前寄存器值复制到存储器中并保存它们
Dialogue: 0,0:22:34.04,0:22:37.04,English,,0,0,0,,And then it schedules the next process for execution
Dialogue: 0,0:22:34.04,0:22:37.04,Chinese,,0,0,0,,然后它会安排下一个待执行的进程
Dialogue: 0,0:22:38.18,0:22:46.00,English,,0,0,0,,And it loads the registers that were saved from the last time that process was running
Dialogue: 0,0:22:38.18,0:22:46.00,Chinese,,0,0,0,,并且它加载上次运行该进程时保存的寄存器
Dialogue: 0,0:22:46.00,0:22:48.04,English,,0,0,0,,It loads those into the cpu registers
Dialogue: 0,0:22:46.00,0:22:48.04,Chinese,,0,0,0,,它将这些加载到 cpu 寄存器中
Dialogue: 0,0:22:48.64,0:22:54.48,English,,0,0,0,,And then it switches the address space to the address space for this process
Dialogue: 0,0:22:48.64,0:22:54.48,Chinese,,0,0,0,,然后它将地址空间切换到此进程的地址空间
Dialogue: 0,0:22:55.44,0:23:00.20,English,,0,0,0,,So this the address space and the register values are the context
Dialogue: 0,0:22:55.44,0:23:00.20,Chinese,,0,0,0,,这个地址空间和寄存器值是「上下文」
Dialogue: 0,0:23:01.56,0:23:09.02,English,,0,0,0,,And so the context switch is what is the change in the address space and the registers
Dialogue: 0,0:23:01.56,0:23:09.02,Chinese,,0,0,0,,上下文切换是地址空间和寄存器的变化
Dialogue: 0,0:23:11.38,0:23:14.00,English,,0,0,0,,Ok so then at that point the that process is running
Dialogue: 0,0:23:11.38,0:23:14.00,Chinese,,0,0,0,,那个进程正在运行
Dialogue: 0,0:23:15.98,0:23:19.02,English,,0,0,0,,Now in reality on modern systems with multiple cores
Dialogue: 0,0:23:15.98,0:23:19.02,Chinese,,0,0,0,,实际上在具有多个核心的现代系统上
Dialogue: 0,0:23:21.18,0:23:25.80,English,,0,0,0,,The operating system will schedule processes on those multiple cores
Dialogue: 0,0:23:21.18,0:23:25.80,Chinese,,0,0,0,,操作系统将在这些多核上安排进程
Dialogue: 0,0:23:25.96,0:23:31.46,English,,0,0,0,,And then if there's not enough cores to handle the processes then it will do the context switching
Dialogue: 0,0:23:25.96,0:23:31.46,Chinese,,0,0,0,,然后，如果没有足够的核心来处理这些过程，那么它将进行上下文切换
Dialogue: 0,0:23:31.92,0:23:34.08,English,,0,0,0,,Just like we showed before
Dialogue: 0,0:23:31.92,0:23:34.08,Chinese,,0,0,0,,就像我们之前展示的一样
Dialogue: 0,0:23:37.74,0:23:41.92,English,,0,0,0,,Now each process represents a what we call a logical control flow
Dialogue: 0,0:23:37.74,0:23:41.92,Chinese,,0,0,0,,我们认为每一个进程代表一个「逻辑控制流」
Dialogue: 0,0:23:42.72,0:23:45.32,English,,0,0,0,,So if you were to you know there's a physical control flow
Dialogue: 0,0:23:42.72,0:23:45.32,Chinese,,0,0,0,,如果只针对所有的 PC 值而言
Dialogue: 0,0:23:45.84,0:23:47.96,English,,0,0,0,,Which if we just looked at all the PC values
Dialogue: 0,0:23:45.84,0:23:47.96,Chinese,,0,0,0,,那么对应有一个「物理控制流」
Dialogue: 0,0:23:50.20,0:23:53.52,English,,0,0,0,,We'd be executing instructions from one process
Dialogue: 0,0:23:50.20,0:23:53.52,Chinese,,0,0,0,,我们将从一个进程执行指令
Dialogue: 0,0:23:53.52,0:23:56.64,English,,0,0,0,,And then all of a sudden we'd be executing from another process
Dialogue: 0,0:23:53.52,0:23:56.64,Chinese,,0,0,0,,然后突然间我们将从另一个进程执行
Dialogue: 0,0:23:57.38,0:24:02.26,English,,0,0,0,,But within a single process there's a logical control flow which are all the instructions for that process
Dialogue: 0,0:23:57.38,0:24:02.26,Chinese,,0,0,0,,但是在单个进程中，有一个逻辑控制流，它是该过程的所有指令
Dialogue: 0,0:24:03.48,0:24:07.16,English,,0,0,0,,Now we say that two processes run concurrently
Dialogue: 0,0:24:03.48,0:24:07.16,Chinese,,0,0,0,,当它们的时序在时间上重叠时
Dialogue: 0,0:24:07.46,0:24:10.64,English,,0,0,0,,If their flows overlap in time otherwise they're sequential
Dialogue: 0,0:24:07.46,0:24:10.64,Chinese,,0,0,0,,我们说两个进程同时运行（「并发」），否则它们是连续的
Dialogue: 0,0:24:11.50,0:24:15.52,English,,0,0,0,,So let's look at an example we have three processes
Dialogue: 0,0:24:11.50,0:24:15.52,Chinese,,0,0,0,,那么让我们看一个例子，我们有三个进程
Dialogue: 0,0:24:15.68,0:24:22.56,English,,0,0,0,,Process A runs for a while and then it's interrupted by process B and process C
Dialogue: 0,0:24:15.68,0:24:22.56,Chinese,,0,0,0,,进程 A 运行一段时间，然后被进程 B 和进程 C 中断
Dialogue: 0,0:24:22.78,0:24:26.00,English,,0,0,0,,And then eventually it continues running and then it terminates
Dialogue: 0,0:24:22.78,0:24:26.00,Chinese,,0,0,0,,然后它继续运行，终止
Dialogue: 0,0:24:26.84,0:24:32.78,English,,0,0,0,,Process B interrupts process A and then it runs for a while and then it terminates
Dialogue: 0,0:24:26.84,0:24:32.78,Chinese,,0,0,0,,进程 B 中断进程 A，然后它运行一段时间，然后它终止
Dialogue: 0,0:24:34.00,0:24:39.70,English,,0,0,0,,Process C once when process B finishes then process C gets to run for a while
Dialogue: 0,0:24:34.00,0:24:39.70,Chinese,,0,0,0,,当进程 B 完成时，然后进程 C 运行一段时间
Dialogue: 0,0:24:40.84,0:24:44.24,English,,0,0,0,,Then process A runs for a while and then process C terminates
Dialogue: 0,0:24:40.84,0:24:44.24,Chinese,,0,0,0,,进程A运行一段时间，然后进程C终止
Dialogue: 0,0:24:45.14,0:24:48.10,English,,0,0,0,,Okay so given this definition of concurrency
Dialogue: 0,0:24:45.14,0:24:48.10,Chinese,,0,0,0,,给出了「并发」的这个定义
Dialogue: 0,0:24:51.20,0:24:54.78,English,,0,0,0,,Which of these processes are running concurrently
Dialogue: 0,0:24:51.20,0:24:54.78,Chinese,,0,0,0,,哪些进程同时运行
Dialogue: 0,0:24:58.12,0:24:59.52,English,,0,0,0,,What about a A and B?
Dialogue: 0,0:24:58.12,0:24:59.52,Chinese,,0,0,0,,A 和 B 是不是同时运行？
Dialogue: 0,0:25:07.50,0:25:12.56,English,,0,0,0,,So A and B flows, B's flow overlaps with A's flow right
Dialogue: 0,0:25:07.50,0:25:12.56,Chinese,,0,0,0,,A 和 B 两个逻辑流，B 的逻辑流中断掉 A 的逻辑流
Dialogue: 0,0:25:13.30,0:25:17.62,English,,0,0,0,,So B
Dialogue: 0,0:25:13.30,0:25:17.62,Chinese,,0,0,0,,
Dialogue: 0,0:25:21.04,0:25:23.82,English,,0,0,0,,B finishes starts and finish
Dialogue: 0,0:25:21.04,0:25:23.82,Chinese,,0,0,0,,B 完成开始和结束的一整个过程
Dialogue: 0,0:25:27.30,0:25:31.58,English,,0,0,0,,Some portion this portion of B flow overlaps with A flow right
Dialogue: 0,0:25:27.30,0:25:31.58,Chinese,,0,0,0,,B 逻辑流的一部分与 A 逻辑流重叠（A 未停止）
Dialogue: 0,0:25:32.18,0:25:34.46,English,,0,0,0,,Because B is still running hasn't finished
Dialogue: 0,0:25:32.18,0:25:34.46,Chinese,,0,0,0,,因为 B 还在运行,还没有完成
Dialogue: 0,0:25:34.90,0:25:40.94,English,,0,0,0,,Ok so A and B are concurrent as and similarly C and A overlap
Dialogue: 0,0:25:34.90,0:25:40.94,Chinese,,0,0,0,,A 和 B 是并发的，并且类似地 C 和 A 重叠
Dialogue: 0,0:25:41.62,0:25:42.84,English,,0,0,0,,So they're concurrent
Dialogue: 0,0:25:41.62,0:25:42.84,Chinese,,0,0,0,,他们是并发的
Dialogue: 0,0:25:43.36,0:25:48.90,English,,0,0,0,,But B and C are not concurrent right B finishes before C starts
Dialogue: 0,0:25:43.36,0:25:48.90,Chinese,,0,0,0,,但是 B 和 C 在 C 不是并发的,因为 B 在 C 开始前已经结束了
Dialogue: 0,0:25:52.82,0:25:56.66,English,,0,0,0,,Now this idea of concurrency it doesn't
Dialogue: 0,0:25:52.82,0:25:56.66,Chinese,,0,0,0,,这种并发的概念.....并没有
Dialogue: 0,0:25:57.74,0:26:01.92,English,,0,0,0,,This definition of concurrency holds regardless of the number of cores
Dialogue: 0,0:25:57.74,0:26:01.92,Chinese,,0,0,0,,无论核心数量为多少，这种并发性定义都会成立
Dialogue: 0,0:26:02.62,0:26:07.70,English,,0,0,0,,Right even if you have one core this example that I showed you was on one core
Dialogue: 0,0:26:02.62,0:26:07.70,Chinese,,0,0,0,,即使你有一个核心，我向你展示的这个例子就是一个核心
Dialogue: 0,0:26:08.14,0:26:11.52,English,,0,0,0,,But even if you have multiple cores as long as the flows overlap in time
Dialogue: 0,0:26:08.14,0:26:11.52,Chinese,,0,0,0,,但即使你有多个核心，只要逻辑流在时间上重叠
Dialogue: 0,0:26:12.12,0:26:13.56,English,,0,0,0,,They're concurrent
Dialogue: 0,0:26:12.12,0:26:13.56,Chinese,,0,0,0,,那么他们是并发的
Dialogue: 0,0:26:14.98,0:26:20.58,English,,0,0,0,,But we can think of these no matter what,we can think of these as running in parallel with each other
Dialogue: 0,0:26:14.98,0:26:20.58,Chinese,,0,0,0,,但是无论如何，我们都可以想到这些，我们可以认为它们是相互「并行」的
Dialogue: 0,0:26:20.58,0:26:23.72,English,,0,0,0,,At least from the point of view of these individual processes
Dialogue: 0,0:26:20.58,0:26:23.72,Chinese,,0,0,0,,至少从这些个别的过程的角度来看
Dialogue: 0,0:26:30.90,0:26:33.24,English,,0,0,0,,Now this notion of a context which
Dialogue: 0,0:26:30.90,0:26:33.24,Chinese,,0,0,0,,现在这个概念的上下文
Dialogue: 0,0:26:35.78,0:26:38.76,English,,0,0,0,,It's managed by...its managed by the kernel
Dialogue: 0,0:26:35.78,0:26:38.76,Chinese,,0,0,0,,它由...由内核管理
Dialogue: 0,0:26:39.94,0:26:43.86,English,,0,0,0,,Okay and it's important to realize that the kernel is not like a separate process that's running
Dialogue: 0,0:26:39.94,0:26:43.86,Chinese,,0,0,0,,重要的是要意识到内核不像是一个正在运行的独立进程
Dialogue: 0,0:26:43.86,0:26:46.54,English,,0,0,0,,It always runs in the context of some existing process
Dialogue: 0,0:26:43.86,0:26:46.54,Chinese,,0,0,0,,它始终在某些现有进程的上下文中运行
Dialogue: 0,0:26:47.96,0:26:53.82,English,,0,0,0,,And it's just code that's in the upper portion of the address space
Dialogue: 0,0:26:47.96,0:26:53.82,Chinese,,0,0,0,,它只是位于地址空间顶部的代码
Dialogue: 0,0:26:54.60,0:26:57.02,English,,0,0,0,,That gets executed as a result of an exception
Dialogue: 0,0:26:54.60,0:26:57.02,Chinese,,0,0,0,,这是因异常而执行的
Dialogue: 0,0:26:59.12,0:27:04.14,English,,0,0,0,,So what what happens the way to think about this is that you have this process a that runs
Dialogue: 0,0:26:59.12,0:27:04.14,Chinese,,0,0,0,,那么考虑这个问题，就是你运行这个过程
Dialogue: 0,0:27:04.36,0:27:07.62,English,,0,0,0,,And then an exception occurs which transfers control to the kernel
Dialogue: 0,0:27:04.36,0:27:07.62,Chinese,,0,0,0,,然后发生异常，将控制权返回到内核
Dialogue: 0,0:27:08.46,0:27:14.04,English,,0,0,0,,The kernel invokes its scheduler which decides whether to let A continue to run
Dialogue: 0,0:27:08.46,0:27:14.04,Chinese,,0,0,0,,内核调用其调度程序，该调度程序决定是否让 A 继续运行
Dialogue: 0,0:27:14.62,0:27:18.86,English,,0,0,0,,Or to to do a context switch and run a new process another process
Dialogue: 0,0:27:14.62,0:27:18.86,Chinese,,0,0,0,,或者做一个上下文切换并运行另一个新的进程
Dialogue: 0,0:27:19.44,0:27:25.56,English,,0,0,0,,So in this example the scheduler is decided to run process B
Dialogue: 0,0:27:19.44,0:27:25.56,Chinese,,0,0,0,,在此示例中，调度程序决定运行进程 B
Dialogue: 0,0:27:25.56,0:27:32.92,English,,0,0,0,,So it executes code and then sort of changes sort of once it repoint the address space
Dialogue: 0,0:27:25.56,0:27:32.92,Chinese,,0,0,0,,一旦重新指定地址空间，它就会执行代码然后进行排序
Dialogue: 0,0:27:34.58,0:27:36.99,English,,0,0,0,,Then it's running in the context of process B
Dialogue: 0,0:27:34.58,0:27:36.99,Chinese,,0,0,0,,然后它在进程 B 的上下文中运行
Dialogue: 0,0:27:37.42,0:27:43.60,English,,0,0,0,,And it finishes loading the registers for process B general-purpose registers
Dialogue: 0,0:27:37.42,0:27:43.60,Chinese,,0,0,0,,它完成加载进程 B 通用寄存器
Dialogue: 0,0:27:43.62,0:27:48.00,English,,0,0,0,,And then transfers control to B and B picks up where it left off
Dialogue: 0,0:27:43.62,0:27:48.00,Chinese,,0,0,0,,然后将控制权转移到 B，B 就从此中断处继续运行
Dialogue: 0,0:27:49.10,0:27:49.74,English,,0,0,0,,Okay
Dialogue: 0,0:27:49.10,0:27:49.74,Chinese,,0,0,0,,好的
Dialogue: 0,0:27:51.50,0:27:53.80,English,,0,0,0,,And that at some point another exception occurs
Dialogue: 0,0:27:51.50,0:27:53.80,Chinese,,0,0,0,,而且在某些时候会发生另一个异常
Dialogue: 0,0:27:54.42,0:28:00.62,English,,0,0,0,,And in the kernel decides to transfer control back to process A which picks up where it left off right here
Dialogue: 0,0:27:54.42,0:28:00.62,Chinese,,0,0,0,,并且在内核中决定将控制权转移回进程 A，进程 A 在此处从中断处继续
Dialogue: 0,0:28:01.68,0:28:04.62,English,,0,0,0,,So whatever instruction it finishes executing
Dialogue: 0,0:28:01.68,0:28:04.62,Chinese,,0,0,0,,无论它完成执行的任何指令
Dialogue: 0,0:28:05.60,0:28:11.66,English,,0,0,0,,Whatever instruction was executing at the time of the exception execute the next instruction here
Dialogue: 0,0:28:05.60,0:28:11.66,Chinese,,0,0,0,,无论在异常时执行什么指令，都要执行下一条指令
Dialogue: 0,0:28:17.56,0:28:20.54,English,,0,0,0,,Now Linux provides a number of functions
Dialogue: 0,0:28:17.56,0:28:20.54,Chinese,,0,0,0,,现在 Linux 提供了许多函数
Dialogue: 0,0:28:21.12,0:28:24.42,English,,0,0,0,,You can call from a user program to manipulate processes
Dialogue: 0,0:28:21.12,0:28:24.42,Chinese,,0,0,0,,你可以从用户程序调用来操作进程
Dialogue: 0,0:28:24.90,0:28:30.40,English,,0,0,0,,And this process this act of manipulating processes we refer to as process control
Dialogue: 0,0:28:24.90,0:28:30.40,Chinese,,0,0,0,,这个操作进程的过程我们称为进程控制
Dialogue: 0,0:28:32.20,0:28:40.28,English,,0,0,0,,Now all of these functions,most I should say,most of these functions call invoke system, make system calls
Dialogue: 0,0:28:32.20,0:28:40.28,Chinese,,0,0,0,,所有这些函数，我应该说，大多数这些函数进行系统调用
Dialogue: 0,0:28:40.68,0:28:45.96,English,,0,0,0,,But they're wrapped in higher levels what we call system level functions that
Dialogue: 0,0:28:40.68,0:28:45.96,Chinese,,0,0,0,,但它们包含在我们称之为系统级函数的更高级别
Dialogue: 0,0:28:46.12,0:28:48.64,English,,0,0,0,,That are the things you actually call from your user program
Dialogue: 0,0:28:46.12,0:28:48.64,Chinese,,0,0,0,,这是你实际从用户程序调用的内容
Dialogue: 0,0:28:49.60,0:28:57.58,English,,0,0,0,,Now system level the Linux system level functions that will typically return -1 if there's an error
Dialogue: 0,0:28:49.60,0:28:57.58,Chinese,,0,0,0,,现在 Linux 系统级函数，如果出现错误，通常会返回 -1
Dialogue: 0,0:28:58.26,0:29:02.42,English,,0,0,0,,And then they'll set a global variable called errno to indicate the reason
Dialogue: 0,0:28:58.26,0:29:02.42,Chinese,,0,0,0,,然后他们将设置一个名为 errno 的全局变量来指示原因
Dialogue: 0,0:29:03.58,0:29:06.68,English,,0,0,0,,So there's a hard and fast rule when you're doing
Dialogue: 0,0:29:03.58,0:29:06.68,Chinese,,0,0,0,,当你做的时候有一条硬性规则
Dialogue: 0,0:29:08.12,0:29:10.60,English,,0,0,0,,When you're invoking system level functions
Dialogue: 0,0:29:08.12,0:29:10.60,Chinese,,0,0,0,,当你调用系统级函数时
Dialogue: 0,0:29:11.84,0:29:16.60,English,,0,0,0,,You must check the return values from those functions you should
Dialogue: 0,0:29:11.84,0:29:16.60,Chinese,,0,0,0,,你必须检查应该使用的那些函数的返回值
Dialogue: 0,0:29:17.10,0:29:20.64,English,,0,0,0,,And this you never you'll get into huge trouble
Dialogue: 0,0:29:17.10,0:29:20.64,Chinese,,0,0,0,,如果忽略检查返回值
Dialogue: 0,0:29:21.18,0:29:23.78,English,,0,0,0,,If you neglect to check the return values
Dialogue: 0,0:29:21.18,0:29:23.78,Chinese,,0,0,0,,你可能就会遇到巨大的麻烦
Dialogue: 0,0:29:24.26,0:29:30.84,English,,0,0,0,,Okay so you should never make a system level function call without checking the return value
Dialogue: 0,0:29:24.26,0:29:30.84,Chinese,,0,0,0,,其实你不应该在不检查返回值的情况下，进行系统级函数调用
Dialogue: 0,0:29:31.64,0:29:35.56,English,,0,0,0,,The and the only exception there's some functions that return void
Dialogue: 0,0:29:31.64,0:29:35.56,Chinese,,0,0,0,,唯一的例外是有些函数返回 void
Dialogue: 0,0:29:37.98,0:29:42.10,English,,0,0,0,,Such as exit or free don't return anything
Dialogue: 0,0:29:37.98,0:29:42.10,Chinese,,0,0,0,,如 exit 或 free 不返回任何值
Dialogue: 0,0:29:43.32,0:29:47.14,English,,0,0,0,,So the way the typical way you would do this is like the fork call
Dialogue: 0,0:29:43.32,0:29:47.14,Chinese,,0,0,0,,你这样做的典型方式就像 fork 调用一样
Dialogue: 0,0:29:47.14,0:29:53.82,English,,0,0,0,,Which we use to create processes returns the process id of the process that it created
Dialogue: 0,0:29:47.14,0:29:53.82,Chinese,,0,0,0,,我们用来创建子进程的进程返回了它创建的子进程的进程ID，则总是正数
Dialogue: 0,0:29:54.36,0:29:57.54,English,,0,0,0,,Which is always positive if there's an error returns -1
Dialogue: 0,0:29:54.36,0:29:57.54,Chinese,,0,0,0,,如果有错误,返回 -1
Dialogue: 0,0:29:57.54,0:30:04.12,English,,0,0,0,,So we check for the return value to be less than 0 and then we deal with that error somehow
Dialogue: 0,0:29:57.54,0:30:04.12,Chinese,,0,0,0,,我们检查返回值是否小于 0，然后我们以某种方式处理该错误
Dialogue: 0,0:30:06.18,0:30:09.52,English,,0,0,0,,Ok in this case we're just printing a message and exiting
Dialogue: 0,0:30:06.18,0:30:09.52,Chinese,,0,0,0,,在这种情况下，我们只是打印一条消息并退出
Dialogue: 0,0:30:10.68,0:30:13.82,English,,0,0,0,,Now this gets although it's essential to do this it gets
Dialogue: 0,0:30:10.68,0:30:13.82,Chinese,,0,0,0,,虽然这是必要的，它必须这样做
Dialogue: 0,0:30:16.16,0:30:20.58,English,,0,0,0,,From my point of view we're trying to present code to you
Dialogue: 0,0:30:16.16,0:30:20.58,Chinese,,0,0,0,,从我的角度来看，我们正试图向你展示代码
Dialogue: 0,0:30:22.06,0:30:25.10,English,,0,0,0,,It gets really messy it takes up a lot of space
Dialogue: 0,0:30:22.06,0:30:25.10,Chinese,,0,0,0,,它变得非常混乱，占用了大量空间
Dialogue: 0,0:30:25.10,0:30:25.40,English,,0,0,0,,Yes
Dialogue: 0,0:30:25.10,0:30:25.40,Chinese,,0,0,0,,是
Dialogue: 0,0:30:25.84,0:30:31.54,English,,0,0,0,,[student speaking]
Dialogue: 0,0:30:31.76,0:30:33.62,English,,0,0,0,,I'm checking that it's less than zero
Dialogue: 0,0:30:31.76,0:30:33.62,Chinese,,0,0,0,,我正在检查它是否小于 0
Dialogue: 0,0:30:37.20,0:30:43.72,English,,0,0,0,,Oh yeah that probably that should be normally the convention is to return non zero so you're right that
Dialogue: 0,0:30:37.20,0:30:43.72,Chinese,,0,0,0,,哦，是的，通常情况应该通常是返回非零，你是对的
Dialogue: 0,0:30:44.82,0:30:49.68,English,,0,0,0,,It's not a hard and fast rule but that's typically the convention so I guess it should be exit one
Dialogue: 0,0:30:44.82,0:30:49.68,Chinese,,0,0,0,,这不是一个硬性规则，但这通常是惯例，我想它应该退出一个
Dialogue: 0,0:30:54.04,0:30:56.22,English,,0,0,0,,So what we'll do to simplify this
Dialogue: 0,0:30:54.04,0:30:56.22,Chinese,,0,0,0,,那么我们要做些什么来简化这一点
Dialogue: 0,0:30:56.76,0:31:00.19,English,,0,0,0,,In the code that we present to you and in the code that we present you in the book
Dialogue: 0,0:30:56.76,0:31:00.19,Chinese,,0,0,0,,在我们向你呈现的代码中以及我们在本书中向你展示的代码中
Dialogue: 0,0:31:00.68,0:31:03.54,English,,0,0,0,,Well we'll define error reporting functions
Dialogue: 0,0:31:00.68,0:31:03.54,Chinese,,0,0,0,,那么我们将定义错误报告功能
Dialogue: 0,0:31:04.32,0:31:09.82,English,,0,0,0,,So unix-style errors where the function returns -1 and then sets there error no
Dialogue: 0,0:31:04.32,0:31:09.82,Chinese,,0,0,0,,像 unix 样式的错误，其中函数返回 -1 然后设置错误号
Dialogue: 0,0:31:11.92,0:31:16.20,English,,0,0,0,,Well if we get that kind of...if we get that kind of error will
Dialogue: 0,0:31:11.92,0:31:16.20,Chinese,,0,0,0,,如果我们得到那种错误会
Dialogue: 0,0:31:16.98,0:31:23.12,English,,0,0,0,,Will print the will print a message and we'll report what that error was  before we exit
Dialogue: 0,0:31:16.98,0:31:23.12,Chinese,,0,0,0,,将打印一条消息，我们将在退出之前报告该错误
Dialogue: 0,0:31:23.46,0:31:30.96,English,,0,0,0,,And so then in the code we can replace that body of that if statement with just a single line
Dialogue: 0,0:31:23.46,0:31:30.96,Chinese,,0,0,0,,然后在代码中我们可以用一行替换 if 语句的主体
Dialogue: 0,0:31:31.36,0:31:34.00,English,,0,0,0,,Okay so that makes the code a little tighter
Dialogue: 0,0:31:31.36,0:31:34.00,Chinese,,0,0,0,,这样可以使代码更紧凑
Dialogue: 0,0:31:34.56,0:31:38.52,English,,0,0,0,,But we'll go even further than that and we'll define these wrappers
Dialogue: 0,0:31:34.56,0:31:38.52,Chinese,,0,0,0,,但我们会比这更进一步，我们将定义这些包装器
Dialogue: 0,0:31:38.52,0:31:44.80,English,,0,0,0,,Which were pioneered by a great technical writer named W.Richards Stevens
Dialogue: 0,0:31:38.52,0:31:44.80,Chinese,,0,0,0,,这是由一位名叫『W.Richards Stevens』的伟大技术家开创的
Dialogue: 0,0:31:45.86,0:31:51.62,English,,0,0,0,,And what we do here is we replace each function with an error at a wrapper
Dialogue: 0,0:31:45.86,0:31:51.62,Chinese,,0,0,0,,我们在这里做的是，在函数中处理错误形成一个包装器
Dialogue: 0,0:31:52.10,0:31:58.02,English,,0,0,0,,That has the identical interface as the function the original function
Dialogue: 0,0:31:52.10,0:31:58.02,Chinese,,0,0,0,,它具有与原始函数相同的接口
Dialogue: 0,0:31:58.28,0:32:01.30,English,,0,0,0,,And it has the first,the first letter uppercase
Dialogue: 0,0:31:58.28,0:32:01.30,Chinese,,0,0,0,,只不过它的第一个字母大写
Dialogue: 0,0:32:02.64,0:32:08.98,English,,0,0,0,,And then what this wrapper does is it calls,it calls the original function checks for the errors
Dialogue: 0,0:32:02.64,0:32:08.98,Chinese,,0,0,0,,这个包装器做的是，它调用原始函数并检查错误
Dialogue: 0,0:32:09.12,0:32:14.54,English,,0,0,0,,And then if there's no error returns what the original function would have returned
Dialogue: 0,0:32:09.12,0:32:14.54,Chinese,,0,0,0,, 如果没有错误，原始函数将返回
Dialogue: 0,0:32:15.42,0:32:20.80,English,,0,0,0,,So the behavior of this wrapper is identical to the wrapped function
Dialogue: 0,0:32:15.42,0:32:20.80,Chinese,,0,0,0,,如果没有错误发生的话
Dialogue: 0,0:32:21.20,0:32:22.28,English,,0,0,0,,If there's not an error
Dialogue: 0,0:32:21.20,0:32:22.28,Chinese,,0,0,0,,这个包装器的行为与被包装函数相同
Dialogue: 0,0:32:22.86,0:32:27.10,English,,0,0,0,,Okay and if there is an error then it deals with it somehow and prints a message
Dialogue: 0,0:32:22.86,0:32:27.10,Chinese,,0,0,0,,如果有错误，那么它以某种方式处理它，并打印一条消息
Dialogue: 0,0:32:27.52,0:32:32.92,English,,0,0,0,,And so then this allows us to make our code really compact without violating this
Dialogue: 0,0:32:27.52,0:32:32.92,Chinese,,0,0,0,,这使我们能够在不违反此规范的情况下使代码真正紧凑
Dialogue: 0,0:32:33.52,0:32:36.38,English,,0,0,0,,Hard and fast rule that we have to check for errors
Dialogue: 0,0:32:33.52,0:32:36.38,Chinese,,0,0,0,,我们必须检查错误的硬性规则
Dialogue: 0,0:32:40.34,0:32:44.64,English,,0,0,0,,Okay the simplest function process control functions are
Dialogue: 0,0:32:40.34,0:32:44.64,Chinese,,0,0,0,,最简单的进程控制函数是
Dialogue: 0,0:32:45.08,0:32:48.96,English,,0,0,0,,Functions that allow you to get the pid for the current process which is getpid
Dialogue: 0,0:32:45.08,0:32:48.96,Chinese,,0,0,0,,getpid函数允许你获取当前进程的pid
Dialogue: 0,0:32:49.66,0:32:54.58,English,,0,0,0,,Or the the processor idea of you if the parent process that created the current process
Dialogue: 0,0:32:49.66,0:32:54.58,Chinese,,0,0,0,,或者是处理器概念中的，创建当前进程的父进程
Dialogue: 0,0:32:55.26,0:33:00.58,English,,0,0,0,,Okay so this these take no arguments and they return an integer which is a process id
Dialogue: 0,0:32:55.26,0:33:00.58,Chinese,,0,0,0,,这些不带参数，它们返回一个整数，这是一个进程ID
Dialogue: 0,0:33:05.20,0:33:09.06,English,,0,0,0,,Now Linux provides ways to create and terminate processes
Dialogue: 0,0:33:05.20,0:33:09.06,Chinese,,0,0,0,,现在 Linux 提供了创建和终止进程的方法
Dialogue: 0,0:33:09.64,0:33:15.20,English,,0,0,0,,And from a programmers perspective we can think of a process as being in one of three states running
Dialogue: 0,0:33:09.64,0:33:15.20,Chinese,,0,0,0,,从程序员的角度来看，我们可以将进程视为处于以下三种运行状态之一
Dialogue: 0,0:33:17.12,0:33:22.06,English,,0,0,0,,Running, so in this case the process is actually running and executes instructions
Dialogue: 0,0:33:17.12,0:33:22.06,Chinese,,0,0,0,,「运行」在这种情况下，该进程实际上正在运行并执行指令
Dialogue: 0,0:33:22.68,0:33:25.74,English,,0,0,0,,Or it can be scheduled
Dialogue: 0,0:33:22.68,0:33:25.74,Chinese,,0,0,0,,或者它可以被调度
Dialogue: 0,0:33:25.74,0:33:28.88,English,,0,0,0,,Maybe it's not running but it can be scheduled at a later time
Dialogue: 0,0:33:25.74,0:33:28.88,Chinese,,0,0,0,,也许它没有运行但可以在稍后时间调度
Dialogue: 0,0:33:31.12,0:33:33.24,English,,0,0,0,,And it's waiting is waiting to be scheduled
Dialogue: 0,0:33:31.12,0:33:33.24,Chinese,,0,0,0,,等待，等待被调度
Dialogue: 0,0:33:33.98,0:33:39.36,English,,0,0,0,,It can be stopped which means that execution is suspended
Dialogue: 0,0:33:33.98,0:33:39.36,Chinese,,0,0,0,,它可以被停止，这意味着执行被暂停
Dialogue: 0,0:33:40.68,0:33:42.80,English,,0,0,0,,And won't be scheduled until further notice
Dialogue: 0,0:33:40.68,0:33:42.80,Chinese,,0,0,0,,并且在进一步通知之前不会调度
Dialogue: 0,0:33:42.82,0:33:46.10,English,,0,0,0,,So we'll see how this works when we study signals in the next lecture
Dialogue: 0,0:33:42.82,0:33:46.10,Chinese,,0,0,0,,当我们在下一讲课中研究信号时，我们将看到它是如何工作的
Dialogue: 0,0:33:46.28,0:33:51.28,English,,0,0,0,,But usually a process is stopped because it receives a certain kind of signal
Dialogue: 0,0:33:46.28,0:33:51.28,Chinese,,0,0,0,,但通常一个进程会停止，是因为它收到某种「信号」
Dialogue: 0,0:33:51.78,0:33:55.76,English,,0,0,0,,And then that the process becomes stopped in ways it won't be executed
Dialogue: 0,0:33:51.78,0:33:55.76,Chinese,,0,0,0,,然后，该进程以不会被执行，即停止
Dialogue: 0,0:33:56.42,0:34:02.46,English,,0,0,0,,It won't be scheduled until you explicitly tell it to be scheduled
Dialogue: 0,0:33:56.42,0:34:02.46,Chinese,,0,0,0,,在你明确告知其调度之前，不会调度它
Dialogue: 0,0:34:02.88,0:34:06.60,English,,0,0,0,,Or process can be terminated which means it stopped permanently
Dialogue: 0,0:34:02.88,0:34:06.60,Chinese,,0,0,0,,或者可以终止进程，这意味着它永久停止
Dialogue: 0,0:34:06.84,0:34:08.94,English,,0,0,0,,Okay so it'll never be scheduled again it's done
Dialogue: 0,0:34:06.84,0:34:08.94,Chinese,,0,0,0,,它永远不会再被安排完成了
Dialogue: 0,0:34:11.58,0:34:14.80,English,,0,0,0,,Now a process can be terminated for one of three reasons
Dialogue: 0,0:34:11.58,0:34:14.80,Chinese,,0,0,0,,终止一个进程可能有如下三个原因
Dialogue: 0,0:34:15.48,0:34:20.26,English,,0,0,0,,So one it receives a signal whose default action is to terminate it
Dialogue: 0,0:34:15.48,0:34:20.26,Chinese,,0,0,0,,它接收一个信号，其默认操作是终止它
Dialogue: 0,0:34:20.86,0:34:24.86,English,,0,0,0,,Or your program returns from the main routine
Dialogue: 0,0:34:20.86,0:34:24.86,Chinese,,0,0,0,,或者你的程序从主程序返回
Dialogue: 0,0:34:25.16,0:34:28.84,English,,0,0,0,,So you know you can...if you know the definition for main is int
Dialogue: 0,0:34:25.16,0:34:28.84,Chinese,,0,0,0,,你知道你可以...如果你知道 main 函数的定义类型是 int
Dialogue: 0,0:34:30.02,0:34:31.82,English,,0,0,0,,C main routines always return an int
Dialogue: 0,0:34:30.02,0:34:31.82,Chinese,,0,0,0,,C 语言主程序总是返回一个 int 值
Dialogue: 0,0:34:32.78,0:34:35.22,English,,0,0,0,,So you can return from main and that will terminate your
Dialogue: 0,0:34:32.78,0:34:35.22,Chinese,,0,0,0,,你可以从 main 函数返回，这将终止你的进程
Dialogue: 0,0:34:35.74,0:34:40.52,English,,0,0,0,,Event it will terminate the process or you can explicitly call the exit function
Dialogue: 0,0:34:35.74,0:34:40.52,Chinese,,0,0,0,,或者你可以显式调用 exit 函数
Dialogue: 0,0:34:41.96,0:34:49.06,English,,0,0,0,,The exit function exits the program with an exit status of the of its argument
Dialogue: 0,0:34:41.96,0:34:49.06,Chinese,,0,0,0,,exit 函数功能就是退出程序，其退出状态为其参数
Dialogue: 0,0:34:49.76,0:34:56.02,English,,0,0,0,,So as as you pointed out that the convention is that for normal return is to return 0
Dialogue: 0,0:34:49.76,0:34:56.02,Chinese,,0,0,0,,正如你所指出的那样，惯例是正常返回是返回 0
Dialogue: 0,0:34:56.34,0:34:57.72,English,,0,0,0,,And then nonzero on error
Dialogue: 0,0:34:56.34,0:34:57.72,Chinese,,0,0,0,,若非零就是错误
Dialogue: 0,0:34:59.36,0:35:04.62,English,,0,0,0,,Or you can...another way to do this is just return an integer value from the main routine
Dialogue: 0,0:34:59.36,0:35:04.62,Chinese,,0,0,0,,或者你可以...另一种方法是从主程序中返回一个整数值
Dialogue: 0,0:35:04.86,0:35:06.34,English,,0,0,0,,And that will set the exit status
Dialogue: 0,0:35:04.86,0:35:06.34,Chinese,,0,0,0,,这将设置退出状态
Dialogue: 0,0:35:07.54,0:35:09.44,English,,0,0,0,,Now exit is kind of unusual
Dialogue: 0,0:35:07.54,0:35:09.44,Chinese,,0,0,0,,exit 函数有点不一样
Dialogue: 0,0:35:09.44,0:35:13.96,English,,0,0,0,,And you'll see this is typical of all these process control functions
Dialogue: 0,0:35:09.44,0:35:13.96,Chinese,,0,0,0,,你会发现这是所有这些进程控制功能的典型特征
Dialogue: 0,0:35:14.54,0:35:18.90,English,,0,0,0,,That they normally functions you call them once and then they return once
Dialogue: 0,0:35:14.54,0:35:18.90,Chinese,,0,0,0,,它们通常起作用，你只调用一次，然后它们返回一次
Dialogue: 0,0:35:19.54,0:35:22.50,English,,0,0,0,,Okay but exit you call once and then it never returns
Dialogue: 0,0:35:19.54,0:35:22.50,Chinese,,0,0,0,,但你调用 exit 一次，它不会返回
Dialogue: 0,0:35:23.32,0:35:27.46,English,,0,0,0,,Okay so that's a little unusual
Dialogue: 0,0:35:23.32,0:35:27.46,Chinese,,0,0,0,,这有点不寻常
Dialogue: 0,0:35:29.14,0:35:34.02,English,,0,0,0,,Now a parent process can create a child process by calling the fork function
Dialogue: 0,0:35:29.14,0:35:34.02,Chinese,,0,0,0,,父进程可以通过调用 fork 函数来创建子进程
Dialogue: 0,0:35:35.86,0:35:39.26,English,,0,0,0,,So fork takes no arguments
Dialogue: 0,0:35:35.86,0:35:39.26,Chinese,,0,0,0,,fork 没有参数
Dialogue: 0,0:35:41.94,0:35:47.54,English,,0,0,0,,And it returns an integer,it creates a new child process
Dialogue: 0,0:35:41.94,0:35:47.54,Chinese,,0,0,0,,它返回一个整数，并且创建一个新的子进程
Dialogue: 0,0:35:49.70,0:35:53.18,English,,0,0,0,,And then it returns in both the parent and the child
Dialogue: 0,0:35:49.70,0:35:53.18,Chinese,,0,0,0,,然后它在父进程和子进程都各自返回一次
Dialogue: 0,0:35:55.26,0:35:57.72,English,,0,0,0,,So this is a little hard to wrap your head around at first
Dialogue: 0,0:35:55.26,0:35:57.72,Chinese,,0,0,0,,一开始，这有点难以理解
Dialogue: 0,0:35:58.02,0:36:00.24,English,,0,0,0,,It's called once by the parent
Dialogue: 0,0:35:58.02,0:36:00.24,Chinese,,0,0,0,,它由父进程调用一次
Dialogue: 0,0:36:01.58,0:36:08.16,English,,0,0,0,,But then it returns in both...it creates a new process and then it returns in both the parent and the child
Dialogue: 0,0:36:01.58,0:36:08.16,Chinese,,0,0,0,,但随后它返回...它创建一个新进程，然后它在父进程和子进程分别返回
Dialogue: 0,0:36:09.82,0:36:11.90,English,,0,0,0,,And to the child it returns 0
Dialogue: 0,0:36:09.82,0:36:11.90,Chinese,,0,0,0,,对于子进程，它返回 0
Dialogue: 0,0:36:13.12,0:36:16.52,English,,0,0,0,,To the parent return it returns to the child's process id
Dialogue: 0,0:36:13.12,0:36:16.52,Chinese,,0,0,0,,对于父进程返回，它返回子进程的 pid
Dialogue: 0,0:36:21.86,0:36:26.12,English,,0,0,0,,The child gets an identical copy of the parents virtual address space
Dialogue: 0,0:36:21.86,0:36:26.12,Chinese,,0,0,0,,子进程获得父进程虚拟地址空间的相同副本
Dialogue: 0,0:36:26.94,0:36:29.99,English,,0,0,0,,But separate right there they're distinct
Dialogue: 0,0:36:26.94,0:36:29.99,Chinese,,0,0,0,,但是它们却不是同一份
Dialogue: 0,0:36:30.86,0:36:37.36,English,,0,0,0,,But immediately after the fork returns the addresses the address space is identical
Dialogue: 0,0:36:30.86,0:36:37.36,Chinese,,0,0,0,,但是在 fork 返回地址之后，地址空间是相同的
Dialogue: 0,0:36:37.70,0:36:43.56,English,,0,0,0,,So that means that all the variables,all the global variables the stack  the code
Dialogue: 0,0:36:37.70,0:36:43.56,Chinese,,0,0,0,,这意味着所有变量，全局变量，栈，代码
Dialogue: 0,0:36:44.22,0:36:50.10,English,,0,0,0,,Everything is identical and the child it has the exact same values as it as it does in the parent
Dialogue: 0,0:36:44.22,0:36:50.10,Chinese,,0,0,0,,一切都是相同的，子进程与父进程具有完全相同的值
Dialogue: 0,0:36:51.86,0:36:56.98,English,,0,0,0,,The child gets identical copies of the parents open open file descriptors
Dialogue: 0,0:36:51.86,0:36:56.98,Chinese,,0,0,0,,子进程获得父进程打开文件描述符的相同副本
Dialogue: 0,0:36:57.02,0:37:04.16,English,,0,0,0,,So the child has access to any open files including like standard in and standard out that the parent had
Dialogue: 0,0:36:57.02,0:37:04.16,Chinese,,0,0,0,,子进程可以访问任何已打开的文件，包括父进程拥有的标准输入和标准输出
Dialogue: 0,0:37:05.60,0:37:09.50,English,,0,0,0,,And the only difference is that the child gets a different process id than the parent
Dialogue: 0,0:37:05.60,0:37:09.50,Chinese,,0,0,0,,唯一的区别是子进程获得的进程ID与父进程不同
Dialogue: 0,0:37:10.88,0:37:12.78,English,,0,0,0,,So fork is really strange
Dialogue: 0,0:37:10.88,0:37:12.78,Chinese,,0,0,0,,fork 很奇怪
Dialogue: 0,0:37:13.66,0:37:19.02,English,,0,0,0,,Because it's called once,but returns twice once, in the parent and once in the child
Dialogue: 0,0:37:13.66,0:37:19.02,Chinese,,0,0,0,,因为它被调用一次，但返回两次，在父进程中返回，在子进程中也返回
Dialogue: 0,0:37:21.56,0:37:23.04,English,,0,0,0,,So here's an example of this
Dialogue: 0,0:37:21.56,0:37:23.04,Chinese,,0,0,0,,这是一个例子
Dialogue: 0,0:37:25.94,0:37:34.66,English,,0,0,0,,Here's...this is an example program, it has a local variable called x on the stack initialized to 1
Dialogue: 0,0:37:25.94,0:37:34.66,Chinese,,0,0,0,,这是一个示例程序，它在堆栈上有一个名为 x 的局部变量，初始化为 1
Dialogue: 0,0:37:36.62,0:37:48.60,English,,0,0,0,,And then it calls fork and fork creates the child and returns a value to that both the parent and the child
Dialogue: 0,0:37:36.62,0:37:48.60,Chinese,,0,0,0,,然后调用 fork ，fork 创建子进程并向父进程和子进程返回一个值
Dialogue: 0,0:37:50.56,0:37:55.84,English,,0,0,0,,The only way we can distinguish whether we're executing in the parent or the child is to check that return value
Dialogue: 0,0:37:50.56,0:37:55.84,Chinese,,0,0,0,,区分是在父项还是在子项中执行的唯一方法是，检查返回值
Dialogue: 0,0:37:56.84,0:38:00.02,English,,0,0,0,,Okay so here if the process id ，if pid == 0
Dialogue: 0,0:37:56.84,0:38:00.02,Chinese,,0,0,0,,如果进程的pid == 0
Dialogue: 0,0:38:00.52,0:38:02.02,English,,0,0,0,,Then we're executing in the child
Dialogue: 0,0:38:00.52,0:38:02.02,Chinese,,0,0,0,,那我们就是在子进程上执行
Dialogue: 0,0:38:02.74,0:38:14.10,English,,0,0,0,,Now remember the child got exactly the same has exactly the same memory and encode is the parent
Dialogue: 0,0:38:02.74,0:38:14.10,Chinese,,0,0,0,,记住，子进程得到的是和父进程完全相同的内存和代码
Dialogue: 0,0:38:15.14,0:38:18.46,English,,0,0,0,,So x in the child is 1
Dialogue: 0,0:38:15.14,0:38:18.46,Chinese,,0,0,0,,子进程的 x 是 1
Dialogue: 0,0:38:18.86,0:38:25.20,English,,0,0,0,,So when we print this message from the child,we increment x and then print this message
Dialogue: 0,0:38:18.86,0:38:25.20,Chinese,,0,0,0,,当我们从子进程打印此消息时，我们增加 x 然后打印此消息
Dialogue: 0,0:38:25.80,0:38:29.52,English,,0,0,0,,So the child will print 1+1=2
Dialogue: 0,0:38:25.80,0:38:29.52,Chinese,,0,0,0,,子进程会打印 1 + 1 = 2
Dialogue: 0,0:38:30.52,0:38:31.56,English,,0,0,0,,And then exit
Dialogue: 0,0:38:30.52,0:38:31.56,Chinese,,0,0,0,,然后退出
Dialogue: 0,0:38:33.60,0:38:36.40,English,,0,0,0,,In the parent when we check that this process id
Dialogue: 0,0:38:33.60,0:38:36.40,Chinese,,0,0,0,,在父进程中我们检查此进程是否为 0
Dialogue: 0,0:38:36.40,0:38:39.96,English,,0,0,0,,It's going to be nonzero because it's the process id of the child
Dialogue: 0,0:38:36.40,0:38:39.96,Chinese,,0,0,0,,它将是非零的，因为它是子进程的​​进程ID
Dialogue: 0,0:38:40.56,0:38:46.52,English,,0,0,0,,So in this case...so the parent won't execute this the body of this conditional
Dialogue: 0,0:38:40.56,0:38:46.52,Chinese,,0,0,0,,在这种情况下......父进程不会执行这个条件块
Dialogue: 0,0:38:47.28,0:38:49.60,English,,0,0,0,,So the parent will execute this printf
Dialogue: 0,0:38:47.28,0:38:49.60,Chinese,,0,0,0,,父进程将执行此 printf
Dialogue: 0,0:38:50.20,0:38:53.00,English,,0,0,0,,And in the parent we decrement x before we print it
Dialogue: 0,0:38:50.20,0:38:53.00,Chinese,,0,0,0,,在父进程中，我们在打印之前递减 x
Dialogue: 0,0:38:53.46,0:38:57.18,English,,0,0,0,,So the parent prints out 1-1 is 0
Dialogue: 0,0:38:53.46,0:38:57.18,Chinese,,0,0,0,,父进程打印出的是 1-1 ，是 0
Dialogue: 0,0:38:58.84,0:39:05.04,English,,0,0,0,,Now there's no guarantee we have no guarantee whether the child or the parent executes first
Dialogue: 0,0:38:58.84,0:39:05.04,Chinese,,0,0,0,,我们无法保证子进程还是父进程先执行
Dialogue: 0,0:39:05.04,0:39:07.46,English,,0,0,0,,It could at when the fork
Dialogue: 0,0:39:05.04,0:39:07.46,Chinese,,0,0,0,,在 fork 时
Dialogue: 0,0:39:08.34,0:39:12.46,English,,0,0,0,,When the fork returns the kernel may decide to schedule the child first
Dialogue: 0,0:39:08.34,0:39:12.46,Chinese,,0,0,0,,当 fork 返回时，内核可能会决定先安排子进程
Dialogue: 0,0:39:13.70,0:39:18.40,English,,0,0,0,,Okay in which case this code in the body of the conditional would run
Dialogue: 0,0:39:13.70,0:39:18.40,Chinese,,0,0,0,,在这种情况下，条件体中的代码将运行
Dialogue: 0,0:39:18.96,0:39:22.20,English,,0,0,0,,Or it may decide to run the parent first okay
Dialogue: 0,0:39:18.96,0:39:22.20,Chinese,,0,0,0,,或者它可能决定首先运行父进程
Dialogue: 0,0:39:23.00,0:39:28.06,English,,0,0,0,,And there's no way to predict and you it's is wrong,it's an error to make any assumption
Dialogue: 0,0:39:23.00,0:39:28.06,Chinese,,0,0,0,,并且没有办法预测，而且你，做出任何假设都是错误的
Dialogue: 0,0:39:28.92,0:39:31.36,English,,0,0,0,,Like that about what's going to run first the parent of the child
Dialogue: 0,0:39:28.92,0:39:31.36,Chinese,,0,0,0,,关于子进程父进程，谁将先运行
Dialogue: 0,0:39:33.06,0:39:35.90,English,,0,0,0,,And you can see that they share the same open files because
Dialogue: 0,0:39:33.06,0:39:35.90,Chinese,,0,0,0,,你可以看到他们共享相同的打开文件，因为
Dialogue: 0,0:39:36.64,0:39:42.24,English,,0,0,0,,Both the parent and the child print to standard out and it prints on the terminal okay
Dialogue: 0,0:39:36.64,0:39:42.24,Chinese,,0,0,0,,父进程和子进程都打印到标准输出，它在终端上打印好了
Dialogue: 0,0:39:43.04,0:39:46.54,English,,0,0,0,,Yes
Dialogue: 0,0:39:43.04,0:39:46.54,Chinese,,0,0,0,,是
Dialogue: 0,0:39:46.58,0:39:50.44,English,,0,0,0,,Oh what if...the question is what if you call fork multiple times, I'll show you some examples of those
Dialogue: 0,0:39:46.58,0:39:50.44,Chinese,,0,0,0,,哦，如果......问题是如果你多次调用 fork，我将向你展示一些例子
Dialogue: 0,0:39:52.70,0:39:59.78,English,,0,0,0,,It gets a little hairy will have...will use a model called the process graph to sort sort of understand what happens
Dialogue: 0,0:39:52.70,0:39:59.78,Chinese,,0,0,0,,它会有点难以理解......可以使用一个叫做「进程图」的模型来排序，理解会发生什么
Dialogue: 0,0:40:04.52,0:40:10.88,English,,0,0,0,,Okay so like just like you said forks,forks can be kind of complex
Dialogue: 0,0:40:04.52,0:40:10.88,Chinese,,0,0,0,,好吧就像你说的 forks (叉子)一样，不过这把forks（叉子）可能有点复杂
Dialogue: 0,0:40:11.12,0:40:14.52,English,,0,0,0,,And time to sin especially if they're nested or you call them multiple times
Dialogue: 0,0:40:11.12,0:40:14.52,Chinese,,0,0,0,,还有随着时间，特别是如果它们是嵌套的，或者你多次调用它们
Dialogue: 0,0:40:15.12,0:40:24.54,English,,0,0,0,,So we use a tool called the process graph to capture sort of what could happen when we call forks
Dialogue: 0,0:40:15.12,0:40:24.54,Chinese,,0,0,0,,我们使用一种称为进程图的工具，来捕捉我们调用 forks 时可能发生的情况
Dialogue: 0,0:40:24.66,0:40:30.18,English,,0,0,0,,Right we can't make any assumption about the ordering of of different processes
Dialogue: 0,0:40:24.66,0:40:30.18,Chinese,,0,0,0,,对，我们不能对不同进程的运行顺序做出任何假设
Dialogue: 0,0:40:30.50,0:40:35.88,English,,0,0,0,,But we can capture the partial ordering of events using this tool called a process graph
Dialogue: 0,0:40:30.50,0:40:35.88,Chinese,,0,0,0,,但我们可以使用称为进程图的工具来了解事件的次序
Dialogue: 0,0:40:36.86,0:40:41.20,English,,0,0,0,,So what we'll do is we'll let each vertex correspond to the execution of a statement
Dialogue: 0,0:40:36.86,0:40:41.20,Chinese,,0,0,0,,我们要做的是让每个顶点对应一个语句的执行
Dialogue: 0,0:40:42.06,0:40:46.84,English,,0,0,0,,And then an edge is that happens before relation so a happens before b
Dialogue: 0,0:40:42.06,0:40:46.84,Chinese,,0,0,0,,然后边是在点之前发生的， a 在 b 之前发生
Dialogue: 0,0:40:47.38,0:40:50.16,English,,0,0,0,,And we will label edges with current values of variables
Dialogue: 0,0:40:47.38,0:40:50.16,Chinese,,0,0,0,,我们将使用当前变量值标记边
Dialogue: 0,0:40:50.94,0:40:52.94,English,,0,0,0,,If we have a printf vertices
Dialogue: 0,0:40:50.94,0:40:52.94,Chinese,,0,0,0,,如果我们有一个 printf 顶点
Dialogue: 0,0:40:53.38,0:40:57.44,English,,0,0,0,,A printed x that corresponds to a printf we can label that with the output
Dialogue: 0,0:40:53.38,0:40:57.44,Chinese,,0,0,0,,打印的 x 对应于 printf，我们可以用输出标记
Dialogue: 0,0:40:58.28,0:41:02.38,English,,0,0,0,,And then the every graph starts with a vertex with no inedges
Dialogue: 0,0:40:58.28,0:41:02.38,Chinese,,0,0,0,,每个图形都以没有入边的顶点开始
Dialogue: 0,0:41:03.56,0:41:07.28,English,,0,0,0,,So given this graph then any topological sort of the graph represents
Dialogue: 0,0:41:03.56,0:41:07.28,Chinese,,0,0,0,,给定此图，任何拓扑类型的图代表着
Dialogue: 0,0:41:07.58,0:41:11.98,English,,0,0,0,,Some feasible total ordering of events
Dialogue: 0,0:41:07.58,0:41:11.98,Chinese,,0,0,0,,一些可行的事件总排序
Dialogue: 0,0:41:13.08,0:41:17.30,English,,0,0,0,,And by topological sort we mean a total ordering of the vertices
Dialogue: 0,0:41:13.08,0:41:17.30,Chinese,,0,0,0,,通过拓扑排序，我们指的是顶点的总排序
Dialogue: 0,0:41:17.40,0:41:19.98,English,,0,0,0,,Where all the edges go from left to right
Dialogue: 0,0:41:17.40,0:41:19.98,Chinese,,0,0,0,,所有边按照从左到右的顺序
Dialogue: 0,0:41:22.18,0:41:24.82,English,,0,0,0,,Okay so let's look at how this would work for our example program
Dialogue: 0,0:41:22.18,0:41:24.82,Chinese,,0,0,0,,让我们来看看它如何适用于我们的示例程序
Dialogue: 0,0:41:27.04,0:41:31.74,English,,0,0,0,,Here we have the parent initially x==1
Dialogue: 0,0:41:27.04,0:41:31.74,Chinese,,0,0,0,,这里我们的父进程最初是 x == 1
Dialogue: 0,0:41:32.60,0:41:34.12,English,,0,0,0,,And then the parent calls fork
Dialogue: 0,0:41:32.60,0:41:34.12,Chinese,,0,0,0,,然后父进程调用 fork
Dialogue: 0,0:41:36.00,0:41:39.72,English,,0,0,0,,The fork returns in both the parent and the child
Dialogue: 0,0:41:36.00,0:41:39.72,Chinese,,0,0,0,,fork 在父进程和子进程中返回
Dialogue: 0,0:41:40.88,0:41:48.76,English,,0,0,0,,The child prints...and both the parent and the child print the value of x  after incrementing or decrementing
Dialogue: 0,0:41:40.88,0:41:48.76,Chinese,,0,0,0,,子进程打印...父进程和子进程在递增或递减后均打印 x 的值
Dialogue: 0,0:41:49.38,0:41:50.46,English,,0,0,0,,And then they both exit
Dialogue: 0,0:41:49.38,0:41:50.46,Chinese,,0,0,0,,然后他们都退出了
Dialogue: 0,0:41:51.44,0:41:52.84,English,,0,0,0,,Ok so you can think of these
Dialogue: 0,0:41:51.44,0:41:52.84,Chinese,,0,0,0,,你可以想到这些
Dialogue: 0,0:41:54.76,0:42:01.94,English,,0,0,0,,As happening...so these happen concurrently right which means they can be interleaved in any way the
Dialogue: 0,0:41:54.76,0:42:01.94,Chinese,,0,0,0,,正如所发生的......这意味着它们可以以任何方式交替进行
Dialogue: 0,0:42:01.94,0:42:07.84,English,,0,0,0,,So the topological sort of this graph will tell us a feasible
Dialogue: 0,0:42:01.94,0:42:07.84,Chinese,,0,0,0,,这个图的拓扑类型将告诉我们一个可行的
Dialogue: 0,0:42:08.48,0:42:11.06,English,,0,0,0,,What's a feasible? What feasible inter leavings?
Dialogue: 0,0:42:08.48,0:42:11.06,Chinese,,0,0,0,,什么是可行的？可能的交替顺序是什么？
Dialogue: 0,0:42:14.26,0:42:18.96,English,,0,0,0,,Okay so we can...so if we real able the graph just to keep it simple
Dialogue: 0,0:42:14.26,0:42:18.96,Chinese,,0,0,0,,如果我们真的能够让图表保持简单
Dialogue: 0,0:42:18.96,0:42:22.68,English,,0,0,0,,So if we real able these edges with just single letters
Dialogue: 0,0:42:18.96,0:42:22.68,Chinese,,0,0,0,,我们只用一个字母就可以实现这些边缘
Dialogue: 0,0:42:25.76,0:42:30.04,English,,0,0,0,,Then this total ordering abecfd
Dialogue: 0,0:42:25.76,0:42:30.04,Chinese,,0,0,0,,然后这个总排序 abecfd
Dialogue: 0,0:42:30.80,0:42:36.04,English,,0,0,0,,Represent is represents it's a topological sort and thus a feasible total ordering
Dialogue: 0,0:42:30.80,0:42:36.04,Chinese,,0,0,0,,表示它是拓扑排序，是可行的总排序
Dialogue: 0,0:42:36.56,0:42:40.40,English,,0,0,0,,So here we have a executing then b
Dialogue: 0,0:42:36.56,0:42:40.40,Chinese,,0,0,0,,这里我们使 a 执行然后 b
Dialogue: 0,0:42:41.60,0:42:43.36,English,,0,0,0,,Then e execute in the child
Dialogue: 0,0:42:41.60,0:42:43.36,Chinese,,0,0,0,,然后 e 执行子进程
Dialogue: 0,0:42:44.50,0:42:55.70,English,,0,0,0,,And then at this point the kernel decides to swap out,swap out e, swap out the child and now let the parent run
Dialogue: 0,0:42:44.50,0:42:55.70,Chinese,,0,0,0,,然后在这一点上，内核决定换出 e，换掉子进程，现在让父进程运行
Dialogue: 0,0:42:56.12,0:42:59.44,English,,0,0,0,,So the parent picks up and executes c
Dialogue: 0,0:42:56.12,0:42:59.44,Chinese,,0,0,0,,父进程选择并执行 c
Dialogue: 0,0:43:01.04,0:43:06.12,English,,0,0,0,,And then it gets rescheduled to chat then the child gets scheduled and executes f
Dialogue: 0,0:43:01.04,0:43:06.12,Chinese,,0,0,0,,然后它被重新安排进行会话，然后子进程被安排并执行 f
Dialogue: 0,0:43:06.54,0:43:09.48,English,,0,0,0,,And then the parent the parent runs and finally finishes
Dialogue: 0,0:43:06.54,0:43:09.48,Chinese,,0,0,0,,然后是父进程运行，最后完成
Dialogue: 0,0:43:10.18,0:43:12.76,English,,0,0,0,,Right so this is very unlikely that
Dialogue: 0,0:43:10.18,0:43:12.76,Chinese,,0,0,0,,对，这是不可能的
Dialogue: 0,0:43:13.28,0:43:20.20,English,,0,0,0,,It you only execute one instruction and then b,and then have a context switch but it's it's feasible
Dialogue: 0,0:43:13.28,0:43:20.20,Chinese,,0,0,0,,它只执行一条指令然后执行 b，然后进行上下文切换，但这是可行的
Dialogue: 0,0:43:20.98,0:43:22.45,English,,0,0,0,,Right because it represents
Dialogue: 0,0:43:20.98,0:43:22.45,Chinese,,0,0,0,,对，因为它代表了
Dialogue: 0,0:43:23.28,0:43:27.88,English,,0,0,0,,Because the total ordering is a topological ordering
Dialogue: 0,0:43:23.28,0:43:27.88,Chinese,,0,0,0,,因为总排序是拓扑排序
Dialogue: 0,0:43:29.16,0:43:34.70,English,,0,0,0,,On the other hand this is infeasible because f
Dialogue: 0,0:43:29.16,0:43:34.70,Chinese,,0,0,0,,另一方面，这是不可行的，因为 f
Dialogue: 0,0:43:35.66,0:43:39.48,English,,0,0,0,,Here in this total ordering we're executing f before e
Dialogue: 0,0:43:35.66,0:43:39.48,Chinese,,0,0,0,,在这个总排序中，我们在 e 之前执行 f
Dialogue: 0,0:43:40.30,0:43:43.26,English,,0,0,0,,And you can see that this that just can't happen right
Dialogue: 0,0:43:40.30,0:43:43.26,Chinese,,0,0,0,,你可以看到，这是不可能发生的
Dialogue: 0,0:43:43.26,0:43:47.96,English,,0,0,0,,So the edges on these the logical flow represented by this child
Dialogue: 0,0:43:43.26,0:43:47.96,Chinese,,0,0,0,,这些逻辑流上的边由它们的子进程表示
Dialogue: 0,0:43:48.20,0:43:51.82,English,,0,0,0,,Have to occur in this order first e and then f right
Dialogue: 0,0:43:48.20,0:43:51.82,Chinese,,0,0,0,,必须先按此顺序发生 e 然后再向右进行
Dialogue: 0,0:43:51.92,0:43:59.92,English,,0,0,0,,By the just because f follows e in the code right that the compilers not
Dialogue: 0,0:43:51.92,0:43:59.92,Chinese,,0,0,0,,仅仅因为 f 在代码中跟随 e 而编译器没有
Dialogue: 0,0:44:04.02,0:44:04.98,English,,0,0,0,,Going to it's not going to alter those
Dialogue: 0,0:44:04.02,0:44:04.98,Chinese,,0,0,0,,它不会改变那些
Dialogue: 0,0:44:07.06,0:44:09.64,English,,0,0,0,,Okay so what happens if now we have two consecutive forks
Dialogue: 0,0:44:07.06,0:44:09.64,Chinese,,0,0,0,,如果现在我们有两个连续的 forks 会发生什么
Dialogue: 0,0:44:13.46,0:44:17.56,English,,0,0,0,,Well let's draw the process graph will help us understand this
Dialogue: 0,0:44:13.46,0:44:17.56,Chinese,,0,0,0,,那么让我们绘制流程图将有助于我们理解这一点
Dialogue: 0,0:44:18.38,0:44:22.78,English,,0,0,0,,So in the parent we print L0  and then fork
Dialogue: 0,0:44:18.38,0:44:22.78,Chinese,,0,0,0,,在父进程中我们打印 L0 然后 fork
Dialogue: 0,0:44:23.76,0:44:26.48,English,,0,0,0,,And that creates a child and both
Dialogue: 0,0:44:23.76,0:44:26.48,Chinese,,0,0,0,,这创造了一个子进程，
Dialogue: 0,0:44:27.44,0:44:31.04,English,,0,0,0,,And so the fork returns to this printf in both the parent and the child
Dialogue: 0,0:44:27.44,0:44:31.04,Chinese,,0,0,0,,fork在父进程和子进程中返回到此 printf
Dialogue: 0,0:44:31.04,0:44:34.58,English,,0,0,0,,So they both the parent and the child print L1
Dialogue: 0,0:44:31.04,0:44:34.58,Chinese,,0,0,0,,他们父进程和子进程都打印 L1
Dialogue: 0,0:44:36.86,0:44:39.40,English,,0,0,0,,And then both parent and child execute a fork
Dialogue: 0,0:44:36.86,0:44:39.40,Chinese,,0,0,0,,然后父和子都执行 fork
Dialogue: 0,0:44:41.54,0:44:47.22,English,,0,0,0,,So that creates another child,that creates two more,now two children
Dialogue: 0,0:44:41.54,0:44:47.22,Chinese,,0,0,0,,这样就创造了另一个子进程，创造了两个子进程，现在又创造了两个子进程
Dialogue: 0,0:44:48.48,0:44:53.90,English,,0,0,0,,And then and so that returns to the printf which says bye
Dialogue: 0,0:44:48.48,0:44:53.90,Chinese,,0,0,0,,然后又返回到输出 Bye 的 printf
Dialogue: 0,0:44:54.80,0:44:59.50,English,,0,0,0,,So the result of this of calling fork twice like this is that it creates four processes
Dialogue: 0,0:44:54.80,0:44:59.50,Chinese,,0,0,0,,调用 fork 两次这样的结果是它创建了四个进程
Dialogue: 0,0:45:01.40,0:45:02.16,English,,0,0,0,,And you can
Dialogue: 0,0:45:01.40,0:45:02.16,Chinese,,0,0,0,,你可以
Dialogue: 0,0:45:02.80,0:45:06.66,English,,0,0,0,,And if it's confusing you can always work it out with the the process graph like this
Dialogue: 0,0:45:02.80,0:45:06.66,Chinese,,0,0,0,,如果它令人困惑，你可以随时使用这样的流程图
Dialogue: 0,0:45:07.18,0:45:11.84,English,,0,0,0,,Okay so we can see feasible and infeasible orderings
Dialogue: 0,0:45:07.18,0:45:11.84,Chinese,,0,0,0,,我们可以看到可行和不可行的排序
Dialogue: 0,0:45:12.66,0:45:14.68,English,,0,0,0,,So this one's feasible take my word for
Dialogue: 0,0:45:12.66,0:45:14.68,Chinese,,0,0,0,,所以我说这个是可行的
Dialogue: 0,0:45:14.70,0:45:16.92,English,,0,0,0,,This one is infeasible
Dialogue: 0,0:45:14.70,0:45:16.92,Chinese,,0,0,0,,这个是不可行的
Dialogue: 0,0:45:17.62,0:45:19.88,English,,0,0,0,,And let's see why so L0
Dialogue: 0,0:45:17.62,0:45:19.88,Chinese,,0,0,0,,让我们看看为什么 L0 如此
Dialogue: 0,0:45:22.06,0:45:28.18,English,,0,0,0,,And there's no way to print by before the first fork
Dialogue: 0,0:45:22.06,0:45:28.18,Chinese,,0,0,0,,并且在第一个分叉之前没有办法打印
Dialogue: 0,0:45:28.56,0:45:29.66,English,,0,0,0,,All right so that's infeasible
Dialogue: 0,0:45:28.56,0:45:29.66,Chinese,,0,0,0,,这是不可行的
Dialogue: 0,0:45:29.82,0:45:34.82,English,,0,0,0,,If we drew out this process graph we'd have a backward edge
Dialogue: 0,0:45:29.82,0:45:34.82,Chinese,,0,0,0,,如果我们绘制出这个流程图，我们就会有一个后边
Dialogue: 0,0:45:38.38,0:45:41.47,English,,0,0,0,,Okay now what happens if we nest forks in the parent
Dialogue: 0,0:45:38.38,0:45:41.47,Chinese,,0,0,0,,如果我们在父进程中嵌套 forks 会发生什么
Dialogue: 0,0:45:41.88,0:45:45.60,English,,0,0,0,,Okay I'm not sure why you'd want to do this except maybe to torture 213 students
Dialogue: 0,0:45:41.88,0:45:45.60,Chinese,,0,0,0,,我不知道你为什么要这样做，除非想要折磨 213班上的学生
Dialogue: 0,0:45:46.78,0:45:47.22,English,,0,0,0,,But
Dialogue: 0,0:45:46.78,0:45:47.22,Chinese,,0,0,0,,但
Dialogue: 0,0:45:50.80,0:45:53.50,English,,0,0,0,,So we can just work this out by drawing the process graph
Dialogue: 0,0:45:50.80,0:45:53.50,Chinese,,0,0,0,,我们可以通过绘制流程图来解决这个问题
Dialogue: 0,0:45:54.86,0:45:57.12,English,,0,0,0,,So here we have the parent it prints L0
Dialogue: 0,0:45:54.86,0:45:57.12,Chinese,,0,0,0,,这里我们有父进程打印 L0
Dialogue: 0,0:45:57.76,0:46:01.04,English,,0,0,0,,And then it does a fork so that creates a child
Dialogue: 0,0:45:57.76,0:46:01.04,Chinese,,0,0,0,,然后它做一个 fork ，以便创建一个子进程
Dialogue: 0,0:46:04.02,0:46:09.74,English,,0,0,0,,So the child if fork is not equal to 0
Dialogue: 0,0:46:04.02,0:46:09.74,Chinese,,0,0,0,,如果 fork 不等于 0
Dialogue: 0,0:46:10.86,0:46:13.82,English,,0,0,0,,Then we're in the parent right so this code executes in the parent
Dialogue: 0,0:46:10.86,0:46:13.82,Chinese,,0,0,0,,然后我们在父进程中，此代码在父进程中被执行
Dialogue: 0,0:46:15.44,0:46:16.88,English,,0,0,0,,If fork is 0
Dialogue: 0,0:46:15.44,0:46:16.88,Chinese,,0,0,0,,如果 fork() 为 0
Dialogue: 0,0:46:17.74,0:46:21.14,English,,0,0,0,,Then we're executing the child and the child just prints by and then
Dialogue: 0,0:46:17.74,0:46:21.14,Chinese,,0,0,0,,我们正在执行子进程，子进程只是打印
Dialogue: 0,0:46:23.06,0:46:28.78,English,,0,0,0,,And then terminate it eventually terminates I didn't show it here but  calls exit
Dialogue: 0,0:46:23.06,0:46:28.78,Chinese,,0,0,0,,然后终止它，我没有在这里显示终止，但是调用了 exit
Dialogue: 0,0:46:29.60,0:46:32.58,English,,0,0,0,,Think the function that called this function calls exit
Dialogue: 0,0:46:29.60,0:46:32.58,Chinese,,0,0,0,,认为调用此函数的函数调用 exit
Dialogue: 0,0:46:33.98,0:46:40.70,English,,0,0,0,,So the parent,so fork not equal to 0 indicates that this is the parent
Dialogue: 0,0:46:33.98,0:46:40.70,Chinese,,0,0,0,,fork() 不等于 0 表示这是父进程
Dialogue: 0,0:46:42.26,0:46:46.00,English,,0,0,0,,So the parent prints L1 and then it does another fork
Dialogue: 0,0:46:42.26,0:46:46.00,Chinese,,0,0,0,,父进程打印 L1，然后再做另一个 fork
Dialogue: 0,0:46:47.16,0:46:48.64,English,,0,0,0,,That fork creates a child
Dialogue: 0,0:46:47.16,0:46:48.64,Chinese,,0,0,0,,那个 fork 创造了一个子进程
Dialogue: 0,0:46:52.00,0:46:54.88,English,,0,0,0,,So if fork is not equal to 0
Dialogue: 0,0:46:52.00,0:46:54.88,Chinese,,0,0,0,,如果 fork() 不等于0
Dialogue: 0,0:46:55.50,0:47:02.50,English,,0,0,0,,Then we're in the parent so the parent prints L2 and then exits this conditional and prints by
Dialogue: 0,0:46:55.50,0:47:02.50,Chinese,,0,0,0,,我们在父进程那里，父进程打印 L2；然后退出这个条件判断，并打印
Dialogue: 0,0:47:03.62,0:47:08.90,English,,0,0,0,,If fork returns 0 then that means we're executing the child
Dialogue: 0,0:47:03.62,0:47:08.90,Chinese,,0,0,0,,如果 fork 返回0则表示我们正在执行子进程
Dialogue: 0,0:47:08.96,0:47:12.60,English,,0,0,0,,So we don't execute this code we jump out of this conditional
Dialogue: 0,0:47:08.96,0:47:12.60,Chinese,,0,0,0,,我们不执行这个代码，我们跳出这个条件
Dialogue: 0,0:47:12.98,0:47:15.32,English,,0,0,0,,And then the child just prints by
Dialogue: 0,0:47:12.98,0:47:15.32,Chinese,,0,0,0,,然后子进程就打印了
Dialogue: 0,0:47:16.32,0:47:16.72,English,,0,0,0,,Okay
Dialogue: 0,0:47:16.32,0:47:16.72,Chinese,,0,0,0,,好的
Dialogue: 0,0:47:19.26,0:47:20.26,English,,0,0,0,,And we can
Dialogue: 0,0:47:19.26,0:47:20.26,Chinese,,0,0,0,,我们可以
Dialogue: 0,0:47:23.76,0:47:27.42,English,,0,0,0,,So this represents an infeasible output from this program
Dialogue: 0,0:47:23.76,0:47:27.42,Chinese,,0,0,0,,这代表了该计划的不可行输出
Dialogue: 0,0:47:30.10,0:47:30.98,English,,0,0,0,,L0...
Dialogue: 0,0:47:30.10,0:47:30.98,Chinese,,0,0,0,,L0 ......
Dialogue: 0,0:47:32.74,0:47:36.02,English,,0,0,0,,So L0 followed by bye, that's feasible
Dialogue: 0,0:47:32.74,0:47:36.02,Chinese,,0,0,0,, L0 跟着 Bye，这是可行的
Dialogue: 0,0:47:37.18,0:47:39.56,English,,0,0,0,,And then followed by L1 that's okay
Dialogue: 0,0:47:37.18,0:47:39.56,Chinese,,0,0,0,,然后是 L1，那很好
Dialogue: 0,0:47:42.58,0:47:45.32,English,,0,0,0,,And then the next bye is okay but it since
Dialogue: 0,0:47:42.58,0:47:45.32,Chinese,,0,0,0,,然后下一个 Bye，但从那以后
Dialogue: 0,0:47:45.80,0:47:51.86,English,,0,0,0,,We can't have this...we can't have this by proceeding this L2
Dialogue: 0,0:47:45.80,0:47:51.86,Chinese,,0,0,0,,我们不能拥有这个...我们不能通过继续这个 L2
Dialogue: 0,0:47:52.74,0:47:58.08,English,,0,0,0,,Because L2 will this printf will execute before this printf
Dialogue: 0,0:47:52.74,0:47:58.08,Chinese,,0,0,0,,因为 L2 将在这个 printf 之前，执行这个 printf
Dialogue: 0,0:48:00.80,0:48:07.54,English,,0,0,0,,Okay and I'll let you work out this one as an exercise
Dialogue: 0,0:48:00.80,0:48:07.54,Chinese,,0,0,0,,我会让你把这个作为练习
Dialogue: 0,0:48:09.14,0:48:14.28,English,,0,0,0,,All right now when a process terminates for whatever reason
Dialogue: 0,0:48:09.14,0:48:14.28,Chinese,,0,0,0,,当一个进程因任何原因终止时，
Dialogue: 0,0:48:14.70,0:48:18.08,English,,0,0,0,,The system actually keeps it around for until it's reaped
Dialogue: 0,0:48:14.70,0:48:18.08,Chinese,,0,0,0,,系统实际上一直保持它直到它被「回收」（reaped）
Dialogue: 0,0:48:19.36,0:48:22.10,English,,0,0,0,,And the reason until it's reaped by its parent
Dialogue: 0,0:48:19.36,0:48:22.10,Chinese,,0,0,0,,直到它被父进程回收的原因
Dialogue: 0,0:48:23.20,0:48:28.38,English,,0,0,0,,And the reason it does this is that the parent may want to know about the exit status of the child
Dialogue: 0,0:48:23.20,0:48:28.38,Chinese,,0,0,0,,它这样做的原因是，父进程可能想知道子进程的退出状态
Dialogue: 0,0:48:28.40,0:48:30.56,English,,0,0,0,,So but if a parent creates a child
Dialogue: 0,0:48:28.40,0:48:30.56,Chinese,,0,0,0,,但如果父进程创建一个子进程
Dialogue: 0,0:48:31.04,0:48:35.90,English,,0,0,0,,It may want to wait for that child to finish and and check its exit status
Dialogue: 0,0:48:31.04,0:48:35.90,Chinese,,0,0,0,,它可能希望等待该子进程完成，并检查其退出状态
Dialogue: 0,0:48:36.76,0:48:38.60,English,,0,0,0,,So when any process terminates
Dialogue: 0,0:48:36.76,0:48:38.60,Chinese,,0,0,0,,当任何进程终止时
Dialogue: 0,0:48:38.96,0:48:43.52,English,,0,0,0,,The system leaves that it, doesn't remove it entirely from the system
Dialogue: 0,0:48:38.96,0:48:43.52,Chinese,,0,0,0,,系统离开它，不会完全从系统中删除它
Dialogue: 0,0:48:43.74,0:48:46.96,English,,0,0,0,,It keeps it a little bit of state associated with that child
Dialogue: 0,0:48:43.74,0:48:46.96,Chinese,,0,0,0,,它保持与子进程相关的一点状态信息
Dialogue: 0,0:48:47.40,0:48:50.88,English,,0,0,0,,In the form of a the exit status of the child
Dialogue: 0,0:48:47.40,0:48:50.88,Chinese,,0,0,0,,以子进程的退出状态的形式
Dialogue: 0,0:48:51.54,0:48:55.74,English,,0,0,0,,And the in some other tables some other OS tables
Dialogue: 0,0:48:51.54,0:48:55.74,Chinese,,0,0,0,,在其他一些表,如 OS 表
Dialogue: 0,0:48:56.70,0:49:00.38,English,,0,0,0,,So because this child that's terminated but it's not gone
Dialogue: 0,0:48:56.70,0:49:00.38,Chinese,,0,0,0,,因为这个子进程已经终止但它并没有消失
Dialogue: 0,0:49:01.04,0:49:04.42,English,,0,0,0,,It they're called zombies so there's sort of half half-living half-dead
Dialogue: 0,0:49:01.04,0:49:04.42,Chinese,,0,0,0,,它们被称为「僵尸进程」，半生半死
Dialogue: 0,0:49:08.34,0:49:11.16,English,,0,0,0,,And so a process a zombie
Dialogue: 0,0:49:08.34,0:49:11.16,Chinese,,0,0,0,,这是一个僵尸的过程
Dialogue: 0,0:49:11.52,0:49:15.52,English,,0,0,0,,Remains a zombie until it's reaped by its parent
Dialogue: 0,0:49:11.52,0:49:15.52,Chinese,,0,0,0,,仍然是一个僵尸，直到它的父进程回收
Dialogue: 0,0:49:16.00,0:49:18.38,English,,0,0,0,,Using a function called wait or waitpid
Dialogue: 0,0:49:16.00,0:49:18.38,Chinese,,0,0,0,,使用名为 wait 或 waitpid 的函数
Dialogue: 0,0:49:19.46,0:49:22.98,English,,0,0,0,,And as a result of doing wait or waitpid
Dialogue: 0,0:49:19.46,0:49:22.98,Chinese,,0,0,0,,并且由于 wait 或 waitpid
Dialogue: 0,0:49:23.14,0:49:25.66,English,,0,0,0,,The parent is given the exit status information
Dialogue: 0,0:49:23.14,0:49:25.66,Chinese,,0,0,0,,父进程被给予退出状态信息
Dialogue: 0,0:49:26.00,0:49:28.90,English,,0,0,0,,And then the kernel deletes the zombie process
Dialogue: 0,0:49:26.00,0:49:28.90,Chinese,,0,0,0,,然后内核删除僵尸进程
Dialogue: 0,0:49:32.12,0:49:35.94,English,,0,0,0,,Now what if the parent doesn't reap it's one of its child zombies
Dialogue: 0,0:49:32.12,0:49:35.94,Chinese,,0,0,0,,如果父进程没有回收它的僵尸子进程，怎么办呢
Dialogue: 0,0:49:36.74,0:49:42.20,English,,0,0,0,,So if any parent if the parent terminates
Dialogue: 0,0:49:36.74,0:49:42.20,Chinese,,0,0,0,,父节点终止，
Dialogue: 0,0:49:43.34,0:49:47.64,English,,0,0,0,,Then the system arranges for the very first process that existed in the system
Dialogue: 0,0:49:43.34,0:49:47.64,Chinese,,0,0,0,,系统安排系统中存在的第一个进程
Dialogue: 0,0:49:48.14,0:49:50.90,English,,0,0,0,,Called the init process which has a process id of one
Dialogue: 0,0:49:48.14,0:49:50.90,Chinese,,0,0,0,,进程 ID 为 1 的 init 进程
Dialogue: 0,0:49:51.18,0:49:54.46,English,,0,0,0,,It arranges for the init process to reap that that child
Dialogue: 0,0:49:51.18,0:49:54.46,Chinese,,0,0,0,,它安排 init 进程回收那个子进程
Dialogue: 0,0:49:57.26,0:50:04.52,English,,0,0,0,,So there's so orphaned children will always be reaped by the init process
Dialogue: 0,0:49:57.26,0:50:04.52,Chinese,,0,0,0,,init 进程总是会回收这样的孤儿进程
Dialogue: 0,0:50:04.92,0:50:10.04,English,,0,0,0,,So we only really have to worry about reaping zombies
Dialogue: 0,0:50:04.92,0:50:10.04,Chinese,,0,0,0,,我们只需要担心回收僵尸
Dialogue: 0,0:50:10.54,0:50:16.68,English,,0,0,0,,In the case where we have long-running parents like shells or servers
Dialogue: 0,0:50:10.54,0:50:16.68,Chinese,,0,0,0,,在我们有长期运行的父进程，如shell或服务器的情况下
Dialogue: 0,0:50:17.44,0:50:22.30,English,,0,0,0,,Because in that case a server may create millions of child processes
Dialogue: 0,0:50:17.44,0:50:22.30,Chinese,,0,0,0,,因为在这种情况下，服务器可能会创建数百万个子进程
Dialogue: 0,0:50:22.30,0:50:29.06,English,,0,0,0,,Each one of those does...each one of those child processes when they terminate
Dialogue: 0,0:50:22.30,0:50:29.06,Chinese,,0,0,0,,每个子进程终止时都会执行这些进程
Dialogue: 0,0:50:29.38,0:50:31.40,English,,0,0,0,,Become zombies and they have state
Dialogue: 0,0:50:29.38,0:50:31.40,Chinese,,0,0,0,,成为僵尸，他们仍带有状态信息
Dialogue: 0,0:50:31.64,0:50:33.48,English,,0,0,0,,That takes up room in the kernel so
Dialogue: 0,0:50:31.64,0:50:33.48,Chinese,,0,0,0,,这占用了内核的空间
Dialogue: 0,0:50:34.20,0:50:37.02,English,,0,0,0,,You can get this it's a form of memory leak
Dialogue: 0,0:50:34.20,0:50:37.02,Chinese,,0,0,0,,你会想到这其实是一种内存泄漏的形式
Dialogue: 0,0:50:37.92,0:50:43.60,English,,0,0,0,,If you don't...if you don't reap these zombie children that can eventually fill up the memory space and crash the kernel
Dialogue: 0,0:50:37.92,0:50:43.60,Chinese,,0,0,0,,如果你没有回收这些僵尸子进程，最终可能会填满内存空间并导致内核崩溃
Dialogue: 0,0:50:48.84,0:50:52.32,English,,0,0,0,,So for cases where you have long-running programs
Dialogue: 0,0:50:48.84,0:50:52.32,Chinese,,0,0,0,,对于长期运行程序的情况
Dialogue: 0,0:50:52.32,0:50:56.48,English,,0,0,0,,Then we have to use wait or waitpid to reap the children
Dialogue: 0,0:50:52.32,0:50:56.48,Chinese,,0,0,0,,然后我们必须使用 wait 或 waitpid 来回收子进程们
Dialogue: 0,0:50:58.32,0:51:05.86,English,,0,0,0,,So let's look at an example,first let's look at an example of this zombie phenomenon
Dialogue: 0,0:50:58.32,0:51:05.86,Chinese,,0,0,0,,让我们看一个例子，首先让我们看看这个僵尸现象的一个例子
Dialogue: 0,0:51:06.56,0:51:09.06,English,,0,0,0,,So here we have a function we call forks
Dialogue: 0,0:51:06.56,0:51:09.06,Chinese,,0,0,0,,这里有一个我们叫做 forks 的函数
Dialogue: 0,0:51:10.14,0:51:17.18,English,,0,0,0,,And then within the child we print a message of the process idea of that child and then we exit the child
Dialogue: 0,0:51:10.14,0:51:17.18,Chinese,,0,0,0,,然后在子进程中我们打印一个关于那个子进程的信息，然后我们退出子进程
Dialogue: 0,0:51:18.24,0:51:22.48,English,,0,0,0,,Within the parent we print a message and then we go into an infinite loop
Dialogue: 0,0:51:18.24,0:51:22.48,Chinese,,0,0,0,,在父进程内我们打印一条消息，然后我们进入一个无限循环
Dialogue: 0,0:51:22.92,0:51:28.74,English,,0,0,0,,Okay so this is a parent that's that never reaps the child that it created
Dialogue: 0,0:51:22.92,0:51:28.74,Chinese,,0,0,0,,这是一个永远不会回收它创建的子进程的父进程
Dialogue: 0,0:51:30.00,0:51:34.18,English,,0,0,0,,So if we run this program called forks
Dialogue: 0,0:51:30.00,0:51:34.18,Chinese,,0,0,0,,如果我们运行这个调用 forks 的程序
Dialogue: 0,0:51:36.20,0:51:38.32,English,,0,0,0,,You can see it prints these two messages
Dialogue: 0,0:51:36.20,0:51:38.32,Chinese,,0,0,0,,你可以看到它打印这两条消息
Dialogue: 0,0:51:39.92,0:51:44.98,English,,0,0,0,,The parent prints a message and the child prints a message and then
Dialogue: 0,0:51:39.92,0:51:44.98,Chinese,,0,0,0,,父进程打印一条消息，然后子进程打印一条消息
Dialogue: 0,0:51:46.28,0:51:48.92,English,,0,0,0,,And we're running it in the background with this ampersand
Dialogue: 0,0:51:46.28,0:51:48.92,Chinese,,0,0,0,,我们用这个 ＆ 符号在后台运行它
Dialogue: 0,0:51:49.16,0:51:54.04,English,,0,0,0,,Okay because we're going to otherwise it would...it's still running
Dialogue: 0,0:51:49.16,0:51:54.04,Chinese,,0,0,0,,因为这样......它还会继续运行
Dialogue: 0,0:51:54.04,0:51:56.76,English,,0,0,0,,And we wouldn't be able to inspect it
Dialogue: 0,0:51:54.04,0:51:56.76,Chinese,,0,0,0,,我们无法检查它
Dialogue: 0,0:51:57.32,0:51:59.50,English,,0,0,0,,So after we run this program in the background
Dialogue: 0,0:51:57.32,0:51:59.50,Chinese,,0,0,0,,在我们在后台运行这个程序之后
Dialogue: 0,0:51:59.96,0:52:02.32,English,,0,0,0,,Then we use ps to print the current processes
Dialogue: 0,0:51:59.96,0:52:02.32,Chinese,,0,0,0,,然后我们使用 ps 来打印当前进程
Dialogue: 0,0:52:03.00,0:52:08.92,English,,0,0,0,,And we can see that there's two...we can see here at the parent which is process id 6639
Dialogue: 0,0:52:03.00,0:52:08.92,Chinese,,0,0,0,,我们可以看到有两个......我们可以在父进程中看到进程ID为 6639
Dialogue: 0,0:52:09.76,0:52:12.74,English,,0,0,0,,And then the child which is 6640 and
Dialogue: 0,0:52:09.76,0:52:12.74,Chinese,,0,0,0,,子进程是 6640和
Dialogue: 0,0:52:14.70,0:52:16.88,English,,0,0,0,,That the defunct indicates that it's a zombie
Dialogue: 0,0:52:14.70,0:52:16.88,Chinese,,0,0,0,,「defunct」表明它是一个僵尸进程
Dialogue: 0,0:52:19.16,0:52:23.78,English,,0,0,0,,Okay now if we kill 6639 that's the parent
Dialogue: 0,0:52:19.16,0:52:23.78,Chinese,,0,0,0,,如果我们杀死父进程 6639
Dialogue: 0,0:52:25.78,0:52:30.32,English,,0,0,0,,And then do another ps you see that the zombies gone that the child is gone
Dialogue: 0,0:52:25.78,0:52:30.32,Chinese,,0,0,0,,启动另一个 ps，你看到那个僵尸进程消失了
Dialogue: 0,0:52:30.32,0:52:33.02,English,,0,0,0,,Because it's been reaped by the init process one
Dialogue: 0,0:52:30.32,0:52:33.02,Chinese,,0,0,0,,因为它是由 init 进程回收的
Dialogue: 0,0:52:36.82,0:52:41.36,English,,0,0,0,,Now what happens if the child doesn't terminate you might wonder like if a parent creates a child
Dialogue: 0,0:52:36.82,0:52:41.36,Chinese,,0,0,0,,现在看看，如果子进程没有终止会发生什么，你可能想确定进程是否创建了子进程
Dialogue: 0,0:52:43.40,0:52:50.66,English,,0,0,0,,And then the parent,and then the child never terminates
Dialogue: 0,0:52:43.40,0:52:50.66,Chinese,,0,0,0,,一个父进程，这个子进程永远不会终止
Dialogue: 0,0:52:51.64,0:52:54.88,English,,0,0,0,,And the parent terminates then what would happen
Dialogue: 0,0:52:51.64,0:52:54.88,Chinese,,0,0,0,,父进程终止了,然后会发生什么
Dialogue: 0,0:52:56.54,0:52:58.94,English,,0,0,0,,So let's just let's look at an example of those in C
Dialogue: 0,0:52:56.54,0:52:58.94,Chinese,,0,0,0,,那么让我们来看看 C 中的例子
Dialogue: 0,0:52:59.92,0:53:04.52,English,,0,0,0,,So here we're calling fork we're creating a child
Dialogue: 0,0:52:59.92,0:53:04.52,Chinese,,0,0,0,,我们在这里调用创造一个子进程
Dialogue: 0,0:53:05.34,0:53:10.48,English,,0,0,0,,Within the child we'd print a message and then the child goes into an infinite loop
Dialogue: 0,0:53:05.34,0:53:10.48,Chinese,,0,0,0,,在子进程中我们打印一条消息，然后子进程进入无限循环
Dialogue: 0,0:53:11.80,0:53:15.48,English,,0,0,0,,And the parent prints a message and then exits
Dialogue: 0,0:53:11.80,0:53:15.48,Chinese,,0,0,0,,父进程打印一条消息然后退出
Dialogue: 0,0:53:16.74,0:53:18.12,English,,0,0,0,,So if we run this program
Dialogue: 0,0:53:16.74,0:53:18.12,Chinese,,0,0,0,,如果我们运行这个程序
Dialogue: 0,0:53:20.58,0:53:23.72,English,,0,0,0,,You can see that the two messages from parent and child
Dialogue: 0,0:53:20.58,0:53:23.72,Chinese,,0,0,0,,你可以看到来自父进程和子进程的两条消息
Dialogue: 0,0:53:25.52,0:53:28.68,English,,0,0,0,,And then if we look at the...if we look at the processes
Dialogue: 0,0:53:25.52,0:53:28.68,Chinese,,0,0,0,,如果我们看一下这些进程
Dialogue: 0,0:53:28.68,0:53:32.30,English,,0,0,0,,We can see that the child is still running
Dialogue: 0,0:53:28.68,0:53:32.30,Chinese,,0,0,0,,我们可以看到子进程还在运行
Dialogue: 0,0:53:39.58,0:53:43.52,English,,0,0,0,,Okay so the child process is still running even though the parents's has terminated
Dialogue: 0,0:53:39.58,0:53:43.52,Chinese,,0,0,0,,即使父进程已经终止，子进程仍然在运行
Dialogue: 0,0:53:45.06,0:53:48.90,English,,0,0,0,,And now if we kill this child 6676
Dialogue: 0,0:53:45.06,0:53:48.90,Chinese,,0,0,0,,如果我们杀死这个子进程 6676
Dialogue: 0,0:53:54.70,0:53:59.08,English,,0,0,0,,And then if we kill it,then we can see that it's it's gone,it's no longer in the system okay so
Dialogue: 0,0:53:54.70,0:53:59.08,Chinese,,0,0,0,,如果我们杀了它，那么我们可以看到它已经消失了，它不再在系统中了
Dialogue: 0,0:54:00.12,0:54:02.72,English,,0,0,0,,That child when we killed it that terminated
Dialogue: 0,0:54:00.12,0:54:02.72,Chinese,,0,0,0,,那个子进程，当我们杀死它时，它便终止了
Dialogue: 0,0:54:03.46,0:54:09.36,English,,0,0,0,,It it had no parents so the init process reaped it and it it's no longer a zombie
Dialogue: 0,0:54:03.46,0:54:09.36,Chinese,,0,0,0,,它没有父进程，初始进程回收了它，它不再是僵尸进程
Dialogue: 0,0:54:12.08,0:54:19.20,English,,0,0,0,,So the function that we use to synchronize with children and reap them
Dialogue: 0,0:54:12.08,0:54:19.20,Chinese,,0,0,0,,我们用来与子进程同步并回收他们的函数
Dialogue: 0,0:54:20.74,0:54:22.20,English,,0,0,0,,The simplest one is called wait
Dialogue: 0,0:54:20.74,0:54:22.20,Chinese,,0,0,0,,最简单的一个叫做 wait
Dialogue: 0,0:54:23.50,0:54:27.20,English,,0,0,0,,And wait it takes an optional status
Dialogue: 0,0:54:23.50,0:54:27.20,Chinese,,0,0,0,,wait 它需要一个可选状态
Dialogue: 0,0:54:28.64,0:54:33.20,English,,0,0,0,,Where you can get the exit status of ,the inspect the exit status of the child
Dialogue: 0,0:54:28.64,0:54:33.20,Chinese,,0,0,0,,可以获得检查子进程的退出状态
Dialogue: 0,0:54:34.26,0:54:39.14,English,,0,0,0,,Basically wait suspends the execution of the process that calls it
Dialogue: 0,0:54:34.26,0:54:39.14,Chinese,,0,0,0,,基本上 wait 会暂停执行调用它的进程
Dialogue: 0,0:54:40.12,0:54:42.36,English,,0,0,0,,Until one or one of its children terminates
Dialogue: 0,0:54:40.12,0:54:42.36,Chinese,,0,0,0,,直到一个或其中一个子进程终止
Dialogue: 0,0:54:42.88,0:54:48.26,English,,0,0,0,,And it doesn't specify which one it just waits,until one of the children that it created terminates
Dialogue: 0,0:54:42.88,0:54:48.26,Chinese,,0,0,0,,并且它没有指定它只是等待哪一个，直到它创建的一个子进程终止
Dialogue: 0,0:54:50.48,0:54:53.16,English,,0,0,0,,And then if this child status is not null
Dialogue: 0,0:54:50.48,0:54:53.16,Chinese,,0,0,0,,如果此子进程状态不为空
Dialogue: 0,0:54:54.02,0:54:58.82,English,,0,0,0,,Then the integer that it returns or the integer that it points to this is a pointer
Dialogue: 0,0:54:54.02,0:54:58.82,Chinese,,0,0,0,,然后它返回的整数或它指向的整数是一个指针
Dialogue: 0,0:54:59.50,0:55:05.54,English,,0,0,0,,The integer that it points to will be set to some value that indicated the reason the child terminated and its exit status
Dialogue: 0,0:54:59.50,0:55:05.54,Chinese,,0,0,0,,它指向的整数将被设置为某个值，该值指示子进程终止的原因及其退出状态
Dialogue: 0,0:55:06.10,0:55:08.50,English,,0,0,0,,And you can check that using these macros
Dialogue: 0,0:55:06.10,0:55:08.50,Chinese,,0,0,0,,你可以检查使用这些宏
Dialogue: 0,0:55:10.00,0:55:14.16,English,,0,0,0,,Which your textbook describes in more detail and let you
Dialogue: 0,0:55:10.00,0:55:14.16,Chinese,,0,0,0,,你的教科书将更详细地描述
Dialogue: 0,0:55:16.61,0:55:19.24,English,,0,0,0,,So let's look at how this works in a simple example
Dialogue: 0,0:55:16.61,0:55:19.24,Chinese,,0,0,0,,让我们看一下这个工作原理的简单示例
Dialogue: 0,0:55:19.88,0:55:26.04,English,,0,0,0,,So here we're calling fork and creating a child which prints a message and then exits
Dialogue: 0,0:55:19.88,0:55:26.04,Chinese,,0,0,0,,这里我们调用 fork 并创建一个打印消息然后退出的子进程
Dialogue: 0,0:55:27.88,0:55:33.14,English,,0,0,0,,The parent prints a message and then it waits for the child to terminate
Dialogue: 0,0:55:27.88,0:55:33.14,Chinese,,0,0,0,,父进程打印一条消息，然后等待子进程终止
Dialogue: 0,0:55:34.14,0:55:37.40,English,,0,0,0,,And when the child terminates it prints a message
Dialogue: 0,0:55:34.14,0:55:37.40,Chinese,,0,0,0,,当子进程终止时，它会打印一条消息
Dialogue: 0,0:55:38.24,0:55:41.74,English,,0,0,0,,And indicating that the child terminated and then prints by
Dialogue: 0,0:55:38.24,0:55:41.74,Chinese,,0,0,0,,并指示子进程终止然后打印
Dialogue: 0,0:55:42.40,0:55:45.34,English,,0,0,0,,So if we were to look at the process graph for this
Dialogue: 0,0:55:42.40,0:55:45.34,Chinese,,0,0,0,,如果我们要查看流程图
Dialogue: 0,0:55:46.14,0:55:50.36,English,,0,0,0,,You would see that we would have the fork creates the parent and the child
Dialogue: 0,0:55:46.14,0:55:50.36,Chinese,,0,0,0,,你会看到我们会让 fork 创建父进程和子进程
Dialogue: 0,0:55:51.52,0:55:54.14,English,,0,0,0,,Both the parent and the child do they're printf
Dialogue: 0,0:55:51.52,0:55:54.14,Chinese,,0,0,0,,父进程和子进程都会打印
Dialogue: 0,0:55:55.74,0:56:04.46,English,,0,0,0,,And then the parent waits it suspends until that the child terminates in this case by calling exit
Dialogue: 0,0:55:55.74,0:56:04.46,Chinese,,0,0,0,,接着父进程等待它暂停，直到子进程在这种情况下通过调用 exit 终止
Dialogue: 0,0:56:07.56,0:56:10.10,English,,0,0,0,,Okay so what that means is it's infeasible
Dialogue: 0,0:56:07.56,0:56:10.10,Chinese,,0,0,0,,那么这意味着它是不可行的
Dialogue: 0,0:56:13.10,0:56:14.70,English,,0,0,0,,So you can see "hello from parent"
Dialogue: 0,0:56:13.10,0:56:14.70,Chinese,,0,0,0,,你可以看到 "hello from parent"
Dialogue: 0,0:56:18.40,0:56:20.07,English,,0,0,0,,It's infeasible though for this
Dialogue: 0,0:56:18.40,0:56:20.07,Chinese,,0,0,0,,尽管如此，这是不可行的
Dialogue: 0,0:56:20.92,0:56:26.46,English,,0,0,0,,This child terminated message CT to occur before the bye
Dialogue: 0,0:56:20.92,0:56:26.46,Chinese,,0,0,0,,这个子进程在打印 Bye 之前打印 CT ，然后终止
Dialogue: 0,0:56:28.42,0:56:29.30,English,,0,0,0,,Because
Dialogue: 0,0:56:28.42,0:56:29.30,Chinese,,0,0,0,,因为
Dialogue: 0,0:56:34.10,0:56:37.70,English,,0,0,0,,Because the child hasn't yet terminated so
Dialogue: 0,0:56:34.10,0:56:37.70,Chinese,,0,0,0,,因为子进程还没有这样终止
Dialogue: 0,0:56:39.62,0:56:42.36,English,,0,0,0,,It's these two...these two messages will never be printed
Dialogue: 0,0:56:39.62,0:56:42.36,Chinese,,0,0,0,,这两个消息永远不会被打印出来
Dialogue: 0,0:56:42.86,0:56:45.46,English,,0,0,0,,Until the child is terminated by calling exit
Dialogue: 0,0:56:42.86,0:56:45.46,Chinese,,0,0,0,,直到子进程通过调用 exit 退出终止
Dialogue: 0,0:56:47.92,0:56:49.42,English,,0,0,0,,So is that clear? Yes!
Dialogue: 0,0:56:47.92,0:56:49.42,Chinese,,0,0,0,,明白了吗？请讲！
Dialogue: 0,0:56:56.32,0:56:58.72,English,,0,0,0,,So the question is can you have an output HP
Dialogue: 0,0:56:56.32,0:56:58.72,Chinese,,0,0,0,,问题是你有输出 HP 吗
Dialogue: 0,0:57:03.24,0:57:09.08,English,,0,0,0,,HP,HC,CT bye yes
Dialogue: 0,0:57:03.24,0:57:09.08,Chinese,,0,0,0,,HP，HC，CT，Bye这样是可行的
Dialogue: 0,0:57:10.76,0:57:20.32,English,,0,0,0,,Yes because the parent prints HP, there's a context switch the child prints HC and then exits
Dialogue: 0,0:57:10.76,0:57:20.32,Chinese,,0,0,0,,是的，因为父进程打印 HP，有一个上下文切换，子进程打印HC然后退出
Dialogue: 0,0:57:21.20,0:57:24.25,English,,0,0,0,,And now the parent will the wait will return
Dialogue: 0,0:57:21.20,0:57:24.25,Chinese,,0,0,0,,现在父进程将等待返回
Dialogue: 0,0:57:24.56,0:57:26.42,English,,0,0,0,,And then it prints CT bye
Dialogue: 0,0:57:24.56,0:57:26.42,Chinese,,0,0,0,,它打印 CT bye
Dialogue: 0,0:57:33.32,0:57:41.02,English,,0,0,0,,Okay here's this is a...this is a little more a little more involved example
Dialogue: 0,0:57:33.32,0:57:41.02,Chinese,,0,0,0,,更加复杂一点的例子
Dialogue: 0,0:57:41.56,0:57:44.42,English,,0,0,0,,So here what we want to do we're going to create a bunch of children
Dialogue: 0,0:57:41.56,0:57:44.42,Chinese,,0,0,0,,我们想要做的就是创造一堆子进程
Dialogue: 0,0:57:45.06,0:57:47.42,English,,0,0,0,,And then we're going to wait for them all to terminate
Dialogue: 0,0:57:45.06,0:57:47.42,Chinese,,0,0,0,,我们将等待他们全部终止
Dialogue: 0,0:57:48.10,0:57:52.70,English,,0,0,0,,And we're going to wait but we won't be able to wait in any specific order right we're just...
Dialogue: 0,0:57:48.10,0:57:52.70,Chinese,,0,0,0,,我们将等待，但我们将无法按任何特定顺序等待，我们只是......
Dialogue: 0,0:57:55.28,0:57:58.02,English,,0,0,0,,So here we have a loop 0 through n
Dialogue: 0,0:57:55.28,0:57:58.02,Chinese,,0,0,0,,这里我们有一个循环 0 到 n
Dialogue: 0,0:57:59.24,0:58:06.44,English,,0,0,0,,And in each loop body we're going to fork a child and exit with a return status
Dialogue: 0,0:57:59.24,0:58:06.44,Chinese,,0,0,0,,在每个循环体中，我们将 fork 一个子进程，并带有一个返回状态退出
Dialogue: 0,0:58:06.44,0:58:08.62,English,,0,0,0,,That that's going to tell us which child it was
Dialogue: 0,0:58:06.44,0:58:08.62,Chinese,,0,0,0,,这将告诉我们这是哪个子进程
Dialogue: 0,0:58:12.02,0:58:16.86,English,,0,0,0,,In the parent so we do this n times
Dialogue: 0,0:58:12.02,0:58:16.86,Chinese,,0,0,0,,在父进程那里我们这样做了 n 次
Dialogue: 0,0:58:18.96,0:58:25.78,English,,0,0,0,,And then afterward the parent inside a similar loop 0 to n
Dialogue: 0,0:58:18.96,0:58:25.78,Chinese,,0,0,0,,父进程在类似的循环 0 到 n 内
Dialogue: 0,0:58:26.32,0:58:29.18,English,,0,0,0,,Add waits for a child to terminate
Dialogue: 0,0:58:26.32,0:58:29.18,Chinese,,0,0,0,,添加等待子进程终止
Dialogue: 0,0:58:29.18,0:58:32.22,English,,0,0,0,,So it will wait for n children to terminate
Dialogue: 0,0:58:29.18,0:58:32.22,Chinese,,0,0,0,,它将等待 n 个子进程终止
Dialogue: 0,0:58:34.50,0:58:41.20,English,,0,0,0,,Wait returns the the process id
Dialogue: 0,0:58:34.50,0:58:41.20,Chinese,,0,0,0,,等待返回进程 ID
Dialogue: 0,0:58:42.22,0:58:51.26,English,,0,0,0,,And then a status which is... in this child status variable
Dialogue: 0,0:58:42.22,0:58:51.26,Chinese,,0,0,0,,这个子进程中的状态....
Dialogue: 0,0:58:52.40,0:58:57.02,English,,0,0,0,,And so we take that variable now and we can use this w if exited macro to determine
Dialogue: 0,0:58:52.40,0:58:57.02,Chinese,,0,0,0,,我们现在采用该变量，如果退出宏，我们可以使用此 w 来确定
Dialogue: 0,0:58:57.03,0:59:00.06,English,,0,0,0,,If it terminated normally with an exit by calling exit
Dialogue: 0,0:58:57.03,0:59:00.06,Chinese,,0,0,0,,如果它通过调用 exit 退出，正常终止
Dialogue: 0,0:59:00.84,0:59:06.68,English,,0,0,0,,And if so then we can check its exit status using the WEXITSTATUS macro
Dialogue: 0,0:59:00.84,0:59:06.68,Chinese,,0,0,0,,如果是这样，那么我们可以使用 WEXITSTATUS 宏 检查其退出状态
Dialogue: 0,0:59:07.28,0:59:10.29,English,,0,0,0,,Otherwise if w exited it
Dialogue: 0,0:59:07.28,0:59:10.29,Chinese,,0,0,0,,否则，如果退出它
Dialogue: 0,0:59:10.64,0:59:17.64,English,,0,0,0,,It's false then that means something the child terminated for some other reason not because it called exit
Dialogue: 0,0:59:10.64,0:59:17.64,Chinese,,0,0,0,,这是假的，这意味着子进程因某种其他原因而终止，而不是因为它调用 exit
Dialogue: 0,0:59:21.32,0:59:22.60,English,,0,0,0,,Okay there's a
Dialogue: 0,0:59:21.32,0:59:22.60,Chinese,,0,0,0,,有一个
Dialogue: 0,0:59:24.06,0:59:28.84,English,,0,0,0,,We can actually use waitpid which is similar to wait
Dialogue: 0,0:59:24.06,0:59:28.84,Chinese,,0,0,0,,我们实际上可以使用类似于 wait 的 waitpid
Dialogue: 0,0:59:28.84,0:59:33.08,English,,0,0,0,,But it allows us to wait for a specific process a specific child
Dialogue: 0,0:59:28.84,0:59:33.08,Chinese,,0,0,0,,但它允许我们等待特定进程，特定子进程
Dialogue: 0,0:59:33.32,0:59:37.72,English,,0,0,0,,A specific child with a specific process id to terminate
Dialogue: 0,0:59:33.32,0:59:37.72,Chinese,,0,0,0,,以终止具有特定进程 ID 的特定子进程
Dialogue: 0,0:59:38.40,0:59:44.52,English,,0,0,0,,And I'll let you can waitpid is really involved and
Dialogue: 0,0:59:38.40,0:59:44.52,Chinese,,0,0,0,,我会告诉你，waitpid 真的复杂
Dialogue: 0,0:59:44.98,0:59:48.10,English,,0,0,0,,It's described in detail in your textbook
Dialogue: 0,0:59:44.98,0:59:48.10,Chinese,,0,0,0,,它在你的教科书中有详细描述
Dialogue: 0,0:59:48.48,0:59:52.20,English,,0,0,0,,And so you'll need to look, you'll need to look there for the details on how that works
Dialogue: 0,0:59:48.48,0:59:52.20,Chinese,,0,0,0,,你需要查看有关其工作原理的详细信息
Dialogue: 0,0:59:55.08,0:59:58.68,English,,0,0,0,,Now another important so we've learned how to create new processes
Dialogue: 0,0:59:55.08,0:59:58.68,Chinese,,0,0,0,,现在另一个重要的是，我们已经学会了如何创建新进程
Dialogue: 0,1:00:02.38,1:00:05.30,English,,0,0,0,,The but we haven't learned how to when we call fork
Dialogue: 0,1:00:02.38,1:00:05.30,Chinese,,0,0,0,,但我们还没有学会如何调用 fork
Dialogue: 0,1:00:05.30,1:00:10.82,English,,0,0,0,,We just create an exact copy of the child is just an exact copy of the parent
Dialogue: 0,1:00:05.30,1:00:10.82,Chinese,,0,0,0,,我们只是创建一个子进程的精确副本，只是父进程的精确副本
Dialogue: 0,1:00:11.24,1:00:14.26,English,,0,0,0,,Running the same code,same program,same variables
Dialogue: 0,1:00:11.24,1:00:14.26,Chinese,,0,0,0,,运行相同的代码，相同的程序，相同的变量
Dialogue: 0,1:00:14.98,1:00:20.28,English,,0,0,0,,Okay to run a different program inside of a process we use a function called execve
Dialogue: 0,1:00:14.98,1:00:20.28,Chinese,,0,0,0,,要在进程内运行不同的程序，我们使用一个名为 execve 的函数
Dialogue: 0,1:00:22.50,1:00:26.40,English,,0,0,0,,And execve loads and runs
Dialogue: 0,1:00:22.50,1:00:26.40,Chinese,,0,0,0,,并执行加载和运行
Dialogue: 0,1:00:28.38,1:00:30.92,English,,0,0,0,,Within the current process it loads and runs
Dialogue: 0,1:00:28.38,1:00:30.92,Chinese,,0,0,0,,在当前流程中，它会加载并运行
Dialogue: 0,1:00:31.46,1:00:34.54,English,,0,0,0,,The executable file name which is its first argument
Dialogue: 0,1:00:31.46,1:00:34.54,Chinese,,0,0,0,,可执行文件名，这是它的第一个参数
Dialogue: 0,1:00:35.48,1:00:39.16,English,,0,0,0,,And file name can be either a binary executable
Dialogue: 0,1:00:35.48,1:00:39.16,Chinese,,0,0,0,,文件名可以是二进制可执行
Dialogue: 0,1:00:40.52,1:00:43.54,English,,0,0,0,,Okay or it can be a script,it can be a text file
Dialogue: 0,1:00:40.52,1:00:43.54,Chinese,,0,0,0,,或者它可以是一个脚本，它可以是一个文本文件
Dialogue: 0,1:00:45.22,1:00:47.72,English,,0,0,0,,A so-called script file that starts
Dialogue: 0,1:00:45.22,1:00:47.72,Chinese,,0,0,0,,一个所谓的脚本文件启动
Dialogue: 0,1:00:49.08,1:00:56.50,English,,0,0,0,,Whose first line starts with a #! and then that the path of some interpreter
Dialogue: 0,1:00:49.08,1:00:56.50,Chinese,,0,0,0,,第一行以 #! 开始，然后是解释器的路径
Dialogue: 0,1:00:56.78,1:00:59.58,English,,0,0,0,,So for example if you want to write a shell script
Dialogue: 0,1:00:56.78,1:00:59.58,Chinese,,0,0,0,,例如，如果你想编写 shell 脚本
Dialogue: 0,1:01:00.50,1:01:07.96,English,,0,0,0,,You the first line of your shell script is a !# and then The path name of the bash
Dialogue: 0,1:01:00.50,1:01:07.96,Chinese,,0,0,0,,你的 shell 脚本的第一行开头是 !# 然后是 bash 的路径名（!# /bin/bash）
Dialogue: 0,1:01:08.94,1:01:11.50,English,,0,0,0,,And then that will execute bash
Dialogue: 0,1:01:08.94,1:01:11.50,Chinese,,0,0,0,,那将执行 bash
Dialogue: 0,1:01:11.90,1:01:17.34,English,,0,0,0,,And then bash will read in that the lines following and interpret them
Dialogue: 0,1:01:11.90,1:01:17.34,Chinese,,0,0,0,,bash 将读取下面的行并解译它们
Dialogue: 0,1:01:18.08,1:01:21.04,English,,0,0,0,,As just as though you'd type them in at the command line
Dialogue: 0,1:01:18.08,1:01:21.04,Chinese,,0,0,0,,就像你在命令行输入它们一样
Dialogue: 0,1:01:23.10,1:01:27.42,English,,0,0,0,,So in either case it executes either an interpreter or it executes a binary
Dialogue: 0,1:01:23.10,1:01:27.42,Chinese,,0,0,0,,在任何一种情况下，它都执行解释器，或执行二进制文件
Dialogue: 0,1:01:28.42,1:01:31.96,English,,0,0,0,,With who's argued with the argument list argv
Dialogue: 0,1:01:28.42,1:01:31.96,Chinese,,0,0,0,,谁对于参数列表 argv 感到迷惑
Dialogue: 0,1:01:33.04,1:01:36.24,English,,0,0,0,,And a list of environment very in envp
Dialogue: 0,1:01:33.04,1:01:36.24,Chinese,,0,0,0,,以及 envp 中的环境列表
Dialogue: 0,1:01:38.52,1:01:41.54,English,,0,0,0,,Okay now by default are the first argument
Dialogue: 0,1:01:38.52,1:01:41.54,Chinese,,0,0,0,,现在默认是第一个参数
Dialogue: 0,1:01:42.18,1:01:48.24,English,,0,0,0,,In argv is the name of the file that that's being executed so it's this file name
Dialogue: 0,1:01:42.18,1:01:48.24,Chinese,,0,0,0,,在 argv 中是正在执行的文件的名称，它是此文件名
Dialogue: 0,1:01:51.32,1:01:52.60,English,,0,0,0,,So what that allows you to do is
Dialogue: 0,1:01:51.32,1:01:52.60,Chinese,,0,0,0,,那么你可以做的是
Dialogue: 0,1:01:53.04,1:01:58.60,English,,0,0,0,,In your code you can check argv[0] if you want to print out the name of the file,the name of the program that's executing
Dialogue: 0,1:01:53.04,1:01:58.60,Chinese,,0,0,0,,在你的代码中，你可以检查 argv [0]，如果你想打印出文件的名称，正在执行的程序的名称
Dialogue: 0,1:01:59.08,1:02:00.72,English,,0,0,0,,You just print out argv[0]
Dialogue: 0,1:01:59.08,1:02:00.72,Chinese,,0,0,0,,你只需打印出 argv [0]
Dialogue: 0,1:02:05.98,1:02:12.04,English,,0,0,0,,Okay now and exceve all of the code and the data and the stack
Dialogue: 0,1:02:05.98,1:02:12.04,Chinese,,0,0,0,,现在好了, exceve 所有代码，数据和堆栈
Dialogue: 0,1:02:12.16,1:02:16.80,English,,0,0,0,,It overwrites the completely overrides the virtual address space
Dialogue: 0,1:02:12.16,1:02:16.80,Chinese,,0,0,0,,它会完全覆盖虚拟地址空间
Dialogue: 0,1:02:17.82,1:02:20.78,English,,0,0,0,,So once you call evceve a within a process
Dialogue: 0,1:02:17.82,1:02:20.78,Chinese,,0,0,0,,一旦你在一个进程调用 exceve
Dialogue: 0,1:02:22.52,1:02:25.14,English,,0,0,0,,It blows away the current program that's it
Dialogue: 0,1:02:22.52,1:02:25.14,Chinese,,0,0,0,,它打破了当前的程序
Dialogue: 0,1:02:25.70,1:02:31.70,English,,0,0,0,,Okay however it retains that it's still the same process, it's just running now a different program
Dialogue: 0,1:02:25.70,1:02:31.70,Chinese,,0,0,0,,但是它保留了，仍然一样的进程，它现在只是运行一个不同的程序
Dialogue: 0,1:02:35.06,1:02:39.44,English,,0,0,0,,And so it retains the process id and any open files that you have
Dialogue: 0,1:02:35.06,1:02:39.44,Chinese,,0,0,0,,它保留了进程 ID 和你拥有的任何打开文件
Dialogue: 0,1:02:43.18,1:02:47.43,English,,0,0,0,,So execve is really mind-blowing because it's called once
Dialogue: 0,1:02:43.18,1:02:47.43,Chinese,,0,0,0,,execve 真的令人兴奋，因为它被称为一次调用
Dialogue: 0,1:02:48.34,1:02:49.36,English,,0,0,0,,But it never returns
Dialogue: 0,1:02:48.34,1:02:49.36,Chinese,,0,0,0,,但它永远不会返回
Dialogue: 0,1:02:53.12,1:02:54.50,English,,0,0,0,,Except if there's an error
Dialogue: 0,1:02:53.12,1:02:54.50,Chinese,,0,0,0,,除非出现错误
Dialogue: 0,1:02:54.58,1:02:59.30,English,,0,0,0,,So if this file doesn't exist for example then then execve will return on -1
Dialogue: 0,1:02:54.58,1:02:59.30,Chinese,,0,0,0,,如果此文件不存在，那么 execve 将返回-1
Dialogue: 0,1:02:59.90,1:03:03.04,English,,0,0,0,,But otherwise in normal operation it never returns
Dialogue: 0,1:02:59.90,1:03:03.04,Chinese,,0,0,0,,但在正常操作中它永远不会返回
Dialogue: 0,1:03:06.00,1:03:07.86,English,,0,0,0,,All right so let's look at the structure of the stack
Dialogue: 0,1:03:06.00,1:03:07.86,Chinese,,0,0,0,,让我们来看看栈帧
Dialogue: 0,1:03:07.88,1:03:10.54,English,,0,0,0,,When this new program starts so after
Dialogue: 0,1:03:07.88,1:03:10.54,Chinese,,0,0,0,,当这个新程序开始之后
Dialogue: 0,1:03:11.42,1:03:15.54,English,,0,0,0,,After exit...after the egg argv finishes its work it creates
Dialogue: 0,1:03:11.42,1:03:15.54,Chinese,,0,0,0,,退出之后...在 argv 完成它的工作之后它创造了
Dialogue: 0,1:03:16.60,1:03:23.98,English,,0,0,0,,It create a new stack, it loads in new code and data creates a new empty heap
Dialogue: 0,1:03:16.60,1:03:23.98,Chinese,,0,0,0,,它创建一个新的堆栈，它在新代码中加载数据，创建一个新的空堆
Dialogue: 0,1:03:25.70,1:03:26.78,English,,0,0,0,,Ok everything's new
Dialogue: 0,1:03:25.70,1:03:26.78,Chinese,,0,0,0,,一切都是新的
Dialogue: 0,1:03:28.42,1:03:32.28,English,,0,0,0,,And the stack that it creates has the following form
Dialogue: 0,1:03:28.42,1:03:32.28,Chinese,,0,0,0,,它创建的堆栈具有以下形式
Dialogue: 0,1:03:33.64,1:03:38.38,English,,0,0,0,,Ok at the bottom here's the bottom of the stack and our stack is growing this way
Dialogue: 0,1:03:33.64,1:03:38.38,Chinese,,0,0,0,,在底部这里是堆栈的底部，我们的堆栈正在以这种方式增长
Dialogue: 0,1:03:40.76,1:03:42.44,English,,0,0,0,,So the first function that executes
Dialogue: 0,1:03:40.76,1:03:42.44,Chinese,,0,0,0,,执行的第一个函数
Dialogue: 0,1:03:43.84,1:03:47.78,English,,0,0,0,,Is a function called libc_start_main
Dialogue: 0,1:03:43.84,1:03:47.78,Chinese,,0,0,0,,是一个名为 libc_start_main 的函数
Dialogue: 0,1:03:48.44,1:03:50.50,English,,0,0,0,,So that has a stack frame
Dialogue: 0,1:03:48.44,1:03:50.50,Chinese,,0,0,0,,它有一个栈帧
Dialogue: 0,1:03:53.83,1:03:59.00,English,,0,0,0,,So let's look this is what I'm showing here is the situation right before the startup code calls main
Dialogue: 0,1:03:53.83,1:03:59.00,Chinese,,0,0,0,,让我们看看，这是我在这里展示的是，启动代码调用 main 之前的情况
Dialogue: 0,1:04:00.76,1:04:07.35,English,,0,0,0,,So there's the future stack frame for main will be here at the top of this
Dialogue: 0,1:04:00.76,1:04:07.35,Chinese,,0,0,0,,main 的未来栈帧将位于此顶部
Dialogue: 0,1:04:07.70,1:04:09.40,English,,0,0,0,,Following the top of the stack
Dialogue: 0,1:04:07.70,1:04:09.40,Chinese,,0,0,0,,在堆栈顶部之后
Dialogue: 0,1:04:11.46,1:04:20.24,English,,0,0,0,,There's some padding and then the argument list in argv  is contained on the stack
Dialogue: 0,1:04:11.46,1:04:20.24,Chinese,,0,0,0,,有一些填充，然后 argv 中的参数列表包含在堆栈中
Dialogue: 0,1:04:20.24,1:04:25.00,English,,0,0,0,,So that the argv is a list of pointers terminated by the null pointer
Dialogue: 0,1:04:20.24,1:04:25.00,Chinese,,0,0,0,,这样 argv 就是一个由零指针终止的指针列表
Dialogue: 0,1:04:25.72,1:04:31.29,English,,0,0,0,,And each one of these pointers points up into a string that corresponds to an argument
Dialogue: 0,1:04:25.72,1:04:31.29,Chinese,,0,0,0,,这些指针中的每一个都指向一个与参数对应的字符串
Dialogue: 0,1:04:32.26,1:04:38.14,English,,0,0,0,,Okay so when you run a program you specify the program name
Dialogue: 0,1:04:32.26,1:04:38.14,Chinese,,0,0,0,,在运行程序时指定程序名称
Dialogue: 0,1:04:39.34,1:04:41.30,English,,0,0,0,,And then arguments separated by spaces
Dialogue: 0,1:04:39.34,1:04:41.30,Chinese,,0,0,0,,由空格分隔的参数
Dialogue: 0,1:04:42.86,1:04:49.94,English,,0,0,0,,Okay and so these arguments this argv is a list of pointers to those arguments strings
Dialogue: 0,1:04:42.86,1:04:49.94,Chinese,,0,0,0,,这些参数，这个 argv 是一个指向这些参数字符串的指针列表
Dialogue: 0,1:04:51.08,1:04:55.60,English,,0,0,0,,And it's pointed to right as main is called
Dialogue: 0,1:04:51.08,1:04:55.60,Chinese,,0,0,0,,它被指向 main 被调用的地址
Dialogue: 0,1:04:55.60,1:04:59.12,English,,0,0,0,,It's the second argument to main
Dialogue: 0,1:04:55.60,1:04:59.12,Chinese,,0,0,0,,这是 main 的第二个参数
Dialogue: 0,1:04:59.46,1:05:05.16,English,,0,0,0,,So it's contained in %rsi the address of this argument lists
Dialogue: 0,1:04:59.46,1:05:05.16,Chinese,,0,0,0,,它包含在 ％rsi ，这个参数的地址列表
Dialogue: 0,1:05:06.10,1:05:10.78,English,,0,0,0,,The number of arguments is contained is the first argument argc
Dialogue: 0,1:05:06.10,1:05:10.78,Chinese,,0,0,0,,第一个参数 argc 是包含的参数数量
Dialogue: 0,1:05:10.82,1:05:17.08,English,,0,0,0,,And that's contained in %rdi by the x86-64  parameter passing convention
Dialogue: 0,1:05:10.82,1:05:17.08,Chinese,,0,0,0,,并且 x86-64 参数传递约定包含在 ％rdi 中
Dialogue: 0,1:05:17.68,1:05:21.62,English,,0,0,0,,Now the environment list is also contained on the stack
Dialogue: 0,1:05:17.68,1:05:21.62,Chinese,,0,0,0,,环境列表也包含在堆栈中
Dialogue: 0,1:05:21.70,1:05:28.98,English,,0,0,0,,And it too consists of a list of pointers each of which points into a environment string
Dialogue: 0,1:05:21.70,1:05:28.98,Chinese,,0,0,0,,它也包含一个指针列表，每个指针都指向一个环境字符串
Dialogue: 0,1:05:28.98,1:05:31.50,English,,0,0,0,,Which is a set of key equal value pairs, okay
Dialogue: 0,1:05:28.98,1:05:31.50,Chinese,,0,0,0,,哪一组是关键的等值对,好的
Dialogue: 0,1:05:33.98,1:05:38.24,English,,0,0,0,,And it's pointed to by the global environment variable environ
Dialogue: 0,1:05:33.98,1:05:38.24,Chinese,,0,0,0,,全局环境变量指向了它
Dialogue: 0,1:05:39.20,1:05:46.40,English,,0,0,0,,And if it's passed in it's pointed at an envp it which is contained in %rdx
Dialogue: 0,1:05:39.20,1:05:46.40,Chinese,,0,0,0,,如果它被传入，则指向包含在 ％rdx 中的 envp
Dialogue: 0,1:05:46.40,1:05:49.40,English,,0,0,0,,Which is the always holds the third argument
Dialogue: 0,1:05:46.40,1:05:49.40,Chinese,,0,0,0,,这就是总是存在的第三个参数
Dialogue: 0,1:05:52.26,1:05:55.22,English,,0,0,0,,Okay so let's look now how we would use this
Dialogue: 0,1:05:52.26,1:05:55.22,Chinese,,0,0,0,,现在让我们来看看我们将如何使用它
Dialogue: 0,1:05:57.44,1:06:02.08,English,,0,0,0,,So we want to within our current program we want to execute the ls command
Dialogue: 0,1:05:57.44,1:06:02.08,Chinese,,0,0,0,,我们希望在当前程序中执行 ls 命令
Dialogue: 0,1:06:03.08,1:06:08.20,English,,0,0,0,,With two arguments - lt and /usr/include
Dialogue: 0,1:06:03.08,1:06:08.20,Chinese,,0,0,0,,有两个参数 -lt 和 /usr/include
Dialogue: 0,1:06:08.20,1:06:13.28,English,,0,0,0,,So what this is saying is list,list the files in /usr/include
Dialogue: 0,1:06:08.20,1:06:13.28,Chinese,,0,0,0,,这就是列出 /usr/include 中的文件
Dialogue: 0,1:06:14.48,1:06:18.08,English,,0,0,0,,Show the long form of the listing and sort them in time order
Dialogue: 0,1:06:14.48,1:06:18.08,Chinese,,0,0,0,,显示list的长格式并按时间顺序对其进行排序
Dialogue: 0,1:06:18.48,1:06:21.04,English,,0,0,0,,From most recently used to at least recently used
Dialogue: 0,1:06:18.48,1:06:21.04,Chinese,,0,0,0,,从最近最多使用到最近最少使用
Dialogue: 0,1:06:23.08,1:06:26.66,English,,0,0,0,,So the way we do this
Dialogue: 0,1:06:23.08,1:06:26.66,Chinese,,0,0,0,,我们这样做的方式
Dialogue: 0,1:06:28.32,1:06:31.24,English,,0,0,0,,If we just called execve it blow away our program
Dialogue: 0,1:06:28.32,1:06:31.24,Chinese,,0,0,0,,如果我们只是调用 execve，那就使我们的程序崩溃
Dialogue: 0,1:06:31.24,1:06:35.08,English,,0,0,0,,So assuming we want to continue to do work after we execute ls
Dialogue: 0,1:06:31.24,1:06:35.08,Chinese,,0,0,0,,假设我们想在执行 ls 后继续工作
Dialogue: 0,1:06:36.24,1:06:40.78,English,,0,0,0,,The the standard way to do this is to to create a child using fork
Dialogue: 0,1:06:36.24,1:06:40.78,Chinese,,0,0,0,,执行此操作的标准方法是使用 fork 创建子进程
Dialogue: 0,1:06:41.92,1:06:44.40,English,,0,0,0,,And then exceve act within the child
Dialogue: 0,1:06:41.92,1:06:44.40,Chinese,,0,0,0,,exceve 在子进程内行动
Dialogue: 0,1:06:45.60,1:06:46.84,English,,0,0,0,,Right have the child do the work
Dialogue: 0,1:06:45.60,1:06:46.84,Chinese,,0,0,0,,是的，让子进程工作良好
Dialogue: 0,1:06:47.76,1:06:53.56,English,,0,0,0,,And then the child terminates and the parent maybe will wait for the child, maybe not right just
Dialogue: 0,1:06:47.76,1:06:53.56,Chinese,,0,0,0,,子进程终止，父进程可能会等待子进程，可能不对
Dialogue: 0,1:06:55.04,1:06:56.52,English,,0,0,0,,Usually it will wait for the child
Dialogue: 0,1:06:55.04,1:06:56.52,Chinese,,0,0,0,,通常它会等待子进程
Dialogue: 0,1:06:58.44,1:07:04.62,English,,0,0,0,,So within the parent we fork a child check that it's 0
Dialogue: 0,1:06:58.44,1:07:04.62,Chinese,,0,0,0,,在父进程中，我们 fork 子进程检查它是 0
Dialogue: 0,1:07:05.78,1:07:10.88,English,,0,0,0,,And so if it's 0 then we're executing that this code executes within the child
Dialogue: 0,1:07:05.78,1:07:10.88,Chinese,,0,0,0,,如果它为 0，那么我在子进程中执行这段代码
Dialogue: 0,1:07:11.46,1:07:12.96,English,,0,0,0,,So the child does the exact
Dialogue: 0,1:07:11.46,1:07:12.96,Chinese,,0,0,0,,子进程恰好工作
Dialogue: 0,1:07:15.02,1:07:18.52,English,,0,0,0,,It passes the name of the function since the
Dialogue: 0,1:07:15.02,1:07:18.52,Chinese,,0,0,0,,它传递了函数的名称
Dialogue: 0,1:07:19.16,1:07:22.88,English,,0,0,0,,The name of the function that we want to the program that we want to execute
Dialogue: 0,1:07:19.16,1:07:22.88,Chinese,,0,0,0,,我们想要执行的程序的函数名称
Dialogue: 0,1:07:22.88,1:07:26.04,English,,0,0,0,,Is always contained in the first element of argv
Dialogue: 0,1:07:22.88,1:07:26.04,Chinese,,0,0,0,,始终包含在 argv 的第一个元素中
Dialogue: 0,1:07:26.50,1:07:31.08,English,,0,0,0,,We call exit with a parameter of myargv[0]
Dialogue: 0,1:07:26.50,1:07:31.08,Chinese,,0,0,0,,我们用参数 myargv[0] 调用 exit
Dialogue: 0,1:07:33.46,1:07:38.20,English,,0,0,0,,And we've set up the argument list in myargv
Dialogue: 0,1:07:33.46,1:07:38.20,Chinese,,0,0,0,,我们在 myargv 中设置了参数列表
Dialogue: 0,1:07:39.62,1:07:43.34,English,,0,0,0,,And we pass the global environment variable environment
Dialogue: 0,1:07:39.62,1:07:43.34,Chinese,,0,0,0,,我们传递了全局变量环境
Dialogue: 0,1:07:43.54,1:07:48.70,English,,0,0,0,,We're just going to use the current list of environment variables that we have in the parent
Dialogue: 0,1:07:43.54,1:07:48.70,Chinese,,0,0,0,,我们将使用父进程中的当前环境变量列表
Dialogue: 0,1:07:52.00,1:07:58.06,English,,0,0,0,,Okay and these environment variables are things of the form USER=droh current working directory
Dialogue: 0,1:07:52.00,1:07:58.06,Chinese,,0,0,0,,这些环境变量是 「USER=droh」，当前工作目录的形式
Dialogue: 0,1:08:02.22,1:08:04.04,English,,0,0,0,,And so the the...
Dialogue: 0,1:08:02.22,1:08:04.04,Chinese,,0,0,0,,......
Dialogue: 0,1:08:06.46,1:08:12.76,English,,0,0,0,,If this program in myargv[0] doesn't exist then exact will return -0
Dialogue: 0,1:08:06.46,1:08:12.76,Chinese,,0,0,0,,如果 myargv[0] 中的这个程序不存在，那么 exact 将返回小于 0 的数
Dialogue: 0,1:08:13.28,1:08:17.19,English,,0,0,0,,So we check for that condition and then exit
Dialogue: 0,1:08:13.28,1:08:17.19,Chinese,,0,0,0,,我们检查那个条件然后退出
Dialogue: 0,1:08:17.64,1:08:21.92,English,,0,0,0,,Otherwise it never returns right it executes ls
Dialogue: 0,1:08:17.64,1:08:21.92,Chinese,,0,0,0,,否则它永远不会返回，它执行 ls
Dialogue: 0,1:08:22.66,1:08:24.60,English,,0,0,0,,ls the code for ls
Dialogue: 0,1:08:22.66,1:08:24.60,Chinese,,0,0,0,,是 ls 的代码
Dialogue: 0,1:08:24.94,1:08:29.98,English,,0,0,0,,This is the name of a binary this is a /bin/ls is a binary file
Dialogue: 0,1:08:24.94,1:08:29.98,Chinese,,0,0,0,,这是二进制文件的名称，这是 /bin/ls，它是二进制文件
Dialogue: 0,1:08:30.94,1:08:33.04,English,,0,0,0,,That binary file gets loaded into memory
Dialogue: 0,1:08:30.94,1:08:33.04,Chinese,,0,0,0,,该二进制文件被加载到内存中
Dialogue: 0,1:08:35.36,1:08:37.83,English,,0,0,0,,That code gets executed and it terminates
Dialogue: 0,1:08:35.36,1:08:37.83,Chinese,,0,0,0,,该代码被执行并终止
Dialogue: 0,1:08:38.48,1:08:42.12,English,,0,0,0,,Okay so the child at this point after the exit
Dialogue: 0,1:08:38.48,1:08:42.12,Chinese,,0,0,0,,在子进程在退出后的这一刻
Dialogue: 0,1:08:43.60,1:08:47.00,English,,0,0,0,,The child is running that the ls code
Dialogue: 0,1:08:43.60,1:08:47.00,Chinese,,0,0,0,,子进程正在运行 ls 代码
Dialogue: 0,1:08:47.00,1:08:50.56,English,,0,0,0,,And it's no longer running any of this code
Dialogue: 0,1:08:47.00,1:08:50.56,Chinese,,0,0,0,,并且它不再运行任何代码
Dialogue: 0,1:08:52.00,1:09:00.38,English,,0,0,0,,Now this seems the first time you see this combination of fork and execve it seems a little odd doesn't it
Dialogue: 0,1:08:52.00,1:09:00.38,Chinese,,0,0,0,,现在这似乎是你第一次看到这个 fork 和 execve 的组合，看起来有点奇怪不是吗
Dialogue: 0,1:09:00.86,1:09:01.50,English,,0,0,0,, why not just
Dialogue: 0,1:09:00.86,1:09:01.50,Chinese,,0,0,0,,为什么不呢
Dialogue: 0,1:09:02.80,1:09:06.24,English,,0,0,0,,Why not just have one command that creates a new process and runs
Dialogue: 0,1:09:02.80,1:09:06.24,Chinese,,0,0,0,,为什么不只有一个命令来创建一个新进程并运行
Dialogue: 0,1:09:07.04,1:09:09.08,English,,0,0,0,,And runs a program in that process ，why
Dialogue: 0,1:09:07.04,1:09:09.08,Chinese,,0,0,0,,并在该进程中运行程序，为什么
Dialogue: 0,1:09:09.74,1:09:15.04,English,,0,0,0,,Why separate why have these two separate fork and execve
Dialogue: 0,1:09:09.74,1:09:15.04,Chinese,,0,0,0,,为什么要分开这两个单独的 fork 和 execve
Dialogue: 0,1:09:19.32,1:09:24.98,English,,0,0,0,,I mean in fact windows does this windows has like one command that creates a process and executes
Dialogue: 0,1:09:19.32,1:09:24.98,Chinese,,0,0,0,,我的意思是事实上，windows 这个窗口就像一个创建进程并执行的命令
Dialogue: 0,1:09:25.46,1:09:31.92,English,,0,0,0,,But it turns out that having a separate function like fork
Dialogue: 0,1:09:25.46,1:09:31.92,Chinese,,0,0,0,,但事实证明，拥有像 fork 这样的独立功能
Dialogue: 0,1:09:32.72,1:09:35.90,English,,0,0,0,,Just to create processes is actually really useful
Dialogue: 0,1:09:32.72,1:09:35.90,Chinese,,0,0,0,,仅仅创建进程，实际上就已经非常有用
Dialogue: 0,1:09:36.46,1:09:40.16,English,,0,0,0,,I mean sometimes you just want to create replicas of your current process for example
Dialogue: 0,1:09:36.46,1:09:40.16,Chinese,,0,0,0,,我的意思是有时你只想创建当前进程的副本
Dialogue: 0,1:09:40.58,1:09:41.79,English,,0,0,0,,Let's say you have a server
Dialogue: 0,1:09:40.58,1:09:41.79,Chinese,,0,0,0,,假设你有一台服务器
Dialogue: 0,1:09:42.64,1:09:47.86,English,,0,0,0,,And you want to create a concurrent server you want to create multiple copies of that server then you just fork
Dialogue: 0,1:09:42.64,1:09:47.86,Chinese,,0,0,0,,并且你想创建一个并发服务器，你想要创建该服务器的多个副本，然后你只需要 fork
Dialogue: 0,1:09:48.76,1:09:53.92,English,,0,0,0,,A bunch you have the main the parent server can fork a bunch of children
Dialogue: 0,1:09:48.76,1:09:53.92,Chinese,,0,0,0,,你的主服务器的一堆服务可以 fork 一堆子进程
Dialogue: 0,1:09:53.92,1:09:56.22,English,,0,0,0,,So that's useful they're just all running the same code
Dialogue: 0,1:09:53.92,1:09:56.22,Chinese,,0,0,0,,这很有用，他们只是运行相同的代码
Dialogue: 0,1:09:56.84,1:09:59.72,English,,0,0,0,,But what's all...what this also allows you to do
Dialogue: 0,1:09:56.84,1:09:59.72,Chinese,,0,0,0,,但是这一切......这也让你做到了
Dialogue: 0,1:10:00.46,1:10:03.34,English,,0,0,0,,Is it allows you to execute code in the child
Dialogue: 0,1:10:00.46,1:10:03.34,Chinese,,0,0,0,,是否允许你在子进程中执行代码
Dialogue: 0,1:10:04.12,1:10:05.98,English,,0,0,0,,Before you call execve
Dialogue: 0,1:10:04.12,1:10:05.98,Chinese,,0,0,0,,在你调用 execve 之前
Dialogue: 0,1:10:07.02,1:10:12.20,English,,0,0,0,,So you may want to set some,you may want to set some...
Dialogue: 0,1:10:07.02,1:10:12.20,Chinese,,0,0,0,,你可能想设置一些，你可能想设置一些......
Dialogue: 0,1:10:13.02,1:10:16.28,English,,0,0,0,,Like some signal with is especially useful when you're dealing with
Dialogue: 0,1:10:13.02,1:10:16.28,Chinese,,0,0,0,,在你处理时，一些信号就特别有用
Dialogue: 0,1:10:16.96,1:10:21.86,English,,0,0,0,,With things like signals if you want to block certain signals or unblock certain signals
Dialogue: 0,1:10:16.96,1:10:21.86,Chinese,,0,0,0,,如果你可以阻塞某些信号或打开某些信号
Dialogue: 0,1:10:22.38,1:10:27.52,English,,0,0,0,,You can do it right here in this this gap between the fork and the exceve
Dialogue: 0,1:10:22.38,1:10:27.52,Chinese,,0,0,0,,你可以在这个 fork 和 exceve 中做到这一点
Dialogue: 0,1:10:32.94,1:10:38.96,English,,0,0,0,,Okay so that's it so just to summarize what we've talked about today
Dialogue: 0,1:10:32.94,1:10:38.96,Chinese,,0,0,0,,总结我们今天讲课内容
Dialogue: 0,1:10:39.86,1:10:50.04,English,,0,0,0,,Exceptions are in response to events that require some kind of non-standard or exceptional call exceptional control flow
Dialogue: 0,1:10:39.86,1:10:50.04,Chinese,,0,0,0,,异常是对需要某种非标准或特殊调用异常控制流的事件的响应
Dialogue: 0,1:10:50.84,1:10:56.66,English,,0,0,0,,They can be generated internally in the form of interrupts or internally in the form of traps and faults
Dialogue: 0,1:10:50.84,1:10:56.66,Chinese,,0,0,0,,它们可以以中断的形式在内部生成，也可以以陷阱和故障的形式在内部生成
Dialogue: 0,1:10:57.62,1:11:02.64,English,,0,0,0,,So at any point in time a process has multiple a system as multiple processes
Dialogue: 0,1:10:57.62,1:11:02.64,Chinese,,0,0,0,,在任何时间点，系统都有多个进程
Dialogue: 0,1:11:03.32,1:11:05.84,English,,0,0,0,,Only one of which can execute on a single core
Dialogue: 0,1:11:03.32,1:11:05.84,Chinese,,0,0,0,,其中只有一个可以在单个核心上执行
Dialogue: 0,1:11:06.62,1:11:11.54,English,,0,0,0,,So the process execution is interleaved by the kernel
Dialogue: 0,1:11:06.62,1:11:11.54,Chinese,,0,0,0,,由内核交替执行进程
Dialogue: 0,1:11:13.10,1:11:19.50,English,,0,0,0,,And each process thinks that it has total control of the processor in its address space
Dialogue: 0,1:11:13.10,1:11:19.50,Chinese,,0,0,0,,并且每个进程都认为它在地址空间中完全控制了处理器
Dialogue: 0,1:11:21.88,1:11:24.96,English,,0,0,0,,There's only one mechanism to spawn processes that's fork
Dialogue: 0,1:11:21.88,1:11:24.96,Chinese,,0,0,0,,只有一种机制来生成的进程，那就是 fork
Dialogue: 0,1:11:25.92,1:11:27.80,English,,0,0,0,,And it's called once and returns twice
Dialogue: 0,1:11:25.92,1:11:27.80,Chinese,,0,0,0,,它被调用一次并返回两次
Dialogue: 0,1:11:29.80,1:11:35.12,English,,0,0,0,,We can terminate our process by calling exit which is called once and never returns
Dialogue: 0,1:11:29.80,1:11:35.12,Chinese,,0,0,0,,我们可以通过调用一次调用 exit 来终止我们的进程，并且永远不会返回
Dialogue: 0,1:11:36.06,1:11:39.30,English,,0,0,0,,We reap and wait for processes using wait or waitpid
Dialogue: 0,1:11:36.06,1:11:39.30,Chinese,,0,0,0,,我们可以使用 wait 和 waitpid 回收并等待进程
Dialogue: 0,1:11:39.88,1:11:42.50,English,,0,0,0,,And we load and run programs using execve
Dialogue: 0,1:11:39.88,1:11:42.50,Chinese,,0,0,0,,我们使用 execve 加载和运行程序
Dialogue: 0,1:11:43.02,1:11:44.96,English,,0,0,0,,Or one of its one of its variants
Dialogue: 0,1:11:43.02,1:11:44.96,Chinese,,0,0,0,,或者它的一个参数之一
Dialogue: 0,1:11:45.86,1:11:48.62,English,,0,0,0,,And this one is called once and and normally never returns
Dialogue: 0,1:11:45.86,1:11:48.62,Chinese,,0,0,0,,这个被称为调用一次，从不返回
Dialogue: 0,1:11:50.00,1:11:52.92,English,,0,0,0,,Okay so that's it for today and
Dialogue: 0,1:11:50.00,1:11:52.92,Chinese,,0,0,0,,这就是今天的全部内容
Dialogue: 0,1:11:53.88,1:11:58.28,English,,0,0,0,,We'll see you have a good weekend and we'll see you on Tuesday
Dialogue: 0,1:11:53.88,1:11:58.28,Chinese,,0,0,0,,祝你们周末愉快，周二我们再见
