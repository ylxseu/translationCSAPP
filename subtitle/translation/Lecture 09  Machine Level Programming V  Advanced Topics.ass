[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Library/Application Support/Aegisub/recovered/../../../../Desktop/../Library/Application Support/Aegisub/recovered/../../../../Desktop/csapp/Lecture 09  Machine Level Programming V  Advanced Topics.mp4
Video File: ../../../../Library/Application Support/Aegisub/recovered/../../../../Desktop/../Library/Application Support/Aegisub/recovered/../../../../Desktop/csapp/Lecture 09  Machine Level Programming V  Advanced Topics.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.187500
Scroll Position: 1498
Active Line: 1506
Video Position: 140868

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Noto Sans CJK SC Black,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,1.5,1.2,2,10,10,10,1
Style: Chinese,Noto Sans CJK SC Black,46,&H00FFFF00,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.2,1.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:04.82,English,,0,0,0,,This will be the last lecture on machine level programming
Dialogue: 0,0:00:00.00,0:00:04.82,Chinese,,0,0,0,,这是关于机器级编程的最后一课
Dialogue: 0,0:00:05.42,0:00:09.94,English,,0,0,0,,We call it advanced topics but think of it more as miscellaneous topics
Dialogue: 0,0:00:05.42,0:00:09.94,Chinese,,0,0,0,,我们把它称之为进阶主题，但觉得它更像是五花八门的主题
Dialogue: 0,0:00:10.70,0:00:16.00,English,,0,0,0,,And I think most to you of course you know that your bomb lab due tonight
Dialogue: 0,0:00:10.70,0:00:16.00,Chinese,,0,0,0,,我认为你们大多数人应该都知道 bomb lab 将于今晚截止
Dialogue: 0,0:00:16.00,0:00:20.72,English,,0,0,0,,So most of you probably well into that or hopefully through it
Dialogue: 0,0:00:16.00,0:00:20.72,Chinese,,0,0,0,,所以你们很有可能已经喜欢上这个实验，甚至已经彻底理解它了
Dialogue: 0,0:00:21.08,0:00:26.44,English,,0,0,0,,And then at midnight tonight the next lab will come out which is called attack lab
Dialogue: 0,0:00:21.08,0:00:26.44,Chinese,,0,0,0,,下一个实验  attack lab 将会在今晚推出
Dialogue: 0,0:00:26.96,0:00:28.98,English,,0,0,0,,And there is a recitation about that yesterday
Dialogue: 0,0:00:26.96,0:00:28.98,Chinese,,0,0,0,,昨天的习题课就是关于这个实验的
Dialogue: 0,0:00:28.98,0:00:32.90,English,,0,0,0,,But this is a lab that's a new to the course
Dialogue: 0,0:00:28.98,0:00:32.90,Chinese,,0,0,0,,但对于这门课来说这是一个全新的实验
Dialogue: 0,0:00:33.36,0:00:37.50,English,,0,0,0,,It's a similar one that we used to use at this point in the course
Dialogue: 0,0:00:33.36,0:00:37.50,Chinese,,0,0,0,,曾经在这个章节中我们门课上用过类似的实验
Dialogue: 0,0:00:37.64,0:00:41.60,English,,0,0,0,,But it's been updated and changed in significant ways
Dialogue: 0,0:00:37.64,0:00:41.60,Chinese,,0,0,0,,但我们已经对它做出了许多重大的更新和改变
Dialogue: 0,0:00:41.70,0:00:49.88,English,,0,0,0,,So when you have labs like we do in this course with this many students
Dialogue: 0,0:00:41.70,0:00:49.88,Chinese,,0,0,0,,所以和参与这个课程的其他同学一样，你们在做实验时
Dialogue: 0,0:00:49.88,0:00:51.90,English,,0,0,0,,There's a lot of things can go wrong
Dialogue: 0,0:00:49.88,0:00:51.90,Chinese,,0,0,0,,确实很多事情都可能出错
Dialogue: 0,0:00:51.90,0:00:55.96,English,,0,0,0,,So we're going to keep a close eye on how things are going
Dialogue: 0,0:00:51.90,0:00:55.96,Chinese,,0,0,0,,因此我们将会密切关注事情的发展
Dialogue: 0,0:00:55.96,0:00:59.70,English,,0,0,0,,But I'd encourage you，you only have a week and a half to do this next lab
Dialogue: 0,0:00:55.96,0:00:59.70,Chinese,,0,0,0,,不过我建议你们只用一周半的时间来完成这个 lab
Dialogue: 0,0:01:00.10,0:01:05.10,English,,0,0,0,,To get started soon and partly by having some people start sooner
Dialogue: 0,0:01:00.10,0:01:05.10,Chinese,,0,0,0,,为了尽快开始做这个实验，有部分人开始的过早了
Dialogue: 0,0:01:05.10,0:01:07.88,English,,0,0,0,,You'll start breaking things for us that we can track down
Dialogue: 0,0:01:05.10,0:01:07.88,Chinese,,0,0,0,,你们这样子做将会使我们不方便跟踪问题
Dialogue: 0,0:01:09.56,0:01:16.94,English,,0,0,0,,So today what we'll talk about is a couple(of),like I said, it's miscellaneous topics but important topics
Dialogue: 0,0:01:09.56,0:01:16.94,Chinese,,0,0,0,,今天我们要讨论的是几个五花八门但又十分重要的话题
Dialogue: 0,0:01:17.00,0:01:25.52,English,,0,0,0,,One is just sort of what does the memory look like when you're running x86-64 programs
Dialogue: 0,0:01:17.00,0:01:25.52,Chinese,,0,0,0,,一个主要是当运行 x86-64 的程序时内存是如何组织的
Dialogue: 0,0:01:26.00,0:01:31.34,English,,0,0,0,,The other is a very important topic on security vulnerability called buffer overflows
Dialogue: 0,0:01:26.00,0:01:31.34,Chinese,,0,0,0,,另一个是关于安全漏洞的重要主题，我们称之为缓冲区溢出
Dialogue: 0,0:01:31.86,0:01:37.44,English,,0,0,0,,And in fact the attack lab will be precisely exploiting those security vulnerabilities
Dialogue: 0,0:01:31.86,0:01:37.44,Chinese,,0,0,0,,实际上 attack lab 实验的内容就将是精准恰当地利用这些安全漏洞
Dialogue: 0,0:01:37.96,0:01:43.02,English,,0,0,0,,And then we'll look at unions,so far you've looked at arrays and structs and how they're organized
Dialogue: 0,0:01:37.96,0:01:43.02,Chinese,,0,0,0,,之后我们将会讨论联合体（一种数据结构），到目前为止你们已经了解了数组和结构体
Dialogue: 0,0:01:43.72,0:01:45.90,English,,0,0,0,,And I want to compare that to unions
Dialogue: 0,0:01:43.72,0:01:45.90,Chinese,,0,0,0,,我会把这些和联合体进行比较
Dialogue: 0,0:01:47.88,0:01:51.04,English,,0,0,0,,So let's talk about memory then
Dialogue: 0,0:01:47.88,0:01:51.04,Chinese,,0,0,0,,现在我们开始讨论内存
Dialogue: 0,0:01:51.04,0:01:57.68,English,,0,0,0,, As I said at the beginning early in the course, conceptually a memory is just a big array of bytes
Dialogue: 0,0:01:51.04,0:01:57.68,Chinese,,0,0,0,,我在这门课的开始就讲过， 从概念上来说「内存」就是一个很大的字节数组
Dialogue: 0,0:01:58.46,0:02:03.44,English,,0,0,0,,And that's the view of this the machine level programmer
Dialogue: 0,0:01:58.46,0:02:03.44,Chinese,,0,0,0,,在机器级编程的程序员眼里看来是这样
Dialogue: 0,0:02:03.72,0:02:05.84,English,,0,0,0,,Even though it's not the actual implementation
Dialogue: 0,0:02:03.72,0:02:05.84,Chinese,,0,0,0,,虽然它不是真实的实现方式
Dialogue: 0,0:02:05.84,0:02:11.84,English,,0,0,0,,There's a whole part that we'll talk about later in the course,this is called virtual memory
Dialogue: 0,0:02:05.84,0:02:11.84,Chinese,,0,0,0,,这一部分我们会在后面的课程中学习，也就是「虚拟内存」
Dialogue: 0,0:02:12.92,0:02:16.14,English,,0,0,0,,This organization is very simple organization
Dialogue: 0,0:02:12.92,0:02:16.14,Chinese,,0,0,0,,这个结构看上去非常简单
Dialogue: 0,0:02:16.60,0:02:27.52,English,,0,0,0,,But the underlying implementation is this complex management of various different memory types from disk memories to solid state disks
Dialogue: 0,0:02:16.60,0:02:27.52,Chinese,,0,0,0,,但它的底层实现，是对一系列不同存储类型的复杂管理，从磁盘存储到固态存储
Dialogue: 0,0:02:28.00,0:02:35.88,English,,0,0,0,,And to what's called DRAM which stands for dynamic RAM the when you buy memory for your processor its DRAM
Dialogue: 0,0:02:28.00,0:02:35.88,Chinese,,0,0,0,,到所谓的DRAM，也就是当你为你的处理器购买内存时就是 DRAM 即动态随机存取存储器
Dialogue: 0,0:02:36.98,0:02:48.27,English,,0,0,0,,Um so as you know in x86-64 we're working with machines that nominally have addresses can be up to 64 bits long
Dialogue: 0,0:02:36.98,0:02:48.27,Chinese,,0,0,0,,正如你所了解的 x86-64 机器的地址在名义上讲有 64 位
Dialogue: 0,0:02:48.66,0:02:52.22,English,,0,0,0,,And if you work out the numbers remember I told you at the beginning of the course
Dialogue: 0,0:02:48.66,0:02:52.22,Chinese,,0,0,0,,如果你们记得这门课开始我讲的内容，就可以算一下这个数有多大
Dialogue: 0,0:02:52.22,0:03:03.22,English,,0,0,0,,You can estimate how big a number like to the 64 is by remembering that 1024 and 1000 are very close to each other
Dialogue: 0,0:02:52.22,0:03:03.22,Chinese,,0,0,0,,通过观察 1024 和 1000 非常接近，你可以估计 2^64 有多大
Dialogue: 0,0:03:03.22,0:03:07.66,English,,0,0,0,,So 2^10 is roughly the same as 10^3
Dialogue: 0,0:03:03.22,0:03:07.66,Chinese,,0,0,0,,因此 2^10 可以近似地看作是 10^3
Dialogue: 0,0:03:08.52,0:03:11.48,English,,0,0,0,,So you take 64 and you think 60
Dialogue: 0,0:03:08.52,0:03:11.48,Chinese,,0,0,0,,64 也可以近似地看作 60
Dialogue: 0,0:03:11.48,0:03:21.04,English,,0,0,0,,So how big is 2^60 well that's 6*10 and therefore it's 6*3,it's like 10^18
Dialogue: 0,0:03:11.48,0:03:21.04,Chinese,,0,0,0,,因此 2^60 就是 (2^10)^6，它约等于 (10^3)^6，也就是 10^18
Dialogue: 0,0:03:22.28,0:03:27.00,English,,0,0,0,,And then you add the four to that that's 2^4 and 16
Dialogue: 0,0:03:22.28,0:03:27.00,Chinese,,0,0,0,,再乘以 2^4 也就是 16
Dialogue: 0,0:03:27.00,0:03:30.58,English,,0,0,0,,So it's around 16*10^18 bytes
Dialogue: 0,0:03:27.00,0:03:30.58,Chinese,,0,0,0,,所以 64 为机器支持的内存大约是 16*10^18 字节
Dialogue: 0,0:03:31.64,0:03:42.50,English,,0,0,0,,So if you were to go off and look online on Amazon for DRAM chips and try to buy that much memory
Dialogue: 0,0:03:31.64,0:03:42.50,Chinese,,0,0,0,,如果你打算在亚马逊上购买这么大的内存
Dialogue: 0,0:03:43.12,0:03:44.74,English,,0,0,0,,You'd find you're spending a lot of money
Dialogue: 0,0:03:43.12,0:03:44.74,Chinese,,0,0,0,,你会发现这是一笔巨款
Dialogue: 0,0:03:45.66,0:03:52.60,English,,0,0,0,,More than you I don't know the numbers but it would be a lot of memory money
Dialogue: 0,0:03:45.66,0:03:52.60,Chinese,,0,0,0,,虽然我不知道是多少但肯定价格不菲
Dialogue: 0,0:03:53.06,0:03:55.16,English,,0,0,0,,And so you basically can't do it nowadays
Dialogue: 0,0:03:53.06,0:03:55.16,Chinese,,0,0,0,,所以我们现在基本上不会这么干
Dialogue: 0,0:03:56.12,0:04:00.48,English,,0,0,0,,Tend to the and so...
Dialogue: 0,0:04:02.28,0:04:09.72,English,,0,0,0,,Right now the machines limit you to actually only 47 bits worth of address in the address space
Dialogue: 0,0:04:02.28,0:04:09.72,Chinese,,0,0,0,,现在 64 位机器会限制只使用 47 位的地址
Dialogue: 0,0:04:10.54,0:04:19.28,English,,0,0,0,,I'll and so 2^47 again work that out that's like 256*10^12
Dialogue: 0,0:04:10.54,0:04:19.28,Chinese,,0,0,0,,大概计算一下就是 256*10^12 字节
Dialogue: 0,0:04:19.28,0:04:21.82,English,,0,0,0,,So it's 256 terabytes
Dialogue: 0,0:04:19.28,0:04:21.82,Chinese,,0,0,0,,也就是 256 TB
Dialogue: 0,0:04:23.16,0:04:26.86,English,,0,0,0,,And as you know you can buy a disk drive now that has 8 terabytes
Dialogue: 0,0:04:23.16,0:04:26.86,Chinese,,0,0,0,,你可以买一块 8TB 的硬盘
Dialogue: 0,0:04:26.86,0:04:28.36,English,,0,0,0,,So it doesn't seem like that much
Dialogue: 0,0:04:26.86,0:04:28.36,Chinese,,0,0,0,,它并不是很贵
Dialogue: 0,0:04:28.36,0:04:37.54,English,,0,0,0,,But if you tried to buy that much DRAM again you'd have to have a pretty big credit-card limit
Dialogue: 0,0:04:28.36,0:04:37.54,Chinese,,0,0,0,,但是如果你买这么大的内存，你必须有很高的信用卡额度
Dialogue: 0,0:04:38.12,0:04:45.70,English,,0,0,0,,And so even that's a huge number and modern super computer installations actually will have almost that much memory
Dialogue: 0,0:04:38.12,0:04:45.70,Chinese,,0,0,0,,即便如此，一些超级计算机确实有这么大的内存
Dialogue: 0,0:04:45.70,0:04:51.76,English,,0,0,0,,But the point is that the hardware of today limits you to 47 bits worth of address
Dialogue: 0,0:04:45.70,0:04:51.76,Chinese,,0,0,0,,不过我想说的是，如今的硬件限制我们只能使用 47 位的地址
Dialogue: 0,0:04:52.56,0:04:58.18,English,,0,0,0,,But that's not really a real limitation in terms of actual machines
Dialogue: 0,0:04:52.56,0:04:58.18,Chinese,,0,0,0,,但这实际上并不是真正的限制
Dialogue: 0,0:04:58.32,0:05:03.12,English,,0,0,0,,And what will happen is memory prices get cheaper and the technology gets better
Dialogue: 0,0:04:58.32,0:05:03.12,Chinese,,0,0,0,,随着技术的进步，内存也会越来越便宜
Dialogue: 0,0:05:03.46,0:05:08.10,English,,0,0,0,,They'll slowly start adding as succeeding generations of processors come along
Dialogue: 0,0:05:03.46,0:05:08.10,Chinese,,0,0,0,,内存将会随着未来的处理器的推出而慢慢增加
Dialogue: 0,0:05:08.78,0:05:11.62,English,,0,0,0,,Let you have bigger and bigger range of addresses
Dialogue: 0,0:05:08.78,0:05:11.62,Chinese,,0,0,0,,地址范围也会越来越大
Dialogue: 0,0:05:12.52,0:05:23.84,English,,0,0,0,,So all that is to say that's why this number shows up which is a seven followed by eleven Fs
Dialogue: 0,0:05:12.52,0:05:23.84,Chinese,,0,0,0,,上面所讲的都是为了说明为什么 00007FFFFFFFFFFF 这个数字会出现在这里
Dialogue: 0,0:05:27.76,0:05:35.56,English,,0,0,0,,I can tell I need to scribble some numbers you guys just saying numbers in the air is not working here
Dialogue: 0,0:05:27.76,0:05:35.56,Chinese,,0,0,0,,这么说你们可能没什么概念，我在本子上写一下
Dialogue: 0,0:05:36.88,0:05:49.88,English,,0,0,0,,So let's try
Dialogue: 0,0:05:36.88,0:05:49.88,Chinese,,0,0,0,,让我们试试
Dialogue: 0,0:05:53.28,0:05:53.96,English,,0,0,0,,Ok
Dialogue: 0,0:05:55.32,0:06:06.21,English,,0,0,0,,Okay so remember I said before to 2^64 is about equal to 16*10^18
Dialogue: 0,0:05:55.32,0:06:06.21,Chinese,,0,0,0,,我刚才说过， 2^64 近似等于 16*10^18
Dialogue: 0,0:06:09.20,0:06:17.82,English,,0,0,0,,And 2^47 is 128*10^12
Dialogue: 0,0:06:09.20,0:06:17.82,Chinese,,0,0,0,,2^47 近似等于 128*10^12
Dialogue: 0,0:06:19.24,0:06:21.14,English,,0,0,0,,So it's 128 terabytes
Dialogue: 0,0:06:19.24,0:06:21.14,Chinese,,0,0,0,,也就是 128 TB
Dialogue: 0,0:06:29.26,0:06:33.56,English,,0,0,0,,So what's the number after a terabyte you know 10^15
Dialogue: 0,0:06:36.78,0:06:40.74,English,,0,0,0,,How many bytes? Yes. Petabytes right
Dialogue: 0,0:06:36.78,0:06:40.74,Chinese,,0,0,0,,有多少字节？ 对，PB
Dialogue: 0,0:06:29.26,0:06:33.56,Chinese,,0,0,0,,TB 之后的单位，或者说 10^15
Dialogue: 0,0:06:44.82,0:06:48.58,English,,0,0,0,,And you know what 10^18 is.Exa
Dialogue: 0,0:06:44.82,0:06:48.58,Chinese,,0,0,0,,你们知道 10^18 是什么单位吗？Exa
Dialogue: 0,0:06:53.40,0:06:58.58,English,,0,0,0,,So just as a reference a company like Google
Dialogue: 0,0:06:53.40,0:06:58.58,Chinese,,0,0,0,,这里我们以谷歌公司为例
Dialogue: 0,0:06:59.08,0:07:08.70,English,,0,0,0,,Roughly, it's probably it's total storage across the whole Enterprise is measured in some small number of exabytes
Dialogue: 0,0:06:59.08,0:07:08.70,Chinese,,0,0,0,,整个谷歌的存储是以 EB 为单位计量的
Dialogue: 0,0:07:09.80,0:07:18.04,English,,0,0,0,,And it every day is getting several petabytes I don't know the numbers are of course secret
Dialogue: 0,0:07:09.80,0:07:18.04,Chinese,,0,0,0,,每天都会产生好几 PB 的数据，我不知道具体是多少因为这是商业机密
Dialogue: 0,0:07:18.04,0:07:25.06,English,,0,0,0,,But maybe 10 petabytes or more per day of new data that it's ingesting into its system so
Dialogue: 0,0:07:18.04,0:07:25.06,Chinese,,0,0,0,,但是至少会有 10 PB 或者更多的数据注入到他们的系统
Dialogue: 0,0:07:25.06,0:07:30.54,English,,0,0,0,,These numbers are pretty huge but not just totally off the charts
Dialogue: 0,0:07:25.06,0:07:30.54,Chinese,,0,0,0,,这些数字很大，但还没有超出我们讨论的范畴
Dialogue: 0,0:07:30.54,0:07:39.20,English,,0,0,0,,Do you know what 10^21 is? It's called a zettabyte with two t's
Dialogue: 0,0:07:30.54,0:07:39.20,Chinese,,0,0,0,,你们知道 10^21 是什么单位吗？它被称为 ZB
Dialogue: 0,0:07:41.54,0:07:55.92,English,,0,0,0,,And it's estimated if you add up all the digital content in the world That gets created everybody's cell phone camera every video Taken by anyone anywhere all year long is a couple of zettabytes a year
Dialogue: 0,0:07:41.54,0:07:55.92,Chinese,,0,0,0,,据估算，如果把全世界一年内所有人拍摄的所有视频加起来大概是几个 ZB
Dialogue: 0,0:07:55.96,0:08:02.30,English,,0,0,0,,So it'll be a while before we're really having to deal with that kind of memory
Dialogue: 0,0:07:55.96,0:08:02.30,Chinese,,0,0,0,,我们目前还没有处理这么大的内存的需求
Dialogue: 0,0:08:03.18,0:08:10.36,English,,0,0,0,,So just to give you an idea so 128 terabytes is the address limit on these systems
Dialogue: 0,0:08:03.18,0:08:10.36,Chinese,,0,0,0,,说这些只是让你们对 128 TB 的内存限制有个概念
Dialogue: 0,0:08:10.70,0:08:17.52,English,,0,0,0,,And so that's why you have to have seven because you remember that's one two three
Dialogue: 0,0:08:10.70,0:08:17.52,Chinese,,0,0,0,,7 用二进制表示是 3 个 1
Dialogue: 0,0:08:18.22,0:08:22.18,English,,0,0,0,,And then there's f but there's 11 of them
Dialogue: 0,0:08:18.22,0:08:22.18,Chinese,,0,0,0,,然后是 F 不过 F 有 11 个
Dialogue: 0,0:08:22.68,0:08:27.74,English,,0,0,0,,And this is 1111 times 11 so that's 44 ones
Dialogue: 0,0:08:22.68,0:08:27.74,Chinese,,0,0,0,,11 个 F 就是 44 个 1
Dialogue: 0,0:08:29.76,0:08:31.20,English,,0,0,0,,And this is 3 ones
Dialogue: 0,0:08:29.76,0:08:31.20,Chinese,,0,0,0,,这里是 3 个 1
Dialogue: 0,0:08:33.44,0:08:36.44,English,,0,0,0,,And that's where you get 47
Dialogue: 0,0:08:33.44,0:08:36.44,Chinese,,0,0,0,,加起来就是 47 个 1
Dialogue: 0,0:08:37.58,0:08:41.86,English,,0,0,0,,In Linux
Dialogue: 0,0:08:37.58,0:08:41.86,Chinese,,0,0,0,,在 Linux 中
Dialogue: 0,0:08:42.32,0:08:46.94,English,,0,0,0,,That's where they put the stack, is up at the very top of the address space
Dialogue: 0,0:08:42.32,0:08:46.94,Chinese,,0,0,0,,那就是他们放置栈的地方，位于整个地址空间的最顶部
Dialogue: 0,0:08:47.14,0:08:53.58,English,,0,0,0,,And I should tell you this picture is not at all to scale it would be impossible to draw this picture to scale
Dialogue: 0,0:08:47.14,0:08:53.58,Chinese,,0,0,0,,这幅图其实并不是按照比例绘制的
Dialogue: 0,0:08:54.30,0:08:59.10,English,,0,0,0,,For example it shows that the stack starts way up at the top
Dialogue: 0,0:08:54.30,0:08:59.10,Chinese,,0,0,0,,在这幅图中栈位于最顶部
Dialogue: 0,0:08:59.10,0:09:03.10,English,,0,0,0,,And remember stacks grow to smaller addresses
Dialogue: 0,0:08:59.10,0:09:03.10,Chinese,,0,0,0,,我们知道栈是向着低地址增长的
Dialogue: 0,0:09:03.14,0:09:09.54,English,,0,0,0,,When you're pushing and also we show the them upside down just to make everything confusing
Dialogue: 0,0:09:03.14,0:09:09.54,Chinese,,0,0,0,,因此我们把栈倒着画，即便这很难理解
Dialogue: 0,0:09:10.08,0:09:17.01,English,,0,0,0,,So the the stack starts there and it grows towards lower addresses
Dialogue: 0,0:09:10.08,0:09:17.01,Chinese,,0,0,0,,所以在这张图中栈从最上方开始并且向下增长
Dialogue: 0,0:09:17.32,0:09:20.50,English,,0,0,0,,And on a typical system it will be limited to 8 megabytes
Dialogue: 0,0:09:17.32,0:09:20.50,Chinese,,0,0,0,,在常用的系统上，栈的大小是 8 MB
Dialogue: 0,0:09:20.78,0:09:28.78,English,,0,0,0,,And you can tell that on a Linux system at least with the the limit command
Dialogue: 0,0:09:20.78,0:09:28.78,Chinese,,0,0,0,,你可以在一个至少有 limit 指令的 Linux 系统上通过 limit 命令来查看
Dialogue: 0,0:09:30.06,0:09:38.30,English,,0,0,0,,Which used to be more interesting than it was is now because a lot of things are unlimited
Dialogue: 0,0:09:30.06,0:09:38.30,Chinese,,0,0,0,,这个命令很有意思，尽管它被称为 limit，但是它显示很多东西都是不受限制的
Dialogue: 0,0:09:38.76,0:09:43.76,English,,0,0,0,,But you see it says the stack size is limited to 8192 kbytes or kilobytes
Dialogue: 0,0:09:38.76,0:09:43.76,Chinese,,0,0,0,,这个命令显示栈被限制在 8192 KB
Dialogue: 0,0:09:43.76,0:09:46.12,English,,0,0,0,,So it's 8 megabytes
Dialogue: 0,0:09:43.76,0:09:46.12,Chinese,,0,0,0,,也就是 8 MB
Dialogue: 0,0:09:49.96,0:10:00.77,English,,0,0,0,,And what that means is if you tried to access any memory via the stack pointer
Dialogue: 0,0:09:49.96,0:10:00.77,Chinese,,0,0,0,,那意味着如果你试图使用栈指针去访问一个超过这个 8 MB 范围的地址
Dialogue: 0,0:10:01.60,0:10:09.10,English,,0,0,0,,That was outside of the range of this 8 megabyte range you'd get a segmentation fault
Dialogue: 0,0:10:01.60,0:10:09.10,Chinese,,0,0,0,,将会产生一个段错误
Dialogue: 0,0:10:10.40,0:10:17.74,English,,0,0,0,,And then down at the lower addresses what comes in what gets put into your program are the parts of the code
Dialogue: 0,0:10:10.40,0:10:17.74,Chinese,,0,0,0,,往下更下方的地址是你的程序存放的是代码的地方
Dialogue: 0,0:10:17.74,0:10:20.60,English,,0,0,0,,That that come out of the executable file
Dialogue: 0,0:10:17.74,0:10:20.60,Chinese,,0,0,0,,它来自于可执行文件
Dialogue: 0,0:10:20.94,0:10:28.36,English,,0,0,0,,And so there's a section and we'll talk more,when we talk about linking actually about the way out of the memory and the different regions of it
Dialogue: 0,0:10:20.94,0:10:28.36,Chinese,,0,0,0,,我们会在后面学习链接的时候更加详细地介绍这一部分
Dialogue: 0,0:10:28.82,0:10:36.80,English,,0,0,0,,But for some obscure reason they call where the code is sitting the executable program the text segment
Dialogue: 0,0:10:28.82,0:10:36.80,Chinese,,0,0,0,,出于一些不明原因，这个存放可执行程序的区域被称为文本段
Dialogue: 0,0:10:36.81,0:10:41.90,English,,0,0,0,,I don't know why that's true, but it's the way it is and that's across many machines
Dialogue: 0,0:10:36.81,0:10:41.90,Chinese,,0,0,0,,我不知道为什么，但是在很多机器中就是这么叫的
Dialogue: 0,0:10:42.30,0:10:49.89,English,,0,0,0,,And then the data, first of all there'll be a section for the data that's allocated at the program begins
Dialogue: 0,0:10:42.30,0:10:49.89,Chinese,,0,0,0,,然来我们来看数据区，首先有一个数据段是在数据区中用来存放程序开始时分配的数据的
Dialogue: 0,0:10:49.89,0:10:55.54,English,,0,0,0,,So any global variables that you've declared will be in that section
Dialogue: 0,0:10:49.89,0:10:55.54,Chinese,,0,0,0,,所以你声明的全局变量都在这个数据段中
Dialogue: 0,0:10:56.26,0:11:05.04,English,,0,0,0,,And then the heap is the part of memory that is x is allocated via call to malloc or one of its related functions
Dialogue: 0,0:10:56.26,0:11:05.04,Chinese,,0,0,0,,堆用来存放通过 malloc 或相关的函数申请的变量
Dialogue: 0,0:11:05.06,0:11:08.16,English,,0,0,0,,And so that varies dynamically as the program runs
Dialogue: 0,0:11:05.06,0:11:08.16,Chinese,,0,0,0,,这些变量在程序运行的时候会动态变化
Dialogue: 0,0:11:08.72,0:11:13.30,English,,0,0,0,,It starts off with a very small allocation and every time you call malloc
Dialogue: 0,0:11:08.72,0:11:13.30,Chinese,,0,0,0,,它从一个很小的分配开始，如果你每次都通过 malloc 申请很小的空间但又没有释放的话
Dialogue: 0,0:11:14.08,0:11:19.96,English,,0,0,0,,If you're not freeing memory and so your memory requirements keep growing
Dialogue: 0,0:11:14.08,0:11:19.96,Chinese,,0,0,0,,你所占用的内存就会越来越大
Dialogue: 0,0:11:20.20,0:11:25.68,English,,0,0,0,,It will crease keep up moving up larger and larger addresses
Dialogue: 0,0:11:20.20,0:11:25.68,Chinese,,0,0,0,,它将会向着高地址不断增加
Dialogue: 0,0:11:26.16,0:11:30.18,English,,0,0,0,,And then somewhere in the code too and this can vary by system is
Dialogue: 0,0:11:30.50,0:11:37.76,English,,0,0,0,,The code that gets brought in that represents the library functions things like printf and malloc itself
Dialogue: 0,0:11:26.16,0:11:37.76,Chinese,,0,0,0,,还有一个地方也是存放代码的，不过它存储的是类似 printf 和 malloc 这样的库函数
Dialogue: 0,0:11:38.28,0:11:40.98,English,,0,0,0,,Our own library code they're stored off on disk
Dialogue: 0,0:11:38.28,0:11:40.98,Chinese,,0,0,0,,库代码被存储在磁盘上
Dialogue: 0,0:11:40.98,0:11:48.16,English,,0,0,0,,And they get brought in they get linked into your program when it first starts executing by a process known as dynamic linking
Dialogue: 0,0:11:40.98,0:11:48.16,Chinese,,0,0,0,,当程序开始执行之初会把它们加载到你的程序当中，称之为「动态加载」
Dialogue: 0,0:11:48.32,0:11:51.74,English,,0,0,0,,Which we'll talk about later in the course too with the linking
Dialogue: 0,0:11:48.32,0:11:51.74,Chinese,,0,0,0,,我们会在之后的课程中学习有关动态链接的内容
Dialogue: 0,0:11:52.38,0:11:59.02,English,,0,0,0,,And what you'll find in general is that allocations will tend to be either at these very low addresses
Dialogue: 0,0:11:52.38,0:11:59.02,Chinese,,0,0,0,,你将会发现，总体上来说你的应用程序在运行时有时会分配低地址的空间
Dialogue: 0,0:11:59.38,0:12:03.74,English,,0,0,0,,Or these very high addresses as your program is running
Dialogue: 0,0:11:59.38,0:12:03.74,Chinese,,0,0,0,,有时又会分配高地址的空间
Dialogue: 0,0:12:06.72,0:12:09.44,English,,0,0,0,,So just as an example here is some code
Dialogue: 0,0:12:06.72,0:12:09.44,Chinese,,0,0,0,,下面有一些代码来做个示范
Dialogue: 0,0:12:09.84,0:12:15.08,English,,0,0,0,,Um that it's only value is to show you different where things get located
Dialogue: 0,0:12:09.84,0:12:15.08,Chinese,,0,0,0,,通过它们被分配的地方就可以看出它们的不同
Dialogue: 0,0:12:15.50,0:12:19.50,English,,0,0,0,,And so you'll see I allocated some a fairly large arrays here
Dialogue: 0,0:12:15.50,0:12:19.50,Chinese,,0,0,0,,如你将会看到的一样，我分配了一些相当大的数组
Dialogue: 0,0:12:19.50,0:12:26.60,English,,0,0,0,,This one is there all cares but this is 1<<24 so it's 16
Dialogue: 0,0:12:19.50,0:12:26.60,Chinese,,0,0,0,,一个是 1<<24，也就是 24 MB 大小的数组
Dialogue: 0,0:12:27.20,0:12:31.10,English,,0,0,0,,A megabyte array and this one is 1<<31
Dialogue: 0,0:12:27.20,0:12:31.10,Chinese,,0,0,0,,另一个是 1<<31
Dialogue: 0,0:12:31.88,0:12:37.10,English,,0,0,0,,So it's 2 gigabytes worth of array
Dialogue: 0,0:12:31.88,0:12:37.10,Chinese,,0,0,0,,也就是 2 GB 大小的数组
Dialogue: 0,0:12:37.10,0:12:43.84,English,,0,0,0,,I found that if I tried to allocate larger ones it the program wouldn't run
Dialogue: 0,0:12:37.10,0:12:43.84,Chinese,,0,0,0,,我发现如果尝试分配更大的数组，程序就将无法运行
Dialogue: 0,0:12:44.82,0:12:51.92,English,,0,0,0,,And I also do some here's just a sort of global variable and here's a function
Dialogue: 0,0:12:44.82,0:12:51.92,Chinese,,0,0,0,,我还声明了一个全局变量和一个函数
Dialogue: 0,0:12:52.90,0:12:56.94,English,,0,0,0,,And then there's a single function here with some local variable
Dialogue: 0,0:12:52.90,0:12:56.94,Chinese,,0,0,0,,以及一个带有几个局部变量的函数
Dialogue: 0,0:12:56.94,0:12:59.60,English,,0,0,0,,And that will be allocated somewhere on the stack
Dialogue: 0,0:12:56.94,0:12:59.60,Chinese,,0,0,0,,这些局部变量都被分配在栈上
Dialogue: 0,0:13:00.38,0:13:02.14,English,,0,0,0,,And then there's several calls to malloc
Dialogue: 0,0:13:00.38,0:13:02.14,Chinese,,0,0,0,,然后调用了几次 malloc 函数
Dialogue: 0,0:13:02.26,0:13:08.94,English,,0,0,0,,Some of which are for some very small chunks of memory and somewhere for some very large chunks of memory
Dialogue: 0,0:13:02.26,0:13:08.94,Chinese,,0,0,0,,还有几个变量通过 malloc 来申请小块的和大块的内存
Dialogue: 0,0:13:09.52,0:13:15.87,English,,0,0,0,,And so we can run this program and see what addresses pop out of it
Dialogue: 0,0:13:09.52,0:13:15.87,Chinese,,0,0,0,,我们可以运行这个程序来观察它们的地址
Dialogue: 0,0:13:16.34,0:13:19.08,English,,0,0,0,,And what you'll see is the stack
Dialogue: 0,0:13:16.34,0:13:19.08,Chinese,,0,0,0,,然后你会看到程序的运行栈
Dialogue: 0,0:13:19.48,0:13:24.94,English,,0,0,0,,This local variable is somewhere up with an address in the range of the stack
Dialogue: 0,0:13:19.48,0:13:24.94,Chinese,,0,0,0,,local 变量被分配在了栈的范围内
Dialogue: 0,0:13:24.94,0:13:28.44,English,,0,0,0,,And you see the 7 and a couple fs and then it goes to something else
Dialogue: 0,0:13:24.94,0:13:28.44,Chinese,,0,0,0,,可以看到它的地址有一个 7，两个 f 和其他的东西
Dialogue: 0,0:13:29.40,0:13:32.14,English,,0,0,0,,And you'll see also interestingly enough that
Dialogue: 0,0:13:29.40,0:13:32.14,Chinese,,0,0,0,,你会看到一些有趣的事
Dialogue: 0,0:13:33.14,0:13:35.54,English,,0,0,0,,And then looking down at the bottom
Dialogue: 0,0:13:33.14,0:13:35.54,Chinese,,0,0,0,,然后往下面看
Dialogue: 0,0:13:36.56,0:13:46.50,English,,0,0,0,,This yellow color is things relegated to the text segment the main function and this function I declared called useless
Dialogue: 0,0:13:36.56,0:13:46.50,Chinese,,0,0,0,,main 函数和我声明的一个名为 useless 的函数被分配在了底部的黄色区域，也就是文本段
Dialogue: 0,0:13:47.10,0:13:49.42,English,,0,0,0,,And then the predefined arrays
Dialogue: 0,0:13:47.10,0:13:49.42,Chinese,,0,0,0,,预定义的数组
Dialogue: 0,0:13:50.58,0:13:55.16,English,,0,0,0,,That were in other words globally declared not declared by malloc
Dialogue: 0,0:13:50.58,0:13:55.16,Chinese,,0,0,0,,或者说不是通过 malloc 分配的数组
Dialogue: 0,0:13:55.16,0:14:02.18,English,,0,0,0,,They're declared as part of the program itself are down here in this data section
Dialogue: 0,0:13:55.16,0:14:02.18,Chinese,,0,0,0,,作为程序本身的一部分，被分配在了数据段中
Dialogue: 0,0:14:02.75,0:14:08.52,English,,0,0,0,,And because it's a very large array, the huge array you actually get some fairly large addresses
Dialogue: 0,0:14:02.75,0:14:08.52,Chinese,,0,0,0,,因为它是一个很大的数组，所以你会得到很大的地址
Dialogue: 0,0:14:09.26,0:14:11.12,English,,0,0,0,,And then interestingly enough
Dialogue: 0,0:14:09.26,0:14:11.12,Chinese,,0,0,0,,有趣的是
Dialogue: 0,0:14:11.66,0:14:15.56,English,,0,0,0,,Or I don't know why it's interesting but for one reason or another
Dialogue: 0,0:14:11.66,0:14:15.56,Chinese,,0,0,0,,或者说我不知道它为什么是有趣的，但是出于某些我也不知道的原因
Dialogue: 0,0:14:16.46,0:14:22.02,English,,0,0,0,,It happen that the smaller chunks of memory allocations
Dialogue: 0,0:14:22.34,0:14:28.74,English,,0,0,0,,Are down here at addresses that are actually just a little bit above  the the pink section right
Dialogue: 0,0:14:16.46,0:14:28.74,Chinese,,0,0,0,,小的数组恰巧被分配在了粉色区域的稍微高出一点的地方
Dialogue: 0,0:14:29.06,0:14:38.62,English,,0,0,0,,And similarly the really big chunks of memory I allocate are way up here near the stack limit
Dialogue: 0,0:14:29.06,0:14:38.62,Chinese,,0,0,0,,类似地，那些巨大的数组被分配在了接近栈的限制的地方
Dialogue: 0,0:14:39.28,0:14:43.60,English,,0,0,0,,And they are...
Dialogue: 0,0:14:43.68,0:14:44.82,English,,0,0,0,,And so they're there
Dialogue: 0,0:14:43.68,0:14:44.82,Chinese,,0,0,0,,他们在这里
Dialogue: 0,0:14:44.82,0:14:53.07,English,,0,0,0,,And in general what's happening is if I were to try and reference A memory address in this empty range I'd get a segmentation fault
Dialogue: 0,0:14:44.82,0:14:53.07,Chinese,,0,0,0,,如果我试着去引用中间的这篇空白区域将会产生一个段错误
Dialogue: 0,0:14:53.46,0:14:57.96,English,,0,0,0,,It's a valid address in terms of its bit of properties
Dialogue: 0,0:14:53.46,0:14:57.96,Chinese,,0,0,0,,根据它的位属性，它是一块有效的地址
Dialogue: 0,0:14:57.96,0:15:03.10,English,,0,0,0,,But it hasn't actually been set up and allocated by the memory the virtual memory allocator
Dialogue: 0,0:14:57.96,0:15:03.10,Chinese,,0,0,0,,但是它还没有通过内存分配程序分配
Dialogue: 0,0:15:03.10,0:15:12.00,English,,0,0,0,,So at any given time the valid addresses are just those in the lower portion or the upper portion of this address ranges
Dialogue: 0,0:15:03.10,0:15:12.00,Chinese,,0,0,0,,所以无论何时，合理的地址都是低地址的这一部分和高地址的这一部分
Dialogue: 0,0:15:12.24,0:15:14.16,English,,0,0,0,,And the middle is sort of no-man's land
Dialogue: 0,0:15:12.24,0:15:14.16,Chinese,,0,0,0,,中间的这一部分则属于「无人区」
Dialogue: 0,0:15:14.38,0:15:17.44,English,,0,0,0,,And then what happens is you keep allocating more with malloc
Dialogue: 0,0:15:14.38,0:15:17.44,Chinese,,0,0,0,,然后将会发生的是，如果你持续通过 malloc 分配内存
Dialogue: 0,0:15:17.86,0:15:22.46,English,,0,0,0,,And it will push the limits of what's addressable in toward it
Dialogue: 0,0:15:17.86,0:15:22.46,Chinese,,0,0,0,,两边的地址将会朝着中间靠近
Dialogue: 0,0:15:22.86,0:15:29.46,English,,0,0,0,,And in principle if you ever got too much of a memory request
Dialogue: 0,0:15:22.86,0:15:29.46,Chinese,,0,0,0,,原则上来说，如果你有太多的内存请求
Dialogue: 0,0:15:29.48,0:15:35.26,English,,0,0,0,,These two would hit each other and you and malloc would return zero at that point
Dialogue: 0,0:15:29.48,0:15:35.26,Chinese,,0,0,0,,上下的这两块将会相遇并且 malloc 将会返回 0
Dialogue: 0,0:15:35.64,0:15:43.26,English,,0,0,0,,But it's highly unlikely given that you have 128 terabytes of (memory) address range here
Dialogue: 0,0:15:35.64,0:15:43.26,Chinese,,0,0,0,,但这样看起来的话内存不像是有 128 TB 的地址空间的样子
Dialogue: 0,0:15:44.06,0:15:50.50,English,,0,0,0,,So that just and you've probably seen this when you're running...you're looking at disassembled code with GDB
Dialogue: 0,0:15:44.06,0:15:50.50,Chinese,,0,0,0,,通过 GDB 调试工具，我们可以在运行的同时看到反汇编的代码
Dialogue: 0,0:15:50.50,0:15:56.76,English,,0,0,0,,You're seeing some addresses that are way up here with the 7 and some f so they're stack addresses
Dialogue: 0,0:15:50.50,0:15:56.76,Chinese,,0,0,0,,看到 7 和几个 f 我们就知道这是栈的地址
Dialogue: 0,0:15:57.20,0:16:03.90,English,,0,0,0,,And you see these fours you know a lot of zeros and some fours those tend to be where the code is going
Dialogue: 0,0:15:57.20,0:16:03.90,Chinese,,0,0,0,,看到很多个 0 和几个 4 我们就知道这是代码运行的地方
Dialogue: 0,0:16:04.32,0:16:09.28,English,,0,0,0,,Question
Dialogue: 0,0:16:04.32,0:16:09.28,Chinese,,0,0,0,,有人提问
Dialogue: 0,0:16:09.42,0:16:12.34,English,,0,0,0,,Why doesn't the heat proceed in one direction I actually don't know
Dialogue: 0,0:16:09.42,0:16:12.34,Chinese,,0,0,0,,我也不知道为什么它们不是朝着一个方向
Dialogue: 0,0:16:13.04,0:16:18.32,English,,0,0,0,,I'll just observe that it was had a strategy of putting big things here in small things here
Dialogue: 0,0:16:13.04,0:16:18.32,Chinese,,0,0,0,,我只是观察到大的东西被放在这儿，小的东西被放在那儿
Dialogue: 0,0:16:18.32,0:16:22.88,English,,0,0,0,,And it probably uses different slightly different management strategies for those two
Dialogue: 0,0:16:18.32,0:16:22.88,Chinese,,0,0,0,,操作系统可能会对它们使用不同的管理策略
Dialogue: 0,0:16:33.10,0:16:38.74,English,,0,0,0,,Okay so that I think you'll find that kind of useful to have some sense when you're looking at
Dialogue: 0,0:16:33.10,0:16:38.74,Chinese,,0,0,0,,Okay，所以我认为你们也会发现
Dialogue: 0,0:16:39.20,0:16:45.20,English,,0,0,0,,When you're running GDB it helps to just have some idea of what's going on when you're looking at these different addresses
Dialogue: 0,0:16:39.20,0:16:45.20,Chinese,,0,0,0,,使用 GDB 调试工具去观察程序运行时的各种地址真的很有用
Dialogue: 0,0:16:47.36,0:16:50.44,English,,0,0,0,,Okay now let's talk about buffer overflow
Dialogue: 0,0:16:47.36,0:16:50.44,Chinese,,0,0,0,,OKay，接下来我们讨论缓冲区溢出
Dialogue: 0,0:16:50.92,0:16:58.48,English,,0,0,0,,And we'll start this you remember on the very first class And I think we might have reviewed this part way along
Dialogue: 0,0:16:50.92,0:16:58.48,Chinese,,0,0,0,,在这门课程开始的时候我们应该已经接触过这部分的内容
Dialogue: 0,0:16:58.80,0:17:10.08,English,,0,0,0,,We showed this example of some programs where if you do an out-of-bounds reference and write a value that's out of bounds in particular
Dialogue: 0,0:16:58.80,0:17:10.08,Chinese,,0,0,0,,当时我们在越界试验的程序中专门写了一个超出范围的值
Dialogue: 0,0:17:10.96,0:17:14.60,English,,0,0,0,,I only have a array of two elements here
Dialogue: 0,0:17:10.96,0:17:14.60,Chinese,,0,0,0,,这儿有一个只有两个元素的数组
Dialogue: 0,0:17:15.00,0:17:18.20,English,,0,0,0,,But this function will take an arbitrary value of i
Dialogue: 0,0:17:15.00,0:17:18.20,Chinese,,0,0,0,,但是这个函数的参数 i 可以是任意值
Dialogue: 0,0:17:18.54,0:17:23.04,English,,0,0,0,,And assign some magic number to ailment i of the array
Dialogue: 0,0:17:18.54,0:17:23.04,Chinese,,0,0,0,,那么在给 i 赋值的时候
Dialogue: 0,0:17:24.06,0:17:25.86,English,,0,0,0,,And it has the possibility of...
Dialogue: 0,0:17:24.06,0:17:25.86,Chinese,,0,0,0,,就有可能...
Dialogue: 0,0:17:27.88,0:17:30.28,English,,0,0,0,,And we saw that when you do that
Dialogue: 0,0:17:27.88,0:17:30.28,Chinese,,0,0,0,,我们来看一下如果这么做会怎样
Dialogue: 0,0:17:30.38,0:17:33.24,English,,0,0,0,,If I gets too big it will first
Dialogue: 0,0:17:30.38,0:17:33.24,Chinese,,0,0,0,,如果 i 大于 1
Dialogue: 0,0:17:33.98,0:17:39.12,English,,0,0,0,,Corrupt the the double that stored is part of the struct
Dialogue: 0,0:17:33.98,0:17:39.12,Chinese,,0,0,0,,它就会污染 d 的值
Dialogue: 0,0:17:39.52,0:17:42.42,English,,0,0,0,,And then when it gets bigger it seems to
Dialogue: 0,0:17:39.52,0:17:42.42,Chinese,,0,0,0,,如果继续增大
Dialogue: 0,0:17:42.92,0:17:47.16,English,,0,0,0,,Not have any effect until it gets too big and then you start corrupting memory
Dialogue: 0,0:17:42.92,0:17:47.16,Chinese,,0,0,0,,看上去好像没有什么影响直到你开始污染内存
Dialogue: 0,0:17:47.74,0:17:54.20,English,,0,0,0,,So the basic point is that it's very easy in a program, a C program in particular
Dialogue: 0,0:17:47.74,0:17:54.20,Chinese,,0,0,0,,在程序中，尤其是 C 程序
Dialogue: 0,0:17:54.56,0:17:59.60,English,,0,0,0,,To a reference memory that's not part of the sort of intent of the program
Dialogue: 0,0:17:54.56,0:17:59.60,Chinese,,0,0,0,,非常容易引用超出程序本身意图的的内存
Dialogue: 0,0:18:02.20,0:18:09.50,English,,0,0,0,,And this can happen in programs that aren't properly written that
Dialogue: 0,0:18:02.20,0:18:09.50,Chinese,,0,0,0,,这会发生在那些没有正确书写的程序中
Dialogue: 0,0:18:10.32,0:18:19.66,English,,0,0,0,,And it becomes a security vulnerability if there's some way for an outsider to overflow a buffer
Dialogue: 0,0:18:10.32,0:18:19.66,Chinese,,0,0,0,,如果有途径能让外界使你程序的缓冲区溢出，这将会产生安全问题
Dialogue: 0,0:18:20.24,0:18:25.20,English,,0,0,0,,For example if there is some way for an outsider to give a larger value of i and ask that
Dialogue: 0,0:18:20.24,0:18:25.20,Chinese,,0,0,0,,比如说，如果外界给 i 赋值一个非常大的值
Dialogue: 0,0:18:25.70,0:18:28.42,English,,0,0,0,,That value be stored there it could crash the program
Dialogue: 0,0:18:25.70,0:18:28.42,Chinese,,0,0,0,,这将会摧毁你的程序
Dialogue: 0,0:18:29.34,0:18:33.98,English,,0,0,0,,And so in general, when you're writing code, you (should) try to think about: can I trust this value?
Dialogue: 0,0:18:29.34,0:18:33.98,Chinese,,0,0,0,,因此当你编写代码时应该考虑：我能否信任这个值？
Dialogue: 0,0:18:33.98,0:18:39.84,English,,0,0,0,,This a value that's been computed by my program and I'm sure that it's within bounds
Dialogue: 0,0:18:33.98,0:18:39.84,Chinese,,0,0,0,,这是一个将会被我的程序运算的值并且我相信它在范围内
Dialogue: 0,0:18:40.20,0:18:43.36,English,,0,0,0,,Or is it something that's come from an external source
Dialogue: 0,0:18:40.20,0:18:43.36,Chinese,,0,0,0,,或者说这个值来自于外部
Dialogue: 0,0:18:43.36,0:18:48.16,English,,0,0,0,,And there is potentially that risk of being a vulnerability
Dialogue: 0,0:18:43.36,0:18:48.16,Chinese,,0,0,0,,它将会有潜在的安全性的问题
Dialogue: 0,0:18:49.58,0:18:53.22,English,,0,0,0,,And so in particular there's a lot a huge class of errors
Dialogue: 0,0:18:53.22,0:19:04.94,English,,0,0,0,,That have to do with overflowing buffers where they're trying to store a string of some type that's been read from a message
Dialogue: 0,0:18:49.58,0:19:04.94,Chinese,,0,0,0,,在存储来自于一条消息的字符串时，将会出现非常多有关缓冲区溢出的问题
Dialogue: 0,0:19:05.70,0:19:10.38,English,,0,0,0,,And without knowing in advance how big that string is
Dialogue: 0,0:19:05.70,0:19:10.38,Chinese,,0,0,0,,由于无法提前知道字符串的大小
Dialogue: 0,0:19:10.38,0:19:14.90,English,,0,0,0,,It's possible that it will be too big for the buffer that's been allocated
Dialogue: 0,0:19:10.38,0:19:14.90,Chinese,,0,0,0,,所以对于已经分配的缓冲区来说，这个字符串可能会过大
Dialogue: 0,0:19:15.48,0:19:21.72,English,,0,0,0,,And so one of the culprits is there's a whole class of library functions that
Dialogue: 0,0:19:22.32,0:19:30.04,English,,0,0,0,,Let you store something a string somewhere without any kind of bounds checking even being possible
Dialogue: 0,0:19:15.48,0:19:30.04,Chinese,,0,0,0,,引发这个问题的罪魁祸首之一就是那些存储字符串但却不检查边界情况的库函数
Dialogue: 0,0:19:30.73,0:19:34.70,English,,0,0,0,,So the sort of worst one is one called gets
Dialogue: 0,0:19:30.73,0:19:34.70,Chinese,,0,0,0,,尤其是 gets 函数
Dialogue: 0,0:19:35.20,0:19:46.00,English,,0,0,0,,And the purpose of gets is normally it's used to read a string from an input from a terminal input something that somebody's typed into a terminal
Dialogue: 0,0:19:35.20,0:19:46.00,Chinese,,0,0,0,,这个函数的目的一般来说是从终端的输入中读取某人键入的字符串
Dialogue: 0,0:19:46.38,0:19:54.76,English,,0,0,0,,And so what it's doing is it's scanning this input string and looking for a character that represents the end of the line
Dialogue: 0,0:19:46.38,0:19:54.76,Chinese,,0,0,0,,所以他做的事情就是扫描输入的字符串并寻找代表一行结束的字符
Dialogue: 0,0:19:54.94,0:19:59.14,English,,0,0,0,,Which we write in C as backslash n
Dialogue: 0,0:19:54.94,0:19:59.14,Chinese,,0,0,0,,我们把这个符号写作「反斜杠 n」
Dialogue: 0,0:19:59.48,0:20:02.94,English,,0,0,0,,And it has a character code at hex of 0a
Dialogue: 0,0:19:59.48,0:20:02.94,Chinese,,0,0,0,,它的十六进制编码是 0x0a
Dialogue: 0,0:20:04.58,0:20:11.28,English,,0,0,0,,And so gets this is sort of an approximate version of what the code for gets looks like
Dialogue: 0,0:20:04.58,0:20:11.28,Chinese,,0,0,0,,这是一个和原版 gets 看上去非常像的一个函数
Dialogue: 0,0:20:11.78,0:20:17.02,English,,0,0,0,,That and it's as an argument it's just given a destination of where to store the result
Dialogue: 0,0:20:11.78,0:20:17.02,Chinese,,0,0,0,,它的参数是保存结果的目标地址
Dialogue: 0,0:20:17.48,0:20:20.76,English,,0,0,0,,And all it does is it reads one character at a time
Dialogue: 0,0:20:17.48,0:20:20.76,Chinese,,0,0,0,,这个函数所做的事情只是一次读取一个字符
Dialogue: 0,0:20:21.16,0:20:27.63,English,,0,0,0,,Looks for an end-of-file meaning that the input stream is closed or an end-of-line
Dialogue: 0,0:20:21.16,0:20:27.63,Chinese,,0,0,0,,查找 EOF 字符意味着输入流已经结束或一行的结束
Dialogue: 0,0:20:27.66,0:20:34.80,English,,0,0,0,,But as long as it until it sees that it just keeps adding more things to the end of this buffer
Dialogue: 0,0:20:27.66,0:20:34.80,Chinese,,0,0,0,,但是只要没有遇到 EOF 它就会不停地向缓冲区的末尾添加字符
Dialogue: 0,0:20:37.66,0:20:39.28,English,,0,0,0,,And so typically
Dialogue: 0,0:20:37.66,0:20:39.28,Chinese,,0,0,0,,通常......
Dialogue: 0,0:20:43.98,0:20:50.66,English,,0,0,0,,When somebody calls gets they'll pass it a pointer to some buffer that they've allocated
Dialogue: 0,0:20:43.98,0:20:50.66,Chinese,,0,0,0,,十分典型的是，当有人调用 gets 函数时，它将传递一个指向已经分配好的缓冲区的指针
Dialogue: 0,0:20:51.36,0:20:56.00,English,,0,0,0,,But the function and it will just gets we'll just fill that buffer up
Dialogue: 0,0:20:51.36,0:20:56.00,Chinese,,0,0,0,,但即便仅是gets函数，它也将恰好填满缓冲区
Dialogue: 0,0:20:56.80,0:21:00.76,English,,0,0,0,,But it can potentially just keep going there's nothing in the function
Dialogue: 0,0:20:56.80,0:21:00.76,Chinese,,0,0,0,,但它很有可能会继续增长
Dialogue: 0,0:21:00.96,0:21:03.44,English,,0,0,0,,There's not even an argument to the function
Dialogue: 0,0:21:00.96,0:21:03.44,Chinese,,0,0,0,,这个函数中缺乏这样一种参数
Dialogue: 0,0:21:03.90,0:21:10.26,English,,0,0,0,,That tells the function when it has to stop when it's reached the limit of it
Dialogue: 0,0:21:03.90,0:21:10.26,Chinese,,0,0,0,,用来告诉这个函数什么时候该停止，什么时候会到达它的极限
Dialogue: 0,0:21:10.58,0:21:13.30,English,,0,0,0,,So it was written it actually gets is
Dialogue: 0,0:21:13.30,0:21:17.62,English,,0,0,0,,If you try to compile code would gets it will flash up a big warning that says
Dialogue: 0,0:21:13.30,0:21:17.62,Chinese,,0,0,0,,当你编译代码时，将会出现一个警告
Dialogue: 0,0:21:17.62,0:21:21.10,English,,0,0,0,,This is really an unsafe function you probably shouldn't even be using it
Dialogue: 0,0:21:17.62,0:21:21.10,Chinese,,0,0,0,,这是一个不安全的函数并且你不应该使用它
Dialogue: 0,0:21:21.50,0:21:28.74,English,,0,0,0,,Because it was written in the 1970s
Dialogue: 0,0:21:21.50,0:21:28.74,Chinese,,0,0,0,,因为这个函数编写于上世纪 70 年代
Dialogue: 0,0:21:28.74,0:21:31.40,English,,0,0,0,,When the early UNIX distributions were coming out
Dialogue: 0,0:21:28.74,0:21:31.40,Chinese,,0,0,0,,当时早期的 UNIX 发行版刚刚推出
Dialogue: 0,0:21:31.76,0:21:34.60,English,,0,0,0,,Where people just weren't worried about security vulnerabilities
Dialogue: 0,0:21:31.76,0:21:34.60,Chinese,,0,0,0,,人们还不用担心安全问题
Dialogue: 0,0:21:34.78,0:21:40.94,English,,0,0,0,,And they just assumed that if you allocated a big enough buffer
Dialogue: 0,0:21:34.78,0:21:40.94,Chinese,,0,0,0,,并且假设你已经分配了足够大的缓冲区
Dialogue: 0,0:21:41.32,0:21:46.44,English,,0,0,0,,That there's no reason why a string should be bigger than what you've allocated
Dialogue: 0,0:21:41.32,0:21:46.44,Chinese,,0,0,0,,输入的字符串也不会比缓冲区还要大
Dialogue: 0,0:21:47.90,0:21:53.16,English,,0,0,0,,And that's actually true with other functions like strcpy
Dialogue: 0,0:21:47.90,0:21:53.16,Chinese,,0,0,0,,strcpy 函数也是如此
Dialogue: 0,0:21:53.68,0:21:58.80,English,,0,0,0,,You recall strcpy has two arguments
Dialogue: 0,0:21:53.68,0:21:58.80,Chinese,,0,0,0,,它有两个参数
Dialogue: 0,0:21:59.40,0:22:02.86,English,,0,0,0,,Excuse me a destination and a source
Dialogue: 0,0:21:59.40,0:22:02.86,Chinese,,0,0,0,,源地址和目标地址
Dialogue: 0,0:22:03.78,0:22:08.64,English,,0,0,0,,And its purpose is to copy the string at the source into the destination
Dialogue: 0,0:22:03.78,0:22:08.64,Chinese,,0,0,0,,它的作用是将源地址的字符串拷贝到目的地址
Dialogue: 0,0:22:09.08,0:22:13.14,English,,0,0,0,,And the way it determines the end of the string and the source is when it hits a null character
Dialogue: 0,0:22:09.08,0:22:13.14,Chinese,,0,0,0,,它将空字符作为字符串的结束
Dialogue: 0,0:22:13.60,0:22:17.86,English,,0,0,0,,That just keeps copying one by one well until it hits it
Dialogue: 0,0:22:13.60,0:22:17.86,Chinese,,0,0,0,,在遇到空字符之前它会一直拷贝
Dialogue: 0,0:22:18.10,0:22:27.38,English,,0,0,0,,But it has no way of knowing there's nothing no information there about how much How big is the the buffer allocated at the destination
Dialogue: 0,0:22:18.10,0:22:27.38,Chinese,,0,0,0,,但是这个函数没有办法知道目标地址的缓冲区有多大
Dialogue: 0,0:22:27.70,0:22:29.66,English,,0,0,0,,And so it can easily overrun that
Dialogue: 0,0:22:27.70,0:22:29.66,Chinese,,0,0,0,,因此很容易就会超出这个范围
Dialogue: 0,0:22:29.92,0:22:36.66,English,,0,0,0,,That a similar one called strcat which is used to concatenate two strings copy another destination
Dialogue: 0,0:22:29.92,0:22:36.66,Chinese,,0,0,0,,还有一个类似的函数称为 strcat，它用来将两个字符串拼接并且拷贝到目标地址
Dialogue: 0,0:22:37.34,0:22:44.30,English,,0,0,0,,And the scanf functions also have possible in the format string
Dialogue: 0,0:22:37.34,0:22:44.30,Chinese,,0,0,0,,scanf 函数在获取输入的字符串时也会有缓冲区溢出的可能
Dialogue: 0,0:22:44.30,0:22:46.06,English,,0,0,0,,You can give the %s
Dialogue: 0,0:22:44.30,0:22:46.06,Chinese,,0,0,0,,给它传递 %s 参数
Dialogue: 0,0:22:46.82,0:22:52.84,English,,0,0,0,,A directive to the format string which says read in a string and store it someplace
Dialogue: 0,0:22:46.82,0:22:52.84,Chinese,,0,0,0,,它会读取一个字符串并且将它存储在某个地方
Dialogue: 0,0:22:53.56,0:22:56.74,English,,0,0,0,,And it doesn't say how long the string is limited to be
Dialogue: 0,0:22:53.56,0:22:56.74,Chinese,,0,0,0,,它既不知道字符串有多长
Dialogue: 0,0:22:56.74,0:23:00.52,English,,0,0,0,,And it doesn't say how much memory is available at the destination
Dialogue: 0,0:22:56.74,0:23:00.52,Chinese,,0,0,0,,也不知道目标地址的缓冲区有多大
Dialogue: 0,0:23:00.78,0:23:04.52,English,,0,0,0,,So again it can easily just write over that a buffer
Dialogue: 0,0:23:00.78,0:23:04.52,Chinese,,0,0,0,,因此它也很容易导致缓冲区溢出
Dialogue: 0,0:23:05.72,0:23:08.16,English,,0,0,0,,So these are real vulnerabilities
Dialogue: 0,0:23:05.72,0:23:08.16,Chinese,,0,0,0,,这些都是真实的安全问题
Dialogue: 0,0:23:08.16,0:23:14.74,English,,0,0,0,,We'll talk in a minute a little later about how you as a programmer can be a little smarter than this
Dialogue: 0,0:23:08.16,0:23:14.74,Chinese,,0,0,0,,之后我们马上会讨论你作为一个程序员如何处理这些问题
Dialogue: 0,0:23:15.12,0:23:22.50,English,,0,0,0,,But in their suit of raw form as presented they have this vulnerability to them
Dialogue: 0,0:23:15.12,0:23:22.50,Chinese,,0,0,0,,屏幕上列出的这些函数都有安全问题
Dialogue: 0,0:23:23.68,0:23:29.30,English,,0,0,0,,So let's look at an example of what this can...what can happen there
Dialogue: 0,0:23:23.68,0:23:29.30,Chinese,,0,0,0,,下面我们来看一个例子
Dialogue: 0,0:23:29.74,0:23:34.96,English,,0,0,0,,So imagine for example we want a to implement echo function
Dialogue: 0,0:23:29.74,0:23:34.96,Chinese,,0,0,0,,我们要实现一个 echo 函数
Dialogue: 0,0:23:34.96,0:23:40.02,English,,0,0,0,,So an echo function is one that you just type something in and prints it back out
Dialogue: 0,0:23:34.96,0:23:40.02,Chinese,,0,0,0,,这个函数的作用就是输入一些东西并把它打印出来
Dialogue: 0,0:23:40.02,0:23:43.80,English,,0,0,0,,It's very uninteresting function except it's very useful to demonstrate things
Dialogue: 0,0:23:40.02,0:23:43.80,Chinese,,0,0,0,,这个函数十分无趣但是在演示某些问题时却很有用
Dialogue: 0,0:23:44.58,0:23:49.32,English,,0,0,0,,So the idea is it has this little buffer it's only enough to hold four characters
Dialogue: 0,0:23:44.58,0:23:49.32,Chinese,,0,0,0,,它的主要想法是，使用一个只能容纳四个字符的缓冲区
Dialogue: 0,0:23:49.78,0:23:53.84,English,,0,0,0,,Because gets to read a string from the input
Dialogue: 0,0:23:49.78,0:23:53.84,Chinese,,0,0,0,,因为 gets 是用来从输入读取字符串
Dialogue: 0,0:23:54.16,0:23:59.78,English,,0,0,0,,And then it calls puts which simply writes back out the output
Dialogue: 0,0:23:54.16,0:23:59.78,Chinese,,0,0,0,,然后它调用 puts ，puts 用来将字符串输出
Dialogue: 0,0:24:09.38,0:24:14.06,English,,0,0,0,,And so let me just demo this not very interesting function
Dialogue: 0,0:24:09.38,0:24:14.06,Chinese,,0,0,0,,我们来演示一下这个无趣的函数
Dialogue: 0,0:24:21.14,0:24:24.98,English,,0,0,0,,So I call here buffdemo-nsp
Dialogue: 0,0:24:21.14,0:24:24.98,Chinese,,0,0,0,,我把这个文件叫做 buffdemo-nsp
Dialogue: 0,0:24:26.74,0:24:31.04,English,,0,0,0,,Meaning as no stack protector we'll see in a minute what a stack protector is
Dialogue: 0,0:24:26.74,0:24:31.04,Chinese,,0,0,0,,这意味着它没有启用栈保护，我们马上就会知道什么是栈保护
Dialogue: 0,0:24:31.46,0:24:35.60,English,,0,0,0,,But you see if you type a reasonably strong small string
Dialogue: 0,0:24:31.46,0:24:35.60,Chinese,,0,0,0,,如果我们输入合理且短小字符串
Dialogue: 0,0:24:41.92,0:24:47.08,English,,0,0,0,,Let's see what remember it can handle more than four
Dialogue: 0,0:24:41.92,0:24:47.08,Chinese,,0,0,0,,它可以处理超过 4 个字符的字符串
Dialogue: 0,0:24:48.04,0:24:50.98,English,,0,0,0,,Actually as written it can't handle more than three right
Dialogue: 0,0:24:48.04,0:24:50.98,Chinese,,0,0,0,,实际上它不能处理超过 3 个字符的字符串
Dialogue: 0,0:24:50.98,0:24:55.26,English,,0,0,0,,Because there should be room for the null character to on terminator
Dialogue: 0,0:24:50.98,0:24:55.26,Chinese,,0,0,0,,因为要给终止处的空字符留出空间
Dialogue: 0,0:25:02.00,0:25:07.92,English,,0,0,0,,So it turns out with this particular one if I type in a string of 24 characters
Dialogue: 0,0:25:02.00,0:25:07.92,Chinese,,0,0,0,,所以结果是，如果我输入一个 24 个字符的字符串
Dialogue: 0,0:25:09.72,0:25:11.04,English,,0,0,0,,It'll be okay
Dialogue: 0,0:25:09.72,0:25:11.04,Chinese,,0,0,0,,也是可以的
Dialogue: 0,0:25:22.36,0:25:24.86,English,,0,0,0,,But if I type in a string of 24 characters
Dialogue: 0,0:25:22.36,0:25:24.86,Chinese,,0,0,0,,但是如果我输入一个 24 个字符的字符串
Dialogue: 0,0:25:27.52,0:25:30.02,English,,0,0,0,,It will hit a segmentation fault
Dialogue: 0,0:25:27.52,0:25:30.02,Chinese,,0,0,0,,将会产生一个段错误
Dialogue: 0,0:25:33.12,0:25:35.90,English,,0,0,0,,So where do those numbers 23 and 24 come in
Dialogue: 0,0:25:33.12,0:25:35.90,Chinese,,0,0,0,,那么这个 23 和 24 是从哪来的呢
Dialogue: 0,0:25:35.90,0:25:39.04,English,,0,0,0,,Well that's something we can learn by looking at the assembly code
Dialogue: 0,0:25:35.90,0:25:39.04,Chinese,,0,0,0,,我们可以从汇编代码中来观察
Dialogue: 0,0:25:56.22,0:25:59.18,English,,0,0,0,,So here's and we'll go through this code
Dialogue: 0,0:25:56.22,0:25:59.18,Chinese,,0,0,0,,现在我们来看汇编代码
Dialogue: 0,0:26:00.08,0:26:04.70,English,,0,0,0,,So first of all, this is the code for echo then
Dialogue: 0,0:26:00.08,0:26:04.70,Chinese,,0,0,0,,这是 echo 函数的汇编代码
Dialogue: 0,0:26:05.58,0:26:09.18,English,,0,0,0,,And you see the echo calls gets and it calls puts
Dialogue: 0,0:26:05.58,0:26:09.18,Chinese,,0,0,0,,它调用了 gets 和 puts
Dialogue: 0,0:26:13.34,0:26:19.56,English,,0,0,0,,And here's the part of the code where you can tell how much memory got allocated for the buffer
Dialogue: 0,0:26:13.34,0:26:19.56,Chinese,,0,0,0,,从这句代码可以看出它为缓冲区分配了多少内存
Dialogue: 0,0:26:20.06,0:26:29.34,English,,0,0,0,,And 0x18 is what in decimal
Dialogue: 0,0:26:20.06,0:26:29.34,Chinese,,0,0,0,,0x18 的十进制表示是多少
Dialogue: 0,0:26:34.04,0:26:34.98,English,,0,0,0,,24 right?
Dialogue: 0,0:26:34.04,0:26:34.98,Chinese,,0,0,0,,24 对吧？
Dialogue: 0,0:26:39.64,0:26:45.54,English,,0,0,0,,And just saw that the thing actually segfaults with a input string of 24
Dialogue: 0,0:26:45.54,0:26:46.60,English,,0,0,0,,So we'll see that in a minute
Dialogue: 0,0:26:39.64,0:26:46.60,Chinese,,0,0,0,,当我们输入一个 24 个字符的字符串时，马上产生了一个段错误
Dialogue: 0,0:26:47.50,0:26:55.28,English,,0,0,0,,But anyways you can see here that it's allocating on the stack a region of 24 bytes
Dialogue: 0,0:26:47.50,0:26:55.28,Chinese,,0,0,0,,但是这个程序在栈上分配了一个 24 字节的区域
Dialogue: 0,0:26:56.00,0:27:04.14,English,,0,0,0,,And it's copying that into %rdi which is of course the argument for gets
Dialogue: 0,0:26:56.00,0:27:04.14,Chinese,,0,0,0,,并且将它拷贝到 %rdi，也就是 gets 的参数
Dialogue: 0,0:27:04.20,0:27:12.76,English,,0,0,0,,So gets is being called with a pointer to a buffer of size 24 of maximum 24
Dialogue: 0,0:27:04.20,0:27:12.76,Chinese,,0,0,0,,因此 gets 在被调用时使用了一个 24 字节的缓冲区
Dialogue: 0,0:27:12.80,0:27:16.62,English,,0,0,0,,Or even though you saw the original declaration was just four
Dialogue: 0,0:27:12.80,0:27:16.62,Chinese,,0,0,0,,即使最开始只声明了 4 个字节的缓冲区
Dialogue: 0,0:27:20.20,0:27:25.84,English,,0,0,0,,Um and then it calls gets and then gets does it thing
Dialogue: 0,0:27:20.20,0:27:25.84,Chinese,,0,0,0,,下一句调用了 gets
Dialogue: 0,0:27:26.44,0:27:30.10,English,,0,0,0,,And just one last little bit to keep in mind is
Dialogue: 0,0:27:26.44,0:27:30.10,Chinese,,0,0,0,,最后需要清楚的是
Dialogue: 0,0:27:31.16,0:27:32.72,English,,0,0,0,,We'll get back to them
Dialogue: 0,0:27:31.16,0:27:32.72,Chinese,,0,0,0,,一会儿再说吧
Dialogue: 0,0:27:33.14,0:27:36.10,English,,0,0,0,,Oh yes and remember echo
Dialogue: 0,0:27:33.14,0:27:36.10,Chinese,,0,0,0,,记住 echo 函数
Dialogue: 0,0:27:38.36,0:27:42.74,English,,0,0,0,,I there's a function called call_echo which is the thing that calls echo
Dialogue: 0,0:27:38.36,0:27:42.74,Chinese,,0,0,0,,有一个名为 call_echo 的函数，它是用来调用 echo 函数的
Dialogue: 0,0:27:43.46,0:27:48.84,English,,0,0,0,,And just to keep in mind this red is the return address for call_echo
Dialogue: 0,0:27:43.46,0:27:48.84,Chinese,,0,0,0,,红色的是 call_echo 的返回值地址
Dialogue: 0,0:27:49.94,0:27:51.88,English,,0,0,0,,And that's going to be important
Dialogue: 0,0:27:49.94,0:27:51.88,Chinese,,0,0,0,,这个很重要
Dialogue: 0,0:27:55.94,0:27:59.66,English,,0,0,0,,So what we see then is the memory layout is
Dialogue: 0,0:27:55.94,0:27:59.66,Chinese,,0,0,0,,现在来看内存的布局
Dialogue: 0,0:28:01.22,0:28:05.86,English,,0,0,0,,The buff is normally big enough for four characters
Dialogue: 0,0:28:01.22,0:28:05.86,Chinese,,0,0,0,,缓冲区对于 4 个字符来说是足够的
Dialogue: 0,0:28:06.58,0:28:10.60,English,,0,0,0,,There's a sort of 20 bytes of unused or wasted space here
Dialogue: 0,0:28:06.58,0:28:10.60,Chinese,,0,0,0,,还有 20 个字节没有使用
Dialogue: 0,0:28:10.96,0:28:17.86,English,,0,0,0,,And then the actual return address which is the return address for back to call_echo is stored on the stack
Dialogue: 0,0:28:10.96,0:28:17.86,Chinese,,0,0,0,,返回到 call_echo 函数的地址被存储在栈上
Dialogue: 0,0:28:23.56,0:28:28.80,English,,0,0,0,,So when this program begins running when echo starts to run
Dialogue: 0,0:28:23.56,0:28:28.80,Chinese,,0,0,0,,当 echo 函数运行的时候
Dialogue: 0,0:28:29.12,0:28:34.38,English,,0,0,0,,We'll find that this is the value on the stack for the return pointer
Dialogue: 0,0:28:29.12,0:28:34.38,Chinese,,0,0,0,,我们将会在栈中找到这个返回地址的指针
Dialogue: 0,0:28:35.98,0:28:43.04,English,,0,0,0,,And if we type in a string of up here of 23 characters
Dialogue: 0,0:28:35.98,0:28:43.04,Chinese,,0,0,0,,如果我们输入 23 个字符
Dialogue: 0,0:28:43.88,0:28:50.22,English,,0,0,0,,You'll see that it uses up this entire buffer and remember a string is terminated with 00
Dialogue: 0,0:28:43.88,0:28:50.22,Chinese,,0,0,0,,将会用光整个缓冲区，因为字符串是以 00 结束的
Dialogue: 0,0:28:51.10,0:28:57.40,English,,0,0,0,,But it still hasn't...it's still within the region that was allocated on the stack for that
Dialogue: 0,0:28:51.10,0:28:57.40,Chinese,,0,0,0,,但是它仍然没有...它仍然在给它分配的范围内
Dialogue: 0,0:28:57.48,0:29:01.60,English,,0,0,0,,So it just barely fits into the the stack
Dialogue: 0,0:28:57.48,0:29:01.60,Chinese,,0,0,0,,它刚好适合这个区域
Dialogue: 0,0:29:02.18,0:29:10.40,English,,0,0,0,,And that's why we technically we overflowed the buffer but we didn't really cause any harm because there was this extra space available
Dialogue: 0,0:29:02.18,0:29:10.40,Chinese,,0,0,0,,这就是为什么我们已经溢出了缓冲区，但是却没有造成什么影响，正是因为这块额外的空间
Dialogue: 0,0:29:11.38,0:29:17.96,English,,0,0,0,,And so that's why I could type in that string of 23 characters and it worked fine
Dialogue: 0,0:29:11.38,0:29:17.96,Chinese,,0,0,0,,我输入了 23 个字符的字符串，程序可以正常运行
Dialogue: 0,0:29:18.98,0:29:20.36,English,,0,0,0,,But now if I type in...
Dialogue: 0,0:29:18.98,0:29:20.36,Chinese,,0,0,0,,但是如果我输入...
Dialogue: 0,0:29:21.76,0:29:23.92,English,,0,0,0,,This is an example showing...
Dialogue: 0,0:29:21.76,0:29:23.92,Chinese,,0,0,0,,正如这个例子所示...
Dialogue: 0,0:29:29.44,0:29:31.12,English,,0,0,0,,I actually 25 characters
Dialogue: 0,0:29:29.44,0:29:31.12,Chinese,,0,0,0,,实际上有 25 个字符
Dialogue: 0,0:29:32.74,0:29:40.14,English,,0,0,0,,So once I go beyond the 23 characters plus the null character you'll see
Dialogue: 0,0:29:32.74,0:29:40.14,Chinese,,0,0,0,,一旦我输入超过 23 个字符，再加上空字符
Dialogue: 0,0:29:40.14,0:29:49.72,English,,0,0,0,,what I'm slowly starting to do is corrupt the the the byte representation of the return address
Dialogue: 0,0:29:40.14,0:29:49.72,Chinese,,0,0,0,,我正慢慢开始做的是破坏返回地址的字节表示
Dialogue: 0,0:29:50.38,0:29:52.64,English,,0,0,0,,And so what happens for example here
Dialogue: 0,0:29:50.38,0:29:52.64,Chinese,,0,0,0,,这个例子中会发生什么
Dialogue: 0,0:29:53.00,0:30:00.98,English,,0,0,0,,Is that rather than trying to return back to the where call_echo was supposed to where it was supposed to go back to
Dialogue: 0,0:29:53.00,0:30:00.98,Chinese,,0,0,0,,它将不会返回 call_echo 调用 echo 的地方
Dialogue: 0,0:30:01.32,0:30:03.74,English,,0,0,0,,It goes back to some other part of your code
Dialogue: 0,0:30:01.32,0:30:03.74,Chinese,,0,0,0,,而是其它地方
Dialogue: 0,0:30:04.20,0:30:11.00,English,,0,0,0,,That may or may not be a valid address or Might not have anything to do with the program you're trying to run
Dialogue: 0,0:30:04.20,0:30:11.00,Chinese,,0,0,0,,那有可能不是一个合法的地址或者说不是你想要的结果
Dialogue: 0,0:30:12.56,0:30:16.56,English,,0,0,0,,So this example shows it and if I typed in the 24
Dialogue: 0,0:30:12.56,0:30:16.56,Chinese,,0,0,0,,这个例子展示了当我输入 24 个字符时的情况
Dialogue: 0,0:30:22.10,0:30:26.04,English,,0,0,0,,Let's see...before I got it to run
Dialogue: 0,0:30:22.10,0:30:26.04,Chinese,,0,0,0,,在我开始运行之前
Dialogue: 0,0:30:26.04,0:30:33.48,English,,0,0,0,,Like this you know this thing depends on the what happens,how the code happens to get compiled
Dialogue: 0,0:30:26.04,0:30:33.48,Chinese,,0,0,0,,会发生什么完全取决于代码如何编译
Dialogue: 0,0:30:36.04,0:30:42.70,English,,0,0,0,,Oh yeah so okay, so actually you see here
Dialogue: 0,0:30:36.04,0:30:42.70,Chinese,,0,0,0,,实际上，如你所见
Dialogue: 0,0:30:43.90,0:30:49.12,English,,0,0,0,,This first string I typed is actually 24 characters long plus the null pointer
Dialogue: 0,0:30:43.90,0:30:49.12,Chinese,,0,0,0,,我输入的第一个字符串有 24 个字符，还有一个空字符
Dialogue: 0,0:30:49.80,0:30:54.12,English,,0,0,0,,So uh and we'll see why it didn't...it should have crashed
Dialogue: 0,0:30:49.80,0:30:54.12,Chinese,,0,0,0,,程序应该已经崩溃了
Dialogue: 0,0:30:54.38,0:30:58.86,English,,0,0,0,,Because we actually overwrite wrote the low order byte of the return address
Dialogue: 0,0:30:54.38,0:30:58.86,Chinese,,0,0,0,,因为我们已经覆盖了返回地址低位的一个字节
Dialogue: 0,0:30:59.68,0:31:02.10,English,,0,0,0,,Here we typed in this is 25 characters
Dialogue: 0,0:30:59.68,0:31:02.10,Chinese,,0,0,0,,下面的例子中我确实输入了 25 个字符
Dialogue: 0,0:31:02.10,0:31:07.46,English,,0,0,0,,And so that's the one I just showed where it really whacked the two bytes of the return address
Dialogue: 0,0:31:02.10,0:31:07.46,Chinese,,0,0,0,,它覆盖了返回地址的两个字节
Dialogue: 0,0:31:08.02,0:31:10.22,English,,0,0,0,,So here we actually did overflow the buffer
Dialogue: 0,0:31:08.02,0:31:10.22,Chinese,,0,0,0,,这里我们确实溢出了缓冲区
Dialogue: 0,0:31:11.24,0:31:17.22,English,,0,0,0,,And let's try and figure out why that didn't harm the the program execution
Dialogue: 0,0:31:11.24,0:31:17.22,Chinese,,0,0,0,,让我们试着搞清楚为什么上面的字符串没有让程序崩溃
Dialogue: 0,0:31:17.22,0:31:18.20,English,,0,0,0,,I see a question
Dialogue: 0,0:31:17.22,0:31:18.20,Chinese,,0,0,0,,有人提问
Dialogue: 0,0:31:18.20,0:31:22.78,English,,0,0,0,,[student speaking]
Dialogue: 0,0:31:18.20,0:31:22.78,Chinese,,0,0,0,,[学生提问](应该是询问返回地址被篡改时会发生什么)
Dialogue: 0,0:31:22.78,0:31:25.58,English,,0,0,0,,Yes it could have been various other things could have there's nothing
Dialogue: 0,0:31:22.78,0:31:25.58,Chinese,,0,0,0,,那个地址可能是其他的东西，也有可能什么也没有
Dialogue: 0,0:31:26.26,0:31:28.68,English,,0,0,0,,It hit a segmentation fault
Dialogue: 0,0:31:26.26,0:31:28.68,Chinese,,0,0,0,,这样就会产生一个段错误
Dialogue: 0,0:31:28.98,0:31:33.14,English,,0,0,0,,It probably went to some weird part of the code and just started executing some random stuff
Dialogue: 0,0:31:28.98,0:31:33.14,Chinese,,0,0,0,,程序可能会跳转到奇怪的地方
Dialogue: 0,0:31:33.48,0:31:35.14,English,,0,0,0,,And just got itself into trouble
Dialogue: 0,0:31:33.48,0:31:35.14,Chinese,,0,0,0,,这可能会使程序崩溃
Dialogue: 0,0:31:35.58,0:31:40.48,English,,0,0,0,,But that's the point is it's not predictable exactly what will happen when you do this
Dialogue: 0,0:31:35.58,0:31:40.48,Chinese,,0,0,0,,总之当你这样做的时候会发生什么完全是不可预测的
Dialogue: 0,0:31:52.40,0:31:56.10,English,,0,0,0,,So this is that the example of what actually happened the first time
Dialogue: 0,0:31:56.42,0:31:59.84,English,,0,0,0,,When I typed in a string that had 24 characters
Dialogue: 0,0:31:52.40,0:31:59.84,Chinese,,0,0,0,,这就是当我输入 24 个字符的字符串的时候发生的事情
Dialogue: 0,0:32:00.24,0:32:04.02,English,,0,0,0,,And so this null byte at the end actually corrupted the return address
Dialogue: 0,0:32:00.24,0:32:04.02,Chinese,,0,0,0,,最后的空字符侵占了返回地址
Dialogue: 0,0:32:05.68,0:32:12.30,English,,0,0,0,,And so it was supposed to return back to this address 0x4006f6
Dialogue: 0,0:32:05.68,0:32:12.30,Chinese,,0,0,0,,它本来应该返回到 0x4006f6
Dialogue: 0,0:32:12.92,0:32:16.98,English,,0,0,0,,And instead it will return back to the address 0x400600
Dialogue: 0,0:32:12.92,0:32:16.98,Chinese,,0,0,0,,但是它实际上返回到了 0x400600
Dialogue: 0,0:32:18.04,0:32:26.16,English,,0,0,0,,Which happens to be in some other weird function that's there and it just sort of landed at some place here
Dialogue: 0,0:32:18.04,0:32:26.16,Chinese,,0,0,0,,因此程序跳转到了一个奇怪的函数
Dialogue: 0,0:32:26.16,0:32:33.28,English,,0,0,0,,And it's doing various things but somehow it didn't really (didn't) crash the program
Dialogue: 0,0:32:26.16,0:32:33.28,Chinese,,0,0,0,,不知道为什么它并没有使程序崩溃
Dialogue: 0,0:32:33.28,0:32:38.62,English,,0,0,0,,And that's one of the frustrating things about this is that things can go wrong in a program
Dialogue: 0,0:32:33.28,0:32:38.62,Chinese,,0,0,0,,让人失望的是它会使程序错误地运行
Dialogue: 0,0:32:39.12,0:32:41.80,English,,0,0,0,,And they don't always cause a crash
Dialogue: 0,0:32:39.12,0:32:41.80,Chinese,,0,0,0,,却不一定会使程序奔溃
Dialogue: 0,0:32:42.14,0:32:47.36,English,,0,0,0,,And so often a bug that's working there might be doing some weird stuff that you don't even know about
Dialogue: 0,0:32:42.14,0:32:47.36,Chinese,,0,0,0,,我们经常会遇到有些 bug 使程序错误地运行但是你却不知道
Dialogue: 0,0:32:51.44,0:33:01.54,English,,0,0,0,,So that's all a fine if it's just a way of crashing programs and I mean that's not great if it's controlling your pacemaker or something like that
Dialogue: 0,0:32:51.44,0:33:01.54,Chinese,,0,0,0,,如果别人通过这些 bug 来控制你的心脏起搏器或其他东西，这显然很危险
Dialogue: 0,0:33:01.54,0:33:08.42,English,,0,0,0,,But if it's just a homework assignment it's like not a big deal so
Dialogue: 0,0:33:01.54,0:33:08.42,Chinese,,0,0,0,,但是如果仅仅是家庭作业的话，这也没什么大不了
Dialogue: 0,0:33:10.46,0:33:15.78,English,,0,0,0,,But what actually and this is sort of only happened since
Dialogue: 0,0:33:16.00,0:33:22.22,English,,0,0,0,,Attacking became a normal activity which has only been the last 30 years
Dialogue: 0,0:33:10.46,0:33:22.22,Chinese,,0,0,0,,在过去的 30 年间，攻击已经变成了一种很正常的行为
Dialogue: 0,0:33:22.62,0:33:32.48,English,,0,0,0,,Is that it gives an opportunity for a hacker or a attacker to inject code into the program and execute it
Dialogue: 0,0:33:22.62,0:33:32.48,Chinese,,0,0,0,,这给了那些黑客或者攻击者将代码注入到你的代码并执行的机会
Dialogue: 0,0:33:32.48,0:33:35.52,English,,0,0,0,,And that's what's called a code injection attack
Dialogue: 0,0:33:32.48,0:33:35.52,Chinese,,0,0,0,,这种行为被称为代码注入攻击
Dialogue: 0,0:33:36.34,0:33:43.18,English,,0,0,0,,And so that the general scheme of it is I have this buffer that I can fill up with whatever bytes I want
Dialogue: 0,0:33:43.52,0:33:47.68,English,,0,0,0,,By feeding them to gets or whatever function is doing this copying
Dialogue: 0,0:33:36.34,0:33:47.68,Chinese,,0,0,0,,常见的模式是，我可以使用任何我想要的字符填充 gets 或其他具有复制功能的函数的缓冲区
Dialogue: 0,0:33:48.00,0:33:51.36,English,,0,0,0,,And what I can do then is set up and pass to it
Dialogue: 0,0:33:48.00,0:33:51.36,Chinese,,0,0,0,,我需要做的就是设置好这个字符串并且把它传递给这些函数
Dialogue: 0,0:33:51.46,0:33:57.48,English,,0,0,0,,Some bytes of actually that encode an executable a little bit of executable code
Dialogue: 0,0:33:51.46,0:33:57.48,Chinese,,0,0,0,,有些字节可以被编码为可执行的代码
Dialogue: 0,0:33:57.48,0:34:03.32,English,,0,0,0,,You've seen an object dump it's printing out these byte code representations of instructions
Dialogue: 0,0:33:57.48,0:34:03.32,Chinese,,0,0,0,,可以将指令转换为字节的形式
Dialogue: 0,0:34:03.32,0:34:09.24,English,,0,0,0,,So imagine you fed some of those bytes into your string
Dialogue: 0,0:34:03.32,0:34:09.24,Chinese,,0,0,0,,假设你把这些字节填充到你的字符串里
Dialogue: 0,0:34:09.26,0:34:11.90,English,,0,0,0,,You encoded them in the string that you pass to gets
Dialogue: 0,0:34:09.26,0:34:11.90,Chinese,,0,0,0,,将它们进行编码然后传递给 gets
Dialogue: 0,0:34:13.04,0:34:22.56,English,,0,0,0,,And then you might have to add some more sort of padding characters ,that characters whose value doesn't matter
Dialogue: 0,0:34:23.03,0:34:30.14,English,,0,0,0,,In order to then get a number back into the position where the return pointer is supposed to be
Dialogue: 0,0:34:13.04,0:34:30.14,Chinese,,0,0,0,,你可能还需要添加一些没有意义的填充字符来获取返回指针
Dialogue: 0,0:34:30.64,0:34:33.76,English,,0,0,0,,And so what's call that number B, it's going to be an address
Dialogue: 0,0:34:30.64,0:34:33.76,Chinese,,0,0,0,,在这里它被称为数字 B
Dialogue: 0,0:34:34.20,0:34:39.22,English,,0,0,0,,One of these ones with the you know that represents a stack location
Dialogue: 0,0:34:34.20,0:34:39.22,Chinese,,0,0,0,,它代表了栈的某个位置
Dialogue: 0,0:34:39.58,0:34:44.24,English,,0,0,0,,And that value B that is the the starting address of the buffer
Dialogue: 0,0:34:39.58,0:34:44.24,Chinese,,0,0,0,,B 是缓冲区的起始地址
Dialogue: 0,0:34:44.72,0:34:53.20,English,,0,0,0,,Which happens to be where your exploit code remember this is just executable instructions or stored here
Dialogue: 0,0:34:44.72,0:34:53.20,Chinese,,0,0,0,,它刚好又是注入代码的地址
Dialogue: 0,0:34:53.78,0:35:00.46,English,,0,0,0,,So now what will happen is when the program does its return here
Dialogue: 0,0:34:53.78,0:35:00.46,Chinese,,0,0,0,,因此程序将会返回到这里
Dialogue: 0,0:35:01.54,0:35:06.12,English,,0,0,0,,It was supposed to return back to wherever it got called from P
Dialogue: 0,0:35:01.54,0:35:06.12,Chinese,,0,0,0,,它本来应该返回 P 中调用它的地方
Dialogue: 0,0:35:11.18,0:35:14.58,English,,0,0,0,,This is a typo, P calls Q not the bar
Dialogue: 0,0:35:11.18,0:35:14.58,Chinese,,0,0,0,,这是个手误，P 调用了 Q 而不是 bar
Dialogue: 0,0:35:18.25,0:35:20.62,English,,0,0,0,,So it's supposed to return back to P
Dialogue: 0,0:35:18.25,0:35:20.62,Chinese,,0,0,0,,所以它本应该返回 P
Dialogue: 0,0:35:21.46,0:35:26.66,English,,0,0,0,,And we're and the address the return address was stored here
Dialogue: 0,0:35:21.46,0:35:26.66,Chinese,,0,0,0,,这个返回值被存储在这里
Dialogue: 0,0:35:26.66,0:35:31.54,English,,0,0,0,,But now I've overwritten that return address  with this buffer position
Dialogue: 0,0:35:26.66,0:35:31.54,Chinese,,0,0,0,,但是现在我使用这个缓冲区覆盖了这个地址
Dialogue: 0,0:35:31.54,0:35:37.40,English,,0,0,0,,So what will happen is the the program counter will happily jump to this bar
Dialogue: 0,0:35:31.54,0:35:37.40,Chinese,,0,0,0,,所以程序将会跳转到 bar 函数
Dialogue: 0,0:35:37.40,0:35:43.04,English,,0,0,0,,And start executing whatever it encounters which are the instructions that you've inserted
Dialogue: 0,0:35:37.40,0:35:43.04,Chinese,,0,0,0,,这个函数会执行你插入的代码
Dialogue: 0,0:35:43.70,0:35:51.70,English,,0,0,0,,And by that means then you can inject code into a machine potentially somewhere else in the internet
Dialogue: 0,0:35:43.70,0:35:51.70,Chinese,,0,0,0,,通过这种方法你可以将代码注入到互联网上的其他机器中去
Dialogue: 0,0:35:51.70,0:35:53.72,English,,0,0,0,,If you could set up a scheme like this
Dialogue: 0,0:35:51.70,0:35:53.72,Chinese,,0,0,0,,如果你设置这样的模式
Dialogue: 0,0:35:53.72,0:35:58.28,English,,0,0,0,,That would feed these bytes into that machine
Dialogue: 0,0:35:53.72,0:35:58.28,Chinese,,0,0,0,,就可以把这些字节注入到其他电脑中
Dialogue: 0,0:35:58.54,0:36:01.06,English,,0,0,0,,And it would read it in with a function like gets
Dialogue: 0,0:35:58.54,0:36:01.06,Chinese,,0,0,0,,它们会使用 gets 这样的函数来读取
Dialogue: 0,0:36:01.44,0:36:05.28,English,,0,0,0,,And then it would try to do its return but it would start executing your code
Dialogue: 0,0:36:01.44,0:36:05.28,Chinese,,0,0,0,,并且开始执行你的代码
Dialogue: 0,0:36:06.22,0:36:09.24,English,,0,0,0,,So that's a classic code injection attack
Dialogue: 0,0:36:06.22,0:36:09.24,Chinese,,0,0,0,,这就是一个经典的代码入侵攻击
Dialogue: 0,0:36:09.54,0:36:14.36,English,,0,0,0,,And in fact in this lab that you're going to start,comes out at midnight
Dialogue: 0,0:36:09.54,0:36:14.36,Chinese,,0,0,0,,Attack lab 将会在今晚午夜推出
Dialogue: 0,0:36:14.68,0:36:24.50,English,,0,0,0,,It's called the attack lab because you're going to do this yourself for part of the lab
Dialogue: 0,0:36:14.68,0:36:24.50,Chinese,,0,0,0,,这个实验被称为 attack lab，你们需要自己完成这一部分
Dialogue: 0,0:36:25.06,0:36:26.80,English,,0,0,0,,I think you'll find it pretty interesting
Dialogue: 0,0:36:25.06,0:36:26.80,Chinese,,0,0,0,,你们将会发现它非常有趣
Dialogue: 0,0:36:31.64,0:36:35.20,English,,0,0,0,,So this used to be a huge problem on programs
Dialogue: 0,0:36:31.64,0:36:35.20,Chinese,,0,0,0,,代码注入攻击以前曾经是一个大问题
Dialogue: 0,0:36:35.20,0:36:46.44,English,,0,0,0,,-yes-so when you're trying to replace read how do you make sure that your new submitted read provides that exact line
Dialogue: 0,0:36:35.20,0:36:46.44,Chinese,,0,0,0,,有人提问：当你尝试去替换代码时，如何确定你注入的代码提供了准确的地址
Dialogue: 0,0:36:46.46,0:36:49.04,English,,0,0,0,,Well that's part of the cleverness of being a hacker
Dialogue: 0,0:36:46.46,0:36:49.04,Chinese,,0,0,0,,这正是黑客的厉害之处
Dialogue: 0,0:36:49.70,0:36:51.92,English,,0,0,0,,You have to make sure it's in the right spot
Dialogue: 0,0:36:49.70,0:36:51.92,Chinese,,0,0,0,,你必须确定它在正确的位置上
Dialogue: 0,0:36:51.92,0:36:54.40,English,,0,0,0,,But it's that's actually one of the easier parts
Dialogue: 0,0:36:51.92,0:36:54.40,Chinese,,0,0,0,,但其实它也是比较简单的一部分
Dialogue: 0,0:36:54.98,0:37:03.72,English,,0,0,0,,Because for example you have to know the binary code To be able to do this or be able to guess
Dialogue: 0,0:36:54.98,0:37:03.72,Chinese,,0,0,0,,因为你必须知道或者猜到这样的二进制编码
Dialogue: 0,0:37:04.44,0:37:09.44,English,,0,0,0,,So for example in that previous one I could tell that it was allocating 24 bytes for that buffer
Dialogue: 0,0:37:04.44,0:37:09.44,Chinese,,0,0,0,,比如说上一个例子中我知道缓冲区分配了 24 个字节
Dialogue: 0,0:37:10.20,0:37:15.58,English,,0,0,0,,And so if I just made sure that the length of my exploit code plus the padding is 24 bytes
Dialogue: 0,0:37:10.20,0:37:15.58,Chinese,,0,0,0,,因此只要我保证我的代码加上填充区是 24 个字节
Dialogue: 0,0:37:16.30,0:37:18.96,English,,0,0,0,,Then right after that comes the return address
Dialogue: 0,0:37:16.30,0:37:18.96,Chinese,,0,0,0,,那么它后面的就是返回地址
Dialogue: 0,0:37:18.96,0:37:20.60,English,,0,0,0,,So that's actually pretty easy to do
Dialogue: 0,0:37:18.96,0:37:20.60,Chinese,,0,0,0,,因此这其实很简单
Dialogue: 0,0:37:20.60,0:37:22.80,English,,0,0,0,,That's not certain how much memory program is that
Dialogue: 0,0:37:20.60,0:37:22.80,Chinese,,0,0,0,,但是我不清楚这个程序占用多少内存
Dialogue: 0,0:37:22.80,0:37:29.72,English,,0,0,0,,No you have to have access,you have to know what the reason why this works is
Dialogue: 0,0:37:22.80,0:37:29.72,Chinese,,0,0,0,,你必须有权限，如果要这样做
Dialogue: 0,0:37:30.84,0:37:35.90,English,,0,0,0,,It works if you have enough knowledge about the operating system that's running at the other end
Dialogue: 0,0:37:30.84,0:37:35.90,Chinese,,0,0,0,,你必须知道那台机器的操作系统
Dialogue: 0,0:37:36.30,0:37:37.84,English,,0,0,0,,For example you know it's Linux
Dialogue: 0,0:37:36.30,0:37:37.84,Chinese,,0,0,0,,比如说它是 Linux 系统
Dialogue: 0,0:37:38.18,0:37:44.10,English,,0,0,0,,You know that you can look at you know what GCC tends to allocate for
Dialogue: 0,0:37:38.18,0:37:44.10,Chinese,,0,0,0,,你知道 GCC 会分配多少字节
Dialogue: 0,0:37:44.10,0:37:50.14,English,,0,0,0,,It you somehow have access to information about the code itself let's you do this
Dialogue: 0,0:37:44.10,0:37:50.14,Chinese,,0,0,0,,不管怎么说你必须知道被注入的那段代码本身的信息来使你完成注入
Dialogue: 0,0:37:56.48,0:37:59.14,English,,0,0,0,,Oh so anyways this used to be a huge problem
Dialogue: 0,0:37:56.48,0:37:59.14,Chinese,,0,0,0,,代码注入攻击过去曾经是一个大问题
Dialogue: 0,0:37:59.16,0:38:05.32,English,,0,0,0,,And it started way back in 1988 the first internet attack with called the Morris worm
Dialogue: 0,0:37:59.16,0:38:05.32,Chinese,,0,0,0,,1988 年，第一个互联网攻击被称为「莫里斯蠕虫」
Dialogue: 0,0:38:05.86,0:38:10.24,English,,0,0,0,,And it at the time the internet was not a very big place
Dialogue: 0,0:38:05.86,0:38:10.24,Chinese,,0,0,0,,当时互联网规模还比较小
Dialogue: 0,0:38:11.16,0:38:17.00,English,,0,0,0,,And it basically brought down a huge fraction of the machines that were on the internet at the time
Dialogue: 0,0:38:11.16,0:38:17.00,Chinese,,0,0,0,,它基本上感染了当时互联网上大部分机器
Dialogue: 0,0:38:17.00,0:38:22.18,English,,0,0,0,,Interestingly enough CMU did not fall victim to this attack
Dialogue: 0,0:38:17.00,0:38:22.18,Chinese,,0,0,0,,有趣的是，我们 CMU 并没有受到攻击
Dialogue: 0,0:38:22.18,0:38:28.48,English,,0,0,0,,Because we'd patched already the vulnerabilities that this particular program exploited
Dialogue: 0,0:38:22.18,0:38:28.48,Chinese,,0,0,0,,因为我们已经修复了这个程序所利用的漏洞
Dialogue: 0,0:38:32.22,0:38:39.96,English,,0,0,0,,And that was the cause that the software engineering institute runs an organization called cert the computer emergency response team
Dialogue: 0,0:38:32.22,0:38:39.96,Chinese,,0,0,0,,软件工程研究所有一个计算机紧急情况应对小组
Dialogue: 0,0:38:40.34,0:38:46.76,English,,0,0,0,,And that team was set up in response to this attack the Morris worm attack
Dialogue: 0,0:38:40.34,0:38:46.76,Chinese,,0,0,0,,设立这个机构的目的就是应对莫里斯蠕虫的攻击
Dialogue: 0,0:38:48.10,0:38:56.03,English,,0,0,0,,We'll also see an interesting example between two companies in messaging services
Dialogue: 0,0:38:48.10,0:38:56.03,Chinese,,0,0,0,,这儿还有关于两个通讯服务公司之间的例子
Dialogue: 0,0:38:56.38,0:39:02.54,English,,0,0,0,,And many others it's been the sort of standard attack mechanism for many years
Dialogue: 0,0:38:56.38,0:39:02.54,Chinese,,0,0,0,,它们使用合理的攻击手段攻击对方已经很多年了
Dialogue: 0,0:39:03.06,0:39:09.36,English,,0,0,0,,And fortunately nowadays there's a few things that make the attacking a less likely to be successful
Dialogue: 0,0:39:03.06,0:39:09.36,Chinese,,0,0,0,,幸运的是，如今的攻击不像以前那么容易了
Dialogue: 0,0:39:09.86,0:39:12.22,English,,0,0,0,,And so it's not as huge a problem as it used to be
Dialogue: 0,0:39:09.86,0:39:12.22,Chinese,,0,0,0,,因此这不再是一个大问题
Dialogue: 0,0:39:12.52,0:39:17.04,English,,0,0,0,,But still it's a source of many vulnerabilities in programs
Dialogue: 0,0:39:12.52,0:39:17.04,Chinese,,0,0,0,,但它仍然是很多程序的漏洞
Dialogue: 0,0:39:18.90,0:39:22.58,English,,0,0,0,,So let's see I won't talk too much about this
Dialogue: 0,0:39:18.90,0:39:22.58,Chinese,,0,0,0,,关于这个我不想说的太多
Dialogue: 0,0:39:22.64,0:39:25.84,English,,0,0,0,,But it used to be in the original implementation of
Dialogue: 0,0:39:26.42,0:39:30.70,English,,0,0,0,,There's a command that most systems have now disabled that
Dialogue: 0,0:39:22.64,0:39:30.70,Chinese,,0,0,0,,现在有一个在很多系统上都被禁用的 finger 命令
Dialogue: 0,0:39:30.70,0:39:33.96,English,,0,0,0,,You could finger you could across to information about
Dialogue: 0,0:39:34.36,0:39:38.66,English,,0,0,0,,Somebody in some remote location it would send a message to that location
Dialogue: 0,0:39:30.70,0:39:38.66,Chinese,,0,0,0,,你可以使用它向远程机器发送消息
Dialogue: 0,0:39:39.48,0:39:41.28,English,,0,0,0,,And then it would reply back
Dialogue: 0,0:39:39.48,0:39:41.28,Chinese,,0,0,0,,远程机器也会回复你
Dialogue: 0,0:39:41.74,0:39:46.70,English,,0,0,0,,And it used gets the honor the actual original implementation called gets
Dialogue: 0,0:39:47.24,0:39:51.40,English,,0,0,0,,To read the input string from that was being sent to it
Dialogue: 0,0:39:41.74,0:39:51.40,Chinese,,0,0,0,,这个命令使用 gets 来读取接收到的字符串
Dialogue: 0,0:39:55.82,0:39:57.84,English,,0,0,0,,And then there is an interesting one
Dialogue: 0,0:39:55.82,0:39:57.84,Chinese,,0,0,0,,还有一个有趣的例子
Dialogue: 0,0:39:57.84,0:40:01.26,English,,0,0,0,,You guys don't remember messaging instant messaging
Dialogue: 0,0:39:57.84,0:40:01.26,Chinese,,0,0,0,,你们很多人可能不知道即时通讯
Dialogue: 0,0:40:01.26,0:40:08.52,English,,0,0,0,,But before it used to be that people would talk to each other on their computers  by sending messages
Dialogue: 0,0:40:01.26,0:40:08.52,Chinese,,0,0,0,,但是以前人们都是通过在计算机上发送消息来聊天的
Dialogue: 0,0:40:08.86,0:40:11.18,English,,0,0,0,,Sort of like you send text messages today
Dialogue: 0,0:40:08.86,0:40:11.18,Chinese,,0,0,0,,就像你们现在发送文本信息一样
Dialogue: 0,0:40:11.70,0:40:19.00,English,,0,0,0,,But there is an interesting thing that there's a company still exists
Dialogue: 0,0:40:11.70,0:40:19.00,Chinese,,0,0,0,,有趣的是，现在仍然存在这么一个公司
Dialogue: 0,0:40:19.00,0:40:23.02,English,,0,0,0,,But it's a shadow of its former self called AOL
Dialogue: 0,0:40:19.00,0:40:23.02,Chinese,,0,0,0,,AOL
Dialogue: 0,0:40:23.36,0:40:28.88,English,,0,0,0,,Which ran the most popular internet services and had the most popular instant messaging program
Dialogue: 0,0:40:23.36,0:40:28.88,Chinese,,0,0,0,,它有着最受欢迎的即时通讯服务和程序
Dialogue: 0,0:40:29.38,0:40:32.36,English,,0,0,0,,And Microsoft came out with its own client
Dialogue: 0,0:40:29.38,0:40:32.36,Chinese,,0,0,0,,微软也推出了自己的客户端
Dialogue: 0,0:40:32.78,0:40:35.20,English,,0,0,0,,Its own program that you could run on your machine
Dialogue: 0,0:40:32.78,0:40:35.20,Chinese,,0,0,0,,你可以运行在你的电脑上
Dialogue: 0,0:40:35.48,0:40:40.06,English,,0,0,0,,And communicate to other people on this a messaging system
Dialogue: 0,0:40:35.48,0:40:40.06,Chinese,,0,0,0,,通过这个通讯系统你可以与其他人交流
Dialogue: 0,0:40:40.06,0:40:42.52,English,,0,0,0,,So the Microsoft code was running on your machine
Dialogue: 0,0:40:40.06,0:40:42.52,Chinese,,0,0,0,,所以，微软的代码运行在你的机器上
Dialogue: 0,0:40:42.90,0:40:49.74,English,,0,0,0,,But it would use the servers that were being run by AOL to manage this messaging traffic
Dialogue: 0,0:40:42.90,0:40:49.74,Chinese,,0,0,0,,但是它使用的服务器却是由 AOL 提供的
Dialogue: 0,0:40:50.38,0:40:57.62,English,,0,0,0,,And the funny story was...
Dialogue: 0,0:40:50.38,0:40:57.62,Chinese,,0,0,0,,有一个好笑的故事是...
Dialogue: 0,0:40:59.18,0:41:01.78,English,,0,0,0,,The this Microsoft program would work fine
Dialogue: 0,0:40:59.18,0:41:01.78,Chinese,,0,0,0,,微软的程序是可以正常运行的
Dialogue: 0,0:41:02.54,0:41:08.44,English,,0,0,0,,You can communicate with your friends who had different messaging clients and it all seemed compatible
Dialogue: 0,0:41:02.54,0:41:08.44,Chinese,,0,0,0,,你可以与使用不同客户端的朋友交流，这是完全兼容的
Dialogue: 0,0:41:08.44,0:41:13.94,English,,0,0,0,,But then suddenly the people that were running the Microsoft version of the software,it wouldn't work
Dialogue: 0,0:41:08.44,0:41:13.94,Chinese,,0,0,0,,但是突然有一天，微软的软件无法运行了
Dialogue: 0,0:41:14.52,0:41:16.96,English,,0,0,0,,And then Microsoft people figured out how to patch it
Dialogue: 0,0:41:14.52,0:41:16.96,Chinese,,0,0,0,,微软的人修复了这个问题
Dialogue: 0,0:41:17.68,0:41:20.00,English,,0,0,0,,And then it would work for a while and then it wouldn't work
Dialogue: 0,0:41:17.68,0:41:20.00,Chinese,,0,0,0,,没过多久之后这个软件又无法运行了
Dialogue: 0,0:41:20.00,0:41:24.64,English,,0,0,0,,And the way what was happening was AOL was using a bug in its own code
Dialogue: 0,0:41:20.00,0:41:24.64,Chinese,,0,0,0,,这是因为 AOL 利用了他们自己代码中的一个 bug
Dialogue: 0,0:41:25.30,0:41:33.86,English,,0,0,0,,To be able to determine who's basically peek into the the machines on the client side
Dialogue: 0,0:41:25.30,0:41:33.86,Chinese,,0,0,0,,用来监控客户端的机器
Dialogue: 0,0:41:34.44,0:41:39.90,English,,0,0,0,,And do a buffer overflow attack on your code that you're running on your machine
Dialogue: 0,0:41:34.44,0:41:39.90,Chinese,,0,0,0,,它可以溢出运行在你的电脑上的代码的缓冲区
Dialogue: 0,0:41:40.22,0:41:44.70,English,,0,0,0,,And then basically peek around and see does this look like AOL code
Dialogue: 0,0:41:40.22,0:41:44.70,Chinese,,0,0,0,,并且检测这个代码是不是 AOL 的代码
Dialogue: 0,0:41:44.70,0:41:46.95,English,,0,0,0,,Or is it something or is it some foreign code
Dialogue: 0,0:41:44.70,0:41:46.95,Chinese,,0,0,0,,或者是其他的代码
Dialogue: 0,0:41:47.38,0:41:54.80,English,,0,0,0,,And so is basic be able to use its own security weakness to figure out this information
Dialogue: 0,0:41:47.38,0:41:54.80,Chinese,,0,0,0,,他们就是利用自己的安全漏洞来获取这些信息
Dialogue: 0,0:41:56.28,0:42:06.26,English,,0,0,0,,And that got disclosed by a sort of funny message from somebody who called himself Phil Bucking
Dialogue: 0,0:41:56.28,0:42:06.26,Chinese,,0,0,0,,这件事被一个自称为 Phil Bucking 的人披露
Dialogue: 0,0:42:07.02,0:42:12.36,English,,0,0,0,,And it was determined that this email originated from somewhere within Microsoft
Dialogue: 0,0:42:07.02,0:42:12.36,Chinese,,0,0,0,,后来经确定这封邮件是微软内部发出的
Dialogue: 0,0:42:15.86,0:42:21.52,English,,0,0,0,,So anyways that and you can read more about it in the book around the slide fun choice
Dialogue: 0,0:42:15.86,0:42:21.52,Chinese,,0,0,0,,你们可以从课本中了解更多有关这件事的细节
Dialogue: 0,0:42:21.78,0:42:26.78,English,,0,0,0,,So in general in the security world you're supposed to distinguish between the idea of a worm and a virus
Dialogue: 0,0:42:21.78,0:42:26.78,Chinese,,0,0,0,,你们应该区别蠕虫和病毒的概念
Dialogue: 0,0:42:26.78,0:42:28.70,English,,0,0,0,,Although people aren't very good at doing that
Dialogue: 0,0:42:26.78,0:42:28.70,Chinese,,0,0,0,,虽然人们经常将他们混淆
Dialogue: 0,0:42:29.06,0:42:35.58,English,,0,0,0,,So worm is a program that can run on its own and propagate itself from one place to the other replicated
Dialogue: 0,0:42:29.06,0:42:35.58,Chinese,,0,0,0,,蠕虫可以自己运行并从一个地方繁衍到另外一个地方
Dialogue: 0,0:42:35.96,0:42:40.80,English,,0,0,0,,A virus is like a biological virus it doesn't live on its own
Dialogue: 0,0:42:35.96,0:42:40.80,Chinese,,0,0,0,,病毒则类似于生物学里的病毒，它不能自己存活
Dialogue: 0,0:42:40.90,0:42:45.78,English,,0,0,0,,It works by attacking a program and basically modifying that program's behavior
Dialogue: 0,0:42:40.90,0:42:45.78,Chinese,,0,0,0,,它攻击一个程序并改变这个程序的行为
Dialogue: 0,0:42:51.30,0:42:56.72,English,,0,0,0,,So that gives you the basic idea of buffer overflows and you'll see it more first hand
Dialogue: 0,0:42:51.30,0:42:56.72,Chinese,,0,0,0,,现在我们已经了解了缓冲区溢出的概念
Dialogue: 0,0:42:57.20,0:43:05.12,English,,0,0,0,,So let's look at it techniques that machines can use to avoid to make themselves less vulnerable to these attacks
Dialogue: 0,0:42:57.20,0:43:05.12,Chinese,,0,0,0,,让我们来看看如何使我们的机器免受这样的攻击
Dialogue: 0,0:43:05.60,0:43:13.38,English,,0,0,0,,Well first of all you the application or the cert the writer on the server-side can write code that's more secure
Dialogue: 0,0:43:05.60,0:43:13.38,Chinese,,0,0,0,,首先就是我们的应用在编写代码时可以写得更安全
Dialogue: 0,0:43:14.90,0:43:20.76,English,,0,0,0,,So for example what you're supposed to do instead of gets is use a function called fgets
Dialogue: 0,0:43:14.90,0:43:20.76,Chinese,,0,0,0,,比如说使用 fgets 来替代 gets
Dialogue: 0,0:43:21.28,0:43:26.18,English,,0,0,0,,And fgets has a property that it passes a parameter
Dialogue: 0,0:43:21.28,0:43:26.18,Chinese,,0,0,0,,fgets 有一个参数
Dialogue: 0,0:43:26.48,0:43:31.40,English,,0,0,0,,Which is the maximum number of bytes that the program should read
Dialogue: 0,0:43:26.48,0:43:31.40,Chinese,,0,0,0,,它用来指示程序应该最多读取多少字节
Dialogue: 0,0:43:31.84,0:43:37.86,English,,0,0,0,,And if there's more bytes than that in the input it will just truncate the input
Dialogue: 0,0:43:31.84,0:43:37.86,Chinese,,0,0,0,,如果输入的字节超过这个数字，它就会将输入的字符串截断
Dialogue: 0,0:43:38.62,0:43:43.40,English,,0,0,0,,So you're really supposed to use fgets and give a limit
Dialogue: 0,0:43:38.62,0:43:43.40,Chinese,,0,0,0,,所以你们应该使用 fgets 来加以限制
Dialogue: 0,0:43:43.92,0:43:49.16,English,,0,0,0,,Similarly a strcpy there is a version of it called strncpy where you can give a limit
Dialogue: 0,0:43:43.92,0:43:49.16,Chinese,,0,0,0,,类似的，strcpy 也有一个使用限制参数的版本，它被称为 strncpy
Dialogue: 0,0:43:49.98,0:43:55.22,English,,0,0,0,,And with a scanf you're supposed to be careful about using the percent s
Dialogue: 0,0:43:49.98,0:43:55.22,Chinese,,0,0,0,,在使用 scanf 时要小心 %s
Dialogue: 0,0:43:55.62,0:43:59.28,English,,0,0,0,,There's even a terminology you can say percent give a number
Dialogue: 0,0:43:55.62,0:43:59.28,Chinese,,0,0,0,,你可以在 % 之前加一个数字
Dialogue: 0,0:43:59.84,0:44:03.58,English,,0,0,0,,That's the maximum length of the string it should read
Dialogue: 0,0:43:59.84,0:44:03.58,Chinese,,0,0,0,,这个数字代表了 scanf 所能读取的字符串的最大长度
Dialogue: 0,0:44:03.58,0:44:09.39,English,,0,0,0,,So these various places you can protect your code to make sure it won't overflow buffers
Dialogue: 0,0:44:03.58,0:44:09.39,Chinese,,0,0,0,,这些都能让你保护你的代码免受缓冲区溢出的困扰
Dialogue: 0,0:44:09.80,0:44:18.94,English,,0,0,0,,Unfortunately a lot of code has been you'd call it hardening,it's been people have gone through it and it's a lot of work
Dialogue: 0,0:44:09.80,0:44:18.94,Chinese,,0,0,0,,不过很多代码已经完成了，重新检查这些地方也是一个不小的工程
Dialogue: 0,0:44:19.04,0:44:23.64,English,,0,0,0,,Because there's a lot of places in programs where you're copying strings from one place to another
Dialogue: 0,0:44:19.04,0:44:23.64,Chinese,,0,0,0,,在程序中经常需要将字符串从一个地方拷贝到另外一个地方
Dialogue: 0,0:44:24.14,0:44:31.56,English,,0,0,0,,And there are a lot of real subtleties like when you're converting from unicode to bytes and so forth
Dialogue: 0,0:44:31.56,0:44:34.68,English,,0,0,0,,That you're going back and forth between different character encodings
Dialogue: 0,0:44:24.14,0:44:34.68,Chinese,,0,0,0,,并且有时还要在不同的字符编码之间来回转换
Dialogue: 0,0:44:35.20,0:44:42.70,English,,0,0,0,,But for the large part and there's tools that the code developers have created to help track down these bugs
Dialogue: 0,0:44:35.20,0:44:42.70,Chinese,,0,0,0,,不过现在开发人员已经开发出了可以帮助我们追踪这些问题的工具
Dialogue: 0,0:44:43.24,0:44:47.72,English,,0,0,0,,So it's become a little bit safer out there but there's still vulnerabilities
Dialogue: 0,0:44:43.24,0:44:47.72,Chinese,,0,0,0,,因此现在编写代码比以前更加安全了，不过还是要小心
Dialogue: 0,0:44:48.50,0:44:53.80,English,,0,0,0,,So then there's other parts where you just try to build in safeguards into the system
Dialogue: 0,0:44:48.50,0:44:53.80,Chinese,,0,0,0,,还有其他的手段也可以增加我们代码的安全性
Dialogue: 0,0:44:54.22,0:44:59.38,English,,0,0,0,,That would make it much harder to do a buffer overflow exploit like I showed you
Dialogue: 0,0:44:54.22,0:44:59.38,Chinese,,0,0,0,,这些比我刚才展示的防止缓冲区溢出还要困难
Dialogue: 0,0:45:00.04,0:45:03.20,English,,0,0,0,,And so one of them is called stack randomization
Dialogue: 0,0:45:00.04,0:45:03.20,Chinese,,0,0,0,,其中的一种手段称为栈随机化
Dialogue: 0,0:45:03.68,0:45:12.06,English,,0,0,0,,Where it goes by a more general term that's abbreviated ASLR
Dialogue: 0,0:45:03.68,0:45:12.06,Chinese,,0,0,0,,用术语来简写就是 ASLR
Dialogue: 0,0:45:12.86,0:45:25.04,English,,0,0,0,,Which stands for Address Space Layout Randomization
Dialogue: 0,0:45:12.86,0:45:25.04,Chinese,,0,0,0,,它代表地址空间布局随机化
Dialogue: 0,0:45:25.50,0:45:33.84,English,,0,0,0,,And the idea of it is to make it so every time a program runs the addresses change a little bit or a lot
Dialogue: 0,0:45:25.50,0:45:33.84,Chinese,,0,0,0,,每次程序运行的时候它的地址都是变化的
Dialogue: 0,0:45:34.24,0:45:39.50,English,,0,0,0,,So that you can't reliably know where things are going to be in the code
Dialogue: 0,0:45:34.24,0:45:39.50,Chinese,,0,0,0,,所以基本不可能知道代码运行在什么地方
Dialogue: 0,0:45:39.96,0:45:49.52,English,,0,0,0,,So imagine for example the and the way it's implemented is before in the sort of run-up of your program when it first starts up
Dialogue: 0,0:45:39.96,0:45:49.52,Chinese,,0,0,0,,想象一下你的程序在启动时的状态
Dialogue: 0,0:45:50.24,0:45:52.76,English,,0,0,0,,But before your main routine gets called
Dialogue: 0,0:45:50.24,0:45:52.76,Chinese,,0,0,0,,在主程序被调用之前
Dialogue: 0,0:45:53.92,0:45:58.72,English,,0,0,0,,It will just do a allocation on the stack of some random number of bytes of storage
Dialogue: 0,0:45:53.92,0:45:58.72,Chinese,,0,0,0,,将会在栈上分配随机大小的空间
Dialogue: 0,0:45:59.36,0:46:05.70,English,,0,0,0,,A fair amount like maybe a megabyte roughly of storage where the exact number is randomly chosen
Dialogue: 0,0:45:59.36,0:46:05.70,Chinese,,0,0,0,,大概有几兆，这个数字是随机的
Dialogue: 0,0:46:06.70,0:46:14.66,English,,0,0,0,,And what that means is that the the dress of the stack of all the different positions of your
Dialogue: 0,0:46:06.70,0:46:14.66,Chinese,,0,0,0,,
Dialogue: 0,0:46:15.26,0:46:20.04,English,,0,0,0,,All the local storage on the stack will shift up and down from one run to another
Dialogue: 0,0:46:15.26,0:46:20.04,Chinese,,0,0,0,,当程序多次运行时，局部变量的地址会发生变化
Dialogue: 0,0:46:20.92,0:46:27.54,English,,0,0,0,,And we can actually see that in this example I showed
Dialogue: 0,0:46:20.92,0:46:27.54,Chinese,,0,0,0,,我们可以通过一个例子来观察这个问题
Dialogue: 0,0:46:33.30,0:46:38.22,English,,0,0,0,,So I have a program here it's not a very interesting program I'll show you
Dialogue: 0,0:46:33.30,0:46:38.22,Chinese,,0,0,0,,我写了一个没什么意义的程序
Dialogue: 0,0:46:39.44,0:46:41.40,English,,0,0,0,,Except to demonstrate these ideas
Dialogue: 0,0:46:39.44,0:46:41.40,Chinese,,0,0,0,,仅仅只是为了演示这个问题
Dialogue: 0,0:46:45.40,0:46:51.92,English,,0,0,0,,All it's doing is there's some code it's based on that one I already showed called locate
Dialogue: 0,0:46:45.40,0:46:51.92,Chinese,,0,0,0,,这个程序做的事和我之前演示的那个一样
Dialogue: 0,0:46:51.92,0:46:54.72,English,,0,0,0,,But this one there's a global variable
Dialogue: 0,0:46:51.92,0:46:54.72,Chinese,,0,0,0,,有全局变量
Dialogue: 0,0:46:55.40,0:47:00.51,English,,0,0,0,,There's some functions there's something that gets allocated by malloc
Dialogue: 0,0:46:55.40,0:47:00.51,Chinese,,0,0,0,,有几个函数，有通过 malloc 分配空间的变量
Dialogue: 0,0:47:00.92,0:47:04.98,English,,0,0,0,,And there's something that is a local variable stored on the stack
Dialogue: 0,0:47:00.92,0:47:04.98,Chinese,,0,0,0,,还有存储在栈上的局部变量
Dialogue: 0,0:47:05.58,0:47:09.10,English,,0,0,0,,And so what I'll do is show addresses that are chosen
Dialogue: 0,0:47:05.58,0:47:09.10,Chinese,,0,0,0,,接下来我们看一下它们的地址
Dialogue: 0,0:47:09.46,0:47:15.66,English,,0,0,0,,The address of this variable then will be a stack address a local of a local variable
Dialogue: 0,0:47:09.46,0:47:15.66,Chinese,,0,0,0,,这个局部变量的地址是一个栈地址
Dialogue: 0,0:47:16.30,0:47:19.34,English,,0,0,0,,Global will be this one that gets allocated globally
Dialogue: 0,0:47:16.30,0:47:19.34,Chinese,,0,0,0,,全局变量分配在数据区
Dialogue: 0,0:47:19.94,0:47:22.10,English,,0,0,0,,The heap is something allocated with malloc
Dialogue: 0,0:47:19.94,0:47:22.10,Chinese,,0,0,0,,通过 malloc 分配的在堆上
Dialogue: 0,0:47:22.82,0:47:27.38,English,,0,0,0,,And then the this function useless will count as a code address
Dialogue: 0,0:47:22.82,0:47:27.38,Chinese,,0,0,0,,这个 useless 函数在代码区
Dialogue: 0,0:47:29.08,0:47:30.32,English,,0,0,0,,And now when I run it
Dialogue: 0,0:47:29.08,0:47:30.32,Chinese,,0,0,0,,现在我运行这个程序
Dialogue: 0,0:47:34.56,0:47:39.62,English,,0,0,0,,You'll see from one run to another that if some of these stay the same and some of them change
Dialogue: 0,0:47:34.56,0:47:39.62,Chinese,,0,0,0,,当程序多次运行时，有些地址保持不变，有些地址则在变化
Dialogue: 0,0:47:40.36,0:47:46.02,English,,0,0,0,,So in particular the global variable is the same 0x60102c
Dialogue: 0,0:47:40.36,0:47:46.02,Chinese,,0,0,0,,global 变量的地址一直都是 0x60102c
Dialogue: 0,0:47:47.70,0:47:56.22,English,,0,0,0,,And the code is the same 0x400590 is the same every execution
Dialogue: 0,0:47:47.70,0:47:56.22,Chinese,,0,0,0,,code 的地址也一直都是 0x400590
Dialogue: 0,0:47:56.66,0:48:00.80,English,,0,0,0,,But you'll see this local variable it's on its a stack address
Dialogue: 0,0:47:56.66,0:48:00.80,Chinese,,0,0,0,,local 变量的地址在栈上
Dialogue: 0,0:48:01.50,0:48:07.34,English,,0,0,0,,But you see that the lower half dozen or so bytes are actually changing from one run to another
Dialogue: 0,0:48:01.50,0:48:07.34,Chinese,,0,0,0,,但是低位的地址一直在变化
Dialogue: 0,0:48:07.84,0:48:12.88,English,,0,0,0,,1,2,3,4,5 so 5 bytes so that's
Dialogue: 0,0:48:07.84,0:48:12.88,Chinese,,0,0,0,,1，2，3，4，5，也就是 5 个字节
Dialogue: 0,0:48:15.92,0:48:17.68,English,,0,0,0,,What 5 hex digits I'm sorry
Dialogue: 0,0:48:15.92,0:48:17.68,Chinese,,0,0,0,,不好意思，这是十六进制
Dialogue: 0,0:48:17.68,0:48:20.10,English,,0,0,0,,So that's 2^20
Dialogue: 0,0:48:17.68,0:48:20.10,Chinese,,0,0,0,,也就是 2^20
Dialogue: 0,0:48:20.70,0:48:25.26,English,,0,0,0,,So roughly a megabyte of variation is going on in stack addresses there
Dialogue: 0,0:48:20.70,0:48:25.26,Chinese,,0,0,0,,差不多有 1 MB 的变化
Dialogue: 0,0:48:25.80,0:48:33.76,English,,0,0,0,,And similarly you'll see that the heap addresses are also varying from one to another From one execution to the other
Dialogue: 0,0:48:25.80,0:48:33.76,Chinese,,0,0,0,,每次运行的时候堆地址也一直在变
Dialogue: 0,0:48:33.78,0:48:38.62,English,,0,0,0,,So malloc has built into it some amount of randomness to in its allocation
Dialogue: 0,0:48:33.78,0:48:38.62,Chinese,,0,0,0,,所以 malloc 在分配的时候具有随机性
Dialogue: 0,0:48:39.34,0:48:43.38,English,,0,0,0,,So why is that...you know what's the purpose of that well
Dialogue: 0,0:48:39.34,0:48:43.38,Chinese,,0,0,0,,为什么会这样呢
Dialogue: 0,0:48:45.46,0:48:49.14,English,,0,0,0,,As I told you this code injection vulnerability
Dialogue: 0,0:48:45.46,0:48:49.14,Chinese,,0,0,0,,我已经告诉过你们
Dialogue: 0,0:48:51.42,0:48:57.30,English,,0,0,0,,Relies on the fact that you can load up this buffer with some executable code
Dialogue: 0,0:48:51.42,0:48:57.30,Chinese,,0,0,0,,可以通过缓冲区来注入可执行代码
Dialogue: 0,0:48:57.74,0:49:03.38,English,,0,0,0,,But somehow you have to know how to get to the start of that code
Dialogue: 0,0:48:57.74,0:49:03.38,Chinese,,0,0,0,,但是你们必须知道代码开始的地方
Dialogue: 0,0:49:04.00,0:49:13.28,English,,0,0,0,,And so this is relying the attack is relying on the fact that it can somehow predict what the this address of the buffer is
Dialogue: 0,0:49:04.00,0:49:13.28,Chinese,,0,0,0,,这个攻击必须要预测到缓冲区的地址
Dialogue: 0,0:49:14.36,0:49:18.04,English,,0,0,0,,And so that it can store it in the right part of the string
Dialogue: 0,0:49:14.36,0:49:18.04,Chinese,,0,0,0,,
Dialogue: 0,0:49:18.16,0:49:22.98,English,,0,0,0,,Put it encode it in the right part of the string so it will show up where the return pointer is supposed to be
Dialogue: 0,0:49:14.36,0:49:22.98,Chinese,,0,0,0,,然后将编码后的字符串放在正确的位置并让它出现在返回指针的位置上
Dialogue: 0,0:49:24.36,0:49:26.52,English,,0,0,0,,And and have it jump to that location
Dialogue: 0,0:49:24.36,0:49:26.52,Chinese,,0,0,0,,这样程序才会跳转到那个位置
Dialogue: 0,0:49:26.92,0:49:28.66,English,,0,0,0,,But now with this randomization
Dialogue: 0,0:49:26.92,0:49:28.66,Chinese,,0,0,0,,但是现在有了这样的随机性
Dialogue: 0,0:49:29.26,0:49:37.50,English,,0,0,0,,This number is varying by quite a bit sort of million over a range of a million or so values
Dialogue: 0,0:49:29.26,0:49:37.50,Chinese,,0,0,0,,这个数字将会变化一百万左右
Dialogue: 0,0:49:37.88,0:49:44.41,English,,0,0,0,,So there's no way in advance even if I have an exact copy of the code not even had access to the system itself
Dialogue: 0,0:49:37.88,0:49:44.41,Chinese,,0,0,0,,因此，即使我有这份代码也无法访问到系统本身
Dialogue: 0,0:49:44.72,0:49:46.13,English,,0,0,0,,And could run it
Dialogue: 0,0:49:44.72,0:49:46.13,Chinese,,0,0,0,,并让它运行
Dialogue: 0,0:49:46.54,0:49:50.04,English,,0,0,0,,I can't predict from one run to the next where it's going to be
Dialogue: 0,0:49:46.54,0:49:50.04,Chinese,,0,0,0,,因为我无法预测到下一个地址
Dialogue: 0,0:49:50.68,0:49:59.86,English,,0,0,0,,So that gives it sort of thoughts this particular attack to make it using this randomization
Dialogue: 0,0:49:50.68,0:49:59.86,Chinese,,0,0,0,,这种随机性使得这种特定的攻击无法实现
Dialogue: 0,0:50:03.14,0:50:07.24,English,,0,0,0,,Another idea that's fairly straightforward
Dialogue: 0,0:50:03.14,0:50:07.24,Chinese,,0,0,0,,另外一种方式则比较直接
Dialogue: 0,0:50:07.24,0:50:11.32,English,,0,0,0,,But it took a long time for the hardware people to implement this
Dialogue: 0,0:50:07.24,0:50:11.32,Chinese,,0,0,0,,但是硬件开发人员在实现的时候却花费了很长时间
Dialogue: 0,0:50:12.04,0:50:17.98,English,,0,0,0,,Is well why is there supposed to be code on the stack in the first place
Dialogue: 0,0:50:12.04,0:50:17.98,Chinese,,0,0,0,,为什么第一个例子中的代码出现在了栈上
Dialogue: 0,0:50:18.00,0:50:21.10,English,,0,0,0,,The code supposed to be located down in the text segment
Dialogue: 0,0:50:18.00,0:50:21.10,Chinese,,0,0,0,,代码本应该位于下面的文本段
Dialogue: 0,0:50:21.70,0:50:25.82,English,,0,0,0,,Where it can be sort of specially identified as being executable
Dialogue: 0,0:50:21.70,0:50:25.82,Chinese,,0,0,0,,在那里它们被标记为可执行的
Dialogue: 0,0:50:26.58,0:50:29.02,English,,0,0,0,,So in the original x86
Dialogue: 0,0:50:26.58,0:50:29.02,Chinese,,0,0,0,,在原始的 x86 上
Dialogue: 0,0:50:29.64,0:50:33.44,English,,0,0,0,,There's a one bit flag for each region of memory
Dialogue: 0,0:50:29.64,0:50:33.44,Chinese,,0,0,0,,每个内存区域都有一个标记位
Dialogue: 0,0:50:34.20,0:50:37.08,English,,0,0,0,,Saying is it actually to one bit flags
Dialogue: 0,0:50:34.20,0:50:37.08,Chinese,,0,0,0,,标记它属于哪种类型
Dialogue: 0,0:50:37.62,0:50:40.04,English,,0,0,0,,One is can this be written to
Dialogue: 0,0:50:37.62,0:50:40.04,Chinese,,0,0,0,,一种是可写
Dialogue: 0,0:50:41.04,0:50:45.46,English,,0,0,0,,So that you can prevent over writes of things like string constants
Dialogue: 0,0:50:41.04,0:50:45.46,Chinese,,0,0,0,,使用它可以避免覆盖一些东西，例如字符串常量
Dialogue: 0,0:50:46.88,0:50:50.59,English,,0,0,0,,And so and then the other is am I can I read it
Dialogue: 0,0:50:46.88,0:50:50.59,Chinese,,0,0,0,,另一种是可读
Dialogue: 0,0:50:51.32,0:50:53.46,English,,0,0,0,,And read means access those bytes
Dialogue: 0,0:50:51.32,0:50:53.46,Chinese,,0,0,0,,这意味着可以访问这些字节
Dialogue: 0,0:50:53.46,0:50:57.18,English,,0,0,0,,It was interpreted that readable and executable were the same thing
Dialogue: 0,0:50:53.46,0:50:57.18,Chinese,,0,0,0,,可读和可执行是一回事
Dialogue: 0,0:50:57.66,0:51:01.30,English,,0,0,0,,I can read it I can execute it and that was the rules
Dialogue: 0,0:50:57.66,0:51:01.30,Chinese,,0,0,0,,我可以读它，我就可以执行它
Dialogue: 0,0:51:02.48,0:51:08.78,English,,0,0,0,,In a sort of last 10 years or so starting first with AMD and then Intel
Dialogue: 0,0:51:02.48,0:51:08.78,Chinese,,0,0,0,,在过去10年左右的时间里，首先是AMD，然后是英特尔
Dialogue: 0,0:51:09.06,0:51:12.54,English,,0,0,0,,Have added a third bit that says is this executable or not
Dialogue: 0,0:51:09.06,0:51:12.54,Chinese,,0,0,0,,添加了第三位，说是这个可执行文件
Dialogue: 0,0:51:13.02,0:51:18.16,English,,0,0,0,,Similarly to the permissions you have on a file on unix is it readable,writable,executable
Dialogue: 0,0:51:13.02,0:51:18.16,Chinese,,0,0,0,,与你在 UNIX 上的文件上拥有的权限类似，它是可读，可写，可执行的
Dialogue: 0,0:51:18.58,0:51:21.30,English,,0,0,0,,Those are three separate permission bits that are alone
Dialogue: 0,0:51:18.58,0:51:21.30,Chinese,,0,0,0,,这些是三个独立的权限位
Dialogue: 0,0:51:22.72,0:51:26.50,English,,0,0,0,,So by simply marking the stack is not executable
Dialogue: 0,0:51:22.72,0:51:26.50,Chinese,,0,0,0,,所以通过简单地标记堆栈是不可执行的
Dialogue: 0,0:51:26.84,0:51:29.22,English,,0,0,0,,It'll also fort this particular attack
Dialogue: 0,0:51:26.84,0:51:29.22,Chinese,,0,0,0,,它也会对这种特殊攻击有所帮助
Dialogue: 0,0:51:29.22,0:51:33.28,English,,0,0,0,,Because I have to be able to execute these bytes that I've injected into the system
Dialogue: 0,0:51:29.22,0:51:33.28,Chinese,,0,0,0,,因为我必须能够执行我注入系统的这些字节
Dialogue: 0,0:51:37.18,0:51:41.76,English,,0,0,0,,And then there's the final idea which is actually fairly effective too
Dialogue: 0,0:51:37.18,0:51:41.76,Chinese,,0,0,0,,然后是最终的想法，实际上也是相当有效的
Dialogue: 0,0:51:42.24,0:51:45.72,English,,0,0,0,,Which they call a canary that they built into the stack
Dialogue: 0,0:51:42.24,0:51:45.72,Chinese,,0,0,0,,他们称之为金丝雀，他们建立在堆栈中
Dialogue: 0,0:51:45.72,0:51:49.20,English,,0,0,0,,And some of you actually encountered this code already and looking at your bombs
Dialogue: 0,0:51:45.72,0:51:49.20,Chinese,,0,0,0,,你们中的一些人实际上已经遇到过这个代码并且看着你的炸弹
Dialogue: 0,0:51:49.20,0:51:51.34,English,,0,0,0,,Because we've been getting some questions about it
Dialogue: 0,0:51:49.20,0:51:51.34,Chinese,,0,0,0,,因为我们一直在问这个问题
Dialogue: 0,0:51:52.52,0:51:55.32,English,,0,0,0,,So let me just give you an example here
Dialogue: 0,0:51:52.52,0:51:55.32,Chinese,,0,0,0,,那么让我举一个例子吧
Dialogue: 0,0:52:05.70,0:52:08.20,English,,0,0,0,,And this one's called buffdemo-sp
Dialogue: 0,0:52:05.70,0:52:08.20,Chinese,,0,0,0,,而这个叫做 buffdemo-sp
Dialogue: 0,0:52:08.20,0:52:11.28,English,,0,0,0,,Because it's been compiled with what they call stack protector
Dialogue: 0,0:52:08.20,0:52:11.28,Chinese,,0,0,0,,因为它已被编译为他们称之为堆栈保护器
Dialogue: 0,0:52:17.54,0:52:22.56,English,,0,0,0,,And this one on now it's the same code as before it's discompiled a little bit differently
Dialogue: 0,0:52:17.54,0:52:22.56,Chinese,,0,0,0,,而现在这个代码与之前的编译方式相同，有点不同
Dialogue: 0,0:52:23.14,0:52:26.70,English,,0,0,0,,What you'll find is I can give a string of length eight
Dialogue: 0,0:52:23.14,0:52:26.70,Chinese,,0,0,0,,你会发现我可以给出一串长度为 8 的字符串
Dialogue: 0,0:52:27.08,0:52:28.58,English,,0,0,0,,And not have a problem
Dialogue: 0,0:52:27.08,0:52:28.58,Chinese,,0,0,0,,并没有问题
Dialogue: 0,0:52:29.04,0:52:32.38,English,,0,0,0,,But if I now have nine characters
Dialogue: 0,0:52:29.04,0:52:32.38,Chinese,,0,0,0,,但如果我现在有 9 个字符
Dialogue: 0,0:52:33.00,0:52:38.80,English,,0,0,0,,It will dump out with this very strange exit error message
Dialogue: 0,0:52:33.00,0:52:38.80,Chinese,,0,0,0,,程序将会以奇怪的错误信息退出
Dialogue: 0,0:52:39.42,0:52:49.78,English,,0,0,0,,That is an indication...That it's detected I attempt to smash the stack
Dialogue: 0,0:52:39.42,0:52:49.78,Chinese,,0,0,0,,这表明程序检测到了栈溢出的问题
Dialogue: 0,0:52:49.78,0:52:52.66,English,,0,0,0,,So buffer overflow is sometimes called stack smashing
Dialogue: 0,0:52:49.78,0:52:52.66,Chinese,,0,0,0,,缓冲区溢出有时候也被称为栈溢出
Dialogue: 0,0:52:53.68,0:53:03.96,English,,0,0,0,,So it detected somehow that even though my code was still the same old crappy code from before Of a very small buffer allocation and no protection
Dialogue: 0,0:52:53.68,0:53:03.96,Chinese,,0,0,0,,即使我的代码和之前一样，只分配了很小的缓冲区，也没有保护
Dialogue: 0,0:53:03.96,0:53:08.36,English,,0,0,0,,Somehow the system protected me from myself
Dialogue: 0,0:53:03.96,0:53:08.36,Chinese,,0,0,0,,系统还是阻止我这样做
Dialogue: 0,0:53:10.30,0:53:19.62,English,,0,0,0,,And that's a by a relatively simple trick that's a fairly clever though what they call stack canary
Dialogue: 0,0:53:10.30,0:53:19.62,Chinese,,0,0,0,,这种非常灵活的机制被称为 canary
Dialogue: 0,0:53:20.36,0:53:27.32,English,,0,0,0,,So that the term canary comes back from a back in the coal mining days of old
Dialogue: 0,0:53:20.36,0:53:27.32,Chinese,,0,0,0,,这个术语来源于以前的矿井工人
Dialogue: 0,0:53:27.68,0:53:33.38,English,,0,0,0,,Before they had very good ways of measuring things they take a bird down with them in a cage
Dialogue: 0,0:53:27.68,0:53:33.38,Chinese,,0,0,0,,他们每次下井时都会带上一只装有金丝雀的鸟笼
Dialogue: 0,0:53:33.92,0:53:40.64,English,,0,0,0,,And a canary is a property that's very susceptible to dying
Dialogue: 0,0:53:33.92,0:53:40.64,Chinese,,0,0,0,,金丝雀对毒性非常敏感
Dialogue: 0,0:53:42.06,0:53:44.96,English,,0,0,0,,If there's nothing if there's methane gas present
Dialogue: 0,0:53:42.06,0:53:44.96,Chinese,,0,0,0,,如果井下有甲烷
Dialogue: 0,0:53:44.96,0:53:52.92,English,,0,0,0,,So these miners would be down there working and they'd see their bird (got) kill over and say oh we got a problem here let's get out fast
Dialogue: 0,0:53:44.96,0:53:52.92,Chinese,,0,0,0,,工人们将会看到金丝雀停止鸣叫或者死亡，于是他们就会迅速撤出
Dialogue: 0,0:53:53.42,0:54:00.60,English,,0,0,0,,So that's why they call it a canary in a coal mine sometimes Some kind of warning signal that that something's not right here
Dialogue: 0,0:53:53.42,0:53:57.14,Chinese,,0,0,0,,这正是为什么我们将这种保护行为称之为 canary
Dialogue: 0,0:54:01.82,0:54:09.90,English,,0,0,0,,And in general we see a GCC if you invoke it with a stack protector nowadays that's the default
Dialogue: 0,0:54:01.82,0:54:09.90,Chinese,,0,0,0,,一般来说我们在使用 gcc 的时候都会启用栈保护
Dialogue: 0,0:54:10.82,0:54:15.48,English,,0,0,0,,So even without you saying anything this code will get built into it
Dialogue: 0,0:54:10.82,0:54:15.48,Chinese,,0,0,0,,因此即使你什么也没写这段代码也是内置的
Dialogue: 0,0:54:18.62,0:54:21.80,English,,0,0,0,,And so let's look at at what that canary code looks like
Dialogue: 0,0:54:18.62,0:54:21.80,Chinese,,0,0,0,,现在我们来看看 canary 代码长什么样
Dialogue: 0,0:54:21.80,0:54:24.84,English,,0,0,0,,And how it does its thing it's really pretty clever as I said
Dialogue: 0,0:54:21.80,0:54:24.84,Chinese,,0,0,0,,以及它是如何工作的
Dialogue: 0,0:54:25.24,0:54:34.46,English,,0,0,0,,And some of you have already observed this strange kind of memory reference In a register reference in the code and your boom labs
Dialogue: 0,0:54:25.24,0:54:34.46,Chinese,,0,0,0,,你们已经在 boom labs 中见过了寄存器引用
Dialogue: 0,0:54:34.46,0:54:39.08,English,,0,0,0,,Because it was compiled with this deck protecting enabled because that's the default
Dialogue: 0,0:54:34.46,0:54:39.08,Chinese,,0,0,0,,这段代码在编译的时候使用了栈保护，因为这是默认的
Dialogue: 0,0:54:40.26,0:54:48.36,English,,0,0,0,,And so in particular what this code shows is it's allocating as before 24 bytes on the stack
Dialogue: 0,0:54:40.26,0:54:48.36,Chinese,,0,0,0,,这个代码像之前一样也分配了 24 字节
Dialogue: 0,0:54:49.22,0:54:53.92,English,,0,0,0,,But now it's getting some number and we'll talk in a second what that means
Dialogue: 0,0:54:49.22,0:54:53.92,Chinese,,0,0,0,,但是这儿还有几个其他的数字，我们之后再讨论
Dialogue: 0,0:54:54.42,0:55:01.22,English,,0,0,0,,And storing it at position 8 offset from the stack pointer
Dialogue: 0,0:54:54.42,0:55:01.22,Chinese,,0,0,0,,这段代码将字符串存储在距离栈指针偏移量为 8 的地方
Dialogue: 0,0:55:01.80,0:55:06.42,English,,0,0,0,,And then the rest of the code and then it zeros it out that's not to worry
Dialogue: 0,0:55:01.80,0:55:06.42,Chinese,,0,0,0,,多余的部分使用 0 填充
Dialogue: 0,0:55:06.64,0:55:12.36,English,,0,0,0,,And then it looks like the your previous code that it's passing a pointer to the stack
Dialogue: 0,0:55:06.64,0:55:12.36,Chinese,,0,0,0,,这看起来和之前的代码中将指针传递给栈差不多
Dialogue: 0,0:55:13.14,0:55:15.82,English,,0,0,0,,Top of the stack as the argument to gets
Dialogue: 0,0:55:13.14,0:55:15.82,Chinese,,0,0,0,,栈顶是 gets 的参数
Dialogue: 0,0:55:17.04,0:55:21.66,English,,0,0,0,,And gets it gets called and then puts gets called
Dialogue: 0,0:55:17.04,0:55:21.66,Chinese,,0,0,0,,之后程序调用了 gets 和 puts
Dialogue: 0,0:55:22.28,0:55:28.80,English,,0,0,0,,But now there's some more code here that is it involves this strange looking register
Dialogue: 0,0:55:22.28,0:55:28.80,Chinese,,0,0,0,,下面的代码也用到了那些看起来很陌生的寄存器
Dialogue: 0,0:55:29.22,0:55:33.82,English,,0,0,0,,And then there's some kind of test and then if that test fails
Dialogue: 0,0:55:29.22,0:55:33.82,Chinese,,0,0,0,,这里有个测试条件
Dialogue: 0,0:55:34.64,0:55:40.72,English,,0,0,0,,It will call this a code that you just saw printed out this error message
Dialogue: 0,0:55:34.64,0:55:40.72,Chinese,,0,0,0,,如果它失败了就会我们刚才看到的输出错误信息
Dialogue: 0,0:55:42.68,0:55:44.76,English,,0,0,0,,So let's see what that all means
Dialogue: 0,0:55:42.68,0:55:44.76,Chinese,,0,0,0,,我们来看看它是什么意思
Dialogue: 0,0:55:45.00,0:55:54.70,English,,0,0,0,,What that means is that at offset 8 from the stack pointer it's putting in 8 bytes a value
Dialogue: 0,0:55:45.00,0:55:54.70,Chinese,,0,0,0,,在栈顶指针前面的 8 个字节里存放了一个值
Dialogue: 0,0:55:55.52,0:55:59.84,English,,0,0,0,,That it's retrieving from a special register
Dialogue: 0,0:55:55.52,0:55:59.84,Chinese,,0,0,0,,这个值是从一个特殊的寄存器里获取到的
Dialogue: 0,0:55:59.84,0:56:07.84,English,,0,0,0,,So fs is a reference to a type of register that was created for the original 8086
Dialogue: 0,0:55:59.84,0:56:07.84,Chinese,,0,0,0,,fs 是一个为 原始的 8086 设计的一个寄存器
Dialogue: 0,0:56:07.84,0:56:12.26,English,,0,0,0,,And is now completely obsolete but it's still there for backward compatibility mode
Dialogue: 0,0:56:07.84,0:56:12.26,Chinese,,0,0,0,,因为它是向下兼容的，因此现在仍然可以使用
Dialogue: 0,0:56:12.78,0:56:18.64,English,,0,0,0,,But what it is it and I actually I looked and I've never fully been able to find the documentation on it
Dialogue: 0,0:56:12.78,0:56:18.64,Chinese,,0,0,0,,但是我没有找到关于它的文档
Dialogue: 0,0:56:19.16,0:56:28.08,English,,0,0,0,,It's able to read from a part of memory a set of values that you can't otherwise get to
Dialogue: 0,0:56:19.16,0:56:28.08,Chinese,,0,0,0,,总之它就是某块内存中的值
Dialogue: 0,0:56:28.56,0:56:35.70,English,,0,0,0,,And so that's the canary it's getting a somehow it's grabbing eight bytes from somewhere
Dialogue: 0,0:56:28.56,0:56:35.70,Chinese,,0,0,0,,canary 从某处获取 8 个字节的值
Dialogue: 0,0:56:36.42,0:56:38.62,English,,0,0,0,,Storing it as this canary value
Dialogue: 0,0:56:36.42,0:56:38.62,Chinese,,0,0,0,,并把它存储为 canary 值
Dialogue: 0,0:56:40.08,0:56:43.82,English,,0,0,0,,And then if you give like a seven character input
Dialogue: 0,0:56:40.08,0:56:43.82,Chinese,,0,0,0,,如果你输入 7 个字符的字符串
Dialogue: 0,0:56:45.32,0:56:50.06,English,,0,0,0,,So you would affect the canary and so what happens when it returns from
Dialogue: 0,0:56:45.32,0:56:50.06,Chinese,,0,0,0,,你就会影响到 canary 的值
Dialogue: 0,0:56:51.96,0:56:57.60,English,,0,0,0,,The two calls from gets and puts before it exits
Dialogue: 0,0:56:51.96,0:56:57.60,Chinese,,0,0,0,,程序就会在调用 gets 和 puts 的地方退出
Dialogue: 0,0:56:57.60,0:57:05.12,English,,0,0,0,,What it's trying to detect is has anything as this buffer somehow overflowed
Dialogue: 0,0:56:57.60,0:57:05.12,Chinese,,0,0,0,,它会检测缓冲区是否溢出
Dialogue: 0,0:57:05.50,0:57:09.90,English,,0,0,0,,And potentially at risk of corrupting some other part of the stack
Dialogue: 0,0:57:05.50,0:57:09.90,Chinese,,0,0,0,,以及是否存在侵占栈中其他部分的风险
Dialogue: 0,0:57:10.52,0:57:16.14,English,,0,0,0,,So basically what it does is it retrieves back from the stack
Dialogue: 0,0:57:16.54,0:57:19.06,English,,0,0,0,,What is the current value of this canary
Dialogue: 0,0:57:10.52,0:57:19.06,Chinese,,0,0,0,,系统所做的就是从栈中取出 canary 的值
Dialogue: 0,0:57:19.62,0:57:26.50,English,,0,0,0,,And it's comparing it to what it should be by retrieving that back from this special region
Dialogue: 0,0:57:19.62,0:57:26.50,Chinese,,0,0,0,,并与刚才的那个特殊区域中的值进行比较
Dialogue: 0,0:57:26.94,0:57:29.94,English,,0,0,0,,And if they're equal it says fine
Dialogue: 0,0:57:26.94,0:57:29.94,Chinese,,0,0,0,,如果他们是相等的那就没有问题
Dialogue: 0,0:57:30.34,0:57:35.54,English,,0,0,0,,But if they're not equal it's detecting this got corrupted so just like the canary in the coalmine
Dialogue: 0,0:57:30.34,0:57:35.54,Chinese,,0,0,0,,但是如果不相等就意味着这个位置被占用了，就像矿井中的金丝雀一样
Dialogue: 0,0:57:35.96,0:57:40.94,English,,0,0,0,,If these bytes get corrupted in any form,it's an indication that something went wrong
Dialogue: 0,0:57:35.96,0:57:40.94,Chinese,,0,0,0,,如果这个位置被占用了，就说明某个地方出问题了
Dialogue: 0,0:57:42.42,0:57:48.52,English,,0,0,0,,Now that example shows that if I have a seven characters string
Dialogue: 0,0:57:42.42,0:57:48.52,Chinese,,0,0,0,,这个例子中我输入了 7 个字符的字符串
Dialogue: 0,0:57:48.88,0:57:51.34,English,,0,0,0,,Then I'm not going to corrupt the canary
Dialogue: 0,0:57:48.88,0:57:51.34,Chinese,,0,0,0,,那么就不会侵占 canary 的位置
Dialogue: 0,0:57:52.42,0:57:55.70,English,,0,0,0,,But you notice I just got away with an eight character string
Dialogue: 0,0:57:52.42,0:57:55.70,Chinese,,0,0,0,,但是如果我输入 8 个字符的字符串
Dialogue: 0,0:57:57.62,0:58:03.20,English,,0,0,0,,So let me just see what's going on here
Dialogue: 0,0:57:57.62,0:58:03.20,Chinese,,0,0,0,,我们来看看会发生什么
Dialogue: 0,0:58:30.60,0:58:32.54,English,,0,0,0,,Okay I want a character string right
Dialogue: 0,0:58:30.60,0:58:32.54,Chinese,,0,0,0,,我会输入一个 8 个字符的字符串
Dialogue: 0,0:58:35.30,0:58:36.60,English,,0,0,0,,Oh wait wait wait
Dialogue: 0,0:58:35.30,0:58:36.60,Chinese,,0,0,0,,噢，等等
Dialogue: 0,0:58:42.74,0:58:47.20,English,,0,0,0,,Ah sorry I have to look I don't have the code in front of me,so I have to look at
Dialogue: 0,0:58:42.74,0:58:47.20,Chinese,,0,0,0,,我得先看看之前的代码所在的位置
Dialogue: 0,0:58:52.98,0:59:00.20,English,,0,0,0,,So anyways here's where it's subtracting 24 from the stack pointer
Dialogue: 0,0:58:52.98,0:59:00.20,Chinese,,0,0,0,,首先，程序在栈上分配了 24 字节的空间
Dialogue: 0,0:59:00.76,0:59:04.80,English,,0,0,0,,And then the next instruction is retrieving this canary value
Dialogue: 0,0:59:00.76,0:59:04.80,Chinese,,0,0,0,,然后获取 canary 的值
Dialogue: 0,0:59:04.80,0:59:09.12,English,,0,0,0,,So let's figure out what the canary is right now we are at
Dialogue: 0,0:59:04.80,0:59:09.12,Chinese,,0,0,0,,我们来看看 canary 的值，现在我们在......
Dialogue: 0,0:59:16.16,0:59:17.48,English,,0,0,0,,72f
Dialogue: 0,0:59:16.16,0:59:17.48,Chinese,,0,0,0,,72f
Dialogue: 0,0:59:17.78,0:59:20.00,English,,0,0,0,,So we're at the first instruction here
Dialogue: 0,0:59:17.78,0:59:20.00,Chinese,,0,0,0,,我们在第一条指令这里
Dialogue: 0,0:59:25.84,0:59:39.48,English,,0,0,0,,Let's do another step
Dialogue: 0,0:59:25.84,0:59:39.48,Chinese,,0,0,0,,执行下一步
Dialogue: 0,0:59:40.06,0:59:41.74,English,,0,0,0,,So this is the canary
Dialogue: 0,0:59:40.06,0:59:41.74,Chinese,,0,0,0,,这就是 canary
Dialogue: 0,0:59:44.46,0:59:48.96,English,,0,0,0,,And it's you'll see actually when from one run to another you get a different value of it
Dialogue: 0,0:59:44.46,0:59:48.96,Chinese,,0,0,0,,程序每次运行的时候它的值都不一样
Dialogue: 0,0:59:49.04,0:59:52.82,English,,0,0,0,,So it's purposely put in there in a way that it's unpredictable
Dialogue: 0,0:59:49.04,0:59:52.82,Chinese,,0,0,0,,它被有意地放在那里并且值是不确定的
Dialogue: 0,0:59:53.42,0:59:56.94,English,,0,0,0,,The one thing you'll notice is that the lower byte is zeroes
Dialogue: 0,0:59:53.42,0:59:56.94,Chinese,,0,0,0,,你们应该注意到了最低位的字节是 0
Dialogue: 0,0:59:57.80,1:00:04.78,English,,0,0,0,,And so apparently they knew that it's so common to have suit off-by-one bugs with strings
Dialogue: 0,0:59:57.80,1:00:04.78,Chinese,,0,0,0,,字符串的 off-by-one bug 很常见
Dialogue: 0,1:00:04.78,1:00:08.42,English,,0,0,0,,Where you don't allocate enough space for the null terminator
Dialogue: 0,1:00:04.78,1:00:08.42,Chinese,,0,0,0,,这是由于你没有为空字符分配空间
Dialogue: 0,1:00:08.82,1:00:16.08,English,,0,0,0,,That they said well rather Than having a canary that will detect that bite being corrupted we'll just sort of give that bite away
Dialogue: 0,1:00:08.82,1:00:16.08,Chinese,,0,0,0,,而 canary 可以检测这个字节是否被修改
Dialogue: 0,1:00:16.96,1:00:21.76,English,,0,0,0,,And so that's why it's letting me type in eight characters
Dialogue: 0,1:00:16.96,1:00:21.76,Chinese,,0,0,0,,这也就是为什么程序允许我输入 8 个字符
Dialogue: 0,1:00:21.84,1:00:26.28,English,,0,0,0,,And it's overriding this low order byte of the canary later on
Dialogue: 0,1:00:21.84,1:00:26.28,Chinese,,0,0,0,,然后空字符将会覆盖 canary 的低字节
Dialogue: 0,1:00:26.76,1:00:28.96,English,,0,0,0,,But that's not going to affect anything
Dialogue: 0,1:00:26.76,1:00:28.96,Chinese,,0,0,0,,不过这不会有什么影响
Dialogue: 0,1:00:53.44,1:00:59.60,English,,0,0,0,,But let's give it, 9 characters,10 character string,a 9 character string
Dialogue: 0,1:00:53.44,1:00:59.60,Chinese,,0,0,0,,我们班来输入一个 9 个字符的字符串
Dialogue: 0,1:01:52.17,1:01:54.78,English,,0,0,0,,All right...
Dialogue: 0,1:01:52.17,1:01:54.78,Chinese,,0,0,0,,好吧
Dialogue: 0,1:01:55.12,1:02:01.14,English,,0,0,0,,Oh well I'm not finding it where I thought it would be
Dialogue: 0,1:01:55.12,1:02:01.14,Chinese,,0,0,0,,我找不到它的位置了
Dialogue: 0,1:02:01.34,1:02:08.58,English,,0,0,0,,Anyways oh this will corrupt the stack
Dialogue: 0,1:02:01.34,1:02:08.58,Chinese,,0,0,0,,不管怎么说它肯定会污染栈
Dialogue: 0,1:02:08.80,1:02:15.18,English,,0,0,0,,But what I showing you the main idea is the canaries some value That gets pulled out and it will vary from one time to the next
Dialogue: 0,1:02:08.80,1:02:15.18,Chinese,,0,0,0,,我想表达的就是 canary 的值每次都会变
Dialogue: 0,1:02:16.00,1:02:20.72,English,,0,0,0,,And it's letting you get away with eight characters plus the null terminator
Dialogue: 0,1:02:16.00,1:02:20.72,Chinese,,0,0,0,,它允许你输入 8 个字符和一个空字符
Dialogue: 0,1:02:20.92,1:02:23.90,English,,0,0,0,,But anything more and it will detect that corruption
Dialogue: 0,1:02:20.92,1:02:23.90,Chinese,,0,0,0,,并且它会检测到这个问题
Dialogue: 0,1:02:38.60,1:02:44.16,English,,0,0,0,,Okay so now we've seen three different protection well for one is write better code
Dialogue: 0,1:02:38.60,1:02:44.16,Chinese,,0,0,0,,我们已经学习了三种保护措施，一种是编写更健壮的代码
Dialogue: 0,1:02:46.30,1:02:51.50,English,,0,0,0,,But there's three protections that are done by the system that have nothing to do with your code
Dialogue: 0,1:02:46.30,1:02:51.50,Chinese,,0,0,0,,但是还有三种是由系统完成的，你不需要在代码中处理
Dialogue: 0,1:02:51.74,1:02:58.24,English,,0,0,0,,Right one is to randomize the stack position
Dialogue: 0,1:02:51.74,1:02:58.24,Chinese,,0,0,0,,一种是随机化栈的位置
Dialogue: 0,1:02:58.26,1:03:01.20,English,,0,0,0,,So it's harder to figure out where the start addresses are
Dialogue: 0,1:02:58.26,1:03:01.20,Chinese,,0,0,0,,这样就很难获取起始地址
Dialogue: 0,1:03:01.72,1:03:07.48,English,,0,0,0,,The second is to make the stack so it's not executable so you can't put code on that
Dialogue: 0,1:03:01.72,1:03:07.48,Chinese,,0,0,0,,第二种是将栈标记为不可执行的，这样就不能把代码放在栈里
Dialogue: 0,1:03:08.04,1:03:15.68,English,,0,0,0,,And then the third is to use a stack canary or other mechanisms to detect a potential buffer overflow at the source
Dialogue: 0,1:03:08.04,1:03:15.68,Chinese,,0,0,0,,第三种就是使用 canary 或其他机制检测代码中潜在的缓冲区溢出风险
Dialogue: 0,1:03:16.94,1:03:22.34,English,,0,0,0,,So now there's another attack that was developed in response to some of these
Dialogue: 0,1:03:16.94,1:03:22.34,Chinese,,0,0,0,,针对这些机制，现在又有了新的攻击
Dialogue: 0,1:03:25.00,1:03:30.02,English,,0,0,0,,That is still often successful it's called return oriented programming
Dialogue: 0,1:03:25.00,1:03:30.02,Chinese,,0,0,0,,它被称为面向返回编程，并且它经常能成功
Dialogue: 0,1:03:30.42,1:03:33.26,English,,0,0,0,,And for your attack lab you're going to be doing these attacks too
Dialogue: 0,1:03:30.42,1:03:33.26,Chinese,,0,0,0,,你们在 attack lab 中也会做这个攻击
Dialogue: 0,1:03:33.26,1:03:36.10,English,,0,0,0,,That's why the attack lab is different than the old lab
Dialogue: 0,1:03:33.26,1:03:36.10,Chinese,,0,0,0,,这和旧的实验不太一样
Dialogue: 0,1:03:36.10,1:03:43.56,English,,0,0,0,,The old web just code injection exploits now you're doing both code injection and return oriented programming
Dialogue: 0,1:03:36.10,1:03:43.56,Chinese,,0,0,0,,旧的实验只做代码注入，而现在你们两个都做
Dialogue: 0,1:03:44.38,1:03:51.12,English,,0,0,0,,So the idea this is if you are a hacker you're frustrated
Dialogue: 0,1:03:44.38,1:03:51.12,Chinese,,0,0,0,,如果你是一个黑客，你肯定很沮丧
Dialogue: 0,1:03:51.12,1:03:58.72,English,,0,0,0,,Because of these these three techniques stack randomization non-executable stack and canaries
Dialogue: 0,1:03:51.12,1:03:58.72,Chinese,,0,0,0,,因为在栈随机化、栈的不可执行属性以及 canary 这三种技术里面
Dialogue: 0,1:03:59.10,1:04:07.48,English,,0,0,0,,Well I can't fix the canary problem that actually the canary is a pretty secure technique
Dialogue: 0,1:03:59.10,1:04:07.48,Chinese,,0,0,0,,我唯独不能攻克 canary，因为它确实是一种很安全的技术
Dialogue: 0,1:04:07.58,1:04:12.28,English,,0,0,0,,There's very I've never seen anyone able to bypass a stack canary
Dialogue: 0,1:04:07.58,1:04:12.28,Chinese,,0,0,0,,我还没见过有人能破解 canary 技术
Dialogue: 0,1:04:13.04,1:04:15.90,English,,0,0,0,,But the other two you can do it using this technique
Dialogue: 0,1:04:13.04,1:04:15.90,Chinese,,0,0,0,,但是其他两种都可以通过这种技术来破解
Dialogue: 0,1:04:16.44,1:04:20.48,English,,0,0,0,,And the strategy is so we don't know where the stack is
Dialogue: 0,1:04:16.44,1:04:20.48,Chinese,,0,0,0,,策略就是，即使我不知道栈在哪里
Dialogue: 0,1:04:21.42,1:04:27.74,English,,0,0,0,,But we could still...but we know where the code is because you saw in that example the code
Dialogue: 0,1:04:21.42,1:04:27.74,Chinese,,0,0,0,,但是我知道代码存在哪里
Dialogue: 0,1:04:28.26,1:04:33.94,English,,0,0,0,,My layout randomization was shifting the stack positions in the heap positions
Dialogue: 0,1:04:28.26,1:04:33.94,Chinese,,0,0,0,,随机化一直在切换栈的位置
Dialogue: 0,1:04:34.54,1:04:40.34,English,,0,0,0,,But it wasn't changing either global variables or or the code itself
Dialogue: 0,1:04:34.54,1:04:40.34,Chinese,,0,0,0,,但是全局变量和代码本身的位置并没有改变
Dialogue: 0,1:04:41.32,1:04:50.04,English,,0,0,0,,So what if I can find some code that sort of already there in the existing part of the program
Dialogue: 0,1:04:41.32,1:04:50.04,Chinese,,0,0,0,,如果我能找到程序中某段代码的位置
Dialogue: 0,1:04:50.60,1:04:55.30,English,,0,0,0,,And I'll use that instead of my own code that I've injected
Dialogue: 0,1:04:50.60,1:04:55.30,Chinese,,0,0,0,,我就可以注入我的代码
Dialogue: 0,1:04:55.98,1:05:00.94,English,,0,0,0,,And of course in general you're not going to find exactly lying there the exact program
Dialogue: 0,1:05:00.94,1:05:05.76,English,,0,0,0,,You want to execute that will cause whatever harm you intend to do
Dialogue: 0,1:04:55.98,1:05:05.76,Chinese,,0,0,0,,当然你一般没有办法找到准确的地址
Dialogue: 0,1:05:06.50,1:05:09.74,English,,0,0,0,,Because that's not usually compiled into most programs
Dialogue: 0,1:05:06.50,1:05:09.74,Chinese,,0,0,0,,因为它不会被编译
Dialogue: 0,1:05:09.76,1:05:22.54,English,,0,0,0,,But if I could set a string together little segments of code and somehow put together a series of little sequences of code
Dialogue: 0,1:05:09.76,1:05:22.54,Chinese,,0,0,0,,但是如果我放几小段代码或者组合一系列代码
Dialogue: 0,1:05:22.78,1:05:24.86,English,,0,0,0,,Maybe I can get something useful done
Dialogue: 0,1:05:22.78,1:05:24.86,Chinese,,0,0,0,,没准有些就会被执行
Dialogue: 0,1:05:25.54,1:05:28.38,English,,0,0,0,,And so that's the idea of this return oriented programming
Dialogue: 0,1:05:25.54,1:05:28.38,Chinese,,0,0,0,,这就是面向返回编程的思想
Dialogue: 0,1:05:28.94,1:05:33.38,English,,0,0,0,,And the idea of it is to find what are known as gadgets
Dialogue: 0,1:05:28.94,1:05:33.38,Chinese,,0,0,0,,它的思想就是找到所谓的 gadget
Dialogue: 0,1:05:34.28,1:05:40.52,English,,0,0,0,,And a gadget is a sequence of bytes that are represent part of the executable program
Dialogue: 0,1:05:34.28,1:05:40.52,Chinese,,0,0,0,,gadget 是代表部分可执行程序的字节系列
Dialogue: 0,1:05:40.86,1:05:47.38,English,,0,0,0,,Where the last byte this is x86 talking here, has a hex value c3
Dialogue: 0,1:05:40.86,1:05:47.38,Chinese,,0,0,0,,最后一个字节是 c3，这里说的是 x86
Dialogue: 0,1:05:47.60,1:05:56.64,English,,0,0,0,,Which is how the ret instruction the return instruction is encoded  in x86 both IA32 and x64
Dialogue: 0,1:05:47.60,1:05:56.64,Chinese,,0,0,0,,它代表了 IA32 和 x64 的返回指令
Dialogue: 0,1:05:59.04,1:06:01.32,English,,0,0,0,,And so as an example
Dialogue: 0,1:05:59.04,1:06:01.32,Chinese,,0,0,0,,举个例子
Dialogue: 0,1:06:02.20,1:06:05.48,English,,0,0,0,,On the easy case is where there's some function
Dialogue: 0,1:06:07.00,1:06:12.96,English,,0,0,0,,And it implements some operation that I might find useful as an attacker to be able to do
Dialogue: 0,1:06:02.20,1:06:12.96,Chinese,,0,0,0,,有些函数实现了一些对攻击者来说非常有用的操作
Dialogue: 0,1:06:13.48,1:06:18.16,English,,0,0,0,,So for example this function is computing a*b+c
Dialogue: 0,1:06:13.48,1:06:18.16,Chinese,,0,0,0,,比如说这个函数的作用是计算 a*b+c
Dialogue: 0,1:06:18.94,1:06:25.64,English,,0,0,0,,And if I look at just the last two instructions from there one of them is a lea which is performing addition
Dialogue: 0,1:06:18.94,1:06:25.64,Chinese,,0,0,0,,最后两个指令，一个是执行加法运算
Dialogue: 0,1:06:26.50,1:06:29.58,English,,0,0,0,,And the other is doing a return
Dialogue: 0,1:06:26.50,1:06:29.58,Chinese,,0,0,0,,另一个执行返回操作
Dialogue: 0,1:06:29.92,1:06:40.24,English,,0,0,0,,So I can think of this good old five bunk byte chunk is a way if I could get some data in registers %rdi and %rdx
Dialogue: 0,1:06:29.92,1:06:40.24,Chinese,,0,0,0,,因此这 5 个字节是获取 %rdi 寄存器和 %rdx 寄存器中的数据的一种途径
Dialogue: 0,1:06:40.92,1:06:44.34,English,,0,0,0,,Then I could compute their sum and stick it in %rax
Dialogue: 0,1:06:40.92,1:06:44.34,Chinese,,0,0,0,,我可以计算它们的和并放入 %rax 寄存器中
Dialogue: 0,1:06:44.48,1:06:49.40,English,,0,0,0,,So imagine taking your program you're trying to execute and breaking it up into these good old fragments
Dialogue: 0,1:06:44.48,1:06:49.40,Chinese,,0,0,0,,想象一下将你们尝试执行的代码分解成碎片
Dialogue: 0,1:06:49.76,1:06:55.10,English,,0,0,0,,And you want to somehow find little block of code somewhere to implement each of these fragments
Dialogue: 0,1:06:49.76,1:06:55.10,Chinese,,0,0,0,,然后再找到实现了这些碎片的代码
Dialogue: 0,1:06:55.96,1:07:00.52,English,,0,0,0,,And then the interesting part is because they each end in c3 this return
Dialogue: 0,1:06:55.96,1:07:00.52,Chinese,,0,0,0,,有趣的是，它们都以 c3 作为返回语句
Dialogue: 0,1:07:00.84,1:07:04.50,English,,0,0,0,,It has is it,well let me get to that in it
Dialogue: 0,1:07:00.84,1:07:04.50,Chinese,,0,0,0,,我们来看这里
Dialogue: 0,1:07:05.12,1:07:13.04,English,,0,0,0,,So that's sort of the obvious way that you pull out this is an addition which you'd expect because that was in the original C code
Dialogue: 0,1:07:05.12,1:07:13.04,Chinese,,0,0,0,,这是一种在原始 C 语言中添加你期待执行的代码的方式
Dialogue: 0,1:07:13.92,1:07:19.52,English,,0,0,0,,But here's an example of a gadget that has nothing to do with the original C code
Dialogue: 0,1:07:13.92,1:07:19.52,Chinese,,0,0,0,,还有一个 gadget 的例子，它并没有修改原有的 C 语言代码
Dialogue: 0,1:07:19.80,1:07:26.14,English,,0,0,0,,It just happens to match the byte pattern of of some existing code
Dialogue: 0,1:07:19.80,1:07:26.14,Chinese,,0,0,0,,它只是碰巧和某些已存在的代码的字节相匹配
Dialogue: 0,1:07:26.66,1:07:36.04,English,,0,0,0,,So this function seems to not do anything too terribly useful from a hackers point of view
Dialogue: 0,1:07:26.66,1:07:36.04,Chinese,,0,0,0,,这个函数在黑客眼里不是非常有用
Dialogue: 0,1:07:36.70,1:07:39.46,English,,0,0,0,,But if you look at this particular byte sequence
Dialogue: 0,1:07:36.70,1:07:39.46,Chinese,,0,0,0,,看这个特殊的字节序列
Dialogue: 0,1:07:39.56,1:07:43.82,English,,0,0,0,,That happens to encode the instruction movq are %rax to %rdi
Dialogue: 0,1:07:39.56,1:07:43.82,Chinese,,0,0,0,,它刚好会被编码成 movq %rax,%rdi
Dialogue: 0,1:07:44.56,1:07:46.44,English,,0,0,0,,And c3 encodes retq
Dialogue: 0,1:07:44.56,1:07:46.44,Chinese,,0,0,0,,和返回语句 c3
Dialogue: 0,1:07:47.14,1:07:51.68,English,,0,0,0,,So and you can see if this is at address for d9
Dialogue: 0,1:07:47.14,1:07:51.68,Chinese,,0,0,0,,如果地址从 4d9 开始
Dialogue: 0,1:07:52.26,1:07:55.48,English,,0,0,0,,That's 4da, 4db,4dc
Dialogue: 0,1:07:52.26,1:07:55.48,Chinese,,0,0,0,,然后是 4da，4db，4dc
Dialogue: 0,1:07:55.50,1:08:00.06,English,,0,0,0,,So at address 0x4004dc
Dialogue: 0,1:07:55.50,1:08:00.06,Chinese,,0,0,0,,那么这个 gadget 的地址应该在 0x4004dc
Dialogue: 0,1:08:00.48,1:08:06.84,English,,0,0,0,,If you could start executing here it would first do a move and then it would do a return
Dialogue: 0,1:08:00.48,1:08:06.84,Chinese,,0,0,0,,如果你从这里开始执行，它会首先执行一个 move 操作，然后返回
Dialogue: 0,1:08:07.62,1:08:13.66,English,,0,0,0,,So I'm sort of taking advantage of the fact in x86 it's this buy donated instruction sequence
Dialogue: 0,1:08:14.36,1:08:23.34,English,,0,0,0,,And if I sort of go off the aligned instructions I can often find useful things to do
Dialogue: 0,1:08:07.62,1:08:23.34,Chinese,,0,0,0,,利用 x86 的标准指令可以做一些非常有用的事
Dialogue: 0,1:08:24.48,1:08:25.96,English,,0,0,0,,So that's what's called a gadget
Dialogue: 0,1:08:24.48,1:08:25.96,Chinese,,0,0,0,,这就是所谓的 gadget
Dialogue: 0,1:08:26.00,1:08:30.23,English,,0,0,0,,And you might ask well what's so special about having them end in a return
Dialogue: 0,1:08:26.00,1:08:30.23,Chinese,,0,0,0,,你们也许会问在这一句后面返回有什么特殊的地方
Dialogue: 0,1:08:30.86,1:08:36.06,English,,0,0,0,,Well imagine I could fill up my buffer instead of with executable code
Dialogue: 0,1:08:30.86,1:08:36.06,Chinese,,0,0,0,,设想一下，如果我不使用可执行代码来填充缓冲区
Dialogue: 0,1:08:36.48,1:08:39.58,English,,0,0,0,,I could fill it up with a series of gadget addresses
Dialogue: 0,1:08:36.48,1:08:39.58,Chinese,,0,0,0,,而是使用 gadget 的地址来填充
Dialogue: 0,1:08:41.72,1:08:46.02,English,,0,0,0,,So each gadget then is some series of bytes where the final byte is c3
Dialogue: 0,1:08:41.72,1:08:46.02,Chinese,,0,0,0,,每个 gadget 的最后一句都是 c3
Dialogue: 0,1:08:49.92,1:08:52.34,English,,0,0,0,,And I'll actually position this
Dialogue: 0,1:08:49.92,1:08:52.34,Chinese,,0,0,0,,我把一个 gadget 放在这里
Dialogue: 0,1:08:53.10,1:09:02.22,English,,0,0,0,,And not the all positions at some place where you're actually going to do the initial return instruction of from before
Dialogue: 0,1:08:53.10,1:08:56.18,Chinese,,0,0,0,,而不是把所有的 gadget 放在程序的返回地址
Dialogue: 0,1:09:02.32,1:09:08.84,English,,0,0,0,,So if I can somehow get the program to return execute a ret
Dialogue: 0,1:09:02.32,1:09:08.84,Chinese,,0,0,0,,如果我可以让程序执行一条 ret 语句
Dialogue: 0,1:09:09.34,1:09:18.02,English,,0,0,0,,Right now what it will do is return will pick an address off of the stack pop an address and begin executing
Dialogue: 0,1:09:09.34,1:09:18.02,Chinese,,0,0,0,,这个返回语句使用栈上弹出的一个地址并从那里开始执行
Dialogue: 0,1:09:18.02,1:09:20.14,English,,0,0,0,,So that will start this code executing
Dialogue: 0,1:09:18.02,1:09:20.14,Chinese,,0,0,0,,它就会执行这段代码
Dialogue: 0,1:09:20.50,1:09:23.58,English,,0,0,0,,And it will hit the c3 the ret instruction at the end
Dialogue: 0,1:09:20.50,1:09:23.58,Chinese,,0,0,0,,它在最后又命中了 c3 执行了返回操作
Dialogue: 0,1:09:24.24,1:09:29.18,English,,0,0,0,,Which will again take a address pop it off the stack and begin executing
Dialogue: 0,1:09:24.24,1:09:29.18,Chinese,,0,0,0,,然后继续使用栈上的地址并开始执行
Dialogue: 0,1:09:29.20,1:09:31.92,English,,0,0,0,,So we'll start executing the second gadget
Dialogue: 0,1:09:29.20,1:09:31.92,Chinese,,0,0,0,,这样就会执行第二个 gadget
Dialogue: 0,1:09:32.26,1:09:38.68,English,,0,0,0,,And so you'll see what will happen is we're effectively concatenating these pieces of code together
Dialogue: 0,1:09:32.26,1:09:38.68,Chinese,,0,0,0,,可以看到，所有的 gadget 被连接在了一起
Dialogue: 0,1:09:38.98,1:09:44.24,English,,0,0,0,,Where it's using a ret to get from one part the end of one gadget to the start of the next
Dialogue: 0,1:09:38.98,1:09:44.24,Chinese,,0,0,0,,从上一个 gadget 返回之后又会从下一个开始执行
Dialogue: 0,1:09:44.82,1:09:47.40,English,,0,0,0,,And so that's why it's called return oriented programming
Dialogue: 0,1:09:44.82,1:09:47.40,Chinese,,0,0,0,,这就是为什么我们将它称为面向返回编程
Dialogue: 0,1:09:47.88,1:09:52.64,English,,0,0,0,,It's a way to instead of sequencing programs using a program counter like you normally do
Dialogue: 0,1:09:47.88,1:09:52.64,Chinese,,0,0,0,,这是一种替换程序计数器的方法
Dialogue: 0,1:09:53.16,1:10:04.62,English,,0,0,0,,Your sequencing programs using the sort of peculiar behavior of this particular x86 how returns work and in that program
Dialogue: 0,1:09:53.16,1:10:04.62,Chinese,,0,0,0,,这一连串代码正是利用了 x86 中返回语句的特殊行为
Dialogue: 0,1:10:04.84,1:10:09.80,English,,0,0,0,,And remember there's enough x86 out there that if I can find a way to attack them
Dialogue: 0,1:10:04.84,1:10:09.80,Chinese,,0,0,0,,如果可以找到攻击 x86 的方法，会有非常多的机器让我们来攻击
Dialogue: 0,1:10:10.36,1:10:14.18,English,,0,0,0,,I'm in pretty,I'm in a pretty good place
Dialogue: 0,1:10:10.36,1:10:14.18,Chinese,,0,0,0,,我在一个非常好的地方
Dialogue: 0,1:10:15.50,1:10:19.32,English,,0,0,0,,It's also possible to attack other processors this way to
Dialogue: 0,1:10:15.50,1:10:19.32,Chinese,,0,0,0,,也可以使用这种方法去攻击其他处理器
Dialogue: 0,1:10:19.32,1:10:22.12,English,,0,0,0,,It's just particularly nice on x86
Dialogue: 0,1:10:19.32,1:10:22.12,Chinese,,0,0,0,,这不过它在 x86 上非常好用
Dialogue: 0,1:10:23.06,1:10:25.60,English,,0,0,0,,So that's the idea of return oriented programming
Dialogue: 0,1:10:23.06,1:10:25.60,Chinese,,0,0,0,,这就是面向返回编程的概念
Dialogue: 0,1:10:25.60,1:10:33.24,English,,0,0,0,,And you'll do this yourself you'll find gadgets string them together to do different things in the attack way
Dialogue: 0,1:10:25.60,1:10:33.24,Chinese,,0,0,0,,你们之后需要使用 gadget 来完成不同的攻击行为
Dialogue: 0,1:10:35.60,1:10:42.70,English,,0,0,0,,But I'll point out that this still doesn't...so that
Dialogue: 0,1:10:35.60,1:10:42.70,Chinese,,0,0,0,,但是需要说明的是...
Dialogue: 0,1:10:43.40,1:10:52.16,English,,0,0,0,,This stack canary idea is still successful detecting a buffer overflows fairly effectively
Dialogue: 0,1:10:43.40,1:10:52.16,Chinese,,0,0,0,,canary 仍然可以检测到缓冲区溢出
Dialogue: 0,1:10:52.16,1:10:54.82,English,,0,0,0,,So in your attack lab for example
Dialogue: 0,1:10:52.16,1:10:54.82,Chinese,,0,0,0,,所以在你们的 attack lab 中
Dialogue: 0,1:10:55.22,1:11:00.68,English,,0,0,0,,We've carefully compiled the code to make it vulnerable to these attacks
Dialogue: 0,1:10:55.22,1:11:00.68,Chinese,,0,0,0,,我么已经使代码更容易受到攻击
Dialogue: 0,1:11:01.62,1:11:05.16,English,,0,0,0,,Otherwise it would be a lot harder lab
Dialogue: 0,1:11:01.62,1:11:05.16,Chinese,,0,0,0,,否则这个 lab 就会很难
Dialogue: 0,1:11:05.78,1:11:12.34,English,,0,0,0,,Like if you could do this you could probably go into the dark world and be very successful
Dialogue: 0,1:11:05.78,1:11:12.34,Chinese,,0,0,0,,并且如果你们能完成这个实验，你们就会进入黑暗世界
Dialogue: 0,1:11:15.34,1:11:21.48,English,,0,0,0,,So we're actually sort of exposing the vulnerability
Dialogue: 0,1:11:15.34,1:11:21.48,Chinese,,0,0,0,,所以我们已经将问题都暴露了出来
Dialogue: 0,1:11:21.48,1:11:26.22,English,,0,0,0,,But in the first part of the lab you're using code injection attacks
Dialogue: 0,1:11:21.48,1:11:26.22,Chinese,,0,0,0,,在实验的第一部分，你们要用到代码注入攻击
Dialogue: 0,1:11:26.22,1:11:31.78,English,,0,0,0,,So we've had to disable stack randomization and also make the stack executable
Dialogue: 0,1:11:26.22,1:11:31.78,Chinese,,0,0,0,,因此我们关闭了栈随机化并且将栈标记为可执行的
Dialogue: 0,1:11:32.26,1:11:39.32,English,,0,0,0,,So we had to sort of...but the return oriented programming we reenable that
Dialogue: 0,1:11:32.26,1:11:39.32,Chinese,,0,0,0,,在面向返回编程中，我们又把这些设置恢复了
Dialogue: 0,1:11:39.50,1:11:44.62,English,,0,0,0,,So that the stack is not executable it keeps jumping around randomly
Dialogue: 0,1:11:39.50,1:11:44.62,Chinese,,0,0,0,,也就是说栈是不可执行的并且栈随机化也会开启
Dialogue: 0,1:11:45.22,1:11:47.62,English,,0,0,0,,But we've turned off the stack canary
Dialogue: 0,1:11:45.22,1:11:47.62,Chinese,,0,0,0,,但是我们关闭了 canary
Dialogue: 0,1:11:47.62,1:11:49.84,English,,0,0,0,,So you'll be able to overflow the buffer
Dialogue: 0,1:11:47.62,1:11:49.84,Chinese,,0,0,0,,所以我们还是可以溢出缓冲区
Dialogue: 0,1:11:50.48,1:11:55.68,English,,0,0,0,,And put in your gadget addresses and build up attacks that way
Dialogue: 0,1:11:50.48,1:11:55.68,Chinese,,0,0,0,,并将你的 gadget 的地址放进去来完成这种攻击
Dialogue: 0,1:11:57.48,1:12:02.78,English,,0,0,0,,So I think you'll find by actually doing it you'll learn a lot more than you can by just hearing about it
Dialogue: 0,1:11:57.48,1:12:02.78,Chinese,,0,0,0,,我认为你们通过这些实验学到的将会比你们听到的还要多
Dialogue: 0,1:12:05.10,1:12:07.44,English,,0,0,0,,Oh you might ask why do we teach you this stuff right
Dialogue: 0,1:12:05.10,1:12:07.44,Chinese,,0,0,0,,你们也许会问为什么我们要教这些
Dialogue: 0,1:12:07.96,1:12:10.54,English,,0,0,0,,And if we supposed to teach you to be good and not evil
Dialogue: 0,1:12:07.96,1:12:10.54,Chinese,,0,0,0,,我们不是应该教给你们好的东西而不是这些罪恶的东西码
Dialogue: 0,1:12:11.12,1:12:17.86,English,,0,0,0,,Well there's a couple reasons one is you're going to learn a lot about machine program execution
Dialogue: 0,1:12:11.12,1:12:17.86,Chinese,,0,0,0,,其实有很多理由，一个就是你们将会学到很多关于程序执行的知识
Dialogue: 0,1:12:18.10,1:12:22.12,English,,0,0,0,,And how stacks work and how byte instructions are encoded and stuff like that
Dialogue: 0,1:12:18.10,1:12:22.12,Chinese,,0,0,0,,栈是如何工作的，字节指令是如何编码的等等
Dialogue: 0,1:12:22.64,1:12:28.42,English,,0,0,0,,You'll use the tools GDB object dump and all those even more than you did with the bomb lab
Dialogue: 0,1:12:22.64,1:12:28.42,Chinese,,0,0,0,,你们将会比 bomb lab 更多地使用 GDB 工具
Dialogue: 0,1:12:28.42,1:12:34.72,English,,0,0,0,,So you'll learn a lot the other is we assume that you will work for forces of good
Dialogue: 0,1:12:28.42,1:12:34.72,Chinese,,0,0,0,,另一个就是你们应该为正义而战
Dialogue: 0,1:12:34.72,1:12:40.86,English,,0,0,0,,But to be a good person you also know what the bet have to know what the bad people do
Dialogue: 0,1:12:34.72,1:12:40.86,Chinese,,0,0,0,,成为一个好人的同时也要知道坏人是怎么做的
Dialogue: 0,1:12:40.86,1:12:48.44,English,,0,0,0,,So part of it is to become more effective as a force for good
Dialogue: 0,1:12:40.86,1:12:48.44,Chinese,,0,0,0,,这样会更加有效
Dialogue: 0,1:12:51.44,1:12:54.80,English,,0,0,0,,Okay so the final thing to talk about today is unions
Dialogue: 0,1:12:51.44,1:12:54.80,Chinese,,0,0,0,,今天要将的最后一部分是联合体
Dialogue: 0,1:12:55.58,1:13:02.00,English,,0,0,0,,And the observation about a union is the declaration of it looks a lot like a struct
Dialogue: 0,1:12:55.58,1:13:02.00,Chinese,,0,0,0,,它的声明看上去和结构体很像
Dialogue: 0,1:13:03.14,1:13:07.04,English,,0,0,0,,Where there's these different fields and they're named and they can have different types
Dialogue: 0,1:13:03.14,1:13:07.04,Chinese,,0,0,0,,可以有名称不同或类型不同的域
Dialogue: 0,1:13:07.06,1:13:11.38,English,,0,0,0,,And there can be pointers to unions and all that stuff
Dialogue: 0,1:13:07.06,1:13:11.38,Chinese,,0,0,0,,也有指向联合体的指针
Dialogue: 0,1:13:11.86,1:13:14.52,English,,0,0,0,,But they're actually totally different what they do
Dialogue: 0,1:13:11.86,1:13:14.52,Chinese,,0,0,0,,但它们实际上完全不一样
Dialogue: 0,1:13:15.08,1:13:21.22,English,,0,0,0,,You recall with a struct what happens is it allocates enough memory for all the fields to coexist
Dialogue: 0,1:13:15.08,1:13:21.22,Chinese,,0,0,0,,结构体为所有的域都分配足够的内存
Dialogue: 0,1:13:22.30,1:13:28.32,English,,0,0,0,,And potentially adding padding bytes for what a union does is it
Dialogue: 0,1:13:29.20,1:13:33.40,English,,0,0,0,,Only k allocates enough storage for the maximum field in it
Dialogue: 0,1:13:22.30,1:13:33.40,Chinese,,0,0,0,,而联合体会使用占用空间最大的域的大小来分配内存
Dialogue: 0,1:13:33.74,1:13:37.20,English,,0,0,0,,And it assumes that you're only going to be using one of the possible fields
Dialogue: 0,1:13:33.74,1:13:37.20,Chinese,,0,0,0,,它假设你只会使用一个域
Dialogue: 0,1:13:37.76,1:13:43.60,English,,0,0,0,,And it will literally a store on top of it these fields get stored on top of each other
Dialogue: 0,1:13:37.76,1:13:43.60,Chinese,,0,0,0,,如果你存储另一个域，它就会覆盖上一个存储的域
Dialogue: 0,1:13:43.60,1:13:49.50,English,,0,0,0,,So that if you try to use multiple fields you can mess things up
Dialogue: 0,1:13:43.60,1:13:49.50,Chinese,,0,0,0,,因此如果你同时使用多个域就会出问题
Dialogue: 0,1:13:50.18,1:13:52.88,English,,0,0,0,,And it's not for that purpose of doing multiple values
Dialogue: 0,1:13:50.18,1:13:52.88,Chinese,,0,0,0,,它不是用来处理多个值的
Dialogue: 0,1:13:52.88,1:13:57.66,English,,0,0,0,,It's for the purpose of for example if I know I'm only going to use one of these
Dialogue: 0,1:13:52.88,1:13:57.66,Chinese,,0,0,0,,如果我知道我只会使用多个值中的一个
Dialogue: 0,1:13:58.20,1:14:05.28,English,,0,0,0,,Or it's another also a way to create essentially an alias that will let you reference memory in different ways
Dialogue: 0,1:13:58.20,1:14:05.28,Chinese,,0,0,0,,或者说它是一种通过别名来引用不同的内存的方式
Dialogue: 0,1:14:07.02,1:14:11.10,English,,0,0,0,,So for example in your data lab you are using
Dialogue: 0,1:14:07.02,1:14:11.10,Chinese,,0,0,0,,举个例子，在 data lab 中
Dialogue: 0,1:14:12.44,1:14:18.16,English,,0,0,0,,You were manipulating the bit level representations of floating point numbers
Dialogue: 0,1:14:12.44,1:14:18.16,Chinese,,0,0,0,,你要处理位级别的浮点数的表示
Dialogue: 0,1:14:18.74,1:14:22.88,English,,0,0,0,,And in our code that would then convert that to an actual float
Dialogue: 0,1:14:18.74,1:14:22.88,Chinese,,0,0,0,,在我们的代码中这将会被转换成一个真正的浮点数
Dialogue: 0,1:14:23.22,1:14:33.32,English,,0,0,0,,We used a union where the union is either to view this field of four bytes is an unsigned or is a float
Dialogue: 0,1:14:23.22,1:14:33.32,Chinese,,0,0,0,,如果我们使用一个包含 unsigned 类型和 float 类型的域的联合体
Dialogue: 0,1:14:33.76,1:14:46.69,English,,0,0,0,,And so I can convert from unsigned to its float representation by just storing the unsigned value in this union
Dialogue: 0,1:14:33.76,1:14:46.69,Chinese,,0,0,0,,我就可以通过将浮点数的字节表示存储到 unsigned 类型的域中
Dialogue: 0,1:14:46.88,1:14:48.92,English,,0,0,0,,And retrieving it as if it were float
Dialogue: 0,1:14:46.88,1:14:48.92,Chinese,,0,0,0,,并通过 float 域来获取它
Dialogue: 0,1:14:49.36,1:14:53.64,English,,0,0,0,,And this is a fundamentally different operation than casting
Dialogue: 0,1:14:49.36,1:14:53.64,Chinese,,0,0,0,,这和类型转换是完全不同的操作
Dialogue: 0,1:14:53.64,1:14:57.68,English,,0,0,0,,Because you recall when you take a unsigned value and you cast it to a float
Dialogue: 0,1:14:53.64,1:14:57.68,Chinese,,0,0,0,,当你将 unsigned 类型的值转换为 float 类型时
Dialogue: 0,1:14:58.02,1:14:59.28,English,,0,0,0,,You actually change the bits
Dialogue: 0,1:14:58.02,1:14:59.28,Chinese,,0,0,0,,你实际上改变了它的位
Dialogue: 0,1:14:59.32,1:15:07.27,English,,0,0,0,,You change it into the floating point number that's the closest a match to this particular number
Dialogue: 0,1:14:59.32,1:15:07.27,Chinese,,0,0,0,,将它转换成了最接近这个值的浮点数
Dialogue: 0,1:15:07.27,1:15:11.22,English,,0,0,0,,It would be the equivalent of the function you implemented float underscore u2f
Dialogue: 0,1:15:07.27,1:15:11.22,Chinese,,0,0,0,,它和你实现的 float_u2f 函数是等效的
Dialogue: 0,1:15:12.14,1:15:17.94,English,,0,0,0,,But this one actually doesn't change bits it just changes the numeric value changes quite a bit
Dialogue: 0,1:15:12.14,1:15:17.94,Chinese,,0,0,0,,但是联合体并没有改变它的位
Dialogue: 0,1:15:19.04,1:15:26.80,English,,0,0,0,,So it's a useful technique to do that to be able to override the the type system and get two bit representations
Dialogue: 0,1:15:19.04,1:15:26.80,Chinese,,0,0,0,,因此联合体是一种切换类型并得到不同的位表示形式的技术
Dialogue: 0,1:15:28.78,1:15:35.62,English,,0,0,0,,And this actually turns out to be one of the places to where byte ordering will show up in programs if you're not careful
Dialogue: 0,1:15:28.78,1:15:35.62,Chinese,,0,0,0,,它实际上说明了如果你不小心的话你的程序中就会出现字节序列（的问题）
Dialogue: 0,1:15:37.36,1:15:42.44,English,,0,0,0,,So in particular with this union I can view a block of eight bytes
Dialogue: 0,1:15:37.36,1:15:42.44,Chinese,,0,0,0,,使用这个联合体，我就可以看到一块 8 个字节的内存
Dialogue: 0,1:15:42.46,1:15:49.06,English,,0,0,0,,As either eight characters four shorts two ints or one long
Dialogue: 0,1:15:42.46,1:15:49.06,Chinese,,0,0,0,,8 个字符，4 个 short，2 个 int，或者 1 个 long
Dialogue: 0,1:15:49.64,1:15:53.88,English,,0,0,0,,And on a 64-bit machine like is shown here where along is 64 bits
Dialogue: 0,1:15:49.64,1:15:53.88,Chinese,,0,0,0,,在 64 位的机器上 long 类型有 64 位
Dialogue: 0,1:15:54.54,1:16:03.32,English,,0,0,0,,You'll see that you're able to look at things as either as a the individual byte making it up
Dialogue: 0,1:15:54.54,1:16:03.32,Chinese,,0,0,0,,你可以查看一个字节
Dialogue: 0,1:16:04.00,1:16:07.44,English,,0,0,0,,Or some longer aggregation of those byte
Dialogue: 0,1:16:04.00,1:16:07.44,Chinese,,0,0,0,,或者更多字节的组合
Dialogue: 0,1:16:08.56,1:16:11.94,English,,0,0,0,,And you'll actually find that depending on what machine you run it on
Dialogue: 0,1:16:08.56,1:16:11.94,Chinese,,0,0,0,,这取决于你使用的机器
Dialogue: 0,1:16:12.34,1:16:17.32,English,,0,0,0,,You'll get a different result because of the byte ordering of the different machines
Dialogue: 0,1:16:17.88,1:16:22.50,English,,0,0,0,,So this goes through it what happens when you run on different machines
Dialogue: 0,1:16:17.88,1:16:22.50,Chinese,,0,0,0,,所以当你在不同的机器上运行时会经历这些
Dialogue: 0,1:16:12.34,1:16:17.32,Chinese,,0,0,0,,由于不同机器上的字节序列不同，因此在不同的机器上会得到不同的结果
Dialogue: 0,1:16:23.28,1:16:26.42,English,,0,0,0,,But you'll notice in particular that
Dialogue: 0,1:16:23.28,1:16:26.42,Chinese,,0,0,0,,尤其需要注意的是
Dialogue: 0,1:16:27.92,1:16:31.28,English,,0,0,0,,On an IA32 machine a 32-bit machine
Dialogue: 0,1:16:27.92,1:16:31.28,Chinese,,0,0,0,,在 IA32 机器上
Dialogue: 0,1:16:33.62,1:16:38.92,English,,0,0,0,,It's coming off in this byte pattern 0xf3f2f1f0
Dialogue: 0,1:16:33.62,1:16:38.92,Chinese,,0,0,0,,这个字节序列是 0xf3f2f1f0
Dialogue: 0,1:16:39.94,1:16:46.34,English,,0,0,0,,And on a sun back when they existed you'd get the opposite because of the byte ordering
Dialogue: 0,1:16:39.94,1:16:46.34,Chinese,,0,0,0,,在 64 位的机器上你会得到相反的字节序列
Dialogue: 0,1:16:47.06,1:16:57.60,English,,0,0,0,,And now on an x86-64 where a along is 64 bits you get eight bytes
Dialogue: 0,1:16:47.06,1:16:57.60,Chinese,,0,0,0,,下面是在一台 x86-64 的机器上的 8 个字节
Dialogue: 0,1:16:58.20,1:17:02.42,English,,0,0,0,,And you can also determine from this if you look carefully that it's in
Dialogue: 0,1:17:02.84,1:17:07.28,English,,0,0,0,,It's a little endian order because this is the we significant byte is f0
Dialogue: 0,1:16:58.20,1:17:07.28,Chinese,,0,0,0,,如果你仔细看你会发现这是一个小端序的字节序，因为它的有效位是 f0
Dialogue: 0,1:17:08.10,1:17:10.30,English,,0,0,0,,Which is the first byte 0xf0
Dialogue: 0,1:17:08.10,1:17:10.30,Chinese,,0,0,0,,也就是第一个字节是 0xf0
Dialogue: 0,1:17:11.12,1:17:16.68,English,,0,0,0,,So it's also way to get to the low level bytes
Dialogue: 0,1:17:11.12,1:17:16.68,Chinese,,0,0,0,,因此这也是一种获取低位字节的方式
Dialogue: 0,1:17:16.74,1:17:23.06,English,,0,0,0,,But when you use this kind of thing you're sort of intentionally telling the C compiler
Dialogue: 0,1:17:16.74,1:17:23.06,Chinese,,0,0,0,,当你使用这种方法的时候，你实际上实在告诉 C 编译器
Dialogue: 0,1:17:23.62,1:17:27.76,English,,0,0,0,,Trust me I know what I'm doing,you don't have to protect me from myself
Dialogue: 0,1:17:23.62,1:17:27.76,Chinese,,0,0,0,,相信我，我知道自己在做什么，不要阻止我
Dialogue: 0,1:17:28.14,1:17:33.40,English,,0,0,0,,And so if you're not careful you can write code where because of a byte ordering problem or something like that
Dialogue: 0,1:17:28.14,1:17:33.40,Chinese,,0,0,0,,因此，如果你不小心，你就会写出含有字节序问题或其他问题的代码
Dialogue: 0,1:17:33.80,1:17:36.64,English,,0,0,0,,we'll run properly on some machines
Dialogue: 0,1:17:33.80,1:17:36.64,Chinese,,0,0,0,,我们可能只能在同一台机器运行
Dialogue: 0,1:17:38.36,1:17:39.84,English,,0,0,0,,So just to summarize 
Dialogue: 0,1:17:38.36,1:17:39.84,Chinese,,0,0,0,,现在我们来总结一下
Dialogue: 0,1:17:39.90,1:17:44.92,English,,0,0,0,,Then We've looked then...We've looked then at the three compound types in c
Dialogue: 0,1:17:39.90,1:17:44.92,Chinese,,0,0,0,,我们已经看过了 C 语言中的三种复杂的类型
Dialogue: 0,1:17:44.92,1:17:48.80,English,,0,0,0,,The ways you can aggregate smaller types into larger ones
Dialogue: 0,1:17:44.92,1:17:48.80,Chinese,,0,0,0,,你可以将小的类型组合成大的类型
Dialogue: 0,1:17:48.80,1:17:54.56,English,,0,0,0,,You can make an array of identical elements indexed by a number the position
Dialogue: 0,1:17:48.80,1:17:54.56,Chinese,,0,0,0,,你可以创建一个使用位置作为索引的数组
Dialogue: 0,1:17:54.90,1:18:00.76,English,,0,0,0,,And that usually turns into some kind of scaled computation to get to the particular place
Dialogue: 0,1:17:54.90,1:18:00.76,Chinese,,0,0,0,,通过这种方式可以到达指定的位置
Dialogue: 0,1:18:01.60,1:18:05.66,English,,0,0,0,,We've seen structures where it's a fixed number of fields
Dialogue: 0,1:18:01.60,1:18:05.66,Chinese,,0,0,0,,我们也学习了结构体，它的域数量是固定的
Dialogue: 0,1:18:06.16,1:18:09.82,English,,0,0,0,,But the fields can be of different type and the reference by their names
Dialogue: 0,1:18:06.16,1:18:09.82,Chinese,,0,0,0,,但是可以通过名字来引用这些不同类型的域
Dialogue: 0,1:18:10.20,1:18:14.92,English,,0,0,0,,And that usually turns into some type of displacement off of the original position
Dialogue: 0,1:18:10.20,1:18:14.92,Chinese,,0,0,0,,它通过起始位置来计算偏移量
Dialogue: 0,1:18:15.58,1:18:24.48,English,,0,0,0,,And then a union is just a way of sort of piling up in one place a number of different fields
Dialogue: 0,1:18:15.58,1:18:24.48,Chinese,,0,0,0,,联合体的域都存储在一个地方
Dialogue: 0,1:18:24.76,1:18:28.38,English,,0,0,0,,And so all it does is allocate the maximum number of bytes
Dialogue: 0,1:18:24.76,1:18:28.38,Chinese,,0,0,0,,它分配的内存取决于占用空间最大的那个域
Dialogue: 0,1:18:28.72,1:18:33.14,English,,0,0,0,,And doesn't create enough space for them all to be there at the same time
Dialogue: 0,1:18:28.72,1:18:33.14,Chinese,,0,0,0,,而不是为所有的域同时分配空间
Dialogue: 0,1:18:34.94,1:18:40.19,English,,0,0,0,,Okay that's it for today then
Dialogue: 0,1:18:34.94,1:18:40.19,Chinese,,0,0,0,,今天就到这里
