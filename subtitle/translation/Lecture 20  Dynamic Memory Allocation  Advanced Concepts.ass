[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 20  Dynamic Memory Allocation  Advanced Concepts.mp4
Video File: ../../../../Desktop/csapp/Lecture 20  Dynamic Memory Allocation  Advanced Concepts.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.875000
Scroll Position: 2117
Active Line: 2137
Video Position: 148461

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Noto Sans CJK SC Black,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,1.5,1.2,2,10,10,10,1
Style: Chinese,Noto Sans CJK SC Black,50,&H00FFFF00,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.2,1.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:01.38,English,,0,0,0,,Good afternoon everybody
Dialogue: 0,0:00:00.00,0:00:01.38,Chinese,,0,0,0,,大家下午好
Dialogue: 0,0:00:02.44,0:00:03.74,English,,0,0,0,,Welcome good to see you
Dialogue: 0,0:00:02.44,0:00:03.74,Chinese,,0,0,0,,欢迎很高兴见到你
Dialogue: 0,0:00:03.86,0:00:07.52,English,,0,0,0,,And welcome to all those who are watching on videotape as well
Dialogue: 0,0:00:03.86,0:00:07.52,Chinese,,0,0,0,,也欢迎正在看录像的同学们
Dialogue: 0,0:00:10.38,0:00:13.28,English,,0,0,0,,I want to clear up. I realized after the last lecture
Dialogue: 0,0:00:10.38,0:00:13.28,Chinese,,0,0,0,,我想重新整理一下上节课的内容
Dialogue: 0,0:00:13.28,0:00:17.48,English,,0,0,0,,That I didn't explain the idea of peak memory utilization very well to you
Dialogue: 0,0:00:13.28,0:00:17.48,Chinese,,0,0,0,,我意识到我没有很好地解释峰值内存利用率这个概念
Dialogue: 0,0:00:17.50,0:00:23.66,English,,0,0,0,,So I want to just explain that it's an important idea and I want to make sure that we have it clear
Dialogue: 0,0:00:17.50,0:00:23.66,Chinese,,0,0,0,,我想要说明这是一个很重要的概念，我希望大家都能够理解
Dialogue: 0,0:00:24.64,0:00:34.08,English,,0,0,0,,So if you recall from we're executing a series a sequence of requests
Dialogue: 0,0:00:24.64,0:00:34.08,Chinese,,0,0,0,,你回忆起我们正在执行一系列请求
Dialogue: 0,0:00:35.78,0:00:46.16,English,,0,0,0,,R0,R1,R2...R(k)...R(n-1)
Dialogue: 0,0:00:35.78,0:00:46.16,Chinese,,0,0,0,,R0，R1，R2，...，R(k)，...，R(N-1)
Dialogue: 0,0:00:47.58,0:00:51.82,English,,0,0,0,,And at any point in time after k+1 requests
Dialogue: 0,0:00:47.58,0:00:51.82,Chinese,,0,0,0,,并且在 k+1 请求之后的任何时间点
Dialogue: 0,0:00:54.56,0:00:57.16,English,,0,0,0,,We have H(k)
Dialogue: 0,0:00:54.56,0:00:57.16,Chinese,,0,0,0,,我们有 H(k)
Dialogue: 0,0:00:58.36,0:01:01.72,English,,0,0,0,,Which is the heap size
Dialogue: 0,0:00:58.36,0:01:01.72,Chinese,,0,0,0,,这是堆大小
Dialogue: 0,0:01:05.74,0:01:07.94,English,,0,0,0,,After k1 requests
Dialogue: 0,0:01:05.74,0:01:07.94,Chinese,,0,0,0,,在 k+1 次请求之后
Dialogue: 0,0:01:17.88,0:01:20.86,English,,0,0,0,,Now we have a P(k) which is the aggregate
Dialogue: 0,0:01:17.88,0:01:20.86,Chinese,,0,0,0,,我们现在有一个 P(k) 的聚合
Dialogue: 0,0:01:27.78,0:01:30.00,English,,0,0,0,,The sum of all of the payloads
Dialogue: 0,0:01:27.78,0:01:30.00,Chinese,,0,0,0,,所有有效载荷的总和
Dialogue: 0,0:01:32.06,0:01:33.72,English,,0,0,0,,After k+1 requests
Dialogue: 0,0:01:32.06,0:01:33.72,Chinese,,0,0,0,,在 k+1 请求之后
Dialogue: 0,0:01:37.44,0:01:40.82,English,,0,0,0,,Okay so what we're trying to do with this pk measure
Dialogue: 0,0:01:37.44,0:01:40.82,Chinese,,0,0,0,,我们正在尝试用这个 p(k)
Dialogue: 0,0:01:41.36,0:01:44.56,English,,0,0,0,,This aggregate payload is at any point in time so
Dialogue: 0,0:01:41.36,0:01:44.56,Chinese,,0,0,0,,此聚合有效负载在任何时间点都是如此
Dialogue: 0,0:01:45.36,0:01:48.00,English,,0,0,0,,As we execute requests one after the other
Dialogue: 0,0:01:45.36,0:01:48.00,Chinese,,0,0,0,,当我们一个接一个地执行请求时
Dialogue: 0,0:01:49.40,0:01:56.48,English,,0,0,0,,The sum of all the payloads in the heap is going to either increase or decrease right so if we execute an allocate
Dialogue: 0,0:01:49.40,0:01:56.48,Chinese,,0,0,0,,如果我们执行分配，堆中所有有效负载的总和将增加或减少
Dialogue: 0,0:01:57.34,0:01:59.62,English,,0,0,0,,Then the size of the payloads will increase
Dialogue: 0,0:01:57.34,0:01:59.62,Chinese,,0,0,0,,然后有效载荷的大小将增加
Dialogue: 0,0:02:00.60,0:02:06.12,English,,0,0,0,,If we execute a free the size of all those allocated payloads will decrease right so
Dialogue: 0,0:02:00.60,0:02:06.12,Chinese,,0,0,0,,如果我们执行 free，则所有分配的有效负载的大小将会减小
Dialogue: 0,0:02:06.82,0:02:09.62,English,,0,0,0,,So as we're executing this the sequence of requests these
Dialogue: 0,0:02:06.82,0:02:09.62,Chinese,,0,0,0,,因此，当我们执行这些请求序列时
Dialogue: 0,0:02:10.28,0:02:14.90,English,,0,0,0,,The aggregate the sum of all the payloads is going to be increasing and decreasing
Dialogue: 0,0:02:10.28,0:02:14.90,Chinese,,0,0,0,,所有有效载荷的总和将会增加和减少
Dialogue: 0,0:02:16.88,0:02:23.18,English,,0,0,0,,Okay and so what we're capturing with the sum of all these payloads is like a perfect allocator that has no overheads
Dialogue: 0,0:02:16.88,0:02:23.18,Chinese,,0,0,0,,我们用所有这些有效载荷的总和捕获的东西就像一个没有开销的完美分配器
Dialogue: 0,0:02:23.62,0:02:26.18,English,,0,0,0,,And even more so one that we can
Dialogue: 0,0:02:23.62,0:02:26.18,Chinese,,0,0,0,,甚至
Dialogue: 0,0:02:27.58,0:02:29.18,English,,0,0,0,,Where we're allowed to compact blocks
Dialogue: 0,0:02:27.58,0:02:29.18,Chinese,,0,0,0,,我们被允许压缩块
Dialogue: 0,0:02:29.52,0:02:34.92,English,,0,0,0,,So the sum of all of the payloads is the minimum possible heap size
Dialogue: 0,0:02:29.52,0:02:34.92,Chinese,,0,0,0,,因此，所有有效负载的总和是最小可能的堆大小
Dialogue: 0,0:02:36.50,0:02:42.60,English,,0,0,0,,It's the minimum possible number of bytes required by those allocated blocks
Dialogue: 0,0:02:36.50,0:02:42.60,Chinese,,0,0,0,,这是分配的块所需的最小字节数
Dialogue: 0,0:02:43.02,0:02:46.50,English,,0,0,0,,Okay so it's very very aggressive and it's impossible to achieve
Dialogue: 0,0:02:43.02,0:02:46.50,Chinese,,0,0,0,,所以它非常完美的，但是无法实现
Dialogue: 0,0:02:47.02,0:02:49.00,English,,0,0,0,,But we're going to use that as sort of a best case
Dialogue: 0,0:02:47.02,0:02:49.00,Chinese,,0,0,0,,但我们将把它作为一种最好的案例
Dialogue: 0,0:02:49.44,0:02:49.86,English,,0,0,0,,Okay
Dialogue: 0,0:02:49.44,0:02:49.86,Chinese,,0,0,0,,好的
Dialogue: 0,0:02:51.14,0:03:00.34,English,,0,0,0,,And so to measure a P(k) memory utilization
Dialogue: 0,0:02:51.14,0:03:00.34,Chinese,,0,0,0,,因此，要测量 P(k) 内存利用率
Dialogue: 0,0:03:05.98,0:03:09.96,English,,0,0,0,,After K+1 requests
Dialogue: 0,0:03:05.98,0:03:09.96,Chinese,,0,0,0,,在 K+1 请求之后
Dialogue: 0,0:03:12.44,0:03:13.84,English,,0,0,0,,Which will denote U(k)
Dialogue: 0,0:03:12.44,0:03:13.84,Chinese,,0,0,0,,哪个将表示 U(k)
Dialogue: 0,0:03:15.58,0:03:17.46,English,,0,0,0,,That's going to be equal to
Dialogue: 0,0:03:15.58,0:03:17.46,Chinese,,0,0,0,,这将等于
Dialogue: 0,0:03:18.28,0:03:20.82,English,,0,0,0,,The max
Dialogue: 0,0:03:18.28,0:03:20.82,Chinese,,0,0,0,,最大
Dialogue: 0,0:03:24.56,0:03:26.80,English,,0,0,0,,For all i <=k
Dialogue: 0,0:03:24.56,0:03:26.80,Chinese,,0,0,0,,对于所有 i <= k
Dialogue: 0,0:03:32.98,0:03:34.44,English,,0,0,0,,Of our aggregate payloads
Dialogue: 0,0:03:32.98,0:03:34.44,Chinese,,0,0,0,,我们的总有效载荷
Dialogue: 0,0:03:36.58,0:03:41.54,English,,0,0,0,,Divided by the size of the heap after after k+1 requests
Dialogue: 0,0:03:36.58,0:03:41.54,Chinese,,0,0,0,,除以在 k+1 个请求之后的堆的大小
Dialogue: 0,0:03:42.76,0:03:45.18,English,,0,0,0,,Okay so what we're doing with this max is
Dialogue: 0,0:03:42.76,0:03:45.18,Chinese,,0,0,0,,那么我们正在做的最大化的是
Dialogue: 0,0:03:46.50,0:03:48.38,English,,0,0,0,,We're remembering the high-water mark
Dialogue: 0,0:03:46.50,0:03:48.38,Chinese,,0,0,0,,我们记得高水位线
Dialogue: 0,0:03:49.36,0:03:51.90,English,,0,0,0,,You know as our aggregate payloads
Dialogue: 0,0:03:49.36,0:03:51.90,Chinese,,0,0,0,,当聚集有效负载增加或者减少时
Dialogue: 0,0:03:52.78,0:03:55.72,English,,0,0,0,,Increase and decrease we're remembering the high-water mark
Dialogue: 0,0:03:52.78,0:03:55.72,Chinese,,0,0,0,,我们记住高水位线
Dialogue: 0,0:03:56.16,0:04:00.72,English,,0,0,0,,Right so that was sort of the worst that was like the biggest set of payloads that we had
Dialogue: 0,0:03:56.16,0:04:00.72,Chinese,,0,0,0,,这是最糟糕的，就像我们拥有的最大有效载荷一样
Dialogue: 0,0:04:01.42,0:04:07.66,English,,0,0,0,,And then so the max is remembering that high-water mark
Dialogue: 0,0:04:01.42,0:04:07.66,Chinese,,0,0,0,,最大值就是这个高水位线
Dialogue: 0,0:04:08.24,0:04:13.00,English,,0,0,0,,And then we're dividing by the total size of the heap in order to get an efficiency measure
Dialogue: 0,0:04:08.24,0:04:13.00,Chinese,,0,0,0,,然后我们将其除以堆的总大小以获得效率度量
Dialogue: 0,0:04:13.50,0:04:15.30,English,,0,0,0,,Okay so this max
Dialogue: 0,0:04:13.50,0:04:15.30,Chinese,,0,0,0,,所以这个最大值
Dialogue: 0,0:04:16.84,0:04:23.30,English,,0,0,0,,P(k) is the best we could have done divided by the total the total heap size
Dialogue: 0,0:04:16.84,0:04:23.30,Chinese,,0,0,0,,我们最好用 P(K) 来除以总堆大小的总和
Dialogue: 0,0:04:23.72,0:04:25.08,English,,0,0,0,,Okay so yes
Dialogue: 0,0:04:23.72,0:04:25.08,Chinese,,0,0,0,,好的，是的
Dialogue: 0,0:04:25.08,0:04:29.82,English,,0,0,0,,[student speaking]
Dialogue: 0,0:04:25.08,0:04:29.82,Chinese,,0,0,0,,学生提问
Dialogue: 0,0:04:31.12,0:04:34.56,English,,0,0,0,,Well that the allocator keeps track of of how big the heap
Dialogue: 0,0:04:31.12,0:04:34.56,Chinese,,0,0,0,,那么分配器会跟踪堆的大小
Dialogue: 0,0:04:35.92,0:04:36.96,English,,0,0,0,,So that's pretty easy right
Dialogue: 0,0:04:35.92,0:04:36.96,Chinese,,0,0,0,,所以这很简单吧
Dialogue: 0,0:04:36.96,0:04:41.60,English,,0,0,0,,So as every time it does,every time it calls sbreak
Dialogue: 0,0:04:36.96,0:04:41.60,Chinese,,0,0,0,,因此，每当它发生时，每次它调用 「sbreak」
Dialogue: 0,0:04:41.60,0:04:44.96,English,,0,0,0,,It just that adds to the size of the heap and remember we're...
Dialogue: 0,0:04:41.60,0:04:44.96,Chinese,,0,0,0,,只是增加了堆的大小
Dialogue: 0,0:04:45.50,0:04:51.54,English,,0,0,0,,We're assuming that the heap in this case is always increasing okay so
Dialogue: 0,0:04:45.50,0:04:51.54,Chinese,,0,0,0,,我们假设在这种情况下堆总是增加
Dialogue: 0,0:04:52.98,0:04:55.36,English,,0,0,0,,But even if we allow the heap size to decrease
Dialogue: 0,0:04:52.98,0:04:55.36,Chinese,,0,0,0,,但即使我们允许堆大小减少
Dialogue: 0,0:04:55.82,0:05:01.50,English,,0,0,0,,Could just if the allocator is controlling the size of the heap by calls to sbreak
Dialogue: 0,0:04:55.82,0:05:01.50,Chinese,,0,0,0,,只是分配器可以通过调用 「sbreak」 来控制堆的大小
Dialogue: 0,0:05:03.38,0:05:04.44,English,,0,0,0,,Okay so is that clear
Dialogue: 0,0:05:03.38,0:05:04.44,Chinese,,0,0,0,,好的就是这么清楚
Dialogue: 0,0:05:05.92,0:05:08.08,English,,0,0,0,,So for U(k) the higher the better
Dialogue: 0,0:05:05.92,0:05:08.08,Chinese,,0,0,0,,因此对于 U(k) 越高越好
Dialogue: 0,0:05:10.16,0:05:14.12,English,,0,0,0,,Okay and for any sequence of allocates and free
Dialogue: 0,0:05:10.16,0:05:14.12,Chinese,,0,0,0,,好的，任何分配和释放序列
Dialogue: 0,0:05:14.66,0:05:16.78,English,,0,0,0,,This max P(k) will be the same
Dialogue: 0,0:05:14.66,0:05:16.78,Chinese,,0,0,0,,这个最大 P(k) 将是相同的
Dialogue: 0,0:05:17.28,0:05:18.68,English,,0,0,0,,Okay that's constant right
Dialogue: 0,0:05:17.28,0:05:18.68,Chinese,,0,0,0,,这是常数
Dialogue: 0,0:05:20.02,0:05:27.24,English,,0,0,0,,But what varies is H(k) and that depends on how efficient your allocator is using the heap storage
Dialogue: 0,0:05:20.02,0:05:27.24,Chinese,,0,0,0,,但是 H(k) 是变化，它取决于分配器使用堆存储的效率
Dialogue: 0,0:05:28.36,0:05:29.50,English,,0,0,0,,Okay yes question
Dialogue: 0,0:05:28.36,0:05:29.50,Chinese,,0,0,0,,好的，是的问题
Dialogue: 0,0:05:29.50,0:05:34.52,English,,0,0,0,,[student speaking]
Dialogue: 0,0:05:29.50,0:05:34.52,Chinese,,0,0,0,,学生提问
Dialogue: 0,0:05:34.52,0:05:37.56,English,,0,0,0,,So what we're doing is at any point in time
Dialogue: 0,0:05:34.52,0:05:37.56,Chinese,,0,0,0,,所以我们正在做的是在任何时间
Dialogue: 0,0:05:38.82,0:05:41.04,English,,0,0,0,,After we're after k+1 requests
Dialogue: 0,0:05:38.82,0:05:41.04,Chinese,,0,0,0,,在我们完成 k+1 次请求之后
Dialogue: 0,0:05:41.76,0:05:46.80,English,,0,0,0,,We're evaluating the utilization of a heap up till that point so it should be k
Dialogue: 0,0:05:41.76,0:05:46.80,Chinese,,0,0,0,,我们正在评估堆的利用率，直到那时它应该是 k
Dialogue: 0,0:05:46.80,0:05:52.16,English,,0,0,0,,[student speaking]
Dialogue: 0,0:05:46.80,0:05:52.16,Chinese,,0,0,0,,学生提问
Dialogue: 0,0:05:52.16,0:05:54.32,English,,0,0,0,,For i <=k
Dialogue: 0,0:05:52.16,0:05:54.32,Chinese,,0,0,0,,for i <= k
Dialogue: 0,0:05:57.48,0:05:58.38,English,,0,0,0,,Oh I'm sorry
Dialogue: 0,0:05:57.48,0:05:58.38,Chinese,,0,0,0,,哦，对不起
Dialogue: 0,0:06:10.86,0:06:13.16,English,,0,0,0,,Yeah sorry good good catch so that should be an i right
Dialogue: 0,0:06:10.86,0:06:13.16,Chinese,,0,0,0,,对不起，所以这应该是 i
Dialogue: 0,0:06:13.16,0:06:19.52,English,,0,0,0,,We want to look at all the requests that came before
Dialogue: 0,0:06:13.16,0:06:19.52,Chinese,,0,0,0,,我们想查看之前的所有请求
Dialogue: 0,0:06:23.06,0:06:24.00,English,,0,0,0,,Okay any other questions
Dialogue: 0,0:06:23.06,0:06:24.00,Chinese,,0,0,0,,还有其他任何问题
Dialogue: 0,0:06:36.06,0:06:41.64,English,,0,0,0,,Okay all right so last time we looked at some simple the basics of dynamic storage allocation
Dialogue: 0,0:06:36.06,0:06:41.64,Chinese,,0,0,0,,好的，所以上次我们看一下简单的动态存储分配的基础知识
Dialogue: 0,0:06:42.18,0:06:45.86,English,,0,0,0,,Today we're going to look at some more sophisticated techniques using
Dialogue: 0,0:06:42.18,0:06:45.86,Chinese,,0,0,0,,今天我们将看一些更复杂的技术
Dialogue: 0,0:06:47.54,0:06:50.64,English,,0,0,0,,Different data structures to store the free list primarily
Dialogue: 0,0:06:47.54,0:06:50.64,Chinese,,0,0,0,,主要用于存储空闲列表的不同数据结构
Dialogue: 0,0:06:52.62,0:06:54.72,English,,0,0,0,,We'll look at implicit allocators
Dialogue: 0,0:06:52.62,0:06:54.72,Chinese,,0,0,0,,我们将看一下隐式分配器
Dialogue: 0,0:06:54.82,0:06:59.00,English,,0,0,0,,So we'll get a sort of a brief survey of how garbage collectors work
Dialogue: 0,0:06:54.82,0:06:59.00,Chinese,,0,0,0,,我们将对垃圾收集器的工作方式进行简要学习
Dialogue: 0,0:06:59.02,0:07:03.58,English,,0,0,0,,And we'll just look at one,just one very simple kind of garbage collector
Dialogue: 0,0:06:59.02,0:07:03.58,Chinese,,0,0,0,,我们只看一个，只是一个非常简单的垃圾收集器
Dialogue: 0,0:07:03.58,0:07:06.84,English,,0,0,0,,But it will give you an idea of what that means
Dialogue: 0,0:07:03.58,0:07:06.84,Chinese,,0,0,0,,但它会让你知道这意味着什么
Dialogue: 0,0:07:07.46,0:07:08.44,English,,0,0,0,,And then we'll finish up
Dialogue: 0,0:07:07.46,0:07:08.44,Chinese,,0,0,0,,然后我们将完成
Dialogue: 0,0:07:10.42,0:07:13.78,English,,0,0,0,,We'll finish up by looking at all the ways you can get yourself into trouble
Dialogue: 0,0:07:10.42,0:07:13.78,Chinese,,0,0,0,,我们将通过在使用动态分配储存空间中可能遇到的问题
Dialogue: 0,0:07:15.00,0:07:16.96,English,,0,0,0,,By using dynamically allocated storage
Dialogue: 0,0:07:15.00,0:07:16.96,Chinese,,0,0,0,,来进行这堂课的学习
Dialogue: 0,0:07:17.04,0:07:21.60,English,,0,0,0,,So once you start dynamically allocating storage
Dialogue: 0,0:07:17.04,0:07:21.60,Chinese,,0,0,0,,一旦你开始动态分配存储
Dialogue: 0,0:07:22.10,0:07:24.84,English,,0,0,0,,Things can go really bad really quickly
Dialogue: 0,0:07:22.10,0:07:24.84,Chinese,,0,0,0,,事情真的很快就会很糟糕
Dialogue: 0,0:07:25.02,0:07:29.60,English,,0,0,0,,And so we'll go over some of those bad things that can happen and
Dialogue: 0,0:07:25.02,0:07:29.60,Chinese,,0,0,0,,所以我们将讨论一些可能发生的坏事
Dialogue: 0,0:07:30.42,0:07:33.60,English,,0,0,0,,Try to alert you to those so you don't do them in your programs
Dialogue: 0,0:07:30.42,0:07:33.60,Chinese,,0,0,0,,尽量提醒你，以免在程序中执行此操作
Dialogue: 0,0:07:44.60,0:07:52.92,English,,0,0,0,,Okay so we looked at how to store a free list in this sort of implicit form by just walking the entire heap
Dialogue: 0,0:07:44.60,0:07:52.92,Chinese,,0,0,0,,好的，我们看看如何通过走完整个堆来存储这种隐式形式的空闲列表
Dialogue: 0,0:07:53.58,0:07:56.84,English,,0,0,0,,And and there by sort of being able to visit all the free blocks
Dialogue: 0,0:07:53.58,0:07:56.84,Chinese,,0,0,0,,并且能够访问所有空闲区块
Dialogue: 0,0:07:57.30,0:07:58.62,English,,0,0,0,,But we can do better
Dialogue: 0,0:07:57.30,0:07:58.62,Chinese,,0,0,0,,但我们可以做得更好
Dialogue: 0,0:07:59.08,0:08:05.18,English,,0,0,0,,If we store the free list using a doubly linked list
Dialogue: 0,0:07:59.08,0:08:05.18,Chinese,,0,0,0,,如果我们用双向链表来储存空闲列表
Dialogue: 0,0:08:07.76,0:08:10.16,English,,0,0,0,,So in we call these explicit free lists
Dialogue: 0,0:08:07.76,0:08:10.16,Chinese,,0,0,0,,我们称之为「显式空闲列表」
Dialogue: 0,0:08:11.02,0:08:13.86,English,,0,0,0,,So the idea with an explicit free list is that
Dialogue: 0,0:08:11.02,0:08:13.86,Chinese,,0,0,0,,因此，显式空闲列表的想法是
Dialogue: 0,0:08:15.38,0:08:16.50,English,,0,0,0,,We put pointers
Dialogue: 0,0:08:15.38,0:08:16.50,Chinese,,0,0,0,,我们把指针
Dialogue: 0,0:08:18.24,0:08:21.52,English,,0,0,0,,We put the pointers that implement the doubly linked list
Dialogue: 0,0:08:18.24,0:08:21.52,Chinese,,0,0,0,,我们用指针实现了双链表
Dialogue: 0,0:08:22.20,0:08:25.38,English,,0,0,0,,Inside the the body of the of a free block
Dialogue: 0,0:08:22.20,0:08:25.38,Chinese,,0,0,0,,把指针指向一个空闲块的里面
Dialogue: 0,0:08:25.64,0:08:28.04,English,,0,0,0,,Say where the old payload used to go so
Dialogue: 0,0:08:25.64,0:08:28.04,Chinese,,0,0,0,,说旧的有效载荷曾经去过的地方
Dialogue: 0,0:08:28.58,0:08:31.94,English,,0,0,0,,Allocated blocks look exactly the same as they did before right
Dialogue: 0,0:08:28.58,0:08:31.94,Chinese,,0,0,0,,分配的块看起来与它们之前完全相同
Dialogue: 0,0:08:31.94,0:08:35.36,English,,0,0,0,,There's a header, optional boundary tag footer
Dialogue: 0,0:08:31.94,0:08:35.36,Chinese,,0,0,0,,有一个头部标记，可选的边界标记脚部
Dialogue: 0,0:08:35.92,0:08:38.14,English,,0,0,0,,And then this the payload and any padding
Dialogue: 0,0:08:35.92,0:08:38.14,Chinese,,0,0,0,,然后是有效载荷和任何填充
Dialogue: 0,0:08:39.70,0:08:50.56,English,,0,0,0,,Free blocks though the allocator is not allowed to touch anything in the inside the payload of an allocated block
Dialogue: 0,0:08:39.70,0:08:50.56,Chinese,,0,0,0,,通过分配器的空闲块不允许触摸分配块的有效负载内部的任何内容
Dialogue: 0,0:08:50.94,0:08:53.20,English,,0,0,0,,But free blocks are free right nobody's using them
Dialogue: 0,0:08:50.94,0:08:53.20,Chinese,,0,0,0,,但空闲区块是空闲的，没有人使用它们
Dialogue: 0,0:08:53.62,0:08:55.84,English,,0,0,0,,And so the allocator can put the
Dialogue: 0,0:08:53.62,0:08:55.84,Chinese,,0,0,0,,所以分配器可以让
Dialogue: 0,0:08:57.42,0:09:02.14,English,,0,0,0,,The pointers that implement the data structure inside the what was the old payload
Dialogue: 0,0:08:57.42,0:09:02.14,Chinese,,0,0,0,,实现数据结构的指针指向曾今是负载的地方
Dialogue: 0,0:09:04.12,0:09:09.48,English,,0,0,0,,So logically this is just a simple doubly linked list,okay that you've all seen before
Dialogue: 0,0:09:04.12,0:09:09.48,Chinese,,0,0,0,,所以逻辑上这只是一个简单的双向链表，你以前都见过
Dialogue: 0,0:09:11.02,0:09:15.62,English,,0,0,0,,But actually these things can be anywhere in memory right
Dialogue: 0,0:09:11.02,0:09:15.62,Chinese,,0,0,0,,但实际上这些东西可以在内存中的任何地方
Dialogue: 0,0:09:15.62,0:09:17.60,English,,0,0,0,,And so you know here we have...
Dialogue: 0,0:09:15.62,0:09:17.60,Chinese,,0,0,0,,所以在这里
Dialogue: 0,0:09:18.82,0:09:21.16,English,,0,0,0,,We have a block of size 6
Dialogue: 0,0:09:18.82,0:09:21.16,Chinese,,0,0,0,,我们有一个大小为 6 的块
Dialogue: 0,0:09:22.00,0:09:25.54,English,,0,0,0,,And it has a 4 word pointer that points to some other link
Dialogue: 0,0:09:22.00,0:09:25.54,Chinese,,0,0,0,,它有一个 4 字指针指向其他链接
Dialogue: 0,0:09:26.00,0:09:28.24,English,,0,0,0,,And it has a backwards pointer that points to
Dialogue: 0,0:09:26.00,0:09:28.24,Chinese,,0,0,0,,它有一个反向指针指向
Dialogue: 0,0:09:28.64,0:09:33.12,English,,0,0,0,,This block which happens to be have a greater memory address than it
Dialogue: 0,0:09:28.64,0:09:33.12,Chinese,,0,0,0,,这个恰好具有比它更大的内存地址的块
Dialogue: 0,0:09:34.92,0:09:37.38,English,,0,0,0,,Okay so just the idea is you can't...
Dialogue: 0,0:09:34.92,0:09:37.38,Chinese,,0,0,0,,好的，只是这个想法是你不能......
Dialogue: 0,0:09:38.34,0:09:42.22,English,,0,0,0,,You know unless you go to great pains to maintain
Dialogue: 0,0:09:38.34,0:09:42.22,Chinese,,0,0,0,,你知道除非你付出巨大的努力来维持
Dialogue: 0,0:09:42.72,0:09:45.64,English,,0,0,0,,This sort of address ordered structure
Dialogue: 0,0:09:42.72,0:09:45.64,Chinese,,0,0,0,,这种地址有序结构
Dialogue: 0,0:09:47.32,0:09:51.68,English,,0,0,0,,These blocks can be sort of scattered anywhere in memory
Dialogue: 0,0:09:47.32,0:09:51.68,Chinese,,0,0,0,,这些块可以分散在内存中的任何位置
Dialogue: 0,0:09:51.78,0:09:57.10,English,,0,0,0,,[student speaking]
Dialogue: 0,0:09:51.78,0:09:57.10,Chinese,,0,0,0,,学生提问
Dialogue: 0,0:09:57.12,0:09:59.12,English,,0,0,0,,Oh yeah so this is after several
Dialogue: 0,0:09:57.12,0:09:59.12,Chinese,,0,0,0,,哦，是的，所以这是几次之后
Dialogue: 0,0:09:59.78,0:10:03.98,English,,0,0,0,,You know just sort of indefinite number of malloc and frees and
Dialogue: 0,0:09:59.78,0:10:03.98,Chinese,,0,0,0,,你知道一些无限数量的 malloc 和 free
Dialogue: 0,0:10:04.84,0:10:05.42,English,,0,0,0,,Yes
Dialogue: 0,0:10:04.84,0:10:05.42,Chinese,,0,0,0,,是
Dialogue: 0,0:10:05.42,0:10:09.64,English,,0,0,0,,[student speaking]
Dialogue: 0,0:10:05.42,0:10:09.64,Chinese,,0,0,0,,学生提问
Dialogue: 0,0:10:09.64,0:10:10.82,English,,0,0,0,,Oh yeah good question
Dialogue: 0,0:10:09.64,0:10:10.82,Chinese,,0,0,0,,哦，是的好问题
Dialogue: 0,0:10:11.32,0:10:15.90,English,,0,0,0,,So the question is what would happen if you free to a block that was in between two free blocks
Dialogue: 0,0:10:11.32,0:10:15.90,Chinese,,0,0,0,,所以问题是如果你释放一个位于两个空闲块之间的块会发生什么
Dialogue: 0,0:10:16.62,0:10:20.62,English,,0,0,0,,And so you have to coalesce it gets a little tricky and I'll show you in a second
Dialogue: 0,0:10:16.62,0:10:20.62,Chinese,,0,0,0,,你必须合并它有点棘手，我会在一秒钟给你看
Dialogue: 0,0:10:21.30,0:10:25.04,English,,0,0,0,,Good now allocating oh yes questions
Dialogue: 0,0:10:21.30,0:10:25.04,Chinese,,0,0,0,,什么问题？
Dialogue: 0,0:10:25.04,0:10:31.62,English,,0,0,0,,[student speaking]
Dialogue: 0,0:10:25.04,0:10:31.62,Chinese,,0,0,0,,学生提问
Dialogue: 0,0:10:31.66,0:10:33.68,English,,0,0,0,,So the question is what happens with locality
Dialogue: 0,0:10:31.66,0:10:33.68,Chinese,,0,0,0,,所以问题是局部会发生什么
Dialogue: 0,0:10:34.38,0:10:37.50,English,,0,0,0,,So you still get block locality
Dialogue: 0,0:10:34.38,0:10:37.50,Chinese,,0,0,0,,所以你仍然得到块局部性
Dialogue: 0,0:10:38.70,0:10:40.42,English,,0,0,0,,You know use blocks are still contiguous
Dialogue: 0,0:10:38.70,0:10:40.42,Chinese,,0,0,0,,你知道使用块仍然是连续的
Dialogue: 0,0:10:43.26,0:10:50.82,English,,0,0,0,,But if you're scanning sort of a set of allocated blocks it would be better
Dialogue: 0,0:10:43.26,0:10:50.82,Chinese,,0,0,0,,但如果你正在扫描一组已分配的块，那就更好了
Dialogue: 0,0:10:50.82,0:10:54.40,English,,0,0,0,,If you could keep them all contiguous right
Dialogue: 0,0:10:50.82,0:10:54.40,Chinese,,0,0,0,,如果你能保持它们所有的连续
Dialogue: 0,0:10:55.38,0:11:00.14,English,,0,0,0,,And so there's a you know that's a trade-off I don't
Dialogue: 0,0:10:55.38,0:11:00.14,Chinese,,0,0,0,,这里有一些权衡
Dialogue: 0,0:11:03.06,0:11:05.66,English,,0,0,0,,It gets difficult if you think how can you maintain
Dialogue: 0,0:11:03.06,0:11:05.66,Chinese,,0,0,0,,如果你考虑你能维持下去会很困难
Dialogue: 0,0:11:05.66,0:11:10.12,English,,0,0,0,,So you don't really care about the locality of free blocks right, you're just walking a linked list
Dialogue: 0,0:11:05.66,0:11:10.12,Chinese,,0,0,0,,所以你真的不关心空闲块的位置，你只是遍历一个链表
Dialogue: 0,0:11:12.56,0:11:14.34,English,,0,0,0,,Well no I shouldn't say that that's
Dialogue: 0,0:11:12.56,0:11:14.34,Chinese,,0,0,0,,好吧，不，我不应该这样说
Dialogue: 0,0:11:14.46,0:11:18.16,English,,0,0,0,,If you're walking that list,if you hit one free block
Dialogue: 0,0:11:14.46,0:11:18.16,Chinese,,0,0,0,,如果你正在走这个列表，如果你命中来一个空闲块
Dialogue: 0,0:11:18.72,0:11:22.26,English,,0,0,0,,It would bring in a whole page so it'd be better
Dialogue: 0,0:11:18.72,0:11:22.26,Chinese,,0,0,0,,它会带来一整页，所以它会更好
Dialogue: 0,0:11:22.94,0:11:27.96,English,,0,0,0,,If you were walking, if the list you know if as much of that list was contained within that page
Dialogue: 0,0:11:22.94,0:11:27.96,Chinese,,0,0,0,,如果你正在遍历列表中，你知道该页中是否包含尽可能多的列表
Dialogue: 0,0:11:27.96,0:11:30.48,English,,0,0,0,,So even that's, so you would benefit
Dialogue: 0,0:11:27.96,0:11:30.48,Chinese,,0,0,0,,所以即便如此，你也会受益
Dialogue: 0,0:11:31.44,0:11:38.08,English,,0,0,0,,You could benefit eat with both allocated blocks because applications would be using them and with free blocks
Dialogue: 0,0:11:31.44,0:11:38.08,Chinese,,0,0,0,,你可以使用两个分配的块受益，因为应用程序将使用它们和空闲块
Dialogue: 0,0:11:38.08,0:11:41.32,English,,0,0,0,,Because the allocator would be walking that free list
Dialogue: 0,0:11:38.08,0:11:41.32,Chinese,,0,0,0,,因为分配器会走那个空闲列表
Dialogue: 0,0:11:42.44,0:11:42.90,English,,0,0,0,,Question
Dialogue: 0,0:11:42.44,0:11:42.90,Chinese,,0,0,0,,问题？
Dialogue: 0,0:11:42.94,0:12:08.90,English,,0,0,0,,[student speaking]
Dialogue: 0,0:11:42.94,0:12:08.90,Chinese,,0,0,0,,学生提问
Dialogue: 0,0:12:08.90,0:12:09.84,English,,0,0,0,,That's a really good question
Dialogue: 0,0:12:08.90,0:12:09.84,Chinese,,0,0,0,,这是一个非常好的问题
Dialogue: 0,0:12:09.84,0:12:15.38,English,,0,0,0,,So the question is could would it be possible for an application to give hints to the allocator
Dialogue: 0,0:12:09.84,0:12:15.38,Chinese,,0,0,0,,问题是应用程序是否有可能给分配器提供一些提示
Dialogue: 0,0:12:15.80,0:12:20.18,English,,0,0,0,,That would improve the allocators performance or memory utilization
Dialogue: 0,0:12:15.80,0:12:20.18,Chinese,,0,0,0,,这会增加分配器性能或内存利用率
Dialogue: 0,0:12:21.70,0:12:23.94,English,,0,0,0,,The the answer you absolutely could
Dialogue: 0,0:12:21.70,0:12:23.94,Chinese,,0,0,0,,答案你绝对可以
Dialogue: 0,0:12:25.98,0:12:29.46,English,,0,0,0,,But it's if you did it wouldn't be a general-purpose allocator
Dialogue: 0,0:12:25.98,0:12:29.46,Chinese,,0,0,0,,但是，如果你这样做，它将不是一个通用的分配器
Dialogue: 0,0:12:29.52,0:12:32.12,English,,0,0,0,,So like malloc is a general-purpose allocator
Dialogue: 0,0:12:29.52,0:12:32.12,Chinese,,0,0,0,,因此 malloc 是一个通用的分配器
Dialogue: 0,0:12:32.80,0:12:35.44,English,,0,0,0,,So and it provides no there's no option
Dialogue: 0,0:12:32.80,0:12:35.44,Chinese,,0,0,0,,所以它并没有提供任何选择
Dialogue: 0,0:12:35.44,0:12:39.00,English,,0,0,0,,It doesn't provide any arguments in its interface for passing that information in
Dialogue: 0,0:12:35.44,0:12:39.00,Chinese,,0,0,0,,它在其接口中不提供任何用于传递该信息的参数
Dialogue: 0,0:12:39.46,0:12:45.54,English,,0,0,0,,But it absolutely if it had some knowledge about the future behavior of a program that could benefit
Dialogue: 0,0:12:39.46,0:12:45.54,Chinese,,0,0,0,,但它如果对某个程序的未来行为有一定的了解，它可以从中受益
Dialogue: 0,0:12:45.72,0:12:50.46,English,,0,0,0,,Right so especially I consider you always have this decision when you place an allocated block
Dialogue: 0,0:12:45.72,0:12:50.46,Chinese,,0,0,0,,对，所以特别是我认为当你放置一个已分配的块时，你总是需要决定
Dialogue: 0,0:12:50.80,0:12:52.24,English,,0,0,0,,Whether to split that block or not
Dialogue: 0,0:12:50.80,0:12:52.24,Chinese,,0,0,0,,是否拆分该块
Dialogue: 0,0:12:53.44,0:12:55.42,English,,0,0,0,,Well if you knew that you were going to get a request
Dialogue: 0,0:12:53.44,0:12:55.42,Chinese,,0,0,0,,如果你知道你会得到一个请求
Dialogue: 0,0:12:57.04,0:13:00.95,English,,0,0,0,,You know if you split that block and you knew that you were going to get requests
Dialogue: 0,0:12:57.04,0:13:00.95,Chinese,,0,0,0,,你知道如果你拆分那块，你知道你会在之后首先得到原始块的大小的请求
Dialogue: 0,0:13:01.44,0:13:05.56,English,,0,0,0,,Coming in the future first for sizes of the original block then you wouldn't want to split it
Dialogue: 0,0:13:01.44,0:13:05.56,Chinese,,0,0,0,,你就不会想拆分它
Dialogue: 0,0:13:06.20,0:13:10.24,English,,0,0,0,,Because you would just keep it unsplit and then
Dialogue: 0,0:13:06.20,0:13:10.24,Chinese,,0,0,0,,你就会保持它不分裂
Dialogue: 0,0:13:11.70,0:13:15.76,English,,0,0,0,,When you freed it then you'd have a block that would be the right size for that future request
Dialogue: 0,0:13:11.70,0:13:15.76,Chinese,,0,0,0,,当你释放它时，你将拥有一个适合未来请求的块
Dialogue: 0,0:13:16.46,0:13:20.54,English,,0,0,0,,And so it's you can absolutely benefit from that
Dialogue: 0,0:13:16.46,0:13:20.54,Chinese,,0,0,0,,所以你绝对可以从中受益
Dialogue: 0,0:13:21.14,0:13:26.42,English,,0,0,0,,And so although if general-purpose allocators there's no provision for that kind of hinting
Dialogue: 0,0:13:21.14,0:13:26.42,Chinese,,0,0,0,,因此，尽管通用分配器不能提供这种暗示
Dialogue: 0,0:13:26.72,0:13:32.14,English,,0,0,0,,But there's nothing to prevent an allocator from doing predictions based on the previous pattern of requests
Dialogue: 0,0:13:26.72,0:13:32.14,Chinese,,0,0,0,,但是没有什么能阻止分配器根据先前的请求模式进行预测
Dialogue: 0,0:13:33.62,0:13:38.08,English,,0,0,0,,You know so if you're getting a pattern of requests it's alternating large block,small block,large box,small block
Dialogue: 0,0:13:33.62,0:13:38.08,Chinese,,0,0,0,,你知道如果你得到一个请求模式 —— 大块，小块，大块，小块交替
Dialogue: 0,0:13:38.12,0:13:43.22,English,,0,0,0,,You could exploit that maybe predict that the next request will be for...
Dialogue: 0,0:13:38.12,0:13:43.22,Chinese,,0,0,0,,你可以利用它可能预测下一个请求将是...
Dialogue: 0,0:13:43.40,0:13:49.22,English,,0,0,0,,You know if the previous request is for a large block the next one might be for a small block and you could
Dialogue: 0,0:13:43.40,0:13:49.22,Chinese,,0,0,0,,如果前一个请求是针对一个大块的，那么下一个请求可能是一个小块
Dialogue: 0,0:13:51.20,0:13:54.12,English,,0,0,0,,That's good question any other questions wizard yes
Dialogue: 0,0:13:51.20,0:13:54.12,Chinese,,0,0,0,,这是一个很好的问题，任何其他问题
Dialogue: 0,0:14:06.74,0:14:07.60,English,,0,0,0,,I don't know
Dialogue: 0,0:14:06.74,0:14:07.60,Chinese,,0,0,0,,我不知道
Dialogue: 0,0:14:07.90,0:14:12.00,English,,0,0,0,,So the question is other intelligent allocators that do that kind of prediction
Dialogue: 0,0:14:07.90,0:14:12.00,Chinese,,0,0,0,,所以问题是进行这种预测的其他智能分配器
Dialogue: 0,0:14:12.42,0:14:16.62,English,,0,0,0,,And if there are I don't know of them,but I wouldn't I wouldn't say no
Dialogue: 0,0:14:12.42,0:14:16.62,Chinese,,0,0,0,,如果有我不知道他们，但我不会说不
Dialogue: 0,0:14:20.30,0:14:20.82,English,,0,0,0,,Yes
Dialogue: 0,0:14:20.30,0:14:20.82,Chinese,,0,0,0,,是
Dialogue: 0,0:14:20.82,0:14:39.14,English,,0,0,0,,[student speaking]
Dialogue: 0,0:14:20.82,0:14:39.14,Chinese,,0,0,0,,学生提问
Dialogue: 0,0:14:39.14,0:14:43.76,English,,0,0,0,,Oh well so the question is what if you ended up with a free block
Dialogue: 0,0:14:39.14,0:14:43.76,Chinese,,0,0,0,,哦，那么问题就是如果你最终得到了一个空闲区块
Dialogue: 0,0:14:44.22,0:14:47.40,English,,0,0,0,,That's a single block surrounded by 2 allocated blocks
Dialogue: 0,0:14:44.22,0:14:47.40,Chinese,,0,0,0,,这是被 2 个已分配块包围块
Dialogue: 0,0:14:48.06,0:14:53.32,English,,0,0,0,,Well in fact I mean that's one of the invariants that a good allocate has to maintain
Dialogue: 0,0:14:48.06,0:14:53.32,Chinese,,0,0,0,,事实上，我的意思是，这是一个好的分配必须保持的不变量之一
Dialogue: 0,0:14:53.78,0:14:56.02,English,,0,0,0,,You should never have 2 contiguous free blocks
Dialogue: 0,0:14:53.78,0:14:56.02,Chinese,,0,0,0,,你永远不应该有  2 个连续的空闲块
Dialogue: 0,0:14:56.78,0:15:00.38,English,,0,0,0,,Right the allocate should always be coalescing as much as it can
Dialogue: 0,0:14:56.78,0:15:00.38,Chinese,,0,0,0,,对分配应始终尽可能合并
Dialogue: 0,0:15:00.90,0:15:02.98,English,,0,0,0,,And if it does that coalescing
Dialogue: 0,0:15:00.90,0:15:02.98,Chinese,,0,0,0,,如果它做到那个合并
Dialogue: 0,0:15:03.34,0:15:09.68,English,,0,0,0,,If it always does that coalescing then there will never be two contiguous free blocks okay
Dialogue: 0,0:15:03.34,0:15:09.68,Chinese,,0,0,0,,如果它总是那样合并那么就永远不会有两个连续的空闲块
Dialogue: 0,0:15:11.64,0:15:12.38,English,,0,0,0,,Yeah it's question
Dialogue: 0,0:15:11.64,0:15:12.38,Chinese,,0,0,0,,是的，问题？
Dialogue: 0,0:15:12.38,0:15:18.08,English,,0,0,0,,[student speaking]
Dialogue: 0,0:15:12.38,0:15:18.08,Chinese,,0,0,0,,学生提问
Dialogue: 0,0:15:18.08,0:15:22.32,English,,0,0,0,,Oh you'll see when it comes into play when we free a block
Dialogue: 0,0:15:18.08,0:15:22.32,Chinese,,0,0,0,,哦，当我们释放一块时，你会看到它会发挥作用
Dialogue: 0,0:15:23.36,0:15:25.22,English,,0,0,0,,Because you have to sort of stitch up
Dialogue: 0,0:15:23.36,0:15:25.22,Chinese,,0,0,0,,因为你必须要缝合
Dialogue: 0,0:15:25.56,0:15:31.86,English,,0,0,0,,When you free a block you have to sort of stitch up the linked list and
Dialogue: 0,0:15:25.56,0:15:31.86,Chinese,,0,0,0,,当你释放一个块时，你必须对链接列表进行拼接
Dialogue: 0,0:15:31.86,0:15:33.84,English,,0,0,0,,So you need both you need both pointers
Dialogue: 0,0:15:31.86,0:15:33.84,Chinese,,0,0,0,,所以你需要两个指针
Dialogue: 0,0:15:34.60,0:15:36.42,English,,0,0,0,,You can do it with singly linked lists
Dialogue: 0,0:15:34.60,0:15:36.42,Chinese,,0,0,0,,你可以使用单链表进行此操作
Dialogue: 0,0:15:36.44,0:15:42.16,English,,0,0,0,,So in your in the k in our book,there's a an allocate that uses a singly linked list
Dialogue: 0,0:15:36.44,0:15:42.16,Chinese,,0,0,0,,所以在我们书中，有一个使用单链表的分配
Dialogue: 0,0:15:42.80,0:15:45.82,English,,0,0,0,,But the disadvantages that free requires a search
Dialogue: 0,0:15:42.80,0:15:45.82,Chinese,,0,0,0,,它的缺点是，调用 free 的时候需要搜索
Dialogue: 0,0:15:46.16,0:15:50.90,English,,0,0,0,,So it requires a search from the beginning of the list to find the previous block
Dialogue: 0,0:15:46.16,0:15:50.90,Chinese,,0,0,0,,所以它需要从列表的开头搜索才能找到前一个块
Dialogue: 0,0:15:55.34,0:15:56.98,English,,0,0,0,,And there are questions these are good yes question
Dialogue: 0,0:15:55.34,0:15:56.98,Chinese,,0,0,0,,有问题这些都是好问题
Dialogue: 0,0:15:57.04,0:16:05.86,English,,0,0,0,,[student speaking]
Dialogue: 0,0:15:57.04,0:16:05.86,Chinese,,0,0,0,,学生提问
Dialogue: 0,0:16:05.88,0:16:07.68,English,,0,0,0,,Okay so the question is for memory utilization
Dialogue: 0,0:16:05.88,0:16:07.68,Chinese,,0,0,0,,好的，问题是内存利用率
Dialogue: 0,0:16:07.68,0:16:11.68,English,,0,0,0,,How does the header and footer count towards memory utilization
Dialogue: 0,0:16:07.68,0:16:11.68,Chinese,,0,0,0,,头部和脚部如何计入内存利用率
Dialogue: 0,0:16:12.96,0:16:17.26,English,,0,0,0,,And so those are overhead  that decrease memory utilization
Dialogue: 0,0:16:12.96,0:16:17.26,Chinese,,0,0,0,,这些开销会降低内存利用率
Dialogue: 0,0:16:17.96,0:16:21.06,English,,0,0,0,,Okay because they're not payload so when we were computing memory utilization
Dialogue: 0,0:16:17.96,0:16:21.06,Chinese,,0,0,0,,因为当我们计算内存利用率时，它们不是有效负载
Dialogue: 0,0:16:21.74,0:16:26.72,English,,0,0,0,,We're doing it by we're using the payload the aggregate payload to
Dialogue: 0,0:16:21.74,0:16:26.72,Chinese,,0,0,0,,我们正在通过使用聚集有效载荷
Dialogue: 0,0:16:27.84,0:16:33.20,English,,0,0,0,,To estimate utilization or to compute our utilization
Dialogue: 0,0:16:27.84,0:16:33.20,Chinese,,0,0,0,,来估算利用率或计算我们的利用率
Dialogue: 0,0:16:33.56,0:16:37.54,English,,0,0,0,,So anything that's not payload sorry is overhead
Dialogue: 0,0:16:33.56,0:16:37.54,Chinese,,0,0,0,,所以任何不是有效载荷的东西都是开销
Dialogue: 0,0:16:37.54,0:16:47.60,English,,0,0,0,,[student speaking]
Dialogue: 0,0:16:37.54,0:16:47.60,Chinese,,0,0,0,,学生提问
Dialogue: 0,0:16:47.60,0:16:51.38,English,,0,0,0,,So we had...if all of payloads were one word and overhead
Dialogue: 0,0:16:47.60,0:16:51.38,Chinese,,0,0,0,,如果所有有效载荷都是一个，开销也是一个字
Dialogue: 0,0:16:51.88,0:16:54.76,English,,0,0,0,,Was one word then there'd be 50%
Dialogue: 0,0:16:51.88,0:16:54.76,Chinese,,0,0,0,,那么利用率就是 50％
Dialogue: 0,0:16:59.30,0:17:09.10,English,,0,0,0,,Yes [student speaking]
Dialogue: 0,0:16:59.30,0:17:09.10,Chinese,,0,0,0,,学生提问
Dialogue: 0,0:17:09.10,0:17:11.76,English,,0,0,0,,Yeah so the question is do you still need a boundary tag if you have
Dialogue: 0,0:17:09.10,0:17:11.76,Chinese,,0,0,0,,是的，问题是你是否还需要一个边界标签
Dialogue: 0,0:17:12.34,0:17:17.24,English,,0,0,0,,These next and previous pointers and the answer is yes absolutely
Dialogue: 0,0:17:12.34,0:17:17.24,Chinese,,0,0,0,,如果有这些指向下一个和前一个指针，答案绝对是肯定的
Dialogue: 0,0:17:17.34,0:17:18.90,English,,0,0,0,,And you'll see in a second why
Dialogue: 0,0:17:17.34,0:17:18.90,Chinese,,0,0,0,,你会马上到原因
Dialogue: 0,0:17:21.06,0:17:21.62,English,,0,0,0,,Yes
Dialogue: 0,0:17:21.06,0:17:21.62,Chinese,,0,0,0,,是
Dialogue: 0,0:17:21.68,0:17:32.52,English,,0,0,0,,[student speaking]
Dialogue: 0,0:17:21.68,0:17:32.52,Chinese,,0,0,0,,学生提问
Dialogue: 0,0:17:32.60,0:17:33.94,English,,0,0,0,,Okay that's a really good question
Dialogue: 0,0:17:32.60,0:17:33.94,Chinese,,0,0,0,,好的，这是一个非常好的问题
Dialogue: 0,0:17:33.94,0:17:37.86,English,,0,0,0,,So you know what do you do if you have next in previous pointers
Dialogue: 0,0:17:33.94,0:17:37.86,Chinese,,0,0,0,,如果你有指向前一个或者后一个的指针，你会怎么做
Dialogue: 0,0:17:38.50,0:17:43.20,English,,0,0,0,,What happened if there's a request for a smaller block
Dialogue: 0,0:17:38.50,0:17:43.20,Chinese,,0,0,0,,如果要求更小的块，会发生什么
Dialogue: 0,0:17:43.88,0:17:48.78,English,,0,0,0,,So the answer is that all of those things the header,the footer,the next and previous pointers
Dialogue: 0,0:17:43.88,0:17:48.78,Chinese,,0,0,0,,所以答案是所有这些东西的头部，脚部，下一个和前一个指针
Dialogue: 0,0:17:49.08,0:17:50.58,English,,0,0,0,,Impose a minimum block size
Dialogue: 0,0:17:49.08,0:17:50.58,Chinese,,0,0,0,,施加最小块大小
Dialogue: 0,0:17:51.65,0:17:58.74,English,,0,0,0,,So if you have a one word header,one word footer,one prev ,one word next
Dialogue: 0,0:17:51.65,0:17:58.74,Chinese,,0,0,0,,因此，如果你有一个字大小头部，一字大小脚部，一字大小下一个、上一个指针
Dialogue: 0,0:17:59.68,0:18:02.62,English,,0,0,0,,Then your minimum block sizes is 4 bytes
Dialogue: 0,0:17:59.68,0:18:02.62,Chinese,,0,0,0,,然后你的最小块大小为 4 个字节
Dialogue: 0,0:18:02.86,0:18:05.60,English,,0,0,0,,And that would be with a zero size payload
Dialogue: 0,0:18:02.86,0:18:05.60,Chinese,,0,0,0,,这将是零大小的有效载荷
Dialogue: 0,0:18:06.64,0:18:10.60,English,,0,0,0,,So you can never allocate a block smaller than your minimum block size
Dialogue: 0,0:18:06.64,0:18:10.60,Chinese,,0,0,0,,因此，你永远不能分配小于最小块大小的块
Dialogue: 0,0:18:10.88,0:18:13.04,English,,0,0,0,,So that's very good very good question
Dialogue: 0,0:18:10.88,0:18:13.04,Chinese,,0,0,0,,所以这是一个非常好的问题
Dialogue: 0,0:18:14.42,0:18:16.62,English,,0,0,0,,So it makes a difference right even though
Dialogue: 0,0:18:14.42,0:18:16.62,Chinese,,0,0,0,,所以尽管如此，它确实有所作为
Dialogue: 0,0:18:18.48,0:18:24.28,English,,0,0,0,,It looks like we're getting these pointers here for free
Dialogue: 0,0:18:18.48,0:18:24.28,Chinese,,0,0,0,,看起来这些指针是用来调用 free
Dialogue: 0,0:18:25.22,0:18:29.08,English,,0,0,0,,But we're not really because of this minimum block size requirement
Dialogue: 0,0:18:25.22,0:18:29.08,Chinese,,0,0,0,,但我们不是，因为这个最小的块大小要求
Dialogue: 0,0:18:29.22,0:18:29.68,English,,0,0,0,,Yes
Dialogue: 0,0:18:29.22,0:18:29.68,Chinese,,0,0,0,,是
Dialogue: 0,0:18:29.68,0:19:08.42,English,,0,0,0,,[student speaking]
Dialogue: 0,0:18:29.68,0:19:08.42,Chinese,,0,0,0,,学生提问
Dialogue: 0,0:19:08.84,0:19:10.02,English,,0,0,0,,Yeah okay so...
Dialogue: 0,0:19:08.84,0:19:10.02,Chinese,,0,0,0,,是的，好吧......
Dialogue: 0,0:19:12.68,0:19:16.40,English,,0,0,0,,The question is can you just get one large block and then split it up
Dialogue: 0,0:19:12.68,0:19:16.40,Chinese,,0,0,0,,问题是你可以得到一个大块然后将其拆分
Dialogue: 0,0:19:16.66,0:19:21.60,English,,0,0,0,,And I guess you're assuming that the request would be 4 equally sized objects
Dialogue: 0,0:19:16.66,0:19:21.60,Chinese,,0,0,0,,而且我猜你假设这个请求是 4 个大小相同的对象
Dialogue: 0,0:19:22.86,0:19:25.02,English,,0,0,0,,And that's a really good strategy actually
Dialogue: 0,0:19:22.86,0:19:25.02,Chinese,,0,0,0,,这实际上是一个非常好的策略
Dialogue: 0,0:19:25.32,0:19:31.70,English,,0,0,0,,So if you think that your workload is going to have
Dialogue: 0,0:19:25.32,0:19:31.70,Chinese,,0,0,0,,因此，如果你认为你的工作量会有所增加
Dialogue: 0,0:19:31.86,0:19:34.08,English,,0,0,0,,No you can't do this in general-purpose allocators
Dialogue: 0,0:19:31.86,0:19:34.08,Chinese,,0,0,0,,不，你不能在通用分配器中这样做
Dialogue: 0,0:19:34.08,0:19:36.02,English,,0,0,0,,But for like a special-purpose allocator
Dialogue: 0,0:19:34.08,0:19:36.02,Chinese,,0,0,0,,但对于像专用分配器一样
Dialogue: 0,0:19:36.02,0:19:39.44,English,,0,0,0,,If you know that you're going to be asking for objects that are all the same size
Dialogue: 0,0:19:36.02,0:19:39.44,Chinese,,0,0,0,,如果你知道你将要求大小相同的块
Dialogue: 0,0:19:39.82,0:19:44.20,English,,0,0,0,,Like compilers for example may maintain abstract syntax trees
Dialogue: 0,0:19:39.82,0:19:44.20,Chinese,,0,0,0,,例如编译器可以维护抽象语法树
Dialogue: 0,0:19:44.60,0:19:48.30,English,,0,0,0,,And and they're allocating nodes dynamically and those nodes are the same size
Dialogue: 0,0:19:44.60,0:19:48.30,Chinese,,0,0,0,,并且他们正在动态分配节点，并且这些节点的大小相同
Dialogue: 0,0:19:49.08,0:19:53.94,English,,0,0,0,,So if you can exploit that by just allocating a large chunk
Dialogue: 0,0:19:49.08,0:19:53.94,Chinese,,0,0,0,,所以如果你可以通过分配一个大块来利用它
Dialogue: 0,0:19:55.52,0:19:58.60,English,,0,0,0,,And then allocating all the objects of that size out of that chunk
Dialogue: 0,0:19:55.52,0:19:58.60,Chinese,,0,0,0,,然后从该块中分配该大小的所有对象
Dialogue: 0,0:19:59.22,0:20:03.30,English,,0,0,0,,It's very efficient,you don't even need pointers or anything all you need is a bit vector
Dialogue: 0,0:19:59.22,0:20:03.30,Chinese,,0,0,0,,这是非常有效的，你甚至不需要指针或任何你需要的东西是有位向量
Dialogue: 0,0:20:03.78,0:20:06.94,English,,0,0,0,,To tell you which chunks are allocated in which chunks are free
Dialogue: 0,0:20:03.78,0:20:06.94,Chinese,,0,0,0,,告诉你哪些块被分配在哪些块是空闲的
Dialogue: 0,0:20:07.40,0:20:10.22,English,,0,0,0,,And then and you also has a side effect you'll get that contiguous
Dialogue: 0,0:20:07.40,0:20:10.22,Chinese,,0,0,0,,然后，你也有一个副作用
Dialogue: 0,0:20:11.54,0:20:15.56,English,,0,0,0,,That contiguous access so if a program access those objects like
Dialogue: 0,0:20:11.54,0:20:15.56,Chinese,,0,0,0,,你会得到连续的访问，所以如果一个程序访问那些对象
Dialogue: 0,0:20:17.28,0:20:20.98,English,,0,0,0,,To be part of a linked list there was something that it was going to traverse
Dialogue: 0,0:20:17.28,0:20:20.98,Chinese,,0,0,0,,要成为链接列表的一部分，它将会遍历某些内容
Dialogue: 0,0:20:21.46,0:20:26.84,English,,0,0,0,,You could allocate those in order and contiguously
Dialogue: 0,0:20:21.46,0:20:26.84,Chinese,,0,0,0,,你可以按顺序和连续分配这些
Dialogue: 0,0:20:27.64,0:20:31.40,English,,0,0,0,,Now with a general-purpose allocator where you don't really know
Dialogue: 0,0:20:27.64,0:20:31.40,Chinese,,0,0,0,,现在有一个通用的分配器，你真的不知道
Dialogue: 0,0:20:31.76,0:20:33.54,English,,0,0,0,,What's going to be requested that
Dialogue: 0,0:20:31.76,0:20:33.54,Chinese,,0,0,0,,有什么样子的请求
Dialogue: 0,0:20:34.76,0:20:42.06,English,,0,0,0,,[student speaking]
Dialogue: 0,0:20:34.76,0:20:42.06,Chinese,,0,0,0,,学生提问
Dialogue: 0,0:20:42.38,0:20:46.96,English,,0,0,0,,Absolutely you could do that,you can make general assumptions about the  sort of behavior of your programs
Dialogue: 0,0:20:42.38,0:20:46.96,Chinese,,0,0,0,,绝对可以这样做，你可以对程序的行为进行一般性的假设
Dialogue: 0,0:20:46.96,0:20:52.74,English,,0,0,0,,And you know you could run traces or like in the case of malloc lab you could look at the traces
Dialogue: 0,0:20:46.96,0:20:52.74,Chinese,,0,0,0,,并且你知道你可以在 malloc 实验室的情况下运行跟踪或类似的东西，你可以看看记录
Dialogue: 0,0:20:54.26,0:20:56.44,English,,0,0,0,,But that's no that's a really good thing you know you can't
Dialogue: 0,0:20:54.26,0:20:56.44,Chinese,,0,0,0,,但这是很好的事情
Dialogue: 0,0:20:57.42,0:21:02.36,English,,0,0,0,,You know you can't just like do if statements to say well
Dialogue: 0,0:20:57.42,0:21:02.36,Chinese,,0,0,0,,你知道你不能只是喜欢描述得好
Dialogue: 0,0:21:02.36,0:21:06.70,English,,0,0,0,,If the size is 42 and then the next size is 24 then I know it's this trace
Dialogue: 0,0:21:02.36,0:21:06.70,Chinese,,0,0,0,,如果大小是 42 然后下一个大小是 24，那么我知道这是一个记录
Dialogue: 0,0:21:08.02,0:21:11.00,English,,0,0,0,,But you can look at a trace and say whom there's an interesting pattern here
Dialogue: 0,0:21:08.02,0:21:11.00,Chinese,,0,0,0,,但是你可以看一下这个记录，并说出这里有一个有趣的模式
Dialogue: 0,0:21:11.78,0:21:15.90,English,,0,0,0,,I'm going to account for that pattern I'm going to optimize for that pattern
Dialogue: 0,0:21:11.78,0:21:15.90,Chinese,,0,0,0,,我将考虑针对该模式进行优化
Dialogue: 0,0:21:16.02,0:21:20.02,English,,0,0,0,,And that would just and that's perfectly valid that's just like taking advantage of
Dialogue: 0,0:21:16.02,0:21:20.02,Chinese,,0,0,0,,这就是公正和完全有效的，就像利用它一样
Dialogue: 0,0:21:20.30,0:21:22.98,English,,0,0,0,,Your workload right that's what we do in systems all the time
Dialogue: 0,0:21:20.30,0:21:22.98,Chinese,,0,0,0,,你的工作是我们在系统中始终做的事情
Dialogue: 0,0:21:23.78,0:21:24.22,English,,0,0,0,,Yes
Dialogue: 0,0:21:23.78,0:21:24.22,Chinese,,0,0,0,,是
Dialogue: 0,0:21:26.42,0:21:43.22,English,,0,0,0,,[student speaking]
Dialogue: 0,0:21:26.42,0:21:43.22,Chinese,,0,0,0,,学生提问
Dialogue: 0,0:21:43.34,0:21:45.50,English,,0,0,0,,Oh oh so the question is why can't we...
Dialogue: 0,0:21:43.34,0:21:45.50,Chinese,,0,0,0,,哦，哦，问题是为什么我们不能......
Dialogue: 0,0:21:46.26,0:21:51.22,English,,0,0,0,,Why can't we sort of have separate areas of the heap for the pointers  and the payloads all right
Dialogue: 0,0:21:46.26,0:21:51.22,Chinese,,0,0,0,,为什么我们不能为指针和有效负载分别拥有堆的独立区域
Dialogue: 0,0:21:51.98,0:22:00.86,English,,0,0,0,,[student speaking]
Dialogue: 0,0:21:51.98,0:22:00.86,Chinese,,0,0,0,,学生提问
Dialogue: 0,0:22:00.86,0:22:04.90,English,,0,0,0,,Oh so the question is why not,why can't we split up payloads
Dialogue: 0,0:22:00.86,0:22:04.90,Chinese,,0,0,0,,哦，好的，问题是为什么我们不能拆分有效载荷
Dialogue: 0,0:22:06.18,0:22:08.00,English,,0,0,0,,And link them together with pointers
Dialogue: 0,0:22:06.18,0:22:08.00,Chinese,,0,0,0,,并用指针将它们链接在一起
Dialogue: 0,0:22:09.00,0:22:12.64,English,,0,0,0,,The answer is that the applications expecting a contiguous block
Dialogue: 0,0:22:09.00,0:22:12.64,Chinese,,0,0,0,,答案是应用程序期望一个连续的块
Dialogue: 0,0:22:13.18,0:22:16.40,English,,0,0,0,,You can't allocate or can't put anything in the payload
Dialogue: 0,0:22:13.18,0:22:16.40,Chinese,,0,0,0,,你无法分配或无法在有效负载中放置任何内容
Dialogue: 0,0:22:17.20,0:22:23.60,English,,0,0,0,,Right all it's allowed to do is return a contiguous block of the size of the application requested
Dialogue: 0,0:22:17.20,0:22:23.60,Chinese,,0,0,0,,所允许做的就是返回一个与所请求的应用程序大小相连的块
Dialogue: 0,0:22:24.36,0:22:27.55,English,,0,0,0,,And app once it does that it can't touch it okay
Dialogue: 0,0:22:24.36,0:22:27.55,Chinese,,0,0,0,,应用程序一旦它这样做它不能触摸它
Dialogue: 0,0:22:28.48,0:22:29.58,English,,0,0,0,,All right good good
Dialogue: 0,0:22:28.48,0:22:29.58,Chinese,,0,0,0,,好的好
Dialogue: 0,0:22:32.86,0:22:35.28,English,,0,0,0,,All right so let's look at how we'd allocate and free
Dialogue: 0,0:22:32.86,0:22:35.28,Chinese,,0,0,0,,好的，让我们来看看我们如何分配和释放
Dialogue: 0,0:22:35.48,0:22:41.02,English,,0,0,0,,Once if we have this explicit list how we would allocate and free blocks
Dialogue: 0,0:22:35.48,0:22:41.02,Chinese,,0,0,0,,如果我们有这个显式列表，我们将如何分配和释放块
Dialogue: 0,0:22:41.64,0:22:43.96,English,,0,0,0,,So allocating is pretty simple
Dialogue: 0,0:22:41.64,0:22:43.96,Chinese,,0,0,0,,所以分配非常简单
Dialogue: 0,0:22:45.44,0:22:49.64,English,,0,0,0,,So here's our sort of a graphic of a free list
Dialogue: 0,0:22:45.44,0:22:49.64,Chinese,,0,0,0,,这里是我们的空闲列表图形
Dialogue: 0,0:22:50.62,0:22:54.02,English,,0,0,0,,So we have 4 word pointers and backward pointers
Dialogue: 0,0:22:50.62,0:22:54.02,Chinese,,0,0,0,,所以我们有 4 字大小得指针和后向指针
Dialogue: 0,0:22:54.92,0:22:58.06,English,,0,0,0,,And the idea is we want to allocate out of this middle block
Dialogue: 0,0:22:54.92,0:22:58.06,Chinese,,0,0,0,,我们想要分配出这个中间块
Dialogue: 0,0:23:01.06,0:23:01.76,English,,0,0,0,,So
Dialogue: 0,0:23:01.06,0:23:01.76,Chinese,,0,0,0,,所以
Dialogue: 0,0:23:03.20,0:23:05.84,English,,0,0,0,,We allocate the block of the size that we need
Dialogue: 0,0:23:03.20,0:23:05.84,Chinese,,0,0,0,,我们分配了我们需要的大小的块
Dialogue: 0,0:23:08.38,0:23:12.76,English,,0,0,0,,And then we just update the forward and back pointers of the previous and next blocks
Dialogue: 0,0:23:08.38,0:23:12.76,Chinese,,0,0,0,,然后我们只更新前一个和下一个块的前向和后向指针
Dialogue: 0,0:23:14.72,0:23:16.28,English,,0,0,0,,To point to this new free block
Dialogue: 0,0:23:14.72,0:23:16.28,Chinese,,0,0,0,,指向这个新的空闲区块
Dialogue: 0,0:23:18.62,0:23:25.18,English,,0,0,0,,Okay so that's pretty simple we're just updating 6 pointers
Dialogue: 0,0:23:18.62,0:23:25.18,Chinese,,0,0,0,,好的，这很简单，我们只是更新 6 个指针
Dialogue: 0,0:23:29.38,0:23:32.80,English,,0,0,0,,Okay now it gets trickier when we have to free because
Dialogue: 0,0:23:29.38,0:23:32.80,Chinese,,0,0,0,,当我们释放得时候，事情变得更加棘手
Dialogue: 0,0:23:33.72,0:23:35.30,English,,0,0,0,,Because we require coalescing
Dialogue: 0,0:23:33.72,0:23:35.30,Chinese,,0,0,0,,因为我们需要合并
Dialogue: 0,0:23:37.28,0:23:38.40,English,,0,0,0,,So when you free a block
Dialogue: 0,0:23:37.28,0:23:38.40,Chinese,,0,0,0,,所以当你释放一块时
Dialogue: 0,0:23:39.10,0:23:41.04,English,,0,0,0,,That's that was previously allocated
Dialogue: 0,0:23:39.10,0:23:41.04,Chinese,,0,0,0,,那是之前分配的
Dialogue: 0,0:23:41.80,0:23:45.24,English,,0,0,0,,The question is what do you do with that free block right it wasn't in the free list
Dialogue: 0,0:23:41.80,0:23:45.24,Chinese,,0,0,0,,问题是你如何处理这个空闲区块，它不在空闲列表中
Dialogue: 0,0:23:45.76,0:23:47.12,English,,0,0,0,,Because it was an allocated block
Dialogue: 0,0:23:45.76,0:23:47.12,Chinese,,0,0,0,,因为它是一个已分配的块
Dialogue: 0,0:23:48.12,0:23:50.10,English,,0,0,0,,So now that you've freed the block where do you put it
Dialogue: 0,0:23:48.12,0:23:50.10,Chinese,,0,0,0,,所以现在你已经释放了阻止你把它放在哪里
Dialogue: 0,0:23:50.78,0:23:51.98,English,,0,0,0,,Which you've got to put it somewhere
Dialogue: 0,0:23:50.78,0:23:51.98,Chinese,,0,0,0,,你必须把它放在某个地方
Dialogue: 0,0:23:52.94,0:23:56.00,English,,0,0,0,,So that the simplest thing is this lifo policy
Dialogue: 0,0:23:52.94,0:23:56.00,Chinese,,0,0,0,,所以最简单的事就是这个「LIFO 政策」
Dialogue: 0,0:23:56.18,0:23:59.42,English,,0,0,0,,So the simplest thing is just put it at the beginning of the list
Dialogue: 0,0:23:56.18,0:23:59.42,Chinese,,0,0,0,,所以最简单的事就是把它放在列表的开头
Dialogue: 0,0:24:00.30,0:24:04.20,English,,0,0,0,,So the last block freed is the first block allocated if it fits
Dialogue: 0,0:24:00.30,0:24:04.20,Chinese,,0,0,0,,因此，释放的最后一个块是分配的第一个块（如果它适合）
Dialogue: 0,0:24:04.86,0:24:06.24,English,,0,0,0,,Okay so that's so-called LIFO
Dialogue: 0,0:24:04.86,0:24:06.24,Chinese,,0,0,0,,那就是所谓的 LIFO
Dialogue: 0,0:24:07.72,0:24:10.14,English,,0,0,0,,Now this is simple
Dialogue: 0,0:24:07.72,0:24:10.14,Chinese,,0,0,0,,现在这很简单
Dialogue: 0,0:24:10.14,0:24:13.46,English,,0,0,0,,Because you're always doing the same thing you're just putting the block at the beginning the list
Dialogue: 0,0:24:10.14,0:24:13.46,Chinese,,0,0,0,,因为你总是在做同样的事情，你只是将块放在列表的开头
Dialogue: 0,0:24:14.14,0:24:17.06,English,,0,0,0,,And it's constant time you're just updating a few pointers
Dialogue: 0,0:24:14.14,0:24:17.06,Chinese,,0,0,0,,而且你只需要更新几个指针就可以了
Dialogue: 0,0:24:18.46,0:24:25.38,English,,0,0,0,,Okay but the studies suggest that the fragmentation can be worse than the alternative technique
Dialogue: 0,0:24:18.46,0:24:25.38,Chinese,,0,0,0,,好的，但研究表明碎片可能比替代技术更糟糕
Dialogue: 0,0:24:26.00,0:24:28.56,English,,0,0,0,,Which is to keep the blocks ordered by address
Dialogue: 0,0:24:26.00,0:24:28.56,Chinese,,0,0,0,,这是保持按地址排序的块
Dialogue: 0,0:24:29.66,0:24:36.76,English,,0,0,0,,Okay so why not if you choose this address ordered policy when you when you free an allocated block
Dialogue: 0,0:24:29.66,0:24:36.76,Chinese,,0,0,0,,好的，那么为什么不在你释放分配的块时选择这个地址排序策略
Dialogue: 0,0:24:38.60,0:24:42.92,English,,0,0,0,,You're going to somehow figure out,you're going to somehow place that block in the list
Dialogue: 0,0:24:38.60,0:24:42.92,Chinese,,0,0,0,,你会以某种方式将该块放在列表中
Dialogue: 0,0:24:43.98,0:24:46.58,English,,0,0,0,,So that the previous block begins at a smaller address
Dialogue: 0,0:24:43.98,0:24:46.58,Chinese,,0,0,0,,这样前一个块就从一个较小的地址开始
Dialogue: 0,0:24:46.78,0:24:48.84,English,,0,0,0,,And the next block begins at a larger address
Dialogue: 0,0:24:46.78,0:24:48.84,Chinese,,0,0,0,,下一个块从更大的地址开始
Dialogue: 0,0:24:49.98,0:24:52.20,English,,0,0,0,,Right so this generally involves some kind of search
Dialogue: 0,0:24:49.98,0:24:52.20,Chinese,,0,0,0,,所以这通常涉及某种搜索
Dialogue: 0,0:24:52.48,0:24:55.62,English,,0,0,0,,You're just given this allocated block
Dialogue: 0,0:24:52.48,0:24:55.62,Chinese,,0,0,0,,你只是给了这个分配块
Dialogue: 0,0:24:56.32,0:24:58.38,English,,0,0,0,,And then somehow you've got and you know it's address
Dialogue: 0,0:24:56.32,0:24:58.38,Chinese,,0,0,0,,然后以某种方式你得到了它的地址
Dialogue: 0,0:24:58.64,0:25:01.50,English,,0,0,0,,And so now you've got to somehow search the free list
Dialogue: 0,0:24:58.64,0:25:01.50,Chinese,,0,0,0,,所以现在你必须以某种方式搜索空闲列表
Dialogue: 0,0:25:02.16,0:25:05.70,English,,0,0,0,,To find the you know the proper place to insert it
Dialogue: 0,0:25:02.16,0:25:05.70,Chinese,,0,0,0,,找到插入它的适当位置
Dialogue: 0,0:25:06.60,0:25:08.84,English,,0,0,0,,Now I suppose you could do better if you had some kind of...
Dialogue: 0,0:25:06.60,0:25:08.84,Chinese,,0,0,0,,现在我想如果你有某种方法你可以做得更好
Dialogue: 0,0:25:09.40,0:25:14.22,English,,0,0,0,,So if you could speed up that search with some kind of  balance tree that would be one option
Dialogue: 0,0:25:09.40,0:25:14.22,Chinese,,0,0,0,,因此，如果你可以使用某种平衡树加速搜索，这将是一种选择
Dialogue: 0,0:25:15.00,0:25:19.94,English,,0,0,0,,Right but then the problem we always run into with balance trees and
Dialogue: 0,0:25:15.00,0:25:19.94,Chinese,,0,0,0,,但后来问题我们总是遇到平衡树和
Dialogue: 0,0:25:20.32,0:25:22.34,English,,0,0,0,,Usually one student...
Dialogue: 0,0:25:20.32,0:25:22.34,Chinese,,0,0,0,,通常一个学生......
Dialogue: 0,0:25:22.48,0:25:26.96,English,,0,0,0,,Somebody always tries to implement malloc with some kind of balance tree red-black tree or something
Dialogue: 0,0:25:22.48,0:25:26.96,Chinese,,0,0,0,,有人总是试图用某种平衡树红黑树或其他东西来实现 malloc
Dialogue: 0,0:25:27.60,0:25:29.90,English,,0,0,0,,And it seems like a really good idea
Dialogue: 0,0:25:27.60,0:25:29.90,Chinese,,0,0,0,,这似乎是一个非常好的主意
Dialogue: 0,0:25:30.64,0:25:39.06,English,,0,0,0,,But you have to realize that you're competing with other techniques specifically segregated lists
Dialogue: 0,0:25:30.64,0:25:39.06,Chinese,,0,0,0,,但是你必须意识到你正在与其他技术竞争，特别是隔离列表
Dialogue: 0,0:25:39.74,0:25:43.52,English,,0,0,0,,That are very fast,they have very small constant factors
Dialogue: 0,0:25:39.74,0:25:43.52,Chinese,,0,0,0,,这非常快，它们具有非常小的常数因子
Dialogue: 0,0:25:44.16,0:25:47.78,English,,0,0,0,,And there's even though ordered lists are I think
Dialogue: 0,0:25:44.16,0:25:47.78,Chinese,,0,0,0,,我认为即使有序列表也是如此
Dialogue: 0,0:25:48.52,0:25:54.00,English,,0,0,0,,It's usually nlog(n) to update an order tree a binary ordered tree
Dialogue: 0,0:25:48.52,0:25:54.00,Chinese,,0,0,0,,通常使用 nlog(n) 更新二叉有序树
Dialogue: 0,0:25:54.46,0:25:56.84,English,,0,0,0,,The constant factors can be quite large
Dialogue: 0,0:25:54.46,0:25:56.84,Chinese,,0,0,0,,常数因素可能非常大
Dialogue: 0,0:25:56.84,0:26:01.46,English,,0,0,0,,And so usually get nailed up with the constant factors of maintaining the tree
Dialogue: 0,0:25:56.84,0:26:01.46,Chinese,,0,0,0,,因此通常会坚持使用维护树的常数因素
Dialogue: 0,0:26:03.08,0:26:06.54,English,,0,0,0,,And you don't get help that the search time is log(n)
Dialogue: 0,0:26:03.08,0:26:06.54,Chinese,,0,0,0,,你没有得到搜索时间为 log(n) 的帮助
Dialogue: 0,0:26:07.06,0:26:08.82,English,,0,0,0,,But as we'll see with segregated lists
Dialogue: 0,0:26:07.06,0:26:08.82,Chinese,,0,0,0,,但正如我们将看到的隔离列表
Dialogue: 0,0:26:10.76,0:26:17.32,English,,0,0,0,,In the limit as the number of different size classes increases
Dialogue: 0,0:26:10.76,0:26:17.32,Chinese,,0,0,0,,在限制中随着不同大小类的数量增加
Dialogue: 0,0:26:17.80,0:26:20.16,English,,0,0,0,,The search time approaches constant time
Dialogue: 0,0:26:17.80,0:26:20.16,Chinese,,0,0,0,,搜索时间接近恒定时间
Dialogue: 0,0:26:20.48,0:26:24.88,English,,0,0,0,,And if you have size classes that cover ranges of powers of two
Dialogue: 0,0:26:20.48,0:26:24.88,Chinese,,0,0,0,,如果你有包含不同范围的大小
Dialogue: 0,0:26:25.12,0:26:27.44,English,,0,0,0,,Then the search time reduces to log time anyway
Dialogue: 0,0:26:25.12,0:26:27.44,Chinese,,0,0,0,,然后搜索时间减少到「logn」时间
Dialogue: 0,0:26:28.20,0:26:33.18,English,,0,0,0,,Because the size of each classes are now logarithmic the log
Dialogue: 0,0:26:28.20,0:26:33.18,Chinese,,0,0,0,,因为每个大小得类现在都是对数的
Dialogue: 0,0:26:35.38,0:26:37.52,English,,0,0,0,,So you know I would suggest on
Dialogue: 0,0:26:35.38,0:26:37.52,Chinese,,0,0,0,,所以你知道我会建议
Dialogue: 0,0:26:39.62,0:26:42.90,English,,0,0,0,,You know just doing the simple thing usually whenever you're dealt with
Dialogue: 0,0:26:39.62,0:26:42.90,Chinese,,0,0,0,,通常当你处理像 malloc 这样得大型得空间设计得时候
Dialogue: 0,0:26:43.34,0:26:47.68,English,,0,0,0,,Sort of large design space like malloc it's you're better off doing the simple thing
Dialogue: 0,0:26:43.34,0:26:47.68,Chinese,,0,0,0,,你最好只做一些简单的事情
Dialogue: 0,0:26:48.80,0:26:52.86,English,,0,0,0,,And then optimizing only when you see that there's that you need to optimize
Dialogue: 0,0:26:48.80,0:26:52.86,Chinese,,0,0,0,,然后只有当你发现需要优化时才进行优化
Dialogue: 0,0:26:54.00,0:27:00.38,English,,0,0,0,,Okay so remember last time we talked about this trick to eliminate the boundary tag footer and allocated blocks
Dialogue: 0,0:26:54.00,0:27:00.38,Chinese,,0,0,0,,好的，所以记得上次我们谈到这个技巧来消除边界标签脚部和分配块
Dialogue: 0,0:27:01.62,0:27:04.18,English,,0,0,0,,That's an example of an optimization you should defer
Dialogue: 0,0:27:01.62,0:27:04.18,Chinese,,0,0,0,,这是你应该推迟的优化的一个例子
Dialogue: 0,0:27:05.16,0:27:12.24,English,,0,0,0,,So that wait you know wait get, do the simple thing and then try to improve incrementally by
Dialogue: 0,0:27:05.16,0:27:12.24,Chinese,,0,0,0,,做一些简单的事情，然后尝试逐步改进
Dialogue: 0,0:27:12.80,0:27:18.04,English,,0,0,0,,By you know this optimization or another optimization
Dialogue: 0,0:27:12.80,0:27:18.04,Chinese,,0,0,0,,通过你了解此优化或其他优化
Dialogue: 0,0:27:18.66,0:27:25.38,English,,0,0,0,,So there's this phenomena of a lot of programmers make the mistake of what we call premature optimization
Dialogue: 0,0:27:18.66,0:27:25.38,Chinese,,0,0,0,,所以很多程序员都会犯这种现象，我们称之为过早优化
Dialogue: 0,0:27:25.38,0:27:28.36,English,,0,0,0,,So try to think of all the fancy things they can do
Dialogue: 0,0:27:25.38,0:27:28.36,Chinese,,0,0,0,,所以试着想想他们能做的所有奇特的事情
Dialogue: 0,0:27:28.78,0:27:30.48,English,,0,0,0,,And then they put all those in at the beginning
Dialogue: 0,0:27:28.78,0:27:30.48,Chinese,,0,0,0,,然后他们把所有这些都放在了开头
Dialogue: 0,0:27:30.88,0:27:33.48,English,,0,0,0,,And before they even know that it needs to be optimized
Dialogue: 0,0:27:30.88,0:27:33.48,Chinese,,0,0,0,,在他们甚至知道它需要优化之前
Dialogue: 0,0:27:33.76,0:27:37.94,English,,0,0,0,,Okay so the sort of the way you want to work on this and any sort of complex
Dialogue: 0,0:27:33.76,0:27:37.94,Chinese,,0,0,0,,好的，那就是你想要解决这个问题的方式以及任何类型的复杂问题
Dialogue: 0,0:27:38.74,0:27:40.34,English,,0,0,0,,Problem like an allocate
Dialogue: 0,0:27:38.74,0:27:40.34,Chinese,,0,0,0,,问题就像分配一样
Dialogue: 0,0:27:40.82,0:27:45.42,English,,0,0,0,,Is to you know first do fairly simple things and then look and see where
Dialogue: 0,0:27:40.82,0:27:45.42,Chinese,,0,0,0,,是你知道先做相当简单的事情
Dialogue: 0,0:27:45.78,0:27:49.04,English,,0,0,0,,Where the slowdowns are and inefficiencies are and then just sort of
Dialogue: 0,0:27:45.78,0:27:49.04,Chinese,,0,0,0,,然后看看哪里很慢，哪里效率很低
Dialogue: 0,0:27:49.74,0:27:53.48,English,,0,0,0,,Hit those one after the other and optimize only for the things that are necessary
Dialogue: 0,0:27:49.74,0:27:53.48,Chinese,,0,0,0,,然后一个接一个地击中那些并且仅针对必要的事物进行优化
Dialogue: 0,0:27:54.70,0:27:56.32,English,,0,0,0,,And this is a good example of that
Dialogue: 0,0:27:54.70,0:27:56.32,Chinese,,0,0,0,,这是一个很好的例子
Dialogue: 0,0:28:00.54,0:28:03.62,English,,0,0,0,,Okay now to get to your question about freeing
Dialogue: 0,0:28:00.54,0:28:03.62,Chinese,,0,0,0,,现在好了解你关于释放的问题
Dialogue: 0,0:28:09.32,0:28:12.08,English,,0,0,0,,Freeing is tough because we always have to do this coalescing right
Dialogue: 0,0:28:09.32,0:28:12.08,Chinese,,0,0,0,,解放是困难的，因为我们总是必须正确地进行合并
Dialogue: 0,0:28:12.09,0:28:18.40,English,,0,0,0,,Because of this invariant that we can never have to free blocks  to adjacent free blocks
Dialogue: 0,0:28:12.09,0:28:18.40,Chinese,,0,0,0,,由于这种不变性，我们永远不能将块释放到相邻的空闲块
Dialogue: 0,0:28:19.62,0:28:23.20,English,,0,0,0,,So let's go through each of those 4 cases that we went over last time
Dialogue: 0,0:28:19.62,0:28:23.20,Chinese,,0,0,0,,那么让我们来看看上次我们去过的 4  个案例
Dialogue: 0,0:28:23.20,0:28:24.12,English,,0,0,0,,And see how we would do it
Dialogue: 0,0:28:23.20,0:28:24.12,Chinese,,0,0,0,,看看我们将如何做到这一点
Dialogue: 0,0:28:24.12,0:28:29.72,English,,0,0,0,,Now that we have this explicit free list
Dialogue: 0,0:28:24.12,0:28:29.72,Chinese,,0,0,0,,现在我们有了这个显式空闲列表
Dialogue: 0,0:28:30.84,0:28:33.10,English,,0,0,0,,So here we have the root of a free list
Dialogue: 0,0:28:30.84,0:28:33.10,Chinese,,0,0,0,,所以这里我们有一个空闲列表的根
Dialogue: 0,0:28:33.52,0:28:35.96,English,,0,0,0,,Pointing to the first block in the free list
Dialogue: 0,0:28:33.52,0:28:35.96,Chinese,,0,0,0,,指向空闲列表中的第一个块
Dialogue: 0,0:28:36.78,0:28:38.52,English,,0,0,0,,There's an all back pointer and then that
Dialogue: 0,0:28:36.78,0:28:38.52,Chinese,,0,0,0,,有一个指向后面得指针
Dialogue: 0,0:28:39.20,0:28:44.60,English,,0,0,0,,There's a null pointer and then the next pointer points to some unspecified block
Dialogue: 0,0:28:39.20,0:28:44.60,Chinese,,0,0,0,,有一个空指针，然后下一个指针指向一些未指定的块
Dialogue: 0,0:28:45.86,0:28:48.68,English,,0,0,0,,And so we have this yellow block which is allocated
Dialogue: 0,0:28:45.86,0:28:48.68,Chinese,,0,0,0,,所以我们有这个分配的黄色块
Dialogue: 0,0:28:48.86,0:28:54.02,English,,0,0,0,,And now the application is called free, free with a pointer that points to the beginning of this block
Dialogue: 0,0:28:48.86,0:28:54.02,Chinese,,0,0,0,,现在，应用程序调用 free，释放其指针指向此块的开头
Dialogue: 0,0:28:55.61,0:28:56.28,English,,0,0,0,,So what do we do
Dialogue: 0,0:28:55.61,0:28:56.28,Chinese,,0,0,0,,那么我们该怎么办
Dialogue: 0,0:28:57.22,0:28:59.68,English,,0,0,0,,Well this case is pretty simple because there's no coalescing
Dialogue: 0,0:28:57.22,0:28:59.68,Chinese,,0,0,0,,那么这个案子非常简单，因为没有合并
Dialogue: 0,0:28:59.68,0:29:06.14,English,,0,0,0,,Because both the predecessor and successor blocks are allocated
Dialogue: 0,0:28:59.68,0:29:06.14,Chinese,,0,0,0,,因为前驱块和后继块都已分配
Dialogue: 0,0:29:07.80,0:29:12.86,English,,0,0,0,,Okay so we just this newly freed block now becomes we're going to do a LIFO policy
Dialogue: 0,0:29:07.80,0:29:12.86,Chinese,,0,0,0,,好的，所以我们这个刚刚释放的块，现我们要做的 LIFO 政策
Dialogue: 0,0:29:12.86,0:29:15.36,English,,0,0,0,,So this becomes the first block in the free list
Dialogue: 0,0:29:12.86,0:29:15.36,Chinese,,0,0,0,,所以这成为空闲列表中的第一个块
Dialogue: 0,0:29:16.64,0:29:18.68,English,,0,0,0,,And so we update the root to point to this
Dialogue: 0,0:29:16.64,0:29:18.68,Chinese,,0,0,0,,所以我们更新根指向这个新释放得块
Dialogue: 0,0:29:19.14,0:29:25.80,English,,0,0,0,,This newly freed block and we update the forward pointer of that block to point to what used to be the first block in the heap
Dialogue: 0,0:29:19.14,0:29:25.80,Chinese,,0,0,0,,我们更新该块的前向指针，此指向曾经是堆中第一个块的内容
Dialogue: 0,0:29:30.02,0:29:31.52,English,,0,0,0,,Now I'm going to be careful
Dialogue: 0,0:29:30.02,0:29:31.52,Chinese,,0,0,0,,现在我要小心了
Dialogue: 0,0:29:33.38,0:29:34.76,English,,0,0,0,,It's a little bit confusing
Dialogue: 0,0:29:33.38,0:29:34.76,Chinese,,0,0,0,,这有点令人困惑
Dialogue: 0,0:29:35.58,0:29:40.82,English,,0,0,0,,Because we've got sort of two notions of like previous and next right there's the
Dialogue: 0,0:29:35.58,0:29:40.82,Chinese,,0,0,0,,因为我们有两个像前一个和下一个一样的概念
Dialogue: 0,0:29:41.96,0:29:44.20,English,,0,0,0,,You know given some block
Dialogue: 0,0:29:41.96,0:29:44.20,Chinese,,0,0,0,,已知一些块
Dialogue: 0,0:29:45.56,0:29:51.32,English,,0,0,0,,There's the predecessor block in memory which may or may not be allocated or free right
Dialogue: 0,0:29:45.56,0:29:51.32,Chinese,,0,0,0,,内存中的前一个块可能会被分配了或者可能是空闲的
Dialogue: 0,0:29:51.32,0:29:52.86,English,,0,0,0,,It may or may not be in a free list
Dialogue: 0,0:29:51.32,0:29:52.86,Chinese,,0,0,0,,它可能在也可能不在空闲列表中
Dialogue: 0,0:29:54.24,0:29:55.68,English,,0,0,0,,And there's a successor block
Dialogue: 0,0:29:54.24,0:29:55.68,Chinese,,0,0,0,,还有一个后继块
Dialogue: 0,0:29:56.18,0:30:03.38,English,,0,0,0,,Okay so we'll use predecessor and successor to distinguish adjacency in memory
Dialogue: 0,0:29:56.18,0:30:03.38,Chinese,,0,0,0,,好的，我们将使用前驱和后继来区分内存中的邻接块
Dialogue: 0,0:30:04.18,0:30:08.50,English,,0,0,0,,Okay and we'll use pre even next to denote adjacency in the free list
Dialogue: 0,0:30:04.18,0:30:08.50,Chinese,,0,0,0,,好的，我们将使用前一个和后一个表示空闲列表中的邻接
Dialogue: 0,0:30:08.98,0:30:15.16,English,,0,0,0,,Okay so this block is the next block for the current block
Dialogue: 0,0:30:08.98,0:30:15.16,Chinese,,0,0,0,,好的，所以这个块是当前块的下一个块
Dialogue: 0,0:30:15.70,0:30:18.06,English,,0,0,0,,And it has no previous block okay
Dialogue: 0,0:30:15.70,0:30:18.06,Chinese,,0,0,0,,它没有前一个块
Dialogue: 0,0:30:20.94,0:30:26.90,English,,0,0,0,,All right now what about case 2,remember case 2 the predecessor block is free
Dialogue: 0,0:30:20.94,0:30:26.90,Chinese,,0,0,0,,那么现在怎么样的情况 2，记住案例 2 前驱块是空闲的
Dialogue: 0,0:30:27.94,0:30:30.16,English,,0,0,0,,And the successor block is allocated
Dialogue: 0,0:30:27.94,0:30:30.16,Chinese,,0,0,0,,并且继承块被分配
Dialogue: 0,0:30:30.94,0:30:32.12,English,,0,0,0,,And now we want to free this
Dialogue: 0,0:30:30.94,0:30:32.12,Chinese,,0,0,0,,现在我们要释放这个
Dialogue: 0,0:30:32.58,0:30:36.72,English,,0,0,0,,What was an allocated block denoted by yellow
Dialogue: 0,0:30:32.58,0:30:36.72,Chinese,,0,0,0,,黄色表示的分配块
Dialogue: 0,0:30:38.12,0:30:43.76,English,,0,0,0,,And we have this predecessor block is part of the free list
Dialogue: 0,0:30:38.12,0:30:43.76,Chinese,,0,0,0,,这个前驱块是空闲列表的一部分
Dialogue: 0,0:30:43.98,0:30:47.40,English,,0,0,0,,Right so it has previous and next blocks
Dialogue: 0,0:30:43.98,0:30:47.40,Chinese,,0,0,0,,对，所以它有前一个和下一个块
Dialogue: 0,0:30:48.04,0:30:49.26,English,,0,0,0,,That are just part of the free list
Dialogue: 0,0:30:48.04,0:30:49.26,Chinese,,0,0,0,,这只是空闲清单的一部分
Dialogue: 0,0:30:49.98,0:30:53.84,English,,0,0,0,,And so a route points just the first block in the list and then eventually
Dialogue: 0,0:30:49.98,0:30:53.84,Chinese,,0,0,0,,因此，路线仅指向列表中的第一个块，然后最终指向
Dialogue: 0,0:30:56.10,0:31:00.80,English,,0,0,0,,You get to this free block which points to this free block which points to this free block
Dialogue: 0,0:30:56.10,0:31:00.80,Chinese,,0,0,0,,你到达这个空闲区块，指向这个空闲区块，指向这个空闲块
Dialogue: 0,0:31:02.28,0:31:04.06,English,,0,0,0,,Ok so what we have to do then
Dialogue: 0,0:31:02.28,0:31:04.06,Chinese,,0,0,0,,那么我们必须做什么呢
Dialogue: 0,0:31:05.26,0:31:11.06,English,,0,0,0,,Is we have to coalesce these two blocks into one big free block
Dialogue: 0,0:31:05.26,0:31:11.06,Chinese,,0,0,0,,我们是否必须将这两个区块合并成一个大的自由区块
Dialogue: 0,0:31:12.48,0:31:15.68,English,,0,0,0,,Okay and then we have to splice it out and stick it at the beginning of the list
Dialogue: 0,0:31:12.48,0:31:15.68,Chinese,,0,0,0,,好的，然后我们必须将它拼接出来并将其放在列表的开头
Dialogue: 0,0:31:18.76,0:31:23.98,English,,0,0,0,,Ok so what that looks like conceptually is we...
Dialogue: 0,0:31:18.76,0:31:23.98,Chinese,,0,0,0,,那么在概念上看起来就是
Dialogue: 0,0:31:24.58,0:31:27.98,English,,0,0,0,,We coalesce these two blocks now to form this one free block
Dialogue: 0,0:31:24.58,0:31:27.98,Chinese,,0,0,0,,我们现在合并这两个块以形成这个一个空闲块
Dialogue: 0,0:31:30.08,0:31:32.16,English,,0,0,0,,And then we splice it out by
Dialogue: 0,0:31:30.08,0:31:32.16,Chinese,,0,0,0,,然后我们将它拼接出来
Dialogue: 0,0:31:33.72,0:31:40.06,English,,0,0,0,,Having what was its previous block now point to what used to be the next block
Dialogue: 0,0:31:33.72,0:31:40.06,Chinese,,0,0,0,,拥有它以前的块现在指向过去的下一个块
Dialogue: 0,0:31:41.24,0:31:42.38,English,,0,0,0,,Okay of the current block
Dialogue: 0,0:31:41.24,0:31:42.38,Chinese,,0,0,0,,好的当前块
Dialogue: 0,0:31:43.80,0:31:44.68,English,,0,0,0,,Okay so this
Dialogue: 0,0:31:43.80,0:31:44.68,Chinese,,0,0,0,,好的，所以这个
Dialogue: 0,0:31:47.60,0:31:51.34,English,,0,0,0,,The pointer from this block now points to this block
Dialogue: 0,0:31:47.60,0:31:51.34,Chinese,,0,0,0,,此块的指针现在指向此块
Dialogue: 0,0:31:51.84,0:31:57.20,English,,0,0,0,,Okay and then the so we've effectively spliced that current block out of the free list
Dialogue: 0,0:31:51.84,0:31:57.20,Chinese,,0,0,0,,好的，然后我们已经有效地将当前的块拼成空闲列表
Dialogue: 0,0:31:57.94,0:32:00.90,English,,0,0,0,,And then we have the route point to that block
Dialogue: 0,0:31:57.94,0:32:00.90,Chinese,,0,0,0,,然后我们有指向这个块的路线
Dialogue: 0,0:32:01.32,0:32:03.22,English,,0,0,0,,So that's now the new first block of the list
Dialogue: 0,0:32:01.32,0:32:03.22,Chinese,,0,0,0,,所以现在是列表中新的第一个块
Dialogue: 0,0:32:08.08,0:32:11.60,English,,0,0,0,,Okay and then we have to update what used to be the first block in the list
Dialogue: 0,0:32:08.08,0:32:11.60,Chinese,,0,0,0,,好的，然后我们必须更新以前列表中的第一个块
Dialogue: 0,0:32:12.28,0:32:16.86,English,,0,0,0,,So now it points back to the newly freed coalesced block
Dialogue: 0,0:32:12.28,0:32:16.86,Chinese,,0,0,0,,所以现在它指向新释放的合并块
Dialogue: 0,0:32:18.84,0:32:20.26,English,,0,0,0,,So that cleared everybody it yes
Dialogue: 0,0:32:18.84,0:32:20.26,Chinese,,0,0,0,,所有人都清楚了吗？
Dialogue: 0,0:32:25.00,0:32:27.80,English,,0,0,0,,Would it be a global variable it could be or it could be
Dialogue: 0,0:32:25.00,0:32:27.80,Chinese,,0,0,0,,因此，可以是全局变量，也可以是
Dialogue: 0,0:32:30.66,0:32:33.34,English,,0,0,0,,There's two ways to do this right it could just be a global variable
Dialogue: 0,0:32:30.66,0:32:33.34,Chinese,,0,0,0,,有两种方法可以做到这一点，它可能只是一个全局变量
Dialogue: 0,0:32:33.76,0:32:40.78,English,,0,0,0,,Or it could be a struct that of like previous and next pointer
Dialogue: 0,0:32:33.76,0:32:40.78,Chinese,,0,0,0,,或者它可能是一个类似上一个和下一个指针的结构
Dialogue: 0,0:32:40.78,0:32:44.94,English,,0,0,0,,So sometimes it's easier if you keep the same you know when you're doing a linked list that
Dialogue: 0,0:32:40.78,0:32:44.94,Chinese,,0,0,0,,因此，如果你在做链接列表的时候保持相同的话，有时会更容易
Dialogue: 0,0:32:45.30,0:32:48.74,English,,0,0,0,,The route if you just make it the same as all the other nodes it can simplify things
Dialogue: 0,0:32:45.30,0:32:48.74,Chinese,,0,0,0,,如果你只是将其与所有其他节点相同，则可以简化操作
Dialogue: 0,0:32:49.34,0:32:52.50,English,,0,0,0,,But yeah it could be a global variable,global scalar in the allocator
Dialogue: 0,0:32:49.34,0:32:52.50,Chinese,,0,0,0,,它可能是一个全局变量，分配器中的全局标量
Dialogue: 0,0:32:58.26,0:33:02.14,English,,0,0,0,,Okay so case...oh now one thing one thing that comes to mind there is like
Dialogue: 0,0:32:58.26,0:33:02.14,Chinese,,0,0,0,,现在有一件事情可以想到就像是
Dialogue: 0,0:33:04.10,0:33:06.08,English,,0,0,0,,There is an optimization that we could do
Dialogue: 0,0:33:04.10,0:33:06.08,Chinese,,0,0,0,,我们可以做一个优化
Dialogue: 0,0:33:08.30,0:33:11.52,English,,0,0,0,,In this case do you see when we coalesce
Dialogue: 0,0:33:08.30,0:33:11.52,Chinese,,0,0,0,,在这种情况下，你看到我们何时合并
Dialogue: 0,0:33:13.22,0:33:16.36,English,,0,0,0,,We could just lead that block right there in the free list
Dialogue: 0,0:33:13.22,0:33:16.36,Chinese,,0,0,0,,我们可以在空闲列表中直接引导该块到此处
Dialogue: 0,0:33:16.58,0:33:19.08,English,,0,0,0,,Right we didn't although we've adopted
Dialogue: 0,0:33:16.58,0:33:19.08,Chinese,,0,0,0,,对，我们没有
Dialogue: 0,0:33:19.36,0:33:24.20,English,,0,0,0,,So the examples I'm going to show you are assuming a LIFO policy for insertion
Dialogue: 0,0:33:19.36,0:33:24.20,Chinese,,0,0,0,,因此，我将向你展示的示例是假设插入的 LIFO 策略
Dialogue: 0,0:33:25.38,0:33:29.02,English,,0,0,0,,We could just leave it there right that and just don't update anything
Dialogue: 0,0:33:25.38,0:33:29.02,Chinese,,0,0,0,,我们可以把它留在那里，只是不更新​​任何东西
Dialogue: 0,0:33:29.18,0:33:33.40,English,,0,0,0,,Just increase create this newly coalesce block
Dialogue: 0,0:33:29.18,0:33:33.40,Chinese,,0,0,0,,只需增加创建这个新的合并块
Dialogue: 0,0:33:33.62,0:33:37.32,English,,0,0,0,,In this case we wouldn't require any free list manipulation
Dialogue: 0,0:33:33.62,0:33:37.32,Chinese,,0,0,0,,在这种情况下，我们不需要任何空闲列表操作
Dialogue: 0,0:33:38.52,0:33:42.18,English,,0,0,0,,Okay but that would be that would be one of these optimizations right
Dialogue: 0,0:33:38.52,0:33:42.18,Chinese,,0,0,0,,好的，但那将是这些优化之一
Dialogue: 0,0:33:44.46,0:33:45.00,English,,0,0,0,,That now
Dialogue: 0,0:33:44.46,0:33:45.00,Chinese,,0,0,0,,那就是现在
Dialogue: 0,0:33:47.48,0:33:52.56,English,,0,0,0,,Case 3 if you recall is the case where the the predecessor block is allocated
Dialogue: 0,0:33:47.48,0:33:52.56,Chinese,,0,0,0,,如果你还记得案例 3 是分配了前驱块的情况
Dialogue: 0,0:33:53.22,0:33:56.08,English,,0,0,0,,And the successor block is free
Dialogue: 0,0:33:53.22,0:33:56.08,Chinese,,0,0,0,,后继块是空闲的
Dialogue: 0,0:34:00.96,0:34:02.48,English,,0,0,0,,The successor block is free
Dialogue: 0,0:34:00.96,0:34:02.48,Chinese,,0,0,0,,后继块是空闲的
Dialogue: 0,0:34:04.20,0:34:06.30,English,,0,0,0,,So in this case what we have to do is we have to create
Dialogue: 0,0:34:04.20,0:34:06.30,Chinese,,0,0,0,,所以在这种情况下我们要做的就是创造
Dialogue: 0,0:34:06.80,0:34:13.92,English,,0,0,0,,We have to coalesce the newly freed block with the successor block
Dialogue: 0,0:34:06.80,0:34:13.92,Chinese,,0,0,0,,我们必须将新释放的块与后继块合并
Dialogue: 0,0:34:15.46,0:34:19.04,English,,0,0,0,,And then we have to splice it out in just the same way we did in case 2
Dialogue: 0,0:34:15.46,0:34:19.04,Chinese,,0,0,0,,然后我们必须以与案例 2 中相同的方式将其拼接出来
Dialogue: 0,0:34:21.48,0:34:23.34,English,,0,0,0,,So we splice it out of the list
Dialogue: 0,0:34:21.48,0:34:23.34,Chinese,,0,0,0,,所以我们将它拼接出列表
Dialogue: 0,0:34:25.82,0:34:29.32,English,,0,0,0,,And then put it at the beginning of the list by pointing the root at it
Dialogue: 0,0:34:25.82,0:34:29.32,Chinese,,0,0,0,,然后通过将根指向它来将其放在列表的开头
Dialogue: 0,0:34:29.94,0:34:33.50,English,,0,0,0,,And then updating what used to be the first block in the list
Dialogue: 0,0:34:29.94,0:34:33.50,Chinese,,0,0,0,,然后更新曾经是列表中第一个块的内容
Dialogue: 0,0:34:34.14,0:34:39.72,English,,0,0,0,,Updating its back pointer it's pre pointer to point to the newly coalesced block
Dialogue: 0,0:34:34.14,0:34:39.72,Chinese,,0,0,0,,更新其后向指针，它的前向指针指向新合并的块
Dialogue: 0,0:34:40.26,0:34:44.70,English,,0,0,0,,Okay so this is completely symmetric with the case that we looked at before
Dialogue: 0,0:34:40.26,0:34:44.70,Chinese,,0,0,0,,好的，这与我们之前看过的情况完全对称
Dialogue: 0,0:34:46.34,0:34:47.60,English,,0,0,0,,But now we no longer have
Dialogue: 0,0:34:46.34,0:34:47.60,Chinese,,0,0,0,,但现在我们不再拥有
Dialogue: 0,0:34:48.06,0:34:51.90,English,,0,0,0,,It's a little bit trickier if we just wanted to leave this block in the free list
Dialogue: 0,0:34:48.06,0:34:51.90,Chinese,,0,0,0,,如果我们只想将这个块留在空闲列表中，这有点棘手
Dialogue: 0,0:34:52.66,0:34:55.26,English,,0,0,0,,We'd have to update all these pointers to point back
Dialogue: 0,0:34:52.66,0:34:55.26,Chinese,,0,0,0,,我们必须更新所有这些指针以指回
Dialogue: 0,0:34:56.28,0:34:58.16,English,,0,0,0,,To the beginning of the newly created block
Dialogue: 0,0:34:56.28,0:34:58.16,Chinese,,0,0,0,,到新创建的块的开头
Dialogue: 0,0:34:58.50,0:35:00.74,English,,0,0,0,,Okay so there's
Dialogue: 0,0:34:58.50,0:35:00.74,Chinese,,0,0,0,,好的，那就是
Dialogue: 0,0:35:02.50,0:35:04.32,English,,0,0,0,,So in this case there's no performance
Dialogue: 0,0:35:02.50,0:35:04.32,Chinese,,0,0,0,,所以在这种情况下没有好的性能优化
Dialogue: 0,0:35:05.62,0:35:08.28,English,,0,0,0,,Optimization right we're still updating the same number of pointers
Dialogue: 0,0:35:05.62,0:35:08.28,Chinese,,0,0,0,,我们仍在更新相同数量的指针
Dialogue: 0,0:35:08.50,0:35:10.62,English,,0,0,0,,Whether we put it in the beginning of the list
Dialogue: 0,0:35:08.50,0:35:10.62,Chinese,,0,0,0,,我们是否把它放在列表的开头
Dialogue: 0,0:35:10.68,0:35:14.02,English,,0,0,0,,Or if we splice it or if we leave it there
Dialogue: 0,0:35:10.68,0:35:14.02,Chinese,,0,0,0,,或者如果我们拼接它或者我们把它留在那里
Dialogue: 0,0:35:17.84,0:35:19.86,English,,0,0,0,,And now case 4 is the
Dialogue: 0,0:35:17.84,0:35:19.86,Chinese,,0,0,0,,而现在案例 4 就是
Dialogue: 0,0:35:20.80,0:35:24.92,English,,0,0,0,,That's the case where both the predecessor and successor blocks are free
Dialogue: 0,0:35:20.80,0:35:24.92,Chinese,,0,0,0,,这是前驱和后继块都是空闲的情况
Dialogue: 0,0:35:26.14,0:35:34.26,English,,0,0,0,,So we have to apply the same splicing technique to both the predecessor block
Dialogue: 0,0:35:26.14,0:35:34.26,Chinese,,0,0,0,,因此，我们必须将相同的拼接技术应用于前一个块
Dialogue: 0,0:35:35.68,0:35:39.80,English,,0,0,0,,And we have to create this new coalesced block
Dialogue: 0,0:35:35.68,0:35:39.80,Chinese,,0,0,0,,我们必须创建这个新的合并块
Dialogue: 0,0:35:39.80,0:35:41.04,English,,0,0,0,,And then we have to splice
Dialogue: 0,0:35:39.80,0:35:41.04,Chinese,,0,0,0,,然后我们必须拼接
Dialogue: 0,0:35:42.92,0:35:45.90,English,,0,0,0,,We have to we have to sort of splice it out by updating
Dialogue: 0,0:35:42.92,0:35:45.90,Chinese,,0,0,0,,我们必须通过更新两组不同的前驱和后继块
Dialogue: 0,0:35:46.40,0:35:51.82,English,,0,0,0,,Two different sets of previous and successor blocks
Dialogue: 0,0:35:46.40,0:35:51.82,Chinese,,0,0,0,,来解决这个问题
Dialogue: 0,0:35:56.08,0:35:58.24,English,,0,0,0,,So when we're finished with that
Dialogue: 0,0:35:56.08,0:35:58.24,Chinese,,0,0,0,,所以当我们完成那个
Dialogue: 0,0:35:58.92,0:36:05.08,English,,0,0,0,,That the this newly coalesced block now is the first block in the heap
Dialogue: 0,0:35:58.92,0:36:05.08,Chinese,,0,0,0,,现在这个新合并的块是堆中的第一个块
Dialogue: 0,0:36:06.70,0:36:07.78,English,,0,0,0,,In the free list
Dialogue: 0,0:36:06.70,0:36:07.78,Chinese,,0,0,0,,在空闲列表中
Dialogue: 0,0:36:08.12,0:36:13.14,English,,0,0,0,,And we've spliced it,we splice it out from these two different parts of the of the free list
Dialogue: 0,0:36:08.12,0:36:13.14,Chinese,,0,0,0,,我们拼接了它，我们将它从空闲列表的这两个不同部分拼接出来
Dialogue: 0,0:36:18.46,0:36:19.96,English,,0,0,0,,Okay so any questions about
Dialogue: 0,0:36:18.46,0:36:19.96,Chinese,,0,0,0,,好的，所以有任何疑问
Dialogue: 0,0:36:25.02,0:36:28.46,English,,0,0,0,,It looks it looks really simple to do
Dialogue: 0,0:36:25.02,0:36:28.46,Chinese,,0,0,0,,看起来它看起来很简单
Dialogue: 0,0:36:30.30,0:36:31.86,English,,0,0,0,,But I guarantee you this will be
Dialogue: 0,0:36:30.30,0:36:31.86,Chinese,,0,0,0,,但我保证
Dialogue: 0,0:36:32.78,0:36:33.68,English,,0,0,0,,Some the hardest
Dialogue: 0,0:36:32.78,0:36:33.68,Chinese,,0,0,0,,对于有些人，这里是最难的
Dialogue: 0,0:36:34.46,0:36:36.40,English,,0,0,0,,It's only like 200 lines of code
Dialogue: 0,0:36:34.46,0:36:36.40,Chinese,,0,0,0,,它只有 200 行代码
Dialogue: 0,0:36:36.48,0:36:38.40,English,,0,0,0,,But some of the hardest code you'll have to write because
Dialogue: 0,0:36:36.48,0:36:38.40,Chinese,,0,0,0,,但是你必须编写一些最难的代码，因为
Dialogue: 0,0:36:40.58,0:36:45.24,English,,0,0,0,,You're sort of free of the c's types us that you have to do everything by explicitly casting
Dialogue: 0,0:36:40.58,0:36:45.24,Chinese,,0,0,0,,你必须通过显式的代码来做所有事情
Dialogue: 0,0:36:45.46,0:36:48.22,English,,0,0,0,,These pointers are just in the middle of arbitrary blocks
Dialogue: 0,0:36:45.46,0:36:48.22,Chinese,,0,0,0,,这些指针位于任意块的中间
Dialogue: 0,0:36:51.42,0:36:55.92,English,,0,0,0,,So it looks simple with the diagram but you're going to have to be really careful when you do this
Dialogue: 0,0:36:51.42,0:36:55.92,Chinese,,0,0,0,,因此，图表看起来很简单，但是当你这样做时你必须要非常小心
Dialogue: 0,0:36:57.50,0:36:58.94,English,,0,0,0,,In fact what I would suggest the
Dialogue: 0,0:36:57.50,0:36:58.94,Chinese,,0,0,0,,事实上我会建议的
Dialogue: 0,0:37:00.74,0:37:02.36,English,,0,0,0,,Best suggestion I can give you is
Dialogue: 0,0:37:00.74,0:37:02.36,Chinese,,0,0,0,,我能给你的最佳建议是
Dialogue: 0,0:37:03.48,0:37:06.54,English,,0,0,0,,If is to start with the implicit list allocator
Dialogue: 0,0:37:03.48,0:37:06.54,Chinese,,0,0,0,,如果是从隐式列表分配器开始
Dialogue: 0,0:37:07.32,0:37:10.52,English,,0,0,0,,That we describe in the book which is too slow to get any credit
Dialogue: 0,0:37:07.32,0:37:10.52,Chinese,,0,0,0,,我们在书中描述的那个太慢而无法获得任何功劳
Dialogue: 0,0:37:10.64,0:37:11.52,English,,0,0,0,,It's a terrible allocator
Dialogue: 0,0:37:10.64,0:37:11.52,Chinese,,0,0,0,,这是一个糟糕的分配器
Dialogue: 0,0:37:11.52,0:37:14.48,English,,0,0,0,,But it contains all the basic ideas
Dialogue: 0,0:37:11.52,0:37:14.48,Chinese,,0,0,0,,但它包含了所有基本思想
Dialogue: 0,0:37:15.50,0:37:21.14,English,,0,0,0,,And then write function write a function called insert block and write another function called remove block
Dialogue: 0,0:37:15.50,0:37:21.14,Chinese,,0,0,0,,然后写函数写一个名为「insert block」的函数，并编写另一个名为「remove block」的函数
Dialogue: 0,0:37:21.70,0:37:27.62,English,,0,0,0,,That inserts a block into the free list and removes a block from the free list respectively
Dialogue: 0,0:37:21.70,0:37:27.62,Chinese,,0,0,0,,将块插入空闲列表并分别从空闲列表中删除块
Dialogue: 0,0:37:28.74,0:37:31.12,English,,0,0,0,,And if you write, if you abstract it like that
Dialogue: 0,0:37:28.74,0:37:31.12,Chinese,,0,0,0,,如果你写，如果你这样抽象
Dialogue: 0,0:37:31.78,0:37:34.04,English,,0,0,0,,If you use that kind of abstraction it's pretty simple
Dialogue: 0,0:37:31.78,0:37:34.04,Chinese,,0,0,0,,如果使用这种抽象，那就非常简单了
Dialogue: 0,0:37:34.56,0:37:38.64,English,,0,0,0,,To convert the implicit list allocator to an explicit list allocator
Dialogue: 0,0:37:34.56,0:37:38.64,Chinese,,0,0,0,,将隐式列表分配器转换为显式列表分配器
Dialogue: 0,0:37:41.06,0:37:43.18,English,,0,0,0,,It'll still be too slow to get
Dialogue: 0,0:37:41.06,0:37:43.18,Chinese,,0,0,0,,得到它仍然太慢了
Dialogue: 0,0:37:43.70,0:37:48.48,English,,0,0,0,,So then that'll go from like a f allocator to a b-allocator
Dialogue: 0,0:37:43.70,0:37:48.48,Chinese,,0,0,0,,那么那将会像 F 等级的分配器变成一个 B- 等级的分配器一样
Dialogue: 0,0:37:50.04,0:37:55.18,English,,0,0,0,,And then to really make a good allocator like an a allocator you need to use segregated lists
Dialogue: 0,0:37:50.04,0:37:55.18,Chinese,,0,0,0,,然后真正做一个像分配器一样好的分配器，你需要使用隔离列表
Dialogue: 0,0:37:55.72,0:37:57.06,English,,0,0,0,,Which we'll look at in a second
Dialogue: 0,0:37:55.72,0:37:57.06,Chinese,,0,0,0,,我们马上就能看到
Dialogue: 0,0:37:59.94,0:38:01.56,English,,0,0,0,,Okay so the explicit lists
Dialogue: 0,0:37:59.94,0:38:01.56,Chinese,,0,0,0,,好的，所以显式列表
Dialogue: 0,0:38:01.84,0:38:06.76,English,,0,0,0,,Now the allocation time is linear in the number of free blocks instead of the total size
Dialogue: 0,0:38:01.84,0:38:06.76,Chinese,,0,0,0,,现在，分配时间是空闲块的数量呈线性关系
Dialogue: 0,0:38:07.36,0:38:11.64,English,,0,0,0,,Of the instead of the total size of the heap
Dialogue: 0,0:38:07.36,0:38:11.64,Chinese,,0,0,0,,而不是堆的总大小
Dialogue: 0,0:38:11.66,0:38:14.96,English,,0,0,0,,So it's this is much faster than that when you have a lot of allocated blocks
Dialogue: 0,0:38:11.66,0:38:14.96,Chinese,,0,0,0,,所以这比你拥有大量分配的块要快得多
Dialogue: 0,0:38:16.80,0:38:19.70,English,,0,0,0,,It's a little more complicated because of all the splicing business
Dialogue: 0,0:38:16.80,0:38:19.70,Chinese,,0,0,0,,由于所有的需要拼接，它有点复杂
Dialogue: 0,0:38:20.22,0:38:23.50,English,,0,0,0,,And you do need some extra space in your
Dialogue: 0,0:38:20.22,0:38:23.50,Chinese,,0,0,0,,你确实需要一些额外的空间
Dialogue: 0,0:38:25.28,0:38:28.72,English,,0,0,0,,For these pointers which increases the minimum block size
Dialogue: 0,0:38:25.28,0:38:28.72,Chinese,,0,0,0,,由于这些增加最小块大小的指针
Dialogue: 0,0:38:28.98,0:38:32.68,English,,0,0,0,,And creates additional and overhead
Dialogue: 0,0:38:28.98,0:38:32.68,Chinese,,0,0,0,,并创造额外的和开销
Dialogue: 0,0:38:34.28,0:38:39.74,English,,0,0,0,,Now the link list the explicit list allocators aren't really
Dialogue: 0,0:38:34.28,0:38:39.74,Chinese,,0,0,0,,显式列表分配器
Dialogue: 0,0:38:40.30,0:38:45.06,English,,0,0,0,,Efficient enough to be used for sort of general purpose real-life allocator
Dialogue: 0,0:38:40.30,0:38:45.06,Chinese,,0,0,0,,不是足够高效地用于各种通用于现实生活分配器
Dialogue: 0,0:38:45.08,0:38:49.84,English,,0,0,0,,But they are useful in as part of a segregated list allocator
Dialogue: 0,0:38:45.08,0:38:49.84,Chinese,,0,0,0,,但它们作为隔离列表分配器的一部分很有用
Dialogue: 0,0:38:49.84,0:38:54.58,English,,0,0,0,,So you can have multiple free lists each of which is an explicit list
Dialogue: 0,0:38:49.84,0:38:54.58,Chinese,,0,0,0,,所以你可以拥有多个空闲列表，每个列表都是一个显式列表
Dialogue: 0,0:38:55.50,0:38:58.44,English,,0,0,0,,And this it's fine for that application
Dialogue: 0,0:38:55.50,0:38:58.44,Chinese,,0,0,0,,这对于该应用程序来说很好
Dialogue: 0,0:39:00.78,0:39:05.06,English,,0,0,0,,Alright so let's look at a third method which is to create call a segregated free list
Dialogue: 0,0:39:00.78,0:39:05.06,Chinese,,0,0,0,,好吧，让我们看看第三种方法，即创建一个隔离的空闲列表
Dialogue: 0,0:39:05.82,0:39:10.32,English,,0,0,0,,Which is to have multiple free lists with different size classes
Dialogue: 0,0:39:05.82,0:39:10.32,Chinese,,0,0,0,,这是多个具有不同大小类的空闲列表
Dialogue: 0,0:39:12.76,0:39:14.68,English,,0,0,0,,So the idea is that each
Dialogue: 0,0:39:12.76,0:39:14.68,Chinese,,0,0,0,,所以想法是
Dialogue: 0,0:39:15.84,0:39:17.28,English,,0,0,0,,Each class of sizes
Dialogue: 0,0:39:15.84,0:39:17.28,Chinese,,0,0,0,,每类尺寸
Dialogue: 0,0:39:18.84,0:39:21.32,English,,0,0,0,,Block sizes has its own free list
Dialogue: 0,0:39:18.84,0:39:21.32,Chinese,,0,0,0,,块大小有自己的空闲列表
Dialogue: 0,0:39:21.86,0:39:25.90,English,,0,0,0,,And that class can be singleton so you know maybe a one particular size
Dialogue: 0,0:39:21.86,0:39:25.90,Chinese,,0,0,0,,那个类可以是单身，所以你知道可能是一个特定的大小
Dialogue: 0,0:39:26.48,0:39:28.18,English,,0,0,0,,Or it can be a range of sizes
Dialogue: 0,0:39:26.48,0:39:28.18,Chinese,,0,0,0,,或者它可以是一系列尺寸
Dialogue: 0,0:39:28.26,0:39:31.24,English,,0,0,0,,So you might have a number of different
Dialogue: 0,0:39:28.26,0:39:31.24,Chinese,,0,0,0,,所以你可能会有很多不同的东西
Dialogue: 0,0:39:32.10,0:39:37.24,English,,0,0,0,,You know if your workload consists of a lot of these small blocks
Dialogue: 0,0:39:32.10,0:39:37.24,Chinese,,0,0,0,,你知道你的工作量是否包含很多这些小块
Dialogue: 0,0:39:37.26,0:39:39.96,English,,0,0,0,,And you know that there's going to be a lot of requests for blocks
Dialogue: 0,0:39:37.26,0:39:39.96,Chinese,,0,0,0,,而且你知道会有很多块请求
Dialogue: 0,0:39:40.92,0:39:41.80,English,,0,0,0,,Of 1 through 4
Dialogue: 0,0:39:40.92,0:39:41.80,Chinese,,0,0,0,,其大小是 1 到 4
Dialogue: 0,0:39:41.82,0:39:47.43,English,,0,0,0,,You can have different free lists for those small for those small block sizes
Dialogue: 0,0:39:41.82,0:39:47.43,Chinese,,0,0,0,,对于那些小块大小，你可以拥有不同的空闲列表
Dialogue: 0,0:39:47.96,0:39:51.40,English,,0,0,0,,And then after that you can go and just do ranges of power of two
Dialogue: 0,0:39:47.96,0:39:51.40,Chinese,,0,0,0,,然后你可以标定一些范围
Dialogue: 0,0:39:51.40,0:39:53.42,English,,0,0,0,,So that's  a common technique
Dialogue: 0,0:39:51.40,0:39:53.42,Chinese,,0,0,0,,所以这是一种常见的技术
Dialogue: 0,0:39:53.96,0:39:57.94,English,,0,0,0,,So here we have a size class that covers blocks from size 5 to 8
Dialogue: 0,0:39:53.96,0:39:57.94,Chinese,,0,0,0,,所以这里我们有一个大小类，涵盖从 5 到 8 的块
Dialogue: 0,0:39:58.42,0:40:03.60,English,,0,0,0,,And then the another size class that covers everything else
Dialogue: 0,0:39:58.42,0:40:03.60,Chinese,,0,0,0,,然后是另一个涵盖其他一切的大小类
Dialogue: 0,0:40:07.38,0:40:09.70,English,,0,0,0,,So the idea with the seglist allocators that
Dialogue: 0,0:40:07.38,0:40:09.70,Chinese,,0,0,0,,所以用 seglist 分配器的想法就是这样
Dialogue: 0,0:40:09.92,0:40:15.20,English,,0,0,0,,So given an array of these free lists one each one for some size class
Dialogue: 0,0:40:09.92,0:40:15.20,Chinese,,0,0,0,,因此给出了这些空闲列表的数组，每个列表都有一个大小类
Dialogue: 0,0:40:16.34,0:40:18.60,English,,0,0,0,,If we want to allocate a block of size n
Dialogue: 0,0:40:16.34,0:40:18.60,Chinese,,0,0,0,,如果我们想要分配一个大小为 n  的块
Dialogue: 0,0:40:19.40,0:40:22.02,English,,0,0,0,,Then we go to the appropriate free list
Dialogue: 0,0:40:19.40,0:40:22.02,Chinese,,0,0,0,,然后我们去相应的空闲列表
Dialogue: 0,0:40:22.54,0:40:27.04,English,,0,0,0,,Right there's only,there's always going to be one free list for any n
Dialogue: 0,0:40:22.54,0:40:27.04,Chinese,,0,0,0,,对于任何 n，其中总会有一个块大小为 n 的空闲列表
Dialogue: 0,0:40:28.40,0:40:31.36,English,,0,0,0,,And then we search that list just like we did before
Dialogue: 0,0:40:28.40,0:40:31.36,Chinese,,0,0,0,,然后我们像以前一样搜索该列表
Dialogue: 0,0:40:31.70,0:40:35.36,English,,0,0,0,,For some size at a block size m > n
Dialogue: 0,0:40:31.70,0:40:35.36,Chinese,,0,0,0,,对于块大小 m > n 的某些大小
Dialogue: 0,0:40:38.26,0:40:40.78,English,,0,0,0,,And then if we find it then we place
Dialogue: 0,0:40:38.26,0:40:40.78,Chinese,,0,0,0,,然后，如果我们找到它
Dialogue: 0,0:40:41.48,0:40:42.60,English,,0,0,0,,We place the new block
Dialogue: 0,0:40:41.48,0:40:42.60,Chinese,,0,0,0,,我们放置新块
Dialogue: 0,0:40:43.70,0:40:46.68,English,,0,0,0,,We place the block in the block that we found
Dialogue: 0,0:40:43.70,0:40:46.68,Chinese,,0,0,0,,我们将块放在我们找到的块中
Dialogue: 0,0:40:46.98,0:40:47.76,English,,0,0,0,,We split it
Dialogue: 0,0:40:46.98,0:40:47.76,Chinese,,0,0,0,,我们分开了
Dialogue: 0,0:40:48.64,0:40:52.42,English,,0,0,0,,And we take this split block and we put it into the appropriate size class
Dialogue: 0,0:40:48.64,0:40:52.42,Chinese,,0,0,0,,我们采用这个拆分块，然后将它放入适当的大小类中
Dialogue: 0,0:40:52.66,0:40:54.38,English,,0,0,0,,So that the block that we split off
Dialogue: 0,0:40:52.66,0:40:54.38,Chinese,,0,0,0,,这样我们拆分的块
Dialogue: 0,0:40:54.94,0:40:58.24,English,,0,0,0,,May or may not belong to the current size class anymore
Dialogue: 0,0:40:54.94,0:40:58.24,Chinese,,0,0,0,,可能会或可能不会属于当前的大小等级
Dialogue: 0,0:40:58.64,0:41:03.96,English,,0,0,0,,Right so we may have to move it and insert it into a whatever the appropriate size class is
Dialogue: 0,0:40:58.64,0:41:03.96,Chinese,,0,0,0,,所以我们可能必须移动它并将其插入任何适当的大小类
Dialogue: 0,0:41:06.18,0:41:08.76,English,,0,0,0,,If there's no block if we can't find a block
Dialogue: 0,0:41:06.18,0:41:08.76,Chinese,,0,0,0,,如果我们找不到块
Dialogue: 0,0:41:09.00,0:41:11.06,English,,0,0,0,,Then we have to try the next larger size class
Dialogue: 0,0:41:09.00,0:41:11.06,Chinese,,0,0,0,,然后我们必须尝试下一个更大的类
Dialogue: 0,0:41:12.12,0:41:14.80,English,,0,0,0,,Okay so it's possible for a given size class
Dialogue: 0,0:41:12.12,0:41:14.80,Chinese,,0,0,0,,好的，对于给定的大小
Dialogue: 0,0:41:14.80,0:41:17.22,English,,0,0,0,,They're just there might not be a block that fits
Dialogue: 0,0:41:14.80,0:41:17.22,Chinese,,0,0,0,,可能没有适合的块
Dialogue: 0,0:41:20.12,0:41:23.94,English,,0,0,0,,So I mean one so we just have to we go to the next size
Dialogue: 0,0:41:20.12,0:41:23.94,Chinese,,0,0,0,,所以我们只需要进入下一个尺寸
Dialogue: 0,0:41:23.94,0:41:28.10,English,,0,0,0,,We try the next larger class and chances are we'll find a block that fits there
Dialogue: 0,0:41:23.94,0:41:28.10,Chinese,,0,0,0,,我们尝试下一个更大的尺寸，我们很有可能在那找到一个适合块
Dialogue: 0,0:41:28.80,0:41:33.60,English,,0,0,0,,And if we and you keep doing that until you eventually if you can't find it
Dialogue: 0,0:41:28.80,0:41:33.60,Chinese,,0,0,0,,如果我们和你一直这样做，直到你最终如果你找不到它
Dialogue: 0,0:41:33.60,0:41:39.16,English,,0,0,0,,You're eventually looking in the size class that covers all the rest the last size class
Dialogue: 0,0:41:33.60,0:41:39.16,Chinese,,0,0,0,,你最终会查看覆盖所有其余大小类的大小类
Dialogue: 0,0:41:40.10,0:41:49.56,English,,0,0,0,,And if then you can't find it then that the allocator has to allocate more memory with by calling sbreak
Dialogue: 0,0:41:40.10,0:41:49.56,Chinese,,0,0,0,,如果那时你找不到它，那么分配器必须通过调用 sbreak 来分配更多的内存
Dialogue: 0,0:41:53.58,0:41:56.26,English,,0,0,0,,Okay to free a block you coalesce like before
Dialogue: 0,0:41:53.58,0:41:56.26,Chinese,,0,0,0,,好吧，像以前一样合并一块
Dialogue: 0,0:41:56.26,0:41:57.84,English,,0,0,0,,And then you place it on the appropriate list
Dialogue: 0,0:41:56.26,0:41:57.84,Chinese,,0,0,0,,之后将其放在适当的列表中
Dialogue: 0,0:41:58.26,0:42:03.88,English,,0,0,0,,So that's straightforward and again you have this option to try to maintain a listed
Dialogue: 0,0:41:58.26,0:42:03.88,Chinese,,0,0,0,,所以这很简单，你再次尝试维护一个列出的选项
Dialogue: 0,0:42:04.46,0:42:07.44,English,,0,0,0,,Address order or just do the simple thing and put it at the beginning of the list
Dialogue: 0,0:42:04.46,0:42:07.44,Chinese,,0,0,0,,地址顺序或只做简单的事情 —— 将其放在列表的开头
Dialogue: 0,0:42:09.38,0:42:17.43,English,,0,0,0,,Okay so seglist allocator are that by far the best type of allocator
Dialogue: 0,0:42:09.38,0:42:17.43,Chinese,,0,0,0,,所以 seglist 分配器是迄今为止最好的分配器类型
Dialogue: 0,0:42:18.40,0:42:25.12,English,,0,0,0,,Because they offer you improvements in both performance throughput and memory utilization
Dialogue: 0,0:42:18.40,0:42:25.12,Chinese,,0,0,0,,因为它们为你提供了吞吐量上的进步和内存利用率方面的改进
Dialogue: 0,0:42:26.42,0:42:28.96,English,,0,0,0,,So they're faster they have higher throughputs because the
Dialogue: 0,0:42:26.42,0:42:28.96,Chinese,,0,0,0,,所以他们的速度更快，具有更高的吞吐量
Dialogue: 0,0:42:29.38,0:42:32.62,English,,0,0,0,,The individual size classes are smaller
Dialogue: 0,0:42:29.38,0:42:32.62,Chinese,,0,0,0,,因为区别一一个巨大的空闲清单
Dialogue: 0,0:42:33.00,0:42:35.68,English,,0,0,0,,Then just like the one giant free list
Dialogue: 0,0:42:33.00,0:42:35.68,Chinese,,0,0,0,,它的单个的大小更小
Dialogue: 0,0:42:36.52,0:42:37.96,English,,0,0,0,,But also you're searching
Dialogue: 0,0:42:36.52,0:42:37.96,Chinese,,0,0,0,,但你也在寻找
Dialogue: 0,0:42:39.24,0:42:42.26,English,,0,0,0,,You're you know that the list that you're searching
Dialogue: 0,0:42:39.24,0:42:42.26,Chinese,,0,0,0,,你正在搜索的列表
Dialogue: 0,0:42:42.32,0:42:47.04,English,,0,0,0,,Is going to be close to the size that you're looking for so the chances of finding something quickly
Dialogue: 0,0:42:42.32,0:42:47.04,Chinese,,0,0,0,,将接近你正在寻找的大小，以便快速找到某些东西
Dialogue: 0,0:42:48.12,0:42:51.78,English,,0,0,0,,In that particular size class are higher than they are
Dialogue: 0,0:42:48.12,0:42:51.78,Chinese,,0,0,0,,在那个特定的尺寸的列表搜索会更快
Dialogue: 0,0:42:52.06,0:42:53.36,English,,0,0,0,,If you're just searching
Dialogue: 0,0:42:52.06,0:42:53.36,Chinese,,0,0,0,,相较于在寻找
Dialogue: 0,0:42:53.92,0:42:57.24,English,,0,0,0,,On you know a single free list that holds all different size classes
Dialogue: 0,0:42:53.92,0:42:57.24,Chinese,,0,0,0,,一个包含所有不同大小类的空闲列表
Dialogue: 0,0:42:58.08,0:43:03.26,English,,0,0,0,,Okay so search is faster so that increases increases throughput
Dialogue: 0,0:42:58.08,0:43:03.26,Chinese,,0,0,0,,好的，所以搜索更快，以便增加吞吐量
Dialogue: 0,0:43:03.84,0:43:06.90,English,,0,0,0,,But the big thing about seglist allocator is that
Dialogue: 0,0:43:03.84,0:43:06.90,Chinese,,0,0,0,,但是关于 Seglist 分配器的重要一点是
Dialogue: 0,0:43:07.50,0:43:12.20,English,,0,0,0,,Like we talked about before they approximate best fit without sacrificing performance
Dialogue: 0,0:43:07.50,0:43:12.20,Chinese,,0,0,0,,就像我们之前谈到的那样，它们在不牺牲性能的情况下接近最佳匹配
Dialogue: 0,0:43:12.90,0:43:17.00,English,,0,0,0,,Right before if we wanted to do best fit on a single a free list
Dialogue: 0,0:43:12.90,0:43:17.00,Chinese,,0,0,0,,如果我们想要在一个空闲列表中做到最合适，就在此之前
Dialogue: 0,0:43:17.00,0:43:18.60,English,,0,0,0,,We had to search the whole free list
Dialogue: 0,0:43:17.00,0:43:18.60,Chinese,,0,0,0,,我们不得不搜索整个空闲列表
Dialogue: 0,0:43:19.00,0:43:20.84,English,,0,0,0,,And then choose the block that fit the best
Dialogue: 0,0:43:19.00,0:43:20.84,Chinese,,0,0,0,,然后选择最适合的块
Dialogue: 0,0:43:22.62,0:43:25.72,English,,0,0,0,,In this case we get best fit for free
Dialogue: 0,0:43:22.62,0:43:25.72,Chinese,,0,0,0,,在这种情况下，我们最适合空闲块
Dialogue: 0,0:43:26.38,0:43:28.82,English,,0,0,0,,By by virtue of having these size classes
Dialogue: 0,0:43:26.38,0:43:28.82,Chinese,,0,0,0,,由于具有这些尺寸等级
Dialogue: 0,0:43:31.28,0:43:33.36,English,,0,0,0,,And so this is
Dialogue: 0,0:43:31.28,0:43:33.36,Chinese,,0,0,0,,所以这就是
Dialogue: 0,0:43:34.46,0:43:38.06,English,,0,0,0,,You know this is how you can improve your memory utilization
Dialogue: 0,0:43:34.46,0:43:38.06,Chinese,,0,0,0,,你知道这是如何提高内存利用率的方法
Dialogue: 0,0:43:38.70,0:43:39.28,English,,0,0,0,,Yes
Dialogue: 0,0:43:38.70,0:43:39.28,Chinese,,0,0,0,,是
Dialogue: 0,0:43:39.28,0:43:51.44,English,,0,0,0,,[student speaking]
Dialogue: 0,0:43:39.28,0:43:51.44,Chinese,,0,0,0,,学生提问
Dialogue: 0,0:43:51.44,0:43:52.68,English,,0,0,0,,Oh yeah yeah good question
Dialogue: 0,0:43:51.44,0:43:52.68,Chinese,,0,0,0,,哦，是的好问题
Dialogue: 0,0:43:52.68,0:43:56.62,English,,0,0,0,,So the question is break constant time
Dialogue: 0,0:43:52.68,0:43:56.62,Chinese,,0,0,0,,所以问题是是打破常数时间
Dialogue: 0,0:43:57.12,0:43:58.68,English,,0,0,0,,It is but it's very expensive
Dialogue: 0,0:43:57.12,0:43:58.68,Chinese,,0,0,0,,这是非常昂贵的
Dialogue: 0,0:43:59.32,0:44:03.80,English,,0,0,0,,So it's a syscall so it has to pass from user space into the kernel that involves
Dialogue: 0,0:43:59.32,0:44:03.80,Chinese,,0,0,0,,所以它是一个系统调用，所以它必须从用户空间传递到内核
Dialogue: 0,0:44:04.56,0:44:06.54,English,,0,0,0,,Changing contacts changing stacks
Dialogue: 0,0:44:04.56,0:44:06.54,Chinese,,0,0,0,,更改调用人更改堆栈
Dialogue: 0,0:44:08.04,0:44:08.82,English,,0,0,0,,So syscalls
Dialogue: 0,0:44:08.04,0:44:08.82,Chinese,,0,0,0,,系统调用
Dialogue: 0,0:44:10.32,0:44:15.70,English,,0,0,0,,Generally you can count on syscall being like several hundred microseconds
Dialogue: 0,0:44:10.32,0:44:15.70,Chinese,,0,0,0,,一般来说，你可以指望系统调用几百微秒
Dialogue: 0,0:44:16.52,0:44:18.54,English,,0,0,0,,Okay it's a non-trivial overhead
Dialogue: 0,0:44:16.52,0:44:18.54,Chinese,,0,0,0,,但这是一个非常大的开销
Dialogue: 0,0:44:20.24,0:44:22.10,English,,0,0,0,,And so in that case you wouldn't want
Dialogue: 0,0:44:20.24,0:44:22.10,Chinese,,0,0,0,,所以在这种情况下
Dialogue: 0,0:44:22.10,0:44:25.36,English,,0,0,0,,You want to amortize the cost of the break
Dialogue: 0,0:44:22.10,0:44:25.36,Chinese,,0,0,0,,你要分摊中断的开销
Dialogue: 0,0:44:25.96,0:44:28.26,English,,0,0,0,,By allocating is somewhat larger chunk
Dialogue: 0,0:44:25.96,0:44:28.26,Chinese,,0,0,0,,通过分配是一个更大的块
Dialogue: 0,0:44:29.02,0:44:33.50,English,,0,0,0,,But you have to be careful if you allocate too large of a chunk then your memory utilization goes down
Dialogue: 0,0:44:29.02,0:44:33.50,Chinese,,0,0,0,,但是如果分配太大的块然后你的内存利用率下降，你必须要小心
Dialogue: 0,0:44:34.10,0:44:36.94,English,,0,0,0,,So it's a trade-off,it's another one of these space-time trade-offs
Dialogue: 0,0:44:34.10,0:44:36.94,Chinese,,0,0,0,,所以这是一个权衡，这是另一个时空权衡
Dialogue: 0,0:44:37.68,0:44:38.04,English,,0,0,0,,Question
Dialogue: 0,0:44:37.68,0:44:38.04,Chinese,,0,0,0,,请讲
Dialogue: 0,0:44:38.04,0:44:40.90,English,,0,0,0,,[student speaking]
Dialogue: 0,0:44:38.04,0:44:40.90,Chinese,,0,0,0,,学生提问
Dialogue: 0,0:44:40.96,0:44:42.54,English,,0,0,0,,So where do you store this array of free lists
Dialogue: 0,0:44:40.96,0:44:42.54,Chinese,,0,0,0,,那么你在哪里存储这个空闲列表数组
Dialogue: 0,0:44:44.06,0:44:45.70,English,,0,0,0,,So you store it in the beginning of the heap
Dialogue: 0,0:44:44.06,0:44:45.70,Chinese,,0,0,0,,所以你将它存储在堆的开头
Dialogue: 0,0:44:48.90,0:44:51.54,English,,0,0,0,,Yeah in fact for your malloc lab we require you to do that
Dialogue: 0,0:44:48.90,0:44:51.54,Chinese,,0,0,0,,事实上，对于你的 malloc lab，我们要求你这样做
Dialogue: 0,0:44:52.18,0:44:52.66,English,,0,0,0,,We don't know
Dialogue: 0,0:44:52.18,0:44:52.66,Chinese,,0,0,0,,我们不知道
Dialogue: 0,0:44:53.14,0:44:54.28,English,,0,0,0,,And the reason is we can't
Dialogue: 0,0:44:53.14,0:44:54.28,Chinese,,0,0,0,,原因是我们做不到
Dialogue: 0,0:44:55.86,0:44:59.14,English,,0,0,0,,That array affects in some small part
Dialogue: 0,0:44:55.86,0:44:59.14,Chinese,,0,0,0,,该阵列在一些小部分中受到影响
Dialogue: 0,0:44:59.32,0:45:02.76,English,,0,0,0,,Depending on how large that array is it affects your memory utilization
Dialogue: 0,0:44:59.32,0:45:02.76,Chinese,,0,0,0,,取决于该阵列的大小，它会影响你的内存利用率
Dialogue: 0,0:45:03.46,0:45:05.12,English,,0,0,0,,And so it should be at the beginning of the heap
Dialogue: 0,0:45:03.46,0:45:05.12,Chinese,,0,0,0,,所以它应该在堆的开头
Dialogue: 0,0:45:13.20,0:45:17.40,English,,0,0,0,,Okay there's an allocators have been around forever and
Dialogue: 0,0:45:13.20,0:45:17.40,Chinese,,0,0,0,,好的，分配器已经永远存在了
Dialogue: 0,0:45:18.22,0:45:23.46,English,,0,0,0,,That the the classic references can use 1973 text
Dialogue: 0,0:45:18.22,0:45:23.46,Chinese,,0,0,0,,经典参考文献可以追溯到 1973
Dialogue: 0,0:45:25.28,0:45:29.06,English,,0,0,0,,And there's also this great paper which you can get from the books website
Dialogue: 0,0:45:25.28,0:45:29.06,Chinese,,0,0,0,,还有这篇很棒的论文，你可以从书籍网站上获得
Dialogue: 0,0:45:29.74,0:45:32.28,English,,0,0,0,,From 1995 that does a survey of
Dialogue: 0,0:45:29.74,0:45:32.28,Chinese,,0,0,0,,从 1995 年开始进行调查
Dialogue: 0,0:45:33.38,0:45:36.06,English,,0,0,0,,You know literate dozens and dozens of techniques like
Dialogue: 0,0:45:33.38,0:45:36.06,Chinese,,0,0,0,,你知道有数十种技术
Dialogue: 0,0:45:36.10,0:45:37.86,English,,0,0,0,,We're just scratching the surface here
Dialogue: 0,0:45:36.10,0:45:37.86,Chinese,,0,0,0,,我们只是在这里摸索表面
Dialogue: 0,0:45:38.36,0:45:39.92,English,,0,0,0,,So if you're really interested in this stuff
Dialogue: 0,0:45:38.36,0:45:39.92,Chinese,,0,0,0,,所以如果你真的对这些东西感兴趣的话
Dialogue: 0,0:45:41.30,0:45:43.66,English,,0,0,0,,That is that papers a fascinating read
Dialogue: 0,0:45:41.30,0:45:43.66,Chinese,,0,0,0,,那篇文章引人入胜
Dialogue: 0,0:45:43.76,0:45:46.32,English,,0,0,0,,And it may give you some ideas for your free lab
Dialogue: 0,0:45:43.76,0:45:46.32,Chinese,,0,0,0,,它可能会为你的 free lab 提供一些想法
Dialogue: 0,0:45:49.66,0:45:50.88,English,,0,0,0,,Ok now so far
Dialogue: 0,0:45:49.66,0:45:50.88,Chinese,,0,0,0,,好了，到目前为止
Dialogue: 0,0:45:51.56,0:45:58.20,English,,0,0,0,,We're assuming that the application is responsible for both allocating storage and freeing storage
Dialogue: 0,0:45:51.56,0:45:58.20,Chinese,,0,0,0,,我们假设应用程序负责分配存储和释放存储
Dialogue: 0,0:45:59.74,0:46:05.34,English,,0,0,0,,But there's a form of memory managers called implicit memory managers
Dialogue: 0,0:45:59.74,0:46:05.34,Chinese,,0,0,0,,但是有一种称为隐式内存管理器的内存管理器
Dialogue: 0,0:46:05.94,0:46:07.78,English,,0,0,0,,That do the freeing for you
Dialogue: 0,0:46:05.94,0:46:07.78,Chinese,,0,0,0,,它帮助你完成释放
Dialogue: 0,0:46:08.44,0:46:10.74,English,,0,0,0,,So applications allocate space
Dialogue: 0,0:46:08.44,0:46:10.74,Chinese,,0,0,0,,应用程序分配空间
Dialogue: 0,0:46:10.74,0:46:15.58,English,,0,0,0,,But they never have to worry about freeing space the system does that automatically
Dialogue: 0,0:46:10.74,0:46:15.58,Chinese,,0,0,0,,但他们永远不必担心释放空间，系统会自动释放空间
Dialogue: 0,0:46:16.82,0:46:23.70,English,,0,0,0,,And so the idea is to identify so-called garbage
Dialogue: 0,0:46:16.82,0:46:23.70,Chinese,,0,0,0,,因此，想法是识别所谓的垃圾
Dialogue: 0,0:46:24.24,0:46:27.82,English,,0,0,0,,So areas of memory that can never be referenced anymore
Dialogue: 0,0:46:24.24,0:46:27.82,Chinese,,0,0,0,,所以永远不能再引用的内存区域
Dialogue: 0,0:46:28.94,0:46:30.18,English,,0,0,0,,And then free up those blocks
Dialogue: 0,0:46:28.94,0:46:30.18,Chinese,,0,0,0,,然后释放那些块
Dialogue: 0,0:46:32.78,0:46:38.44,English,,0,0,0,,Okay so what's garbage well here's an example we have a function foo  that malloc 128 bytes
Dialogue: 0,0:46:32.78,0:46:38.44,Chinese,,0,0,0,,那有什么垃圾？举个例子，我们有一个函数 foo 里面使用 malloc 分配了 128 字节
Dialogue: 0,0:46:39.26,0:46:41.72,English,,0,0,0,,It stores the address in this pointer p
Dialogue: 0,0:46:39.26,0:46:41.72,Chinese,,0,0,0,,它将地址存储在该指针 p 中
Dialogue: 0,0:46:42.88,0:46:45.86,English,,0,0,0,,And then at some point when it returns from foo
Dialogue: 0,0:46:42.88,0:46:45.86,Chinese,,0,0,0,,然后返回
Dialogue: 0,0:46:46.64,0:46:50.26,English,,0,0,0,,This pointer is lost forever right because p is a local variable on the stack
Dialogue: 0,0:46:46.64,0:46:50.26,Chinese,,0,0,0,,这个指针永远丢失，因为 p 是堆栈上的局部变量
Dialogue: 0,0:46:50.98,0:46:53.46,English,,0,0,0,,So once this function returns
Dialogue: 0,0:46:50.98,0:46:53.46,Chinese,,0,0,0,,一旦这个函数返回
Dialogue: 0,0:46:54.14,0:46:59.10,English,,0,0,0,,That the block of memory pointed to by p is garbage can never be referenced again
Dialogue: 0,0:46:54.14,0:46:59.10,Chinese,,0,0,0,,p 指向的内存块是垃圾，永远不能再被引用
Dialogue: 0,0:47:00.46,0:47:04.20,English,,0,0,0,,Because there's no way,there's no way for the program to get get access to that
Dialogue: 0,0:47:00.46,0:47:04.20,Chinese,,0,0,0,,因为没有办法，程序无法获得访问权限
Dialogue: 0,0:47:05.46,0:47:07.82,English,,0,0,0,,And so what an allocator will recognize
Dialogue: 0,0:47:05.46,0:47:07.82,Chinese,,0,0,0,,那么分配器会识别什么
Dialogue: 0,0:47:08.02,0:47:11.78,English,,0,0,0,,At some point that this block of memory is garbage
Dialogue: 0,0:47:08.02,0:47:11.78,Chinese,,0,0,0,,在某些时候，这块内存是垃圾
Dialogue: 0,0:47:12.18,0:47:14.64,English,,0,0,0,,And that it will free those blocks by calling free
Dialogue: 0,0:47:12.18,0:47:14.64,Chinese,,0,0,0,,并且它将通过调用 free 来释放这些块
Dialogue: 0,0:47:14.64,0:47:17.34,English,,0,0,0,,It's the same kind of exactly the same free call
Dialogue: 0,0:47:14.64,0:47:17.34,Chinese,,0,0,0,,调用的是相同的 free 函数
Dialogue: 0,0:47:17.90,0:47:19.42,English,,0,0,0,,As we've discussed
Dialogue: 0,0:47:17.90,0:47:19.42,Chinese,,0,0,0,,正如我们所讨论的那样
Dialogue: 0,0:47:19.58,0:47:24.40,English,,0,0,0,,But now it's called by the garbage collector not by the application
Dialogue: 0,0:47:19.58,0:47:24.40,Chinese,,0,0,0,,但现在它被垃圾收集器调用而不是应用程序
Dialogue: 0,0:47:25.20,0:47:30.00,English,,0,0,0,,Okay so you see this in all different kinds of dynamic languages
Dialogue: 0,0:47:25.20,0:47:30.00,Chinese,,0,0,0,,好吧，你可以在所有不同类型的动态语言中看到这一点
Dialogue: 0,0:47:30.52,0:47:34.74,English,,0,0,0,,And there's there's there's also variants available for C
Dialogue: 0,0:47:30.52,0:47:34.74,Chinese,,0,0,0,,而且还有可用于 C 的变体
Dialogue: 0,0:47:34.74,0:47:38.36,English,,0,0,0,,But because of C's pointer properties
Dialogue: 0,0:47:34.74,0:47:38.36,Chinese,,0,0,0,,但是因为 C 的指针属性
Dialogue: 0,0:47:38.96,0:47:42.96,English,,0,0,0,,That the garbage collectors for C are conservative in the sense
Dialogue: 0,0:47:38.96,0:47:42.96,Chinese,,0,0,0,,从某种意义上说，C 的垃圾收集器是保守的
Dialogue: 0,0:47:42.96,0:47:45.24,English,,0,0,0,,That there's some blocks won't be freed
Dialogue: 0,0:47:42.96,0:47:45.24,Chinese,,0,0,0,,有一些块将不会被释放
Dialogue: 0,0:47:45.48,0:47:48.42,English,,0,0,0,,There's some garbage blocks that won't be free
Dialogue: 0,0:47:45.48,0:47:48.42,Chinese,,0,0,0,,有些垃圾块不会释放
Dialogue: 0,0:47:48.42,0:47:54.72,English,,0,0,0,,Because the allocator can't determine that they are indeed garbage
Dialogue: 0,0:47:48.42,0:47:54.72,Chinese,,0,0,0,,因为分配器无法确定它们是垃圾
Dialogue: 0,0:47:55.10,0:47:57.42,English,,0,0,0,,So it has to be careful when it whenever there's a doubt
Dialogue: 0,0:47:55.10,0:47:57.42,Chinese,,0,0,0,,因此，只要有疑问，就必须小心
Dialogue: 0,0:47:58.08,0:48:02.94,English,,0,0,0,,It it leaves it doesn't reclaim the allocated block
Dialogue: 0,0:47:58.08,0:48:02.94,Chinese,,0,0,0,,所以不会回收这些分配的块
Dialogue: 0,0:48:07.04,0:48:12.16,English,,0,0,0,,So it gets to this question of like how does the memory manager know when memory can be free
Dialogue: 0,0:48:07.04,0:48:12.16,Chinese,,0,0,0,,所以有这样一个问题，内存管理器如何知道内存何时可以被释放
Dialogue: 0,0:48:13.18,0:48:15.52,English,,0,0,0,,And you know if we knew
Dialogue: 0,0:48:13.18,0:48:15.52,Chinese,,0,0,0,,而且
Dialogue: 0,0:48:16.50,0:48:19.44,English,,0,0,0,,If somehow we knew we could predict all of the future requests
Dialogue: 0,0:48:16.50,0:48:19.44,Chinese,,0,0,0,,如果以某种方式我们知道我们可以预测所有未来的请求
Dialogue: 0,0:48:20.28,0:48:24.94,English,,0,0,0,,And then if we knew that there were no future requests access that block then we could free it
Dialogue: 0,0:48:20.28,0:48:24.94,Chinese,,0,0,0,,然后，如果我们知道将来没有请求访问该块，那么我们可以释放它
Dialogue: 0,0:48:25.62,0:48:26.88,English,,0,0,0,,Okay but we can't predict that
Dialogue: 0,0:48:25.62,0:48:26.88,Chinese,,0,0,0,,好的，但我们无法预测
Dialogue: 0,0:48:28.64,0:48:29.64,English,,0,0,0,,Okay so we have to
Dialogue: 0,0:48:28.64,0:48:29.64,Chinese,,0,0,0,,所以我们可以......
Dialogue: 0,0:48:31.66,0:48:32.94,English,,0,0,0,,But if there's no pointers
Dialogue: 0,0:48:31.66,0:48:32.94,Chinese,,0,0,0,,但如果没有指针
Dialogue: 0,0:48:33.48,0:48:37.44,English,,0,0,0,,If no pointers exist to a particular block then we know that it can't be accessed
Dialogue: 0,0:48:33.48,0:48:37.44,Chinese,,0,0,0,,如果特定块没有指针，那么我们就知道无法访问它
Dialogue: 0,0:48:38.06,0:48:40.50,English,,0,0,0,,Okay and so that we can predict right if there's some way
Dialogue: 0,0:48:38.06,0:48:40.50,Chinese,,0,0,0,,好的，以便我们可以预测是否有某种方式
Dialogue: 0,0:48:40.98,0:48:49.36,English,,0,0,0,,We can sort of scan the program identify or scan the memory identify all the pointers in that memory
Dialogue: 0,0:48:40.98,0:48:49.36,Chinese,,0,0,0,,我们可以扫描程序识别或扫描内存识别该内存中的所有指针
Dialogue: 0,0:48:50.00,0:48:52.80,English,,0,0,0,,And and see which blocks are pointed to
Dialogue: 0,0:48:50.00,0:48:52.80,Chinese,,0,0,0,,并查看指向哪些块
Dialogue: 0,0:48:53.30,0:48:57.88,English,,0,0,0,,And if they're not pointed to by any pointer than then they're garbage by definition
Dialogue: 0,0:48:53.30,0:48:57.88,Chinese,,0,0,0,,如果它们没有被任何指针指向，那么根据定义它们就是垃圾
Dialogue: 0,0:48:58.98,0:49:02.56,English,,0,0,0,,Okay so to do this though it's difficult
Dialogue: 0,0:48:58.98,0:49:02.56,Chinese,,0,0,0,,好的，这样做虽然很难
Dialogue: 0,0:49:04.00,0:49:08.66,English,,0,0,0,,So first of all the memory manager has to be able to distinguish pointers from non pointers
Dialogue: 0,0:49:04.00,0:49:08.66,Chinese,,0,0,0,,首先，内存管理器必须能够区分指针和非指针
Dialogue: 0,0:49:09.66,0:49:14.58,English,,0,0,0,,Which we can't do and see right they're just these integral values
Dialogue: 0,0:49:09.66,0:49:14.58,Chinese,,0,0,0,,我们做不到，他们只是一个值
Dialogue: 0,0:49:14.62,0:49:17.18,English,,0,0,0,,Right we don't know it could be it
Dialogue: 0,0:49:14.62,0:49:17.18,Chinese,,0,0,0,,我们不知道它是不是指针
Dialogue: 0,0:49:18.12,0:49:19.98,English,,0,0,0,,If we see this large integral value
Dialogue: 0,0:49:18.12,0:49:19.98,Chinese,,0,0,0,,如果我们看到这个大值
Dialogue: 0,0:49:20.56,0:49:22.96,English,,0,0,0,,This large long a 8 byte value
Dialogue: 0,0:49:20.56,0:49:22.96,Chinese,,0,0,0,,这个大的长 8 字节值
Dialogue: 0,0:49:23.70,0:49:28.04,English,,0,0,0,,It could be pointing to a data structure it could just be a large integer right
Dialogue: 0,0:49:23.70,0:49:28.04,Chinese,,0,0,0,,它可能指向一个数据结构，它可能只是一个大整数
Dialogue: 0,0:49:28.10,0:49:28.92,English,,0,0,0,,We don't know
Dialogue: 0,0:49:28.10,0:49:28.92,Chinese,,0,0,0,,我们不知道
Dialogue: 0,0:49:32.48,0:49:36.98,English,,0,0,0,,And then we also all pointers have to point to the start of a block which is not true and see either
Dialogue: 0,0:49:32.48,0:49:36.98,Chinese,,0,0,0,,然后我们所有指针都必须指向一个的块的开始，这个我们也看不到
Dialogue: 0,0:49:38.60,0:49:42.92,English,,0,0,0,,Okay so if we have a pointer and we identify that it's a pointer
Dialogue: 0,0:49:38.60,0:49:42.92,Chinese,,0,0,0,,好的，如果我们有一个指针，我们发现它是一个指针
Dialogue: 0,0:49:43.08,0:49:45.92,English,,0,0,0,,Then we know that it points to some block
Dialogue: 0,0:49:43.08,0:49:45.92,Chinese,,0,0,0,,然后我们知道它指向一些块
Dialogue: 0,0:49:45.92,0:49:49.78,English,,0,0,0,,If it points inside of a block how do we how do we find the beginning of that block
Dialogue: 0,0:49:45.92,0:49:49.78,Chinese,,0,0,0,,如果它指向一个块的内部，我们如何找到该块的开头
Dialogue: 0,0:49:50.92,0:49:52.80,English,,0,0,0,,You know how do we know how big that block is
Dialogue: 0,0:49:50.92,0:49:52.80,Chinese,,0,0,0,,你知道我们怎么知道那个块有多大
Dialogue: 0,0:49:53.24,0:49:58.14,English,,0,0,0,,All right so it has to point to the beginning of the block where the header  tells us the size and
Dialogue: 0,0:49:53.24,0:49:58.14,Chinese,,0,0,0,,所以它必须指向块的开头，头部告诉我们块大小
Dialogue: 0,0:50:00.98,0:50:03.14,English,,0,0,0,,The and there can't be a way to hide pointers
Dialogue: 0,0:50:00.98,0:50:03.14,Chinese,,0,0,0,,并且没有办法隐藏指针
Dialogue: 0,0:50:03.14,0:50:06.66,English,,0,0,0,,The point that the property of being a pointer has to be some kind of static
Dialogue: 0,0:50:03.14,0:50:06.66,Chinese,,0,0,0,,作为指针的属性必须是某种静态的点
Dialogue: 0,0:50:07.64,0:50:09.66,English,,0,0,0,,Thing that doesn't that can't change
Dialogue: 0,0:50:07.64,0:50:09.66,Chinese,,0,0,0,,那不能改变的东西
Dialogue: 0,0:50:11.92,0:50:13.04,English,,0,0,0,,So that's sort of the challenges
Dialogue: 0,0:50:11.92,0:50:13.04,Chinese,,0,0,0,,所以这就是挑战
Dialogue: 0,0:50:13.04,0:50:15.60,English,,0,0,0,,If you're thinking about how in the world can you implement a garbage collector
Dialogue: 0,0:50:13.04,0:50:15.60,Chinese,,0,0,0,,如果你正在考虑究竟如何实现垃圾收集器
Dialogue: 0,0:50:15.60,0:50:18.76,English,,0,0,0,,So those are some of the challenges that they present
Dialogue: 0,0:50:15.60,0:50:18.76,Chinese,,0,0,0,,所以这些是他们提出的一些挑战
Dialogue: 0,0:50:19.38,0:50:25.54,English,,0,0,0,,And because of that this is this been a the history of research and garbage collectors is old
Dialogue: 0,0:50:19.38,0:50:25.54,Chinese,,0,0,0,,而正因为如此，这是研究它的历史，垃圾回收是一个非常古老问题
Dialogue: 0,0:50:26.00,0:50:28.04,English,,0,0,0,,Its ancient and ongoing
Dialogue: 0,0:50:26.00,0:50:28.04,Chinese,,0,0,0,,它古老而持续
Dialogue: 0,0:50:28.14,0:50:32.74,English,,0,0,0,,It's still it's still ongoing today particularly in the context of parallel programs
Dialogue: 0,0:50:28.14,0:50:32.74,Chinese,,0,0,0,,今天仍在继续研究，特别是在并行程序的背景下
Dialogue: 0,0:50:32.78,0:50:36.44,English,,0,0,0,,And garbage collecting programs that are running multiple threads
Dialogue: 0,0:50:32.78,0:50:36.44,Chinese,,0,0,0,,程序运行多个线程进行垃圾回收
Dialogue: 0,0:50:37.10,0:50:38.50,English,,0,0,0,,So there's a whole bunch of these things
Dialogue: 0,0:50:37.10,0:50:38.50,Chinese,,0,0,0,,所以这里有很多东西
Dialogue: 0,0:50:40.24,0:50:43.00,English,,0,0,0,,That people have looked at going all the way back to 1960
Dialogue: 0,0:50:40.24,0:50:43.00,Chinese,,0,0,0,,人们研究它的历史能一直追溯到 1960 年
Dialogue: 0,0:50:44.44,0:50:47.34,English,,0,0,0,,Today we'll look at we'll look at the simplest
Dialogue: 0,0:50:44.44,0:50:47.34,Chinese,,0,0,0,,今天我们来看看最简单的
Dialogue: 0,0:50:48.06,0:50:50.18,English,,0,0,0,,What one of the simpler variants called mark-and-sweep
Dialogue: 0,0:50:48.06,0:50:50.18,Chinese,,0,0,0,,其中之一称为「标记和扫描」
Dialogue: 0,0:50:50.40,0:50:51.94,English,,0,0,0,,And we won't discuss the rest
Dialogue: 0,0:50:50.40,0:50:51.94,Chinese,,0,0,0,,我们不会讨论其余的问题
Dialogue: 0,0:50:52.58,0:50:57.12,English,,0,0,0,,But if you're interested in them there's a pretty good book that describes that describes these things
Dialogue: 0,0:50:52.58,0:50:57.12,Chinese,,0,0,0,,但是，如果你对它们感兴趣，有一本非常好的书介绍这些内容
Dialogue: 0,0:51:00.24,0:51:01.86,English,,0,0,0,,All right so how do we build an allocator
Dialogue: 0,0:51:00.24,0:51:01.86,Chinese,,0,0,0,,好的，我们如何建立一个分配器
Dialogue: 0,0:51:02.66,0:51:05.16,English,,0,0,0,,So we start by viewing memory as a directed graph
Dialogue: 0,0:51:02.66,0:51:05.16,Chinese,,0,0,0,,我们首先将内存视为有向图
Dialogue: 0,0:51:05.88,0:51:11.30,English,,0,0,0,,Where each node in the graph corresponds to a block
Dialogue: 0,0:51:05.88,0:51:11.30,Chinese,,0,0,0,,图中的每个节点对应一个块
Dialogue: 0,0:51:13.46,0:51:14.76,English,,0,0,0,,Okay a block a heap block
Dialogue: 0,0:51:13.46,0:51:14.76,Chinese,,0,0,0,,好吧一个堆块
Dialogue: 0,0:51:19.39,0:51:21.64,English,,0,0,0,,And an allocated heap block
Dialogue: 0,0:51:19.39,0:51:21.64,Chinese,,0,0,0,,一个分配的堆块
Dialogue: 0,0:51:24.52,0:51:28.62,English,,0,0,0,,And each edge is a pointer that's contained somewhere within that block
Dialogue: 0,0:51:24.52,0:51:28.62,Chinese,,0,0,0,,每个边都是一个包含在该块内某处的指针
Dialogue: 0,0:51:29.82,0:51:31.04,English,,0,0,0,,Okay a pointer to another block
Dialogue: 0,0:51:29.82,0:51:31.04,Chinese,,0,0,0,,好的指向另一个块的指针
Dialogue: 0,0:51:33.42,0:51:37.08,English,,0,0,0,,And then there's special nodes called root nodes
Dialogue: 0,0:51:33.42,0:51:37.08,Chinese,,0,0,0,,然后有一些称为根节点的特殊节点
Dialogue: 0,0:51:37.92,0:51:40.68,English,,0,0,0,,That contain pointers into the heap but they're not part of the heap
Dialogue: 0,0:51:37.92,0:51:40.68,Chinese,,0,0,0,,它包含指向堆的指针，但它们不是堆的一部分
Dialogue: 0,0:51:41.26,0:51:43.94,English,,0,0,0,,So for example pointers that are stored on the stack
Dialogue: 0,0:51:41.26,0:51:43.94,Chinese,,0,0,0,,例如存储在堆栈上的指针
Dialogue: 0,0:51:44.82,0:51:46.36,English,,0,0,0,,Pointers that are stored in registers
Dialogue: 0,0:51:44.82,0:51:46.36,Chinese,,0,0,0,,存储在寄存器中的指针
Dialogue: 0,0:51:47.30,0:51:49.60,English,,0,0,0,,They point to memory locations in the heap
Dialogue: 0,0:51:47.30,0:51:49.60,Chinese,,0,0,0,,它们指向堆中的内存位置
Dialogue: 0,0:51:50.72,0:51:56.06,English,,0,0,0,,But nothing and but there outside of the heap
Dialogue: 0,0:51:50.72,0:51:56.06,Chinese,,0,0,0,,但除了堆外
Dialogue: 0,0:51:56.66,0:51:57.92,English,,0,0,0,,So and we call those route notes
Dialogue: 0,0:51:56.66,0:51:57.92,Chinese,,0,0,0,,我们称这些路线结点
Dialogue: 0,0:51:57.92,0:52:00.88,English,,0,0,0,,So nothing points to them or at least if something does point to them
Dialogue: 0,0:51:57.92,0:52:00.88,Chinese,,0,0,0,,所以没有任何东西指向他们，或者至少如果有什么东西指向他们
Dialogue: 0,0:52:00.88,0:52:02.16,English,,0,0,0,,We don't care about what it is
Dialogue: 0,0:52:00.88,0:52:02.16,Chinese,,0,0,0,,我们不关心它是什么
Dialogue: 0,0:52:04.06,0:52:09.98,English,,0,0,0,,Okay we're only concerned about characterizing nodes that correspond to memory in the heap
Dialogue: 0,0:52:04.06,0:52:09.98,Chinese,,0,0,0,,我们只关心表征与堆中的内存相对应的节点
Dialogue: 0,0:52:11.22,0:52:15.44,English,,0,0,0,,So I we say that a a node or a block is reachable
Dialogue: 0,0:52:11.22,0:52:15.44,Chinese,,0,0,0,,所以我说我们可以访问一个节点或一个块
Dialogue: 0,0:52:15.44,0:52:17.48,English,,0,0,0,,If there's some path from a root node
Dialogue: 0,0:52:15.44,0:52:17.48,Chinese,,0,0,0,,如果有一个来自根节点的路径
Dialogue: 0,0:52:19.90,0:52:21.62,English,,0,0,0,,From a root node to that block
Dialogue: 0,0:52:19.90,0:52:21.62,Chinese,,0,0,0,,从根节点到该块
Dialogue: 0,0:52:21.68,0:52:24.10,English,,0,0,0,,So and we've denoted those by green
Dialogue: 0,0:52:21.68,0:52:24.10,Chinese,,0,0,0,,所以我们用绿色表示了那些
Dialogue: 0,0:52:24.16,0:52:26.70,English,,0,0,0,,So all of these green blocks in the heap are reachable
Dialogue: 0,0:52:24.16,0:52:26.70,Chinese,,0,0,0,,因此堆中的所有这些绿色块都是可访问的
Dialogue: 0,0:52:27.17,0:52:33.54,English,,0,0,0,,Because you can start at a root node and just follow some sequence of pointers to get to that node
Dialogue: 0,0:52:27.17,0:52:33.54,Chinese,,0,0,0,,因为你可以从根节点开始，只需按照一些指针序列即可到达该节点
Dialogue: 0,0:52:35.44,0:52:40.34,English,,0,0,0,,Nodes that aren't reachable are called a garbage
Dialogue: 0,0:52:35.44,0:52:40.34,Chinese,,0,0,0,,无法访问的结点称为垃圾
Dialogue: 0,0:52:40.74,0:52:44.50,English,,0,0,0,,Because there's  no way to get to them from the root nodes
Dialogue: 0,0:52:40.74,0:52:44.50,Chinese,,0,0,0,,因为没有办法从根节点到达它们
Dialogue: 0,0:52:45.18,0:52:48.46,English,,0,0,0,,Okay so there's no node inside the heap that points to them
Dialogue: 0,0:52:45.18,0:52:48.46,Chinese,,0,0,0,,好的，所以堆里面没有指向它们的节点
Dialogue: 0,0:52:48.46,0:52:52.06,English,,0,0,0,,And there's no node, there's no root node that points to them
Dialogue: 0,0:52:48.46,0:52:52.06,Chinese,,0,0,0,,并且没有指向它们的根节点
Dialogue: 0,0:52:52.06,0:52:54.32,English,,0,0,0,,So basically there's just no path from a root node
Dialogue: 0,0:52:52.06,0:52:54.32,Chinese,,0,0,0,,所以基本上没有来自根节点的路径
Dialogue: 0,0:52:54.66,0:52:59.04,English,,0,0,0,,That'll get you to one of these non reachable or garbage nodes
Dialogue: 0,0:52:54.66,0:52:59.04,Chinese,,0,0,0,,使你进入这些不可达或垃圾节点之一
Dialogue: 0,0:53:00.04,0:53:01.44,English,,0,0,0,,And since they're non reachable
Dialogue: 0,0:53:00.04,0:53:01.44,Chinese,,0,0,0,,因为他们无法到达
Dialogue: 0,0:53:03.20,0:53:06.04,English,,0,0,0,,The application will never be able to reference them in the future
Dialogue: 0,0:53:03.20,0:53:06.04,Chinese,,0,0,0,,该应用程序将来永远无法引用它们
Dialogue: 0,0:53:06.38,0:53:07.88,English,,0,0,0,,So we can predict with certainty
Dialogue: 0,0:53:06.38,0:53:07.88,Chinese,,0,0,0,,所以我们可以肯定地预测
Dialogue: 0,0:53:08.26,0:53:10.78,English,,0,0,0,,That that those are garbage and they can be freed
Dialogue: 0,0:53:08.26,0:53:10.78,Chinese,,0,0,0,,那些是垃圾，它们可以被释放
Dialogue: 0,0:53:13.56,0:53:16.28,English,,0,0,0,,So basically after we free these then they're removed from the graph
Dialogue: 0,0:53:13.56,0:53:16.28,Chinese,,0,0,0,,所以基本上在我们释放这些之后，它们就会从图表中删除
Dialogue: 0,0:53:23.58,0:53:25.14,English,,0,0,0,,So now we can build
Dialogue: 0,0:53:23.58,0:53:25.14,Chinese,,0,0,0,,所以现在我们可以建立
Dialogue: 0,0:53:26.62,0:53:30.48,English,,0,0,0,,A simple garbage collector on top of the existing malloc and free package
Dialogue: 0,0:53:26.62,0:53:30.48,Chinese,,0,0,0,,基于现有 malloc 和 free 软件包之上的简单垃圾收集器
Dialogue: 0,0:53:30.72,0:53:33.64,English,,0,0,0,,Right so you implement malloc and free just like before
Dialogue: 0,0:53:30.72,0:53:33.64,Chinese,,0,0,0,,像以前一样实现 malloc 和 free
Dialogue: 0,0:53:34.78,0:53:36.62,English,,0,0,0,,And then you the program
Dialogue: 0,0:53:34.78,0:53:36.62,Chinese,,0,0,0,,然后你的程序
Dialogue: 0,0:53:38.88,0:53:41.30,English,,0,0,0,,Calls malloc just like before
Dialogue: 0,0:53:38.88,0:53:41.30,Chinese,,0,0,0,,像以前一样调用 malloc
Dialogue: 0,0:53:41.30,0:53:45.18,English,,0,0,0,,And you just you do malloc exactly the same way until you run out of space
Dialogue: 0,0:53:41.30,0:53:45.18,Chinese,,0,0,0,,而且你只是以完全相同的方式做 malloc，直到你的空间不足为止
Dialogue: 0,0:53:45.70,0:53:48.40,English,,0,0,0,,By whatever different definition you want to use of running out of space
Dialogue: 0,0:53:45.70,0:53:48.40,Chinese,,0,0,0,,通过任何不同的定义，你希望使空间不足
Dialogue: 0,0:53:48.40,0:53:51.78,English,,0,0,0,,Maybe you have some kind of maximum heap size you're willing to use
Dialogue: 0,0:53:48.40,0:53:51.78,Chinese,,0,0,0,,也许你愿意使用的最大的堆
Dialogue: 0,0:53:52.16,0:53:55.40,English,,0,0,0,,Or at some point the os will just stop giving you virtual memory
Dialogue: 0,0:53:52.16,0:53:55.40,Chinese,,0,0,0,,或者在某些时候，操作系统将停止为你提供虚拟内存
Dialogue: 0,0:53:56.94,0:53:58.08,English,,0,0,0,,When you run out of space
Dialogue: 0,0:53:56.94,0:53:58.08,Chinese,,0,0,0,,当你的空间不足时
Dialogue: 0,0:54:01.26,0:54:06.68,English,,0,0,0,,You add an extra mark bit into the header of each block
Dialogue: 0,0:54:01.26,0:54:06.68,Chinese,,0,0,0,,你在每个块的头部中添加一个额外的标记位
Dialogue: 0,0:54:06.68,0:54:10.40,English,,0,0,0,,So this could be you know we have like 3 or 4 spare bits
Dialogue: 0,0:54:06.68,0:54:10.40,Chinese,,0,0,0,,所以这可能是你知道我们有 3 或 4 个备用位
Dialogue: 0,0:54:10.40,0:54:11.68,English,,0,0,0,,That we can use in the header
Dialogue: 0,0:54:10.40,0:54:11.68,Chinese,,0,0,0,,我们可以在头部中使用
Dialogue: 0,0:54:12.06,0:54:14.14,English,,0,0,0,,So we can denote one of those as the mark bit
Dialogue: 0,0:54:12.06,0:54:14.14,Chinese,,0,0,0,,所以我们可以将其中一个表示为标记位
Dialogue: 0,0:54:15.42,0:54:17.48,English,,0,0,0,,And then we are garbage collection
Dialogue: 0,0:54:15.42,0:54:17.48,Chinese,,0,0,0,,然后我们是垃圾收集
Dialogue: 0,0:54:20.30,0:54:26.28,English,,0,0,0,,Our garbage collection phase when we run out of space consists of two different sub phases
Dialogue: 0,0:54:20.30,0:54:26.28,Chinese,,0,0,0,,当我们用完空间时，我们的垃圾回收包括两个不同的子阶段
Dialogue: 0,0:54:26.28,0:54:28.86,English,,0,0,0,, One is the mark phase which starts at all the roots
Dialogue: 0,0:54:26.28,0:54:28.86,Chinese,,0,0,0,,之一是从所有根节点开始的标记
Dialogue: 0,0:54:29.66,0:54:32.88,English,,0,0,0,,And then and it just traverses this from the roots
Dialogue: 0,0:54:29.66,0:54:32.88,Chinese,,0,0,0,,然后它只是从根结点上穿过它
Dialogue: 0,0:54:32.88,0:54:36.00,English,,0,0,0,,It traverses the set of of nodes
Dialogue: 0,0:54:32.88,0:54:36.00,Chinese,,0,0,0,,遍历所有节点
Dialogue: 0,0:54:36.00,0:54:39.90,English,,0,0,0,,That are reachable from the root and it sets the mark bit in each one of those nodes
Dialogue: 0,0:54:36.00,0:54:39.90,Chinese,,0,0,0,,可从根访问，并在每个节点中设置标记位
Dialogue: 0,0:54:40.60,0:54:47.54,English,,0,0,0,,Okay and then once after you finish marking all of the reachable blocks
Dialogue: 0,0:54:40.60,0:54:47.54,Chinese,,0,0,0,,好的，然后在完成标记所有可到达的块之后
Dialogue: 0,0:54:47.96,0:54:51.36,English,,0,0,0,,Then you sweep through the entire heap starting at the very beginning of the heap
Dialogue: 0,0:54:47.96,0:54:51.36,Chinese,,0,0,0,,然后从堆的最开始扫描整个堆
Dialogue: 0,0:54:52.26,0:54:57.30,English,,0,0,0,,And you look for all allocated blocks that aren't marked
Dialogue: 0,0:54:52.26,0:54:57.30,Chinese,,0,0,0,,并且查找未标记的所有已分配块
Dialogue: 0,0:54:58.36,0:55:00.78,English,,0,0,0,,So they're not marked they're not reachable in their garbage
Dialogue: 0,0:54:58.36,0:55:00.78,Chinese,,0,0,0,,所以它们没有标记没有办法遍历到几点就是垃圾
Dialogue: 0,0:55:02.88,0:55:10.96,English,,0,0,0,,So first, you do a search from the roots
Dialogue: 0,0:55:02.88,0:55:10.96,Chinese,,0,0,0,,首先，你从根节点开始搜索
Dialogue: 0,0:55:10.98,0:55:12.94,English,,0,0,0,,And then you do a sweep of the entire heap
Dialogue: 0,0:55:10.98,0:55:12.94,Chinese,,0,0,0,,然后你扫描整个堆
Dialogue: 0,0:55:18.14,0:55:22.52,English,,0,0,0,,So let's say before the marks
Dialogue: 0,0:55:18.14,0:55:22.52,Chinese,,0,0,0,,所以，在标记之前
Dialogue: 0,0:55:23.48,0:55:28.70,English,,0,0,0,,We have a heap that looks like this,we have a single root that points to this block
Dialogue: 0,0:55:23.48,0:55:28.70,Chinese,,0,0,0,,我们有一个看起来像这样的堆，我们有一个指向这个块的根
Dialogue: 0,0:55:29.78,0:55:34.92,English,,0,0,0,,And what we're going to do here we're always going to point to the payload right of the block
Dialogue: 0,0:55:29.78,0:55:34.92,Chinese,,0,0,0,,而我们在这里要做的就是总是指向块的有效载荷
Dialogue: 0,0:55:35.30,0:55:36.64,English,,0,0,0,,It's just a convention that we use
Dialogue: 0,0:55:35.30,0:55:36.64,Chinese,,0,0,0,,这只是我们使用的惯例
Dialogue: 0,0:55:37.82,0:55:40.16,English,,0,0,0,,So we're pointing to the beginning of the block
Dialogue: 0,0:55:37.82,0:55:40.16,Chinese,,0,0,0,,所以我们指的是块的开头
Dialogue: 0,0:55:40.78,0:55:46.18,English,,0,0,0,,Because we know that the header is one word behind it
Dialogue: 0,0:55:40.78,0:55:46.18,Chinese,,0,0,0,,因为我们知道头部后是一个字
Dialogue: 0,0:55:47.90,0:55:50.60,English,,0,0,0,,And so let's say and in this case
Dialogue: 0,0:55:47.90,0:55:50.60,Chinese,,0,0,0,,在这种情况下
Dialogue: 0,0:55:52.34,0:55:55.50,English,,0,0,0,,The edges denote pointers that are contained in the block
Dialogue: 0,0:55:52.34,0:55:55.50,Chinese,,0,0,0,,边表示块中包含的指针
Dialogue: 0,0:55:55.86,0:55:58.58,English,,0,0,0,,So they're not the previous and next pointers that we were maintaining
Dialogue: 0,0:55:55.86,0:55:58.58,Chinese,,0,0,0,,所以它们不是我们维护的上一个和下一个指针
Dialogue: 0,0:55:58.58,0:56:02.36,English,,0,0,0,,These are just pointers that the application has put into those blocks
Dialogue: 0,0:55:58.58,0:56:02.36,Chinese,,0,0,0,,这些只是应用程序放入这些块的指针
Dialogue: 0,0:56:03.62,0:56:08.08,English,,0,0,0,,So here we have the root pointing to this the central block
Dialogue: 0,0:56:03.62,0:56:08.08,Chinese,,0,0,0,,这里我们有根指向这个中心块
Dialogue: 0,0:56:08.94,0:56:12.96,English,,0,0,0,,And then there's a pointer that points to this block
Dialogue: 0,0:56:08.94,0:56:12.96,Chinese,,0,0,0,,然后有一个指向这个块的指针
Dialogue: 0,0:56:12.96,0:56:15.62,English,,0,0,0,,And there's another pointer that points to this block and
Dialogue: 0,0:56:12.96,0:56:15.62,Chinese,,0,0,0,,并且还有另一个指向此块的指针
Dialogue: 0,0:56:16.18,0:56:18.76,English,,0,0,0,,And there's a pointer in this block that points to this block
Dialogue: 0,0:56:16.18,0:56:18.76,Chinese,,0,0,0,,并且此块中有一个指针指向此块
Dialogue: 0,0:56:20.72,0:56:22.00,English,,0,0,0,,So after we do the mark
Dialogue: 0,0:56:20.72,0:56:22.00,Chinese,,0,0,0,,所以在我们做了标记之后
Dialogue: 0,0:56:22.78,0:56:25.96,English,,0,0,0,,And we search this we search these and then
Dialogue: 0,0:56:22.78,0:56:25.96,Chinese,,0,0,0,,我们搜索这些之后
Dialogue: 0,0:56:26.52,0:56:30.58,English,,0,0,0,,All of the reachable blocks have the mark bit set which is denoted by pink
Dialogue: 0,0:56:26.52,0:56:30.58,Chinese,,0,0,0,,所有可到达的块都具有标记位设置，其由粉红色表示
Dialogue: 0,0:56:31.80,0:56:36.56,English,,0,0,0,,And so then the the blocks that aren't marked then we can free
Dialogue: 0,0:56:31.80,0:56:36.56,Chinese,,0,0,0,,然后那些没有标记的块然后我们就可以释放了
Dialogue: 0,0:56:38.74,0:56:39.82,English,,0,0,0,,And return to the free list
Dialogue: 0,0:56:38.74,0:56:39.82,Chinese,,0,0,0,,并返回空闲列表
Dialogue: 0,0:56:43.32,0:56:48.48,English,,0,0,0,,Okay so let's look at the assumptions for a simple implementation just to make sure this is clear
Dialogue: 0,0:56:43.32,0:56:48.48,Chinese,,0,0,0,,好的，让我们看一下这个假设的简单实现，能让大家更清楚
Dialogue: 0,0:56:49.60,0:56:55.28,English,,0,0,0,,So the application calls new to get a pointer to a block with all the values cleared
Dialogue: 0,0:56:49.60,0:56:55.28,Chinese,,0,0,0,,应用程序调用 new 来获取指针指向清除所有值内存块
Dialogue: 0,0:56:57.28,0:57:00.94,English,,0,0,0,,It calls read(b,i) to read location i of block b
Dialogue: 0,0:56:57.28,0:57:00.94,Chinese,,0,0,0,,它调用 read(b, i) 来读取块 b 的位置 i
Dialogue: 0,0:57:01.74,0:57:08.14,English,,0,0,0,,And it uses write(b,i,v) to write a value v into location i of block b
Dialogue: 0,0:57:01.74,0:57:08.14,Chinese,,0,0,0,,并且它使用 write(b, i, v) 将值 v 写入块 b 的位置 i
Dialogue: 0,0:57:09.08,0:57:13.06,English,,0,0,0,,Then each block will have a header word which will address as b[-1]
Dialogue: 0,0:57:09.08,0:57:13.06,Chinese,,0,0,0,,然后每个块将有一个头部字，其地址为 b[-1]
Dialogue: 0,0:57:16.64,0:57:18.24,English,,0,0,0,,And then the garbage collector has
Dialogue: 0,0:57:16.64,0:57:18.24,Chinese,,0,0,0,,然后垃圾收集器
Dialogue: 0,0:57:19.58,0:57:24.06,English,,0,0,0,,It has functions that it uses to identify whether a pointer
Dialogue: 0,0:57:19.58,0:57:24.06,Chinese,,0,0,0,,它具有用于识别指针的功能
Dialogue: 0,0:57:24.50,0:57:27.34,English,,0,0,0,,Whether its input parameter is indeed a pointer
Dialogue: 0,0:57:24.50,0:57:27.34,Chinese,,0,0,0,,它的输入参数是否确实是一个指针
Dialogue: 0,0:57:27.54,0:57:30.48,English,,0,0,0,,Okay so there's some way to distinguish a pointer from an on pointer
Dialogue: 0,0:57:27.54,0:57:30.48,Chinese,,0,0,0,,好的，有一些方法可以区分指针和指针
Dialogue: 0,0:57:31.54,0:57:33.32,English,,0,0,0,,And it can get the length of some block
Dialogue: 0,0:57:31.54,0:57:33.32,Chinese,,0,0,0,,它可以得到一些块的长度
Dialogue: 0,0:57:34.76,0:57:37.50,English,,0,0,0,,Not including the header and it can get a set of all of the routes
Dialogue: 0,0:57:34.76,0:57:37.50,Chinese,,0,0,0,,不包括头部，它可以获得一组所有路线
Dialogue: 0,0:57:41.56,0:57:44.32,English,,0,0,0,,So given those assumptions
Dialogue: 0,0:57:41.56,0:57:44.32,Chinese,,0,0,0,,所以给出了这些假设
Dialogue: 0,0:57:45.36,0:57:47.62,English,,0,0,0,,We a pseudocode for the mark step
Dialogue: 0,0:57:45.36,0:57:47.62,Chinese,,0,0,0,,我们是标记步骤的伪代码
Dialogue: 0,0:57:50.98,0:57:54.98,English,,0,0,0,,So this initially is a pointer,a route pointer
Dialogue: 0,0:57:50.98,0:57:54.98,Chinese,,0,0,0,,所以这最初是一个指针，一个路由指针
Dialogue: 0,0:57:57.78,0:58:00.22,English,,0,0,0,,Okay and then we check as a terminating condition
Dialogue: 0,0:57:57.78,0:58:00.22,Chinese,,0,0,0,,然后我们检查作为终止条件
Dialogue: 0,0:58:00.90,0:58:05.00,English,,0,0,0,,We check to see if that input is indeed a pointer and if so we return
Dialogue: 0,0:58:00.90,0:58:05.00,Chinese,,0,0,0,,我们检查输入是否确实是指针，如果是，我们返回
Dialogue: 0,0:58:07.18,0:58:11.80,English,,0,0,0,,Okay then we do a depth-first traversal of the of the graph
Dialogue: 0,0:58:07.18,0:58:11.80,Chinese,,0,0,0,,好的，然后我们对图表进行深度优先遍历
Dialogue: 0,0:58:12.72,0:58:13.32,English,,0,0,0,,So if
Dialogue: 0,0:58:12.72,0:58:13.32,Chinese,,0,0,0,,因此，如果
Dialogue: 0,0:58:15.18,0:58:20.74,English,,0,0,0,,And this...so we're doing a depth-first traversal of the graph and this is pointer is sort of our terminating condition for that
Dialogue: 0,0:58:15.18,0:58:20.74,Chinese,,0,0,0,,所以我们正在对图进行深度优先遍历，这是指针是我们的终止
Dialogue: 0,0:58:21.14,0:58:22.40,English,,0,0,0,,That depth-first traversal
Dialogue: 0,0:58:21.14,0:58:22.40,Chinese,,0,0,0,,深度优先遍历的条件
Dialogue: 0,0:58:24.24,0:58:27.96,English,,0,0,0,,Then we check the mark bit and if it's set then that's another terminating condition
Dialogue: 0,0:58:24.24,0:58:27.96,Chinese,,0,0,0,,然后我们检查标记位，如果它已设置，那么这是另一个终止条件
Dialogue: 0,0:58:27.96,0:58:33.60,English,,0,0,0,,There's no reason to search once we find a marked node
Dialogue: 0,0:58:27.96,0:58:33.60,Chinese,,0,0,0,,一旦找到标记的节点，就没有理由进行搜索
Dialogue: 0,0:58:34.62,0:58:37.84,English,,0,0,0,,We know that all of reachable nodes from that node is marked
Dialogue: 0,0:58:34.62,0:58:37.84,Chinese,,0,0,0,,我们知道从该结点出发的所有可以到达的结点都已经被标记
Dialogue: 0,0:58:37.94,0:58:41.82,English,,0,0,0,,So we can terminate a return and just stop the search
Dialogue: 0,0:58:37.94,0:58:41.82,Chinese,,0,0,0,,所以我们可以终止，返回并停止搜索
Dialogue: 0,0:58:42.62,0:58:45.08,English,,0,0,0,,If it's not set then we set the mark bit
Dialogue: 0,0:58:42.62,0:58:45.08,Chinese,,0,0,0,,如果没有设置，那么我们设置标记位
Dialogue: 0,0:58:45.94,0:58:48.38,English,,0,0,0,,And then we look at each word in the block
Dialogue: 0,0:58:45.94,0:58:48.38,Chinese,,0,0,0,,然后我们看看块中的每个字
Dialogue: 0,0:58:51.36,0:58:54.36,English,,0,0,0,,And we recursively call mark on each one of those words
Dialogue: 0,0:58:51.36,0:58:54.36,Chinese,,0,0,0,,我们递归地在每个字上调用标记
Dialogue: 0,0:58:54.84,0:58:57.06,English,,0,0,0,,Now each one of those words may or may not be a pointer right 
Dialogue: 0,0:58:54.84,0:58:57.06,Chinese,,0,0,0,,那么这些字中的每一个都可能是也可能不是指针
Dialogue: 0,0:58:57.16,0:59:02.80,English,,0,0,0,,So if it's not a pointer then mark will just return instantly immediately
Dialogue: 0,0:58:57.16,0:59:02.80,Chinese,,0,0,0,,如果它不是指针，标记后马上返回
Dialogue: 0,0:59:03.50,0:59:07.42,English,,0,0,0,,If it is a pointer then it will continue the recursive depth first search
Dialogue: 0,0:59:03.50,0:59:07.42,Chinese,,0,0,0,,如果它是一个指针，那么它将继续递归深度优先搜索
Dialogue: 0,0:59:09.16,0:59:14.52,English,,0,0,0,,Okay so does that make make sense it's just the familiar def first graph traversal bit
Dialogue: 0,0:59:09.16,0:59:14.52,Chinese,,0,0,0,,理解了吗？这就是大家熟悉图的深度优先搜索算法
Dialogue: 0,0:59:16.28,0:59:17.32,English,,0,0,0,,That we all know about
Dialogue: 0,0:59:16.28,0:59:17.32,Chinese,,0,0,0,,我们都知道
Dialogue: 0,0:59:19.76,0:59:25.50,English,,0,0,0,,Okay and then the sweep, sweep takes a pointer to the beginning of the heap
Dialogue: 0,0:59:19.76,0:59:25.50,Chinese,,0,0,0,,好的，然后扫描，扫描采用指向堆的开头的指针
Dialogue: 0,0:59:25.66,0:59:28.36,English,,0,0,0,,The first it takes a pointer to the first block in the heap
Dialogue: 0,0:59:25.66,0:59:28.36,Chinese,,0,0,0,,第一个是指向堆中第一个块的指针
Dialogue: 0,0:59:28.90,0:59:31.28,English,,0,0,0,,And then some a pointer to the end of the heap
Dialogue: 0,0:59:28.90,0:59:31.28,Chinese,,0,0,0,,然后是一些指向堆末尾的指针
Dialogue: 0,0:59:33.40,0:59:37.66,English,,0,0,0,,And then in a while loop then it scans the heap each block
Dialogue: 0,0:59:33.40,0:59:37.66,Chinese,,0,0,0,,然后在 while 循环中，它会扫描每个块的堆
Dialogue: 0,0:59:38.86,0:59:40.96,English,,0,0,0,,If the mark bit is set it clears it
Dialogue: 0,0:59:38.86,0:59:40.96,Chinese,,0,0,0,,如果设置了标记位，则清除它
Dialogue: 0,0:59:45.28,0:59:50.26,English,,0,0,0,,If it's allocated it frees it right
Dialogue: 0,0:59:45.28,0:59:50.26,Chinese,,0,0,0,,如果它被分配，释放它
Dialogue: 0,0:59:53.64,0:59:57.30,English,,0,0,0,,And then it updates and then it gets the address of the the next block
Dialogue: 0,0:59:53.64,0:59:57.30,Chinese,,0,0,0,,然后它更新，然后它获取下一个块的地址
Dialogue: 0,0:59:57.50,0:59:59.12,English,,0,0,0,,And then just continues until the end
Dialogue: 0,0:59:57.50,0:59:59.12,Chinese,,0,0,0,,然后继续直到结束
Dialogue: 0,1:00:05.44,1:00:07.56,English,,0,0,0,,Okay so how do we do such a thing in C right
Dialogue: 0,1:00:05.44,1:00:07.56,Chinese,,0,0,0,,那么我们如何在 C 中做这样的事情吧
Dialogue: 0,1:00:07.56,1:00:12.26,English,,0,0,0,,Because all of these assumptions I've made don't hold and C right you can't tell a pointer from a null pointer
Dialogue: 0,1:00:07.56,1:00:12.26,Chinese,,0,0,0,,因为我所做的所有这些假设不一定对，在 C 中你不能区分指向空指针的指针
Dialogue: 0,1:00:12.82,1:00:14.10,English,,0,0,0,,Pointers can point anywhere
Dialogue: 0,1:00:12.82,1:00:14.10,Chinese,,0,0,0,,指针可以指向任何地方
Dialogue: 0,1:00:17.60,1:00:20.76,English,,0,0,0,,So what you could do so the big issue is that
Dialogue: 0,1:00:17.60,1:00:20.76,Chinese,,0,0,0,,所以最大的问题是
Dialogue: 0,1:00:22.42,1:00:23.80,English,,0,0,0,,If we get some value
Dialogue: 0,1:00:22.42,1:00:23.80,Chinese,,0,0,0,,如果我们得到一些值
Dialogue: 0,1:00:26.92,1:00:31.80,English,,0,0,0,,It even if it is a pointer it could point right into the middle of the block
Dialogue: 0,1:00:26.92,1:00:31.80,Chinese,,0,0,0,,即使它是指针，它也可以指向块的中间
Dialogue: 0,1:00:34.84,1:00:35.76,English,,0,0,0,,So given that
Dialogue: 0,1:00:34.84,1:00:35.76,Chinese,,0,0,0,,考虑到这些
Dialogue: 0,1:00:36.44,1:00:40.24,English,,0,0,0,,So first of all we don't know if that value really is a pointer it could just be a big integer
Dialogue: 0,1:00:36.44,1:00:40.24,Chinese,,0,0,0,,首先，我们不知道该值是否真的是指针，它可能只是一个大整数
Dialogue: 0,1:00:40.98,1:00:44.14,English,,0,0,0,,But it also could be a pointer that's pointing into some data structure
Dialogue: 0,1:00:40.98,1:00:44.14,Chinese,,0,0,0,,但它也可能是一个指向某些数据结构的指针
Dialogue: 0,1:00:45.52,1:00:50.28,English,,0,0,0,,So if it is a pointer how do we find the beginning of the block
Dialogue: 0,1:00:45.52,1:00:50.28,Chinese,,0,0,0,,所以，如果它是一个指针，我们如何找到块的开头
Dialogue: 0,1:00:52.46,1:00:54.48,English,,0,0,0,,So what we could do is just assume that
Dialogue: 0,1:00:52.46,1:00:54.48,Chinese,,0,0,0,,所以我们能做的就是假设
Dialogue: 0,1:00:55.12,1:00:56.56,English,,0,0,0,,Every value is a pointer
Dialogue: 0,1:00:55.12,1:00:56.56,Chinese,,0,0,0,,每个值都是一个指针
Dialogue: 0,1:00:57.34,1:01:01.08,English,,0,0,0,,And then we maintain a balance tree to keep track of all the allocated blocks
Dialogue: 0,1:00:57.34,1:01:01.08,Chinese,,0,0,0,,然后我们维护一个平衡树来跟踪所有已分配的块
Dialogue: 0,1:01:01.70,1:01:04.00,English,,0,0,0,,And so whenever we encounter a particular value
Dialogue: 0,1:01:01.70,1:01:04.00,Chinese,,0,0,0,,所以每当我们遇到特定的价值时
Dialogue: 0,1:01:04.72,1:01:09.34,English,,0,0,0,,We would search that binary tree to see if assuming it is a pointer
Dialogue: 0,1:01:04.72,1:01:09.34,Chinese,,0,0,0,,我们会搜索那个二叉树，看看它是否是一个指针
Dialogue: 0,1:01:09.50,1:01:14.26,English,,0,0,0,,If it falls within the the beginning and end of some allocated block
Dialogue: 0,1:01:09.50,1:01:14.26,Chinese,,0,0,0,,如果它属于某个已分配块的开头和结尾
Dialogue: 0,1:01:15.50,1:01:18.92,English,,0,0,0,,Okay if that condition is true then we assume that it's
Dialogue: 0,1:01:15.50,1:01:18.92,Chinese,,0,0,0,,如果那个条件是真的
Dialogue: 0,1:01:19.42,1:01:21.74,English,,0,0,0,,Pointing that that's a pointer to an allocated block
Dialogue: 0,1:01:19.42,1:01:21.74,Chinese,,0,0,0,,我们假设它这个指针指向已分配块
Dialogue: 0,1:01:22.24,1:01:25.04,English,,0,0,0,,And we assume that block is reachable
Dialogue: 0,1:01:22.24,1:01:25.04,Chinese,,0,0,0,,我们假设块可以访问
Dialogue: 0,1:01:25.84,1:01:30.02,English,,0,0,0,,Now the reason it's conservative is because it really may not be a pointer it might be this integer
Dialogue: 0,1:01:25.84,1:01:30.02,Chinese,,0,0,0,,现在它保守的原因是因为它可能不是指针，它可能是这个整数
Dialogue: 0,1:01:30.36,1:01:32.78,English,,0,0,0,,And we'll assume it's a pointer and assume that
Dialogue: 0,1:01:30.36,1:01:32.78,Chinese,,0,0,0,,我们假设它是一个指针
Dialogue: 0,1:01:33.26,1:01:36.56,English,,0,0,0,,The block that it purportedly points to is allocated
Dialogue: 0,1:01:33.26,1:01:36.56,Chinese,,0,0,0,,并且假设它据称指向的块被分配
Dialogue: 0,1:01:37.04,1:01:40.20,English,,0,0,0,,But it may in fact be not be a pointer and the block that
Dialogue: 0,1:01:37.04,1:01:40.20,Chinese,,0,0,0,,但它实际上可能不是指针和块
Dialogue: 0,1:01:40.70,1:01:41.78,English,,0,0,0,,It points to is garbage
Dialogue: 0,1:01:40.70,1:01:41.78,Chinese,,0,0,0,,它指的是垃圾
Dialogue: 0,1:01:42.14,1:01:48.52,English,,0,0,0,,Right so what with this scheme we would leave some non reachable blocks
Dialogue: 0,1:01:42.14,1:01:48.52,Chinese,,0,0,0,,所以使用这个方案我们会留下一些不可访问的块
Dialogue: 0,1:01:50.22,1:01:54.54,English,,0,0,0,,We will indicate that some non reachable blocks are really reachable
Dialogue: 0,1:01:50.22,1:01:54.54,Chinese,,0,0,0,,我们将指出一些不可到访问的块确实可以访问
Dialogue: 0,1:01:57.52,1:01:58.30,English,,0,0,0,,Okay so
Dialogue: 0,1:01:57.52,1:01:58.30,Chinese,,0,0,0,,然后
Dialogue: 0,1:02:00.20,1:02:04.16,English,,0,0,0,,So once now that we've got this great tool to dynamically allocate memory
Dialogue: 0,1:02:00.20,1:02:04.16,Chinese,,0,0,0,,一旦我们有了这个动态分配内存的好工具
Dialogue: 0,1:02:06.12,1:02:07.46,English,,0,0,0,,We can use it in our programs
Dialogue: 0,1:02:06.12,1:02:07.46,Chinese,,0,0,0,,我们可以在我们的程序中使用它
Dialogue: 0,1:02:08.06,1:02:10.64,English,,0,0,0,,And shoot ourselves in the foot in all different kinds of ways
Dialogue: 0,1:02:08.06,1:02:10.64,Chinese,,0,0,0,,并且用各种各样的方式给自己带来一些麻烦
Dialogue: 0,1:02:10.86,1:02:16.14,English,,0,0,0,,Okay so I'm going to try to help  help you out here by identifying
Dialogue: 0,1:02:10.86,1:02:16.14,Chinese,,0,0,0,,所以我打算用一些与内存相关的操作或者
Dialogue: 0,1:02:16.66,1:02:24.28,English,,0,0,0,,Some of the perils and pitfalls that that we can run into with memory related operations or operations on memory
Dialogue: 0,1:02:16.66,1:02:24.28,Chinese,,0,0,0,,内存操作可能会遇到的一些危险和陷阱
Dialogue: 0,1:02:25.24,1:02:29.82,English,,0,0,0,,And opera errors errors involving memory
Dialogue: 0,1:02:25.24,1:02:29.82,Chinese,,0,0,0,,涉及内存的的错误是
Dialogue: 0,1:02:30.10,1:02:35.70,English,,0,0,0,,Are the worst the worst kinds of bugs to try to find out
Dialogue: 0,1:02:30.10,1:02:35.70,Chinese,,0,0,0,,最糟糕的一种漏洞
Dialogue: 0,1:02:36.96,1:02:39.98,English,,0,0,0,,And the reason is that they're distant in both space and time
Dialogue: 0,1:02:36.96,1:02:39.98,Chinese,,0,0,0,,原因是他们在空间和时间上都很遥远
Dialogue: 0,1:02:40.96,1:02:44.74,English,,0,0,0,,So let's say you write to the wrong memory location and corrupt some data structure
Dialogue: 0,1:02:40.96,1:02:44.74,Chinese,,0,0,0,,因此，假设你写入错误的内存位置并破坏某些数据结构
Dialogue: 0,1:02:46.00,1:02:48.42,English,,0,0,0,,The right doesn't elicit any error
Dialogue: 0,1:02:46.00,1:02:48.42,Chinese,,0,0,0,,当下不会引起任何错误
Dialogue: 0,1:02:49.08,1:02:53.44,English,,0,0,0,,You only find out about that erroneous right
Dialogue: 0,1:02:49.08,1:02:53.44,Chinese,,0,0,0,,当你尝试引用该数据结构或者数据结构中的特定部分的时候
Dialogue: 0,1:02:53.44,1:02:57.22,English,,0,0,0,,When you try to reference that data structure or that particular part of the data structure
Dialogue: 0,1:02:53.44,1:02:57.22,Chinese,,0,0,0,,你才能够发现错误
Dialogue: 0,1:02:57.84,1:03:02.56,English,,0,0,0,,Which may be in a part of the code that's way far away from the right that caused the problem
Dialogue: 0,1:02:57.84,1:03:02.56,Chinese,,0,0,0,,可能是离当前操作区域很远的代码的一部分导致了这个问题
Dialogue: 0,1:03:03.80,1:03:08.14,English,,0,0,0,,Both in space you know in distance you know lines of code it could be a completely different function
Dialogue: 0,1:03:03.80,1:03:08.14,Chinese,,0,0,0,,可能是离当前的代码很远，也可能和当前的功能完全不同
Dialogue: 0,1:03:08.14,1:03:09.68,English,,0,0,0,,And a completely different module
Dialogue: 0,1:03:08.14,1:03:09.68,Chinese,,0,0,0,,也可能是一个完全不同的模块
Dialogue: 0,1:03:10.32,1:03:12.98,English,,0,0,0,,But also in time it may not you know you may do the right
Dialogue: 0,1:03:10.32,1:03:12.98,Chinese,,0,0,0,,当下，你可能运行正确
Dialogue: 0,1:03:13.18,1:03:16.36,English,,0,0,0,,And then eons later other some read and it fails
Dialogue: 0,1:03:13.18,1:03:16.36,Chinese,,0,0,0,,然后很久以后其他人运行了一遍就失败了
Dialogue: 0,1:03:16.80,1:03:21.06,English,,0,0,0,,Right so this is a fundamental thing that makes memory related bugs just so nasty
Dialogue: 0,1:03:16.80,1:03:21.06,Chinese,,0,0,0,,所以这个基本的东西使内存相关的错误如此讨厌
Dialogue: 0,1:03:23.76,1:03:28.42,English,,0,0,0,,And another thing that makes them hard to deal with
Dialogue: 0,1:03:23.76,1:03:28.42,Chinese,,0,0,0,,另一件让他们难以应对的事情
Dialogue: 0,1:03:28.88,1:03:33.16,English,,0,0,0,,Is people's misunderstanding and misuse of pointers right
Dialogue: 0,1:03:28.88,1:03:33.16,Chinese,,0,0,0,,是人们对指针的误解和误用
Dialogue: 0,1:03:33.16,1:03:35.26,English,,0,0,0,,So usually an erroneous right is some is
Dialogue: 0,1:03:33.16,1:03:35.26,Chinese,,0,0,0,,所以通常一些错误就是
Dialogue: 0,1:03:36.08,1:03:41.72,English,,0,0,0,,Some either a misunderstanding of pointers or an improperly initialized pointer
Dialogue: 0,1:03:36.08,1:03:41.72,Chinese,,0,0,0,,有些是对指针的误解或者是指针初始化不正确
Dialogue: 0,1:03:42.10,1:03:43.98,English,,0,0,0,,So it all boils down to these pointers
Dialogue: 0,1:03:42.10,1:03:43.98,Chinese,,0,0,0,,这一切归结为指针
Dialogue: 0,1:03:48.10,1:03:51.10,English,,0,0,0,,Okay and so I'm going to show you how to understand pointers
Dialogue: 0,1:03:48.10,1:03:51.10,Chinese,,0,0,0,,好的，我将向你展示如何理解指针
Dialogue: 0,1:03:52.76,1:03:53.98,English,,0,0,0,,Okay for the first time in your lives
Dialogue: 0,1:03:52.76,1:03:53.98,Chinese,,0,0,0,,这是你生命中的第一次
Dialogue: 0,1:03:56.76,1:03:58.64,English,,0,0,0,,I don't know about you but when I learned C
Dialogue: 0,1:03:56.76,1:03:58.64,Chinese,,0,0,0,,我不了解你，但是当我学习 C 时
Dialogue: 0,1:04:01.28,1:04:02.38,English,,0,0,0,,I learned about pointers
Dialogue: 0,1:04:01.28,1:04:02.38,Chinese,,0,0,0,,我了解了指针
Dialogue: 0,1:04:02.60,1:04:07.50,English,,0,0,0,,I just knew about what a few different types of pointers  were by and I did it by pattern matching
Dialogue: 0,1:04:02.60,1:04:07.50,Chinese,,0,0,0,,我只知道几个不同类型的指针是什么，我通过模式匹配来做到这一点
Dialogue: 0,1:04:08.16,1:04:11.72,English,,0,0,0,,So I knew that int *p was a pointer to an int
Dialogue: 0,1:04:08.16,1:04:11.72,Chinese,,0,0,0,,所以我知道 int* p 是指向 int 的指针
Dialogue: 0,1:04:12.56,1:04:15.64,English,,0,0,0,,I knew that int **p was an array
Dialogue: 0,1:04:12.56,1:04:15.64,Chinese,,0,0,0,,我知道 int** p 是一个数组
Dialogue: 0,1:04:16.48,1:04:18.02,English,,0,0,0,,I knew that int *p
Dialogue: 0,1:04:16.48,1:04:18.02,Chinese,,0,0,0,,我知道 int* p
Dialogue: 0,1:04:18.66,1:04:24.48,English,,0,0,0,,Open bracket closed bracket was also an array just a different way to  express that array
Dialogue: 0,1:04:18.66,1:04:24.48,Chinese,,0,0,0,,左括号和右括号也是另一种表达数组的方式
Dialogue: 0,1:04:24.48,1:04:28.76,English,,0,0,0,,So I had a small handful of pointers types that I could deal with
Dialogue: 0,1:04:24.48,1:04:28.76,Chinese,,0,0,0,,我有一些我可以处理的指针类型
Dialogue: 0,1:04:29.36,1:04:33.98,English,,0,0,0,,But I had no underlying understanding of what that meant or anything was just pure pattern matching
Dialogue: 0,1:04:29.36,1:04:33.98,Chinese,,0,0,0,,但我对这意味着什么并不了解，或者只是简单的模式识别
Dialogue: 0,1:04:34.98,1:04:36.68,English,,0,0,0,,And I'll bet you that's the way you do it too
Dialogue: 0,1:04:34.98,1:04:36.68,Chinese,,0,0,0,,而且我敢打赌你也是这样做的
Dialogue: 0,1:04:38.40,1:04:40.28,English,,0,0,0,,All right but that's all going to change today
Dialogue: 0,1:04:38.40,1:04:40.28,Chinese,,0,0,0,,但今天一切都会改变
Dialogue: 0,1:04:41.90,1:04:42.58,English,,0,0,0,,All right so
Dialogue: 0,1:04:41.90,1:04:42.58,Chinese,,0,0,0,,好的
Dialogue: 0,1:04:43.94,1:04:45.84,English,,0,0,0,,In order to really understand pointers
Dialogue: 0,1:04:43.94,1:04:45.84,Chinese,,0,0,0,,为了真正理解指针
Dialogue: 0,1:04:46.80,1:04:51.54,English,,0,0,0,,You need to understand the precedence of various operators in C
Dialogue: 0,1:04:46.80,1:04:51.54,Chinese,,0,0,0,,你需要了解 C 中各种运算符的优先级
Dialogue: 0,1:04:52.70,1:04:56.02,English,,0,0,0,,Because the pointer types are declared using these operators
Dialogue: 0,1:04:52.70,1:04:56.02,Chinese,,0,0,0,,因为使用这些运算符声明指针类型
Dialogue: 0,1:04:56.70,1:05:01.08,English,,0,0,0,,And so my copy of k and r is it has a dog-eared at page 53
Dialogue: 0,1:04:56.70,1:05:01.08,Chinese,,0,0,0,,此内容在 k&r 第 53 页
Dialogue: 0,1:05:01.48,1:05:04.34,English,,0,0,0,,This table comes from page 53 of K&R
Dialogue: 0,1:05:01.48,1:05:04.34,Chinese,,0,0,0,,此表来自 K&R 的第 53 页
Dialogue: 0,1:05:05.12,1:05:09.22,English,,0,0,0,,And you should have a paper clip or have that folded over for reference
Dialogue: 0,1:05:05.12,1:05:09.22,Chinese,,0,0,0,,你应该有一个回形针或将它折叠起来作为参考
Dialogue: 0,1:05:10.66,1:05:12.42,English,,0,0,0,,Now the thing to notice is that
Dialogue: 0,1:05:10.66,1:05:12.42,Chinese,,0,0,0,,现在需要注意的是
Dialogue: 0,1:05:13.62,1:05:18.46,English,,0,0,0,,Function and array and then and these struct these various struct operators
Dialogue: 0,1:05:13.62,1:05:18.46,Chinese,,0,0,0,,函数和数组然后和这些结构这些各种 struct 运算符
Dialogue: 0,1:05:18.96,1:05:21.46,English,,0,0,0,,Have the highest priority,highest precedence
Dialogue: 0,1:05:18.96,1:05:21.46,Chinese,,0,0,0,,拥有最高优先级
Dialogue: 0,1:05:23.86,1:05:29.58,English,,0,0,0,,And that that's followed by unary operators so the star this is the dereference operator
Dialogue: 0,1:05:23.86,1:05:29.58,Chinese,,0,0,0,,接下来是一元运算符，所以 「*」 就是解除引用运算符
Dialogue: 0,1:05:29.58,1:05:32.46,English,,0,0,0,,And then the address of operator
Dialogue: 0,1:05:29.58,1:05:32.46,Chinese,,0,0,0,,然后是地址运算符
Dialogue: 0,1:05:33.60,1:05:36.00,English,,0,0,0,,The they fall right below
Dialogue: 0,1:05:33.60,1:05:36.00,Chinese,,0,0,0,,它们在
Dialogue: 0,1:05:37.34,1:05:40.76,English,,0,0,0,,The highest precedence operators
Dialogue: 0,1:05:37.34,1:05:40.76,Chinese,,0,0,0,,最高优先级运算符的后面
Dialogue: 0,1:05:41.34,1:05:47.58,English,,0,0,0,,And then the binary versions of operators you know that you use in arithmetic operations are below those
Dialogue: 0,1:05:41.34,1:05:47.58,Chinese,,0,0,0,,你知道在算术运算中使用的运算符的二进制版本的优先级低于这些运算符
Dialogue: 0,1:05:48.72,1:05:49.74,English,,0,0,0,,Okay so just remember
Dialogue: 0,1:05:48.72,1:05:49.74,Chinese,,0,0,0,,所以请记住
Dialogue: 0,1:05:50.64,1:05:54.46,English,,0,0,0,,That function and array is higher than *
Dialogue: 0,1:05:50.64,1:05:54.46,Chinese,,0,0,0,,该函数和数组的优先级高于 *
Dialogue: 0,1:05:56.80,1:05:58.16,English,,0,0,0,,That too deep the dereference
Dialogue: 0,1:05:56.80,1:05:58.16,Chinese,,0,0,0,,这种解除引用太深了
Dialogue: 0,1:06:00.34,1:06:04.96,English,,0,0,0,,Now the great thing about pointers although they always seem really complicated
Dialogue: 0,1:06:00.34,1:06:04.96,Chinese,,0,0,0,,现在关于指针的好处虽然它们看起来总是很复杂
Dialogue: 0,1:06:05.86,1:06:07.86,English,,0,0,0,,Is that there's an algorithm for
Dialogue: 0,1:06:05.86,1:06:07.86,Chinese,,0,0,0,,这是一个算法吗？
Dialogue: 0,1:06:09.22,1:06:10.70,English,,0,0,0,,It for there's an algorithm for
Dialogue: 0,1:06:09.22,1:06:10.70,Chinese,,0,0,0,,它有一个算法
Dialogue: 0,1:06:11.66,1:06:15.90,English,,0,0,0,,Constructing an english sentence that explains exactly what that pointer
Dialogue: 0,1:06:11.66,1:06:15.90,Chinese,,0,0,0,,构造一个英语句子，准确地解释了那个指针
Dialogue: 0,1:06:17.04,1:06:20.54,English,,0,0,0,,What that definition of the pointer means
Dialogue: 0,1:06:17.04,1:06:20.54,Chinese,,0,0,0,,指针的定义意味着什么
Dialogue: 0,1:06:21.48,1:06:25.32,English,,0,0,0,,Okay and if you're interested it's in the K&R are in section 5.12
Dialogue: 0,1:06:21.48,1:06:25.32,Chinese,,0,0,0,,如果你对 K&R 感兴趣，请参阅第 5.12 节
Dialogue: 0,1:06:26.38,1:06:28.60,English,,0,0,0,,But I'll explain it to you now
Dialogue: 0,1:06:26.38,1:06:28.60,Chinese,,0,0,0,,但我现在会向你解释
Dialogue: 0,1:06:29.80,1:06:33.58,English,,0,0,0,,Now I don't know how much in this class you're going to remember
Dialogue: 0,1:06:29.80,1:06:33.58,Chinese,,0,0,0,,现在我不知道你会在这堂中学到多少
Dialogue: 0,1:06:34.74,1:06:38.66,English,,0,0,0,,Okay but I guarantee you're going to remember this as the day you finally understood pointers okay
Dialogue: 0,1:06:34.74,1:06:38.66,Chinese,,0,0,0,,但我保证你会记住这一天，因为你终于理解指针了
Dialogue: 0,1:06:38.82,1:06:39.06,English,,0,0,0,,So all
Dialogue: 0,1:06:38.82,1:06:39.06,Chinese,,0,0,0,,所以
Dialogue: 0,1:06:43.37,1:06:44.45,English,,0,0,0,,Right so here's how it works
Dialogue: 0,1:06:43.37,1:06:44.45,Chinese,,0,0,0,,这是它的工作原理
Dialogue: 0,1:06:45.28,1:06:49.62,English,,0,0,0,,You always start it the this is a definition of a pointer some kind
Dialogue: 0,1:06:45.28,1:06:49.62,Chinese,,0,0,0,,你总是这样开始，这是某种指针的定义
Dialogue: 0,1:06:50.80,1:06:54.52,English,,0,0,0,,You always start with the variable name
Dialogue: 0,1:06:50.80,1:06:54.52,Chinese,,0,0,0,,你始终以变量名称开头
Dialogue: 0,1:07:01.20,1:07:02.68,English,,0,0,0,,And then you use your precedence
Dialogue: 0,1:07:01.20,1:07:02.68,Chinese,,0,0,0,,然后你使用你的优先权
Dialogue: 0,1:07:03.08,1:07:06.46,English,,0,0,0,,Then you look for operators on either side of that variable name
Dialogue: 0,1:07:03.08,1:07:06.46,Chinese,,0,0,0,,然后，你在该变量名称的任一侧查找运算符
Dialogue: 0,1:07:06.54,1:07:08.66,English,,0,0,0,,And you choose the one that has the highest precedence
Dialogue: 0,1:07:06.54,1:07:08.66,Chinese,,0,0,0,,并且你选择具有最高优先级的那个
Dialogue: 0,1:07:10.66,1:07:15.86,English,,0,0,0,,Okay so we start with the variable so we say p  is a
Dialogue: 0,1:07:10.66,1:07:15.86,Chinese,,0,0,0,,我们从变量开始，所以我们说 p 是一个
Dialogue: 0,1:07:17.04,1:07:18.62,English,,0,0,0,,Then we look to the left and the right
Dialogue: 0,1:07:17.04,1:07:18.62,Chinese,,0,0,0,,然后我们向左看和向右看
Dialogue: 0,1:07:18.62,1:07:22.36,English,,0,0,0,,There's nothing to the right but there's a there's a pointer symbol to the left
Dialogue: 0,1:07:18.62,1:07:22.36,Chinese,,0,0,0,,右边没什么，但是左边有一个指针符号
Dialogue: 0,1:07:22.38,1:07:25.12,English,,0,0,0,,So we say p is a pointer
Dialogue: 0,1:07:22.38,1:07:25.12,Chinese,,0,0,0,,所以我们说 p 是一个指针
Dialogue: 0,1:07:25.66,1:07:30.32,English,,0,0,0,,And there's nothing more and then we always end up with the type of thing that it points that
Dialogue: 0,1:07:25.66,1:07:30.32,Chinese,,0,0,0,,并没有更多，然后我们总是最终得到它所指出的那种东西
Dialogue: 0,1:07:31.06,1:07:33.58,English,,0,0,0,,So p is a pointer to an int
Dialogue: 0,1:07:31.06,1:07:33.58,Chinese,,0,0,0,,所以 p 是指向 int 的指针
Dialogue: 0,1:07:43.70,1:07:44.76,English,,0,0,0,,Right so p is
Dialogue: 0,1:07:43.70,1:07:44.76,Chinese,,0,0,0,,所以 p 是
Dialogue: 0,1:07:46.50,1:07:50.76,English,,0,0,0,,P is a pointer to some integer in memory okay
Dialogue: 0,1:07:46.50,1:07:50.76,Chinese,,0,0,0,,P 是指向内存中某个整数的指针
Dialogue: 0,1:07:50.94,1:07:52.44,English,,0,0,0,,So we all know that one that's pretty easy
Dialogue: 0,1:07:50.94,1:07:52.44,Chinese,,0,0,0,,这个非常简单
Dialogue: 0,1:07:53.64,1:07:54.64,English,,0,0,0,,Okay what about the next one
Dialogue: 0,1:07:53.64,1:07:54.64,Chinese,,0,0,0,,下一个呢
Dialogue: 0,1:07:56.04,1:07:57.76,English,,0,0,0,,You've probably seen something like this
Dialogue: 0,1:07:56.04,1:07:57.76,Chinese,,0,0,0,,你可能已经见过像这样的东西了
Dialogue: 0,1:07:59.32,1:08:02.24,English,,0,0,0,,Some programs declare our v using this notation
Dialogue: 0,1:07:59.32,1:08:02.24,Chinese,,0,0,0,,有些程序使用这种表示法声明我们的 v
Dialogue: 0,1:08:04.34,1:08:06.92,English,,0,0,0,,And so this you can have an optional size or not
Dialogue: 0,1:08:04.34,1:08:06.92,Chinese,,0,0,0,,所以你可以有一个可选尺寸
Dialogue: 0,1:08:10.38,1:08:13.80,English,,0,0,0,,So we always star out we say p is a
Dialogue: 0,1:08:10.38,1:08:13.80,Chinese,,0,0,0,,所以我们说 p 是一个
Dialogue: 0,1:08:15.22,1:08:17.69,English,,0,0,0,,Well now in this case there's operators to the left and the right
Dialogue: 0,1:08:15.22,1:08:17.69,Chinese,,0,0,0,,现在在这种情况下，左侧和右侧都有操作符
Dialogue: 0,1:08:18.04,1:08:24.86,English,,0,0,0,,Remember the array operator has higher precedence than the dereferencing operator the pointer operators
Dialogue: 0,1:08:18.04,1:08:24.86,Chinese,,0,0,0,,请记住，数组运算符的优先级高于指针运算符
Dialogue: 0,1:08:24.88,1:08:34.20,English,,0,0,0,,So we say so p is an array 13 array of size 13  of
Dialogue: 0,1:08:24.88,1:08:34.20,Chinese,,0,0,0,,所以我们说 p 是一个大小为 13 的数组
Dialogue: 0,1:08:35.64,1:08:39.04,English,,0,0,0,,So there's nothing more so we go to the left of pointers
Dialogue: 0,1:08:35.64,1:08:39.04,Chinese,,0,0,0,,右边没有更多的东西，所以我们去指针的左边
Dialogue: 0,1:08:39.56,1:08:44.10,English,,0,0,0,,So p is an array 13 of pointers to ints
Dialogue: 0,1:08:39.56,1:08:44.10,Chinese,,0,0,0,,所以 p 是一个由 13 个指向 int 的指针组成的数组
Dialogue: 0,1:08:51.08,1:08:58.46,English,,0,0,0,,So p is an array of 13 pointers
Dialogue: 0,1:08:51.08,1:08:58.46,Chinese,,0,0,0,,所以 p 是一个由 13 个指针构成的数组
Dialogue: 0,1:09:00.42,1:09:04.02,English,,0,0,0,,Each of which points to an int
Dialogue: 0,1:09:00.42,1:09:04.02,Chinese,,0,0,0,,每个都指向一个 int
Dialogue: 0,1:09:05.14,1:09:07.62,English,,0,0,0,,Right in this case p is just the name of the array
Dialogue: 0,1:09:05.14,1:09:07.62,Chinese,,0,0,0,,在这种情况下，p 就是数组的名称
Dialogue: 0,1:09:08.32,1:09:09.78,English,,0,0,0,,So by default p
Dialogue: 0,1:09:08.32,1:09:09.78,Chinese,,0,0,0,,默认情况下
Dialogue: 0,1:09:10.62,1:09:14.50,English,,0,0,0,,P is equivalent is the address of the array
Dialogue: 0,1:09:10.62,1:09:14.50,Chinese,,0,0,0,,p 等价于数组的地址
Dialogue: 0,1:09:14.70,1:09:21.42,English,,0,0,0,,When you reference an array name you're addressing your dressing the address of the first element
Dialogue: 0,1:09:14.70,1:09:21.42,Chinese,,0,0,0,,当你引用数组名称时，你正在寻找第一个元素的地址
Dialogue: 0,1:09:23.84,1:09:24.96,English,,0,0,0,,Okay how about the next one
Dialogue: 0,1:09:23.84,1:09:24.96,Chinese,,0,0,0,,下一个怎么样
Dialogue: 0,1:09:27.22,1:09:30.96,English,,0,0,0,,Here we're being if we put parentheses around things then we can be explicit
Dialogue: 0,1:09:27.22,1:09:30.96,Chinese,,0,0,0,,我们在这里，如果我们把括号放在事物周围，那么我们可以是明确的
Dialogue: 0,1:09:31.22,1:09:32.44,English,,0,0,0,,Okay and this is a good practice
Dialogue: 0,1:09:31.22,1:09:32.44,Chinese,,0,0,0,,好的，这是一个很好的做法
Dialogue: 0,1:09:33.60,1:09:34.94,English,,0,0,0,,So here we're saying p
Dialogue: 0,1:09:33.60,1:09:34.94,Chinese,,0,0,0,,所以我们在这里说 p
Dialogue: 0,1:09:35.52,1:09:38.00,English,,0,0,0,,And we have to look at this one first because of the parentheses
Dialogue: 0,1:09:35.52,1:09:38.00,Chinese,,0,0,0,,由于括号，我们必须首先看一下这个
Dialogue: 0,1:09:39.30,1:09:43.02,English,,0,0,0,,So p is an array[13] of pointers to ints
Dialogue: 0,1:09:39.30,1:09:43.02,Chinese,,0,0,0,,p 是一个指向由 13 个指向 int 的指针所构成的数组
Dialogue: 0,1:09:43.28,1:09:44.26,English,,0,0,0,,So that's the same thing
Dialogue: 0,1:09:43.28,1:09:44.26,Chinese,,0,0,0,,所以这是一回事
Dialogue: 0,1:09:44.80,1:09:46.36,English,,0,0,0,,And here we're just being more explicit
Dialogue: 0,1:09:44.80,1:09:46.36,Chinese,,0,0,0,,在这里，我们只是更明确
Dialogue: 0,1:09:47.38,1:09:48.86,English,,0,0,0,,Now what about **p
Dialogue: 0,1:09:47.38,1:09:48.86,Chinese,,0,0,0,,现在怎么样 **p
Dialogue: 0,1:09:50.70,1:09:55.22,English,,0,0,0,,So p is a pointer to a pointer to an int
Dialogue: 0,1:09:50.70,1:09:55.22,Chinese,,0,0,0,,p 是指向 int 的指针的指针
Dialogue: 0,1:09:56.84,1:09:58.58,English,,0,0,0,,Okay so this is a different type of array
Dialogue: 0,1:09:56.84,1:09:58.58,Chinese,,0,0,0,,这是一种不同类型的数组
Dialogue: 0,1:10:02.10,1:10:09.38,English,,0,0,0,,So p is a pointer to a pointer to an int
Dialogue: 0,1:10:02.10,1:10:09.38,Chinese,,0,0,0,,p 是指向 int 指针的指针
Dialogue: 0,1:10:10.90,1:10:13.30,English,,0,0,0,,Okay and
Dialogue: 0,1:10:10.90,1:10:13.30,Chinese,,0,0,0,,好的
Dialogue: 0,1:10:15.16,1:10:17.46,English,,0,0,0,,And typically so this is another way to do arrays
Dialogue: 0,1:10:15.16,1:10:17.46,Chinese,,0,0,0,,通常这是另一种产生数组的方法
Dialogue: 0,1:10:20.66,1:10:23.60,English,,0,0,0,,So the same way the char* points to a string
Dialogue: 0,1:10:20.66,1:10:23.60,Chinese,,0,0,0,,所以 char* 指向字符串的方式相同
Dialogue: 0,1:10:27.18,1:10:31.72,English,,0,0,0,,It points to a pointer but then you can index on that
Dialogue: 0,1:10:27.18,1:10:31.72,Chinese,,0,0,0,,它指向一个指针，然后你可以索引它
Dialogue: 0,1:10:32.38,1:10:36.86,English,,0,0,0,,Each one of those then points corresponds to a pointer
Dialogue: 0,1:10:32.38,1:10:36.86,Chinese,,0,0,0,,其中每一个指向对应的指针
Dialogue: 0,1:10:40.70,1:10:42.02,English,,0,0,0,,Whoops okay
Dialogue: 0,1:10:40.70,1:10:42.02,Chinese,,0,0,0,,哎呀
Dialogue: 0,1:10:43.98,1:10:48.46,English,,0,0,0,,Here's another one now p because and because of the parentheses we have to go left
Dialogue: 0,1:10:43.98,1:10:48.42,Chinese,,0,0,0,,这是另一个，p 因为括号我们必须到左边
Dialogue: 0,1:10:48.46,1:11:02.06,English,,0,0,0,,So p is a pointer to an array[13] of ints
Dialogue: 0,1:10:48.46,1:11:02.06,Chinese,,0,0,0,,p 是一个指向大小为 13 的 int 型数组的指针
Dialogue: 0,1:11:11.84,1:11:12.92,English,,0,0,0,,Right now what about this one
Dialogue: 0,1:11:11.84,1:11:12.92,Chinese,,0,0,0,,现在怎么样呢
Dialogue: 0,1:11:14.62,1:11:21.00,English,,0,0,0,,f is a function is...it a function or a pointer
Dialogue: 0,1:11:14.62,1:11:21.00,Chinese,,0,0,0,,f 是一个函数，它是一个函数或一个指针
Dialogue: 0,1:11:22.78,1:11:24.84,English,,0,0,0,,f is a function right because of the precedence
Dialogue: 0,1:11:22.78,1:11:24.84,Chinese,,0,0,0,,由于优先权，f 是一个函数
Dialogue: 0,1:11:25.44,1:11:30.26,English,,0,0,0,,So f is a function returning pointer to int
Dialogue: 0,1:11:25.44,1:11:30.26,Chinese,,0,0,0,,f 是一个返回 int 指针的函数
Dialogue: 0,1:11:32.70,1:11:33.76,English,,0,0,0,,Ok so if we go
Dialogue: 0,1:11:32.70,1:11:33.76,Chinese,,0,0,0,,好的
Dialogue: 0,1:11:35.98,1:11:37.18,English,,0,0,0,,If we go p=f
Dialogue: 0,1:11:35.98,1:11:37.18,Chinese,,0,0,0,,如果我们让 p = f
Dialogue: 0,1:11:39.40,1:11:43.70,English,,0,0,0,,Then that returns that initialized p to point to some int
Dialogue: 0,1:11:39.40,1:11:43.70,Chinese,,0,0,0,,然后返回初始化的 p 指向某个 int
Dialogue: 0,1:11:49.92,1:11:50.66,English,,0,0,0,,All right
Dialogue: 0,1:11:49.92,1:11:50.66,Chinese,,0,0,0,,好吧
Dialogue: 0,1:11:52.64,1:11:56.20,English,,0,0,0,,And I'm going to do this one let's jump down in the interest of time
Dialogue: 0,1:11:52.64,1:11:56.20,Chinese,,0,0,0,,我打算这样做，让我们为了时间而跳下来
Dialogue: 0,1:11:57.46,1:12:01.66,English,,0,0,0,,Totally ridiculous case just so you can see that this algorithm works
Dialogue: 0,1:11:57.46,1:12:01.66,Chinese,,0,0,0,,完全荒谬的情况，只是让你可以看到这个算法的工作原理
Dialogue: 0,1:12:02.58,1:12:07.96,English,,0,0,0,,All right so x is an array of pointers
Dialogue: 0,1:12:02.58,1:12:07.96,Chinese,,0,0,0,,x 是一个指针数组
Dialogue: 0,1:12:09.72,1:12:14.62,English,,0,0,0,,To functions returning pointers
Dialogue: 0,1:12:09.72,1:12:14.62,Chinese,,0,0,0,,返回指针的函数
Dialogue: 0,1:12:16.26,1:12:17.56,English,,0,0,0,,To an array five int
Dialogue: 0,1:12:16.26,1:12:17.56,Chinese,,0,0,0,,指向 int 类型长度为 5 的数组
Dialogue: 0,1:12:19.44,1:12:21.68,English,,0,0,0,,And if you ever use anything like that in your code
Dialogue: 0,1:12:19.44,1:12:21.68,Chinese,,0,0,0,,如果你在代码中使用过类似的东西
Dialogue: 0,1:12:22.72,1:12:23.44,English,,0,0,0,,Shame on you
Dialogue: 0,1:12:22.72,1:12:23.44,Chinese,,0,0,0,,真丢脸
Dialogue: 0,1:12:26.26,1:12:27.64,English,,0,0,0,,All right so there you go so that's
Dialogue: 0,1:12:26.26,1:12:27.64,Chinese,,0,0,0,,所以你打算怎么做
Dialogue: 0,1:12:28.22,1:12:30.06,English,,0,0,0,,Now you know now you understand pointers
Dialogue: 0,1:12:28.22,1:12:30.06,Chinese,,0,0,0,,现在你了解了指针
Dialogue: 0,1:12:30.32,1:12:34.82,English,,0,0,0,,Simple as can be and all you need is page 53 of K&R is a handy reference
Dialogue: 0,1:12:30.32,1:12:34.82,Chinese,,0,0,0,,尽可能简单，你可以参考 K&R 的第 53 页
Dialogue: 0,1:12:36.24,1:12:39.36,English,,0,0,0,,All right so let's we'll take the last five minutes and I'll show you some
Dialogue: 0,1:12:36.24,1:12:39.36,Chinese,,0,0,0,,好吧，让我们在最后五分钟，我会告诉你们一些
Dialogue: 0,1:12:40.70,1:12:42.40,English,,0,0,0,,Some of the ways you can trip yourself up
Dialogue: 0,1:12:40.70,1:12:42.40,Chinese,,0,0,0,,一些你可以绊倒自己的方法
Dialogue: 0,1:12:43.04,1:12:44.22,English,,0,0,0,,When you're accessing memory
Dialogue: 0,1:12:43.04,1:12:44.22,Chinese,,0,0,0,,当你访问内存时
Dialogue: 0,1:12:44.82,1:12:47.04,English,,0,0,0,,Okay so first is the classic scanf bug
Dialogue: 0,1:12:44.82,1:12:47.04,Chinese,,0,0,0,,首先是经典的 scanf 错误
Dialogue: 0,1:12:47.12,1:12:55.44,English,,0,0,0,,You probably all done this where you forget to pass it the address of a variable instead you pass it the address
Dialogue: 0,1:12:47.12,1:12:55.44,Chinese,,0,0,0,,你可能都做到了这一点，你忘记传递变量的地址
Dialogue: 0,1:12:56.82,1:13:02.96,English,,0,0,0,,So scanf doesn't know where to put the you know put the data
Dialogue: 0,1:12:56.82,1:13:02.96,Chinese,,0,0,0,,所以 scanf 不知道把数据放在哪里
Dialogue: 0,1:13:04.52,1:13:07.68,English,,0,0,0,,Okay another common mistake is to read uninitialized memory
Dialogue: 0,1:13:04.52,1:13:07.68,Chinese,,0,0,0,,另一个常见错误是读取未初始化的内存
Dialogue: 0,1:13:07.68,1:13:10.90,English,,0,0,0,,So suit you can't really assume that your heap data is initialized to 0
Dialogue: 0,1:13:07.68,1:13:10.90,Chinese,,0,0,0,,你不能真正假设你的堆数据初始化为 0
Dialogue: 0,1:13:11.96,1:13:16.82,English,,0,0,0,,So here we're we're malloc an array of an int
Dialogue: 0,1:13:11.96,1:13:16.82,Chinese,,0,0,0,,这里我们使用 malloc 分配一个 int 的数组
Dialogue: 0,1:13:17.24,1:13:18.72,English,,0,0,0,,And then we're going through and we're doing
Dialogue: 0,1:13:17.24,1:13:18.72,Chinese,,0,0,0,,我们正在做
Dialogue: 0,1:13:19.12,1:13:20.78,English,,0,0,0,,We're updating this vector
Dialogue: 0,1:13:19.12,1:13:20.78,Chinese,,0,0,0,,我们正在更新此向量
Dialogue: 0,1:13:21.54,1:13:24.82,English,,0,0,0,,This y vector we're reading y[i]
Dialogue: 0,1:13:21.54,1:13:24.82,Chinese,,0,0,0,,这个 y 矢量我们正在读 y[i]
Dialogue: 0,1:13:25.54,1:13:29.90,English,,0,0,0,,We're taking y[i] = y[i] + a[i][j]*x[j]
Dialogue: 0,1:13:25.54,1:13:29.90,Chinese,,0,0,0,,我们使 y [i] = y [i] + a [i] [j] * x [j]
Dialogue: 0,1:13:30.42,1:13:37.68,English,,0,0,0,,Okay so we're using we're assuming that y that malloc returns memory that's all zeros
Dialogue: 0,1:13:30.42,1:13:37.68,Chinese,,0,0,0,,所以我们正在使用我们假设那个 malloc 返回全部为零的内存
Dialogue: 0,1:13:38.22,1:13:39.06,English,,0,0,0,,So that'll get you
Dialogue: 0,1:13:38.22,1:13:39.06,Chinese,,0,0,0,,这会让你
Dialogue: 0,1:13:42.30,1:13:46.34,English,,0,0,0,,It's also easy to allocate the wrong sized object
Dialogue: 0,1:13:42.30,1:13:46.34,Chinese,,0,0,0,,分配错误大小的对象也很容易
Dialogue: 0,1:13:47.08,1:13:48.26,English,,0,0,0,,So here we want to create
Dialogue: 0,1:13:47.08,1:13:48.26,Chinese,,0,0,0,,我们想在这里创建
Dialogue: 0,1:13:49.60,1:13:54.48,English,,0,0,0,,An array of n pointers of n pointers to ints
Dialogue: 0,1:13:49.60,1:13:54.48,Chinese,,0,0,0,,一组 n 个指针，指向 int 的 n 个指针
Dialogue: 0,1:13:56.06,1:13:58.88,English,,0,0,0,,Okay and then for each one we want to allocate m ints
Dialogue: 0,1:13:56.06,1:13:58.88,Chinese,,0,0,0,,然后我们想要分配 m 个整数
Dialogue: 0,1:13:59.04,1:14:01.86,English,,0,0,0,,All right so this work we're creating a two-dimensional array
Dialogue: 0,1:13:59.04,1:14:01.86,Chinese,,0,0,0,,这项工作我们正在创建一个二维数组
Dialogue: 0,1:14:03.64,1:14:05.40,English,,0,0,0,,And can you see the mistake which
Dialogue: 0,1:14:03.64,1:14:05.40,Chinese,,0,0,0,,你能看出错误吗？
Dialogue: 0,1:14:10.42,1:14:12.06,English,,0,0,0,,Which line is buggy this one
Dialogue: 0,1:14:10.42,1:14:12.06,Chinese,,0,0,0,,哪一行有问题
Dialogue: 0,1:14:17.72,1:14:19.26,English,,0,0,0,,This one or this one
Dialogue: 0,1:14:17.72,1:14:19.26,Chinese,,0,0,0,,这一个或这一个
Dialogue: 0,1:14:20.76,1:14:23.42,English,,0,0,0,,The first one right because we really want size int star
Dialogue: 0,1:14:20.76,1:14:23.42,Chinese,,0,0,0,,第一行！因为我们想要是 int *
Dialogue: 0,1:14:24.40,1:14:29.30,English,,0,0,0,,Right so we're erroneous incorrectly assuming that int are the same sizes as pointers
Dialogue: 0,1:14:24.40,1:14:29.30,Chinese,,0,0,0,,我们错误地认为 int 与指针的大小相同
Dialogue: 0,1:14:30.84,1:14:32.26,English,,0,0,0,,This is a classic
Dialogue: 0,1:14:30.84,1:14:32.26,Chinese,,0,0,0,,这是非常经典的错误
Dialogue: 0,1:14:33.60,1:14:36.10,English,,0,0,0,,On this this assumption is true for 32-bit code
Dialogue: 0,1:14:33.60,1:14:36.10,Chinese,,0,0,0,,对此，这种假设适用于 32 位代码
Dialogue: 0,1:14:36.24,1:14:39.60,English,,0,0,0,,Ints and pointers are the same size but it's not true for 64-bit
Dialogue: 0,1:14:36.24,1:14:39.60,Chinese,,0,0,0,,Ints 和指针的大小相同，但对于 64 位则不然
Dialogue: 0,1:14:40.06,1:14:47.82,English,,0,0,0,,And so this is why when you...when people port 32-bit code to 64-bit machine a lot of times it breaks
Dialogue: 0,1:14:40.06,1:14:47.82,Chinese,,0,0,0,,所以这就是为什么当人们将 32 位代码移植到 64 位机器时很多时候它会中断
Dialogue: 0,1:14:48.20,1:14:49.50,English,,0,0,0,,Because they have this assumption
Dialogue: 0,1:14:48.20,1:14:49.50,Chinese,,0,0,0,,因为他们有这个假设
Dialogue: 0,1:14:51.28,1:14:54.42,English,,0,0,0,,Okay another way you it's easy to overwrite memory
Dialogue: 0,1:14:51.28,1:14:54.42,Chinese,,0,0,0,,另一种方式是你很容易覆盖内存
Dialogue: 0,1:14:55.28,1:14:59.18,English,,0,0,0,,So here we're creating correctly creating this array
Dialogue: 0,1:14:55.28,1:14:59.18,Chinese,,0,0,0,,所以我们正在创建这个数组
Dialogue: 0,1:14:59.56,1:15:02.74,English,,0,0,0,,But then when we create each of the sub arrays
Dialogue: 0,1:14:59.56,1:15:02.74,Chinese,,0,0,0,,但是当我们创建每个子数组时
Dialogue: 0,1:15:04.38,1:15:06.88,English,,0,0,0,,Instead of i less than or equal to n we're actually
Dialogue: 0,1:15:04.38,1:15:06.88,Chinese,,0,0,0,,我实际上并没有小于或等于 N
Dialogue: 0,1:15:07.22,1:15:10.58,English,,0,0,0,,We only created n of these things but we're traversing n+1
Dialogue: 0,1:15:07.22,1:15:10.58,Chinese,,0,0,0,,我们只创建了这些东西，但我们正在遍历 N + 1
Dialogue: 0,1:15:10.64,1:15:12.00,English,,0,0,0,,Because of this less than or equal
Dialogue: 0,1:15:10.64,1:15:12.00,Chinese,,0,0,0,,因为这个小于或等于
Dialogue: 0,1:15:12.32,1:15:13.96,English,,0,0,0,,So this is a classic off by one bug
Dialogue: 0,1:15:12.32,1:15:13.96,Chinese,,0,0,0,,所以这是一个经典的错误
Dialogue: 0,1:15:16.68,1:15:21.56,English,,0,0,0,,Ok another problem you saw it with the code injection attacks from your attack lab
Dialogue: 0,1:15:16.68,1:15:21.56,Chinese,,0,0,0,,好的另一个问题是你从 attack lab 看到的代码注入攻击
Dialogue: 0,1:15:21.94,1:15:24.06,English,,0,0,0,,Not checking the the size of a buffer
Dialogue: 0,1:15:21.94,1:15:24.06,Chinese,,0,0,0,,不检查缓冲区的大小
Dialogue: 0,1:15:24.66,1:15:28.10,English,,0,0,0,,So get ass is a classic example of this
Dialogue: 0,1:15:24.66,1:15:28.10,Chinese,,0,0,0,,所以缓冲区溢出就是一个典型的例子
Dialogue: 0,1:15:28.84,1:15:30.02,English,,0,0,0,,So that will get you into trouble
Dialogue: 0,1:15:28.84,1:15:30.02,Chinese,,0,0,0,,这样会让你陷入困境
Dialogue: 0,1:15:32.34,1:15:35.88,English,,0,0,0,,Another another classic mistake is misunderstanding pointer arithmetic
Dialogue: 0,1:15:32.34,1:15:35.88,Chinese,,0,0,0,,另一个经典错误是误解指针算术
Dialogue: 0,1:15:36.57,1:15:38.16,English,,0,0,0,,All right so if you increment a pointer
Dialogue: 0,1:15:36.57,1:15:38.16,Chinese,,0,0,0,,如果你增加一个指针
Dialogue: 0,1:15:41.22,1:15:46.90,English,,0,0,0,,Then it's incremented by the size of the object that pointer points to
Dialogue: 0,1:15:41.22,1:15:46.90,Chinese,,0,0,0,,然后它增加指针所指向的对象的大小
Dialogue: 0,1:15:48.16,1:15:51.08,English,,0,0,0,,Right so if you increment an int *  by one
Dialogue: 0,1:15:48.16,1:15:51.08,Chinese,,0,0,0,,如果你将 int* 递增 1
Dialogue: 0,1:15:51.60,1:15:53.42,English,,0,0,0,,It actually increments it by 4
Dialogue: 0,1:15:51.60,1:15:53.42,Chinese,,0,0,0,,它实际上将它增加 4
Dialogue: 0,1:15:54.20,1:15:55.36,English,,0,0,0,,Because that's the size of an int
Dialogue: 0,1:15:54.20,1:15:55.36,Chinese,,0,0,0,,因为那是 int 的大小
Dialogue: 0,1:15:58.04,1:16:00.24,English,,0,0,0,,He's got that's a really important distinction
Dialogue: 0,1:15:58.04,1:16:00.24,Chinese,,0,0,0,,他有这个非常重要的区别
Dialogue: 0,1:16:00.86,1:16:03.14,English,,0,0,0,,And so people will often
Dialogue: 0,1:16:00.86,1:16:03.14,Chinese,,0,0,0,,所以人们会经常这样
Dialogue: 0,1:16:03.94,1:16:07.22,English,,0,0,0,,So here it's assuming that incrementing so p is a pointer
Dialogue: 0,1:16:03.94,1:16:07.22,Chinese,,0,0,0,,所以这里假设递增，因为 p 是一个指针
Dialogue: 0,1:16:07.84,1:16:12.00,English,,0,0,0,,And the programmer here assumed that he wants to increment the pointer to sort of traverse it
Dialogue: 0,1:16:07.84,1:16:12.00,Chinese,,0,0,0,,并且程序员在这里假设他想要将指针递增以达到遍历数组的目的
Dialogue: 0,1:16:12.36,1:16:15.40,English,,0,0,0,,An array so he doesn't understand pointer arithmetic
Dialogue: 0,1:16:12.36,1:16:15.40,Chinese,,0,0,0,,他不懂指针算术
Dialogue: 0,1:16:16.00,1:16:21.04,English,,0,0,0,,And so to get to the next int increments  p by size int
Dialogue: 0,1:16:16.00,1:16:21.04,Chinese,,0,0,0,,所以要通过 size(int) 来获得下一个 int 增量 p
Dialogue: 0,1:16:21.62,1:16:24.68,English,,0,0,0,,Okay this will really increment it by 16 not by 4
Dialogue: 0,1:16:21.62,1:16:24.68,Chinese,,0,0,0,,这会增加 16 而不是 4
Dialogue: 0,1:16:27.70,1:16:30.72,English,,0,0,0,,Okay overriding memory that's a really nasty one
Dialogue: 0,1:16:27.70,1:16:30.72,Chinese,,0,0,0,,好内存覆盖是一个非常讨厌的
Dialogue: 0,1:16:31.60,1:16:38.96,English,,0,0,0,,And a lot of times this can happen if you don't understand the precedence of the operators
Dialogue: 0,1:16:31.60,1:16:38.96,Chinese,,0,0,0,,很多时候，如果你不了解运算符的优先级，就会发生这种情况
Dialogue: 0,1:16:38.96,1:16:39.90,English,,0,0,0,,That you're working with
Dialogue: 0,1:16:38.96,1:16:39.90,Chinese,,0,0,0,,你正在使用它们
Dialogue: 0,1:16:40.66,1:16:44.76,English,,0,0,0,,So this is a heap not too kind of heap we've been talking about but oh the heap data structure
Dialogue: 0,1:16:40.66,1:16:44.76,Chinese,,0,0,0,,所以这是一堆不是我们一直在讨论的那种堆，而是堆数据结构
Dialogue: 0,1:16:45.38,1:16:48.30,English,,0,0,0,,And this is a function to delete from a heap
Dialogue: 0,1:16:45.38,1:16:48.30,Chinese,,0,0,0,,这是一个从堆中删除的功能
Dialogue: 0,1:16:48.30,1:16:50.84,English,,0,0,0,,And this actually is from my own code I have to admit
Dialogue: 0,1:16:48.30,1:16:50.84,Chinese,,0,0,0,,我必须得承认这其实是来自我自己的代码
Dialogue: 0,1:16:52.44,1:16:57.44,English,,0,0,0,,And so I want to delete in it an element
Dialogue: 0,1:16:52.44,1:16:57.44,Chinese,,0,0,0,,我想在其中删除一个元素
Dialogue: 0,1:16:58.78,1:17:00.62,English,,0,0,0,,I want to delete the first element of the heap
Dialogue: 0,1:16:58.78,1:17:00.62,Chinese,,0,0,0,,我想删除堆的第一个元素
Dialogue: 0,1:17:01.18,1:17:03.20,English,,0,0,0,,Right and then I want to reify it
Dialogue: 0,1:17:01.18,1:17:03.20,Chinese,,0,0,0,,后我想要实现它
Dialogue: 0,1:17:04.10,1:17:06.98,English,,0,0,0,,Okay so I and then I want to return, I want to return that
Dialogue: 0,1:17:04.10,1:17:06.98,Chinese,,0,0,0,,然后我想返回这个
Dialogue: 0,1:17:07.68,1:17:09.90,English,,0,0,0,,So I get the first element the heap
Dialogue: 0,1:17:07.68,1:17:09.90,Chinese,,0,0,0,,我得到堆的第一个元素
Dialogue: 0,1:17:10.98,1:17:14.62,English,,0,0,0,,I decreased the size of the heap
Dialogue: 0,1:17:10.98,1:17:14.62,Chinese,,0,0,0,,我减小了堆的大小
Dialogue: 0,1:17:15.11,1:17:18.58,English,,0,0,0,,I take the last element and make that the first element
Dialogue: 0,1:17:15.11,1:17:18.58,Chinese,,0,0,0,,我拿出最后一个元素并将其作为第一个元素
Dialogue: 0,1:17:21.96,1:17:25.18,English,,0,0,0,,And and now I want to decrease the size of the heap
Dialogue: 0,1:17:21.96,1:17:25.18,Chinese,,0,0,0,,现在我想减小堆的大小
Dialogue: 0,1:17:25.88,1:17:29.44,English,,0,0,0,,Because this delete operation will delete the heap size by one
Dialogue: 0,1:17:25.88,1:17:29.44,Chinese,,0,0,0,,因为此删除操作会将堆大小删除一个
Dialogue: 0,1:17:30.70,1:17:33.06,English,,0,0,0,,So notice here we passed size n as a pointer
Dialogue: 0,1:17:30.70,1:17:33.06,Chinese,,0,0,0,,所以请注意，我们将 「size」作为指针传递
Dialogue: 0,1:17:34.00,1:17:35.92,English,,0,0,0,,And when this when this function terminate
Dialogue: 0,1:17:34.00,1:17:35.92,Chinese,,0,0,0,,而当这个功能终止时
Dialogue: 0,1:17:35.92,1:17:42.76,English,,0,0,0,,When this function return size should be updated size as a pointer the value that it points to you should be decremented
Dialogue: 0,1:17:35.92,1:17:42.76,Chinese,,0,0,0,,当这个函数返回 size 所指向的值会被更新，它将会减少
Dialogue: 0,1:17:43.22,1:17:44.06,English,,0,0,0,,Okay that's our intent
Dialogue: 0,1:17:43.22,1:17:44.06,Chinese,,0,0,0,,这是我们的意图
Dialogue: 0,1:17:44.74,1:17:47.72,English,,0,0,0,,And we do it right here with the *size--
Dialogue: 0,1:17:44.74,1:17:47.72,Chinese,,0,0,0,,我们就在这里用 *size--
Dialogue: 0,1:17:47.72,1:17:50.58,English,,0,0,0,,So what we want to do is we want to dereference size
Dialogue: 0,1:17:47.72,1:17:50.58,Chinese,,0,0,0,,所以我们想做的是我们想要取消引用大小
Dialogue: 0,1:17:51.76,1:17:53.20,English,,0,0,0,,And then decrement that value
Dialogue: 0,1:17:51.76,1:17:53.20,Chinese,,0,0,0,,然后递减该值
Dialogue: 0,1:17:54.36,1:18:02.92,English,,0,0,0,,But because the unary minus minus has higher of precedence than then the dereference
Dialogue: 0,1:17:54.36,1:18:02.92,Chinese,,0,0,0,,但是因为「一元减」的优先级高于取消引用的优先级
Dialogue: 0,1:18:03.70,1:18:06.74,English,,0,0,0,,What we're really doing is we're decrementing the pointer
Dialogue: 0,1:18:03.70,1:18:06.74,Chinese,,0,0,0,,我们真正在做的是我们减少指针
Dialogue: 0,1:18:07.16,1:18:09.04,English,,0,0,0,,And then dereferencing the value that's
Dialogue: 0,1:18:07.16,1:18:09.04,Chinese,,0,0,0,,然后解除引用的值
Dialogue: 0,1:18:10.30,1:18:14.78,English,,0,0,0,,One word less than a size variable
Dialogue: 0,1:18:10.30,1:18:14.78,Chinese,,0,0,0,,一个小于 size 一字的变量
Dialogue: 0,1:18:15.00,1:18:16.24,English,,0,0,0,,All right so these are nasty
Dialogue: 0,1:18:15.00,1:18:16.24,Chinese,,0,0,0,,这些都很讨厌
Dialogue: 0,1:18:16.92,1:18:18.94,English,,0,0,0,,And it would have been much cleaner
Dialogue: 0,1:18:16.92,1:18:18.94,Chinese,,0,0,0,,它本来会更简洁
Dialogue: 0,1:18:20.02,1:18:26.16,English,,0,0,0,,If I had just put parentheses around like I intended just parentheses star sized parentheses
Dialogue: 0,1:18:20.02,1:18:26.16,Chinese,,0,0,0,,如果我只是把括号括起来，就像我打算用圆括号星号括起来一样
Dialogue: 0,1:18:27.98,1:18:32.96,English,,0,0,0,,Alright another way you can mess up is referencing forgetting the local variables disappear
Dialogue: 0,1:18:27.98,1:18:32.96,Chinese,,0,0,0,,另一种方法你可以搞砸是引用忘记局部变量消失
Dialogue: 0,1:18:33.68,1:18:38.16,English,,0,0,0,,So if you have a function that returns an address of a local variable no good
Dialogue: 0,1:18:33.68,1:18:38.16,Chinese,,0,0,0,,所以如果你有一个函数返回一个局部变量的地址，这一点都不好
Dialogue: 0,1:18:38.76,1:18:40.40,English,,0,0,0,,Okay no good at all
Dialogue: 0,1:18:38.76,1:18:40.40,Chinese,,0,0,0,,一点也不好
Dialogue: 0,1:18:41.46,1:18:46.36,English,,0,0,0,,It might be okay for a while until somebody another function reuses that space
Dialogue: 0,1:18:41.46,1:18:46.36,Chinese,,0,0,0,,一段时间可能没关系，直到某人有另一个功能重用该空间
Dialogue: 0,1:18:46.84,1:18:51.02,English,,0,0,0,,That could be a return address it could be another functions local variable
Dialogue: 0,1:18:46.84,1:18:51.02,Chinese,,0,0,0,,这可能是一个返回地址，它可能是另一个函数局部变量
Dialogue: 0,1:18:54.72,1:18:58.78,English,,0,0,0,,Another terrible mistake this is a really bad one is freeing a block multiple time
Dialogue: 0,1:18:54.72,1:18:58.78,Chinese,,0,0,0,,另一个可怕的错误是一个非常糟糕的错误是多次释放一个块
Dialogue: 0,1:18:59.32,1:19:02.26,English,,0,0,0,,Now you know from your understanding now of malloc
Dialogue: 0,1:18:59.32,1:19:02.26,Chinese,,0,0,0,,现在你从现在对 malloc 的了解中得知
Dialogue: 0,1:19:02.64,1:19:07.36,English,,0,0,0,,That free actually writes to the heap right it's coalescing it's changing pointers
Dialogue: 0,1:19:02.64,1:19:07.36,Chinese,,0,0,0,,这个 free 实际上写入了堆，它正在合并它正在改变的指针
Dialogue: 0,1:19:07.86,1:19:09.36,English,,0,0,0,,It's changing size block sizes
Dialogue: 0,1:19:07.86,1:19:09.36,Chinese,,0,0,0,,它正在改变块大小
Dialogue: 0,1:19:10.02,1:19:13.78,English,,0,0,0,,So if you free a block that's already been freed terrible things will happen
Dialogue: 0,1:19:10.02,1:19:13.78,Chinese,,0,0,0,,如果你释放一块已经被释放的块，那么可怕的事情就会发生
Dialogue: 0,1:19:17.36,1:19:21.78,English,,0,0,0,,Another thing you can do wrong is to reference a block you forget that you freed a block and then you reference
Dialogue: 0,1:19:17.36,1:19:21.78,Chinese,,0,0,0,,你可能做错的另一件事是引用一个块，你忘了你释放了一个块然后你引用
Dialogue: 0,1:19:22.04,1:19:24.24,English,,0,0,0,,It so here we free of this block x
Dialogue: 0,1:19:22.04,1:19:24.24,Chinese,,0,0,0,,在这里我们释放了这个块 x
Dialogue: 0,1:19:25.02,1:19:26.32,English,,0,0,0,,And then we're referencing it here
Dialogue: 0,1:19:25.02,1:19:26.32,Chinese,,0,0,0,,然后我们在这里引用它
Dialogue: 0,1:19:28.42,1:19:30.10,English,,0,0,0,,Another big problem is
Dialogue: 0,1:19:28.42,1:19:30.10,Chinese,,0,0,0,,另一个大问题是
Dialogue: 0,1:19:30.64,1:19:34.30,English,,0,0,0,,Memory leaks so failing to free block so allocating some block
Dialogue: 0,1:19:30.64,1:19:34.30,Chinese,,0,0,0,,内存泄漏，无法释放块，因此分配了一些块
Dialogue: 0,1:19:34.86,1:19:36.40,English,,0,0,0,,Function and then returning
Dialogue: 0,1:19:34.86,1:19:36.40,Chinese,,0,0,0,,然后函数返回
Dialogue: 0,1:19:36.96,1:19:39.48,English,,0,0,0,,That block will stay there forever right because it's garbage
Dialogue: 0,1:19:36.96,1:19:39.48,Chinese,,0,0,0,,那块将永远留在那里因为它是垃圾
Dialogue: 0,1:19:43.58,1:19:47.20,English,,0,0,0,,Okay so there's a number of ways to deal with memory bugs
Dialogue: 0,1:19:43.58,1:19:47.20,Chinese,,0,0,0,,有很多方法可以处理内存错误
Dialogue: 0,1:19:47.20,1:19:51.86,English,,0,0,0,,GDB is sometimes good at least it'll tell you where a segfault occurs
Dialogue: 0,1:19:47.20,1:19:51.86,Chinese,,0,0,0,,GDB 有时候很好，它至少可以告诉你 segfault 发生在哪里
Dialogue: 0,1:19:52.52,1:19:54.48,English,,0,0,0,,Then you got to track down what the right that
Dialogue: 0,1:19:52.52,1:19:54.48,Chinese,,0,0,0,,然后你必须找到正确的
Dialogue: 0,1:19:55.22,1:19:56.78,English,,0,0,0,,Sort of caused that segfault
Dialogue: 0,1:19:55.22,1:19:56.78,Chinese,,0,0,0,,排序导致了段错误的位置
Dialogue: 0,1:19:58.64,1:19:59.92,English,,0,0,0,,The best thing you can do
Dialogue: 0,1:19:58.64,1:19:59.92,Chinese,,0,0,0,,你能做的最好的事情
Dialogue: 0,1:20:00.56,1:20:06.18,English,,0,0,0,,But GDB falls down whenever you're doing manipulation of complex data structures
Dialogue: 0,1:20:00.56,1:20:06.18,Chinese,,0,0,0,,但是，只要你正在操纵复杂的数据结构，GDB 就会崩溃
Dialogue: 0,1:20:06.82,1:20:09.54,English,,0,0,0,,It's just simple sort of looking one instruction at a time
Dialogue: 0,1:20:06.82,1:20:09.54,Chinese,,0,0,0,,它只是简单地一次查看一条指令
Dialogue: 0,1:20:10.00,1:20:14.74,English,,0,0,0,,What you really need to do is identify any complex data structure like a heap for example
Dialogue: 0,1:20:10.00,1:20:14.74,Chinese,,0,0,0,,你真正需要做的是识别任何复杂的数据结构，例如堆
Dialogue: 0,1:20:15.62,1:20:20.10,English,,0,0,0,,Is identify invariance for that structure that data structure should always maintain
Dialogue: 0,1:20:15.62,1:20:20.10,Chinese,,0,0,0,,确定数据结构应始终保持的结构的不变性
Dialogue: 0,1:20:21.08,1:20:22.34,English,,0,0,0,,And then you write a function
Dialogue: 0,1:20:21.08,1:20:22.34,Chinese,,0,0,0,,然后你写一个函数
Dialogue: 0,1:20:22.68,1:20:27.34,English,,0,0,0,,That iterates over that structure that data structure and checks that all those they're invariants are true
Dialogue: 0,1:20:22.68,1:20:27.34,Chinese,,0,0,0,,迭代数据结构时，检查所有那些不变量的结构是否为真
Dialogue: 0,1:20:28.06,1:20:30.34,English,,0,0,0,,So for example in it
Dialogue: 0,1:20:28.06,1:20:30.34,Chinese,,0,0,0,,例如
Dialogue: 0,1:20:31.14,1:20:34.50,English,,0,0,0,,And in allocator one of the invariance is that there should be no
Dialogue: 0,1:20:31.14,1:20:34.50,Chinese,,0,0,0,,在分配器中，其中一个不变性是
Dialogue: 0,1:20:35.52,1:20:37.82,English,,0,0,0,,That there should never be two contiguous free blocks
Dialogue: 0,1:20:35.52,1:20:37.82,Chinese,,0,0,0,,永远不应该有两个连续的空闲块
Dialogue: 0,1:20:38.14,1:20:44.52,English,,0,0,0,,Right so your consistency checker should go through the heap and make sure there's no contiguous free blocks
Dialogue: 0,1:20:38.14,1:20:44.52,Chinese,,0,0,0,,所以你的一致性检查器应该通过堆并确保没有连续的空闲块
Dialogue: 0,1:20:45.26,1:20:50.36,English,,0,0,0,,Or another invariant is that every free block should be in a free list somewhere
Dialogue: 0,1:20:45.26,1:20:50.36,Chinese,,0,0,0,,或者另一个不变量是每个空闲块应该在某个地方的空闲列表中
Dialogue: 0,1:20:51.32,1:20:57.04,English,,0,0,0,,Right so you would up your consistency checker would scan the heap count the number of free blocks
Dialogue: 0,1:20:51.32,1:20:57.04,Chinese,,0,0,0,,你想你的一致性检查器将扫描堆计数空闲块的数量
Dialogue: 0,1:20:57.56,1:20:59.44,English,,0,0,0,,And then scan the free list and make sure
Dialogue: 0,1:20:57.56,1:20:59.44,Chinese,,0,0,0,,然后扫描空闲列表并确保
Dialogue: 0,1:20:59.80,1:21:03.32,English,,0,0,0,,That the number of blocks in the free list is the same as the number of free blocks
Dialogue: 0,1:20:59.80,1:21:03.32,Chinese,,0,0,0,,空闲列表中的块数与空闲块的数量相同
Dialogue: 0,1:21:04.24,1:21:07.58,English,,0,0,0,,Okay so this idea of a consistency checker is something you'll use in your malloc lab
Dialogue: 0,1:21:04.24,1:21:07.58,Chinese,,0,0,0,,我们会在 malloc  lab 中使用一致性检查器
Dialogue: 0,1:21:07.80,1:21:13.92,English,,0,0,0,,But it's something it's also something you should use whenever you're updating any kind of complex data structure
Dialogue: 0,1:21:07.80,1:21:13.92,Chinese,,0,0,0,,但是，无论何时更新任何类型的复杂数据结构，都应该使用它
Dialogue: 0,1:21:16.08,1:21:20.04,English,,0,0,0,,And you know about valgrind but the great thing about these heap checkers
Dialogue: 0,1:21:16.08,1:21:20.04,Chinese,,0,0,0,,你知道 valgrind，但关于这些堆检查器
Dialogue: 0,1:21:20.54,1:21:22.10,English,,0,0,0,,Ok I'm passionate about heap checkers
Dialogue: 0,1:21:20.54,1:21:22.10,Chinese,,0,0,0,,我对堆检查器很有热情
Dialogue: 0,1:21:23.15,1:21:24.26,English,,0,0,0,,Or consistency checkers
Dialogue: 0,1:21:23.15,1:21:24.26,Chinese,,0,0,0,,或一致性检查员
Dialogue: 0,1:21:25.28,1:21:29.38,English,,0,0,0,,The really powerful thing about them is you write them to run silently
Dialogue: 0,1:21:25.28,1:21:29.38,Chinese,,0,0,0,,关于它们的真正强大之处在于你将它们写成静默运行
Dialogue: 0,1:21:30.64,1:21:35.48,English,,0,0,0,,They don't print anything unless they find that a violation of the invariance
Dialogue: 0,1:21:30.64,1:21:35.48,Chinese,,0,0,0,,除非他们发现违反不变性，否则他们不会打印任何内容
Dialogue: 0,1:21:36.50,1:21:40.12,English,,0,0,0,,If you write your consistency checker like this then you can use it like a probe
Dialogue: 0,1:21:36.50,1:21:40.12,Chinese,,0,0,0,,如果你像这样编写一致性检查器，那么你可以像探测器一样使用它
Dialogue: 0,1:21:40.94,1:21:42.30,English,,0,0,0,,So your program crashes
Dialogue: 0,1:21:40.94,1:21:42.30,Chinese,,0,0,0,,你的程序崩溃了
Dialogue: 0,1:21:43.22,1:21:47.54,English,,0,0,0,,So you do it you use this heap checker to do a binary search to isolate the cause
Dialogue: 0,1:21:43.22,1:21:47.54,Chinese,,0,0,0,,你这样做，你使用这个堆检查器进行二进制搜索，以找出原因
Dialogue: 0,1:21:48.30,1:21:52.42,English,,0,0,0,,So you know you put your heap checker here
Dialogue: 0,1:21:48.30,1:21:52.42,Chinese,,0,0,0,,所以你知道你把堆检查器放在这里
Dialogue: 0,1:21:52.96,1:21:54.06,English,,0,0,0,,Everything is ok
Dialogue: 0,1:21:52.96,1:21:54.06,Chinese,,0,0,0,,一切都好
Dialogue: 0,1:21:54.40,1:21:56.08,English,,0,0,0,,And then later the program crash
Dialogue: 0,1:21:54.40,1:21:56.08,Chinese,,0,0,0,,然后程序崩溃了
Dialogue: 0,1:21:56.96,1:21:58.76,English,,0,0,0,,So now you stick the heap checker here
Dialogue: 0,1:21:56.96,1:21:58.76,Chinese,,0,0,0,,所以现在你把堆检查器粘在这里
Dialogue: 0,1:22:00.02,1:22:04.32,English,,0,0,0,,And now it crash the heap checker detects an in violation
Dialogue: 0,1:22:00.02,1:22:04.32,Chinese,,0,0,0,,现在崩溃堆检查器检测到违规
Dialogue: 0,1:22:04.58,1:22:06.98,English,,0,0,0,,So you know that the problem is somewhere here
Dialogue: 0,1:22:04.58,1:22:06.98,Chinese,,0,0,0,,所以你知道这个问题就在这里
Dialogue: 0,1:22:06.98,1:22:09.44,English,,0,0,0,,And you can just keep narrowing it down so it's just like a probe
Dialogue: 0,1:22:06.98,1:22:09.44,Chinese,,0,0,0,,你可以继续缩小范围，这就像探测器一样
Dialogue: 0,1:22:09.96,1:22:12.92,English,,0,0,0,,Surgical probe that you can use to to track down bugs
Dialogue: 0,1:22:09.96,1:22:12.92,Chinese,,0,0,0,,你可以用来追踪错误的手术探针
Dialogue: 0,1:22:14.28,1:22:15.76,English,,0,0,0,,And so that's if you do this like it's
Dialogue: 0,1:22:14.28,1:22:15.76,Chinese,,0,0,0,,如果你像这样做的话
Dialogue: 0,1:22:17.06,1:22:20.60,English,,0,0,0,,I don't know how anybody debugs malloc without this kind of tool
Dialogue: 0,1:22:17.06,1:22:20.60,Chinese,,0,0,0,,我不知道有没有人在没有这种工具的情况下调试 malloc
Dialogue: 0,1:22:24.92,1:22:26.70,English,,0,0,0,,Okay so that's it for today
Dialogue: 0,1:22:24.92,1:22:26.70,Chinese,,0,0,0,,好的，这就是今天的内容
Dialogue: 0,1:22:28.70,1:22:30.54,English,,0,0,0,,Have a good weekend we'll see you on Tuesday
Dialogue: 0,1:22:28.70,1:22:30.54,Chinese,,0,0,0,,祝周末愉快，周二我们会见到你
