[Script Info]
; Script generated by Aegisub r8942
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: csapp/Lecture 17  Virtual Memory  Concepts.mp4
Video File: csapp/Lecture 17  Virtual Memory  Concepts.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.003906
Scroll Position: 1485
Active Line: 1493
Video Position: 126993

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Noto Sans CJK SC Black,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,1.5,1.2,2,10,10,10,1
Style: Chinese,Noto Sans CJK SC Black,40,&H00FFFF00,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.2,1.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.06,0:00:01.44,English,,0,0,0,,Good afternoon everybody
Dialogue: 0,0:00:00.06,0:00:01.44,Chinese,,0,0,0,,大家下午好
Dialogue: 0,0:00:02.24,0:00:03.90,English,,0,0,0,,Welcome good to see you as always
Dialogue: 0,0:00:02.24,0:00:03.90,Chinese,,0,0,0,,很高兴再次和大家见面
Dialogue: 0,0:00:06.08,0:00:12.46,English,,0,0,0,,Today we're going to learn about an important concept in computer science called virtual memory
Dialogue: 0,0:00:06.08,0:00:12.46,Chinese,,0,0,0,,今天我们将学习计算机科学中的一个重要概念「虚拟内存」
Dialogue: 0,0:00:18.86,0:00:23.43,English,,0,0,0,,So consider a system that uses physical addressing
Dialogue: 0,0:00:18.86,0:00:23.43,Chinese,,0,0,0,,考虑一个使用物理寻址的系统
Dialogue: 0,0:00:23.43,0:00:31.34,English,,0,0,0,,Right, our idea about memory so far has been that it's a contiguous array of physical bytes
Dialogue: 0,0:00:23.43,0:00:31.34,Chinese,,0,0,0,,到目前为止，我们把内存理解成一个连续的物理字节数组
Dialogue: 0,0:00:31.90,0:00:37.08,English,,0,0,0,,That we can access just by giving an offset called an address
Dialogue: 0,0:00:31.90,0:00:37.08,Chinese,,0,0,0,,可以通过给出一些称为地址的偏移来访问
Dialogue: 0,0:00:38.38,0:00:41.12,English,,0,0,0,,So in a system that uses physical addressing
Dialogue: 0,0:00:38.38,0:00:41.12,Chinese,,0,0,0,,所以在使用物理寻址的系统中
Dialogue: 0,0:00:43.34,0:00:46.91,English,,0,0,0,,The CPU executes like say a move instruction
Dialogue: 0,0:00:43.34,0:00:46.91,Chinese,,0,0,0,,以 CPU 执行一条移动指令为例
Dialogue: 0,0:00:47.54,0:00:50.74,English,,0,0,0,,Which generates an effective address,the physical address
Dialogue: 0,0:00:47.54,0:00:50.74,Chinese,,0,0,0,,生成了一个有效的物理地址
Dialogue: 0,0:00:51.12,0:00:55.42,English,,0,0,0,,And this address is actually the offset of a byte in main memory so
Dialogue: 0,0:00:51.12,0:00:55.42,Chinese,,0,0,0,,这个地址实际上是主存储器中一个字节的偏移量
Dialogue: 0,0:00:56.22,0:01:00.22,English,,0,0,0,,You know here the CPU has generated a physical address of 4
Dialogue: 0,0:00:56.22,0:01:00.22,Chinese,,0,0,0,,如图，CPU 在这里生成的物理地址为 4
Dialogue: 0,0:01:01.86,0:01:04.06,English,,0,0,0,,Sends that address to the memory
Dialogue: 0,0:01:01.86,0:01:04.06,Chinese,,0,0,0,,把地址发送给内存
Dialogue: 0,0:01:05.72,0:01:13.20,English,,0,0,0,,And then the memory fetches the word from at that address and then sends it back to the CPU
Dialogue: 0,0:01:05.72,0:01:13.20,Chinese,,0,0,0,,然后内存从该地址获取其中保存的字，然后将其发送回 CPU
Dialogue: 0,0:01:15.84,0:01:20.40,English,,0,0,0,,This is in fact the way that very simple microcontrollers work
Dialogue: 0,0:01:15.84,0:01:20.40,Chinese,,0,0,0,,实际上，这是非常简单的微控制器工作的方式
Dialogue: 0,0:01:20.96,0:01:27.56,English,,0,0,0,,But it's not the way most systems work including your phones, your desktops, your servers
Dialogue: 0,0:01:20.96,0:01:27.56,Chinese,,0,0,0,,但这并不是大多数系统的工作方式，包括手机，台式机和服务器
Dialogue: 0,0:01:28.60,0:01:33.44,English,,0,0,0,,These systems instead virtualize this main memory
Dialogue: 0,0:01:28.60,0:01:33.44,Chinese,,0,0,0,,这些系统虚拟化这个主存储器
Dialogue: 0,0:01:34.88,0:01:39.90,English,,0,0,0,,Now the idea of virtualization is a very important one in computer science
Dialogue: 0,0:01:34.88,0:01:39.90,Chinese,,0,0,0,,现在，虚拟化的概念在计算机科学中是非常重要的
Dialogue: 0,0:01:40.48,0:01:45.24,English,,0,0,0,,And it expands a lot of it applies to, a lot of areas of computer systems
Dialogue: 0,0:01:40.48,0:01:45.24,Chinese,,0,0,0,,它扩展了很多，应用于计算机系统的很多领域
Dialogue: 0,0:01:46.10,0:01:48.48,English,,0,0,0,,Now when you virtualize a resource
Dialogue: 0,0:01:46.10,0:01:48.48,Chinese,,0,0,0,,当你一个虚拟化资源时
Dialogue: 0,0:01:49.26,0:01:54.76,English,,0,0,0,,You present the user of that resource with some different kind of view of that resource
Dialogue: 0,0:01:49.26,0:01:54.76,Chinese,,0,0,0,,你向该资源的用户显示该资源的一些不同类型的视图
Dialogue: 0,0:01:56.30,0:02:01.42,English,,0,0,0,,You present typically some kind of an abstraction or some kind of a different view of the resource
Dialogue: 0,0:01:56.30,0:02:01.42,Chinese,,0,0,0,,你通常会呈现某种抽象或某种不同的资源视图
Dialogue: 0,0:02:03.20,0:02:07.16,English,,0,0,0,,And you do it by interposing on accesses to that resource
Dialogue: 0,0:02:03.20,0:02:07.16,Chinese,,0,0,0,,你可以通过介入对该资源的访问过程来实现这一点
Dialogue: 0,0:02:08.46,0:02:11.64,English,,0,0,0,,So in all cases there's some resource and you want to virtualize it
Dialogue: 0,0:02:08.46,0:02:11.64,Chinese,,0,0,0,,所以当你有一些资源，并且想要虚拟化它时
Dialogue: 0,0:02:12.48,0:02:17.58,English,,0,0,0,,And you do that by intercepting or interposing on the accesses to that resource
Dialogue: 0,0:02:12.48,0:02:17.58,Chinese,,0,0,0,,你通过干预或介入对该资源的访问过程来实现这一点
Dialogue: 0,0:02:18.94,0:02:25.00,English,,0,0,0,,And then once you...we saw this when we created wrapper functions for like malloc
Dialogue: 0,0:02:18.94,0:02:25.00,Chinese,,0,0,0,,好的，然后一旦你……我们在为 malloc 创建包装函数时看到了这一点
Dialogue: 0,0:02:25.00,0:02:26.62,English,,0,0,0,,When I was showing you interpositioning
Dialogue: 0,0:02:25.00,0:02:26.62,Chinese,,0,0,0,,我在给你们讲解打桩技术时提到过
Dialogue: 0,0:02:27.14,0:02:30.44,English,,0,0,0,,The same technique is used to virtualize a resource
Dialogue: 0,0:02:27.14,0:02:30.44,Chinese,,0,0,0,,相同的技术可以用来虚拟化资源
Dialogue: 0,0:02:31.18,0:02:35.94,English,,0,0,0,,And once you've intercepted that access, then you can deal with it any way you want
Dialogue: 0,0:02:31.18,0:02:35.94,Chinese,,0,0,0,,一旦你拦截了访问的过程，那么你就可以用任何你想要的方式处理它
Dialogue: 0,0:02:35.94,0:02:42.70,English,,0,0,0,,So that's how you have sort of full power to change a person to change the view of that resource okay
Dialogue: 0,0:02:35.94,0:02:42.70,Chinese,,0,0,0,,这样你就有很多方法改变那个资源对用户的视图
Dialogue: 0,0:02:43.86,0:02:46.62,English,,0,0,0,,So a good example you saw this when we looked at disks
Dialogue: 0,0:02:43.86,0:02:46.62,Chinese,,0,0,0,,我们看待磁盘的方式就是一个很好的例子
Dialogue: 0,0:02:48.28,0:02:54.10,English,,0,0,0,,And you know physically disk consists of cylinders, tracks, sectors, platters surfaces
Dialogue: 0,0:02:48.28,0:02:54.10,Chinese,,0,0,0,,而且你知道磁盘在物理上由柱面、磁道、扇区、盘面组成
Dialogue: 0,0:02:55.38,0:02:59.58,English,,0,0,0,,And to access a particular sector on one of those disks
Dialogue: 0,0:02:55.38,0:02:59.58,Chinese,,0,0,0,,访问这些磁盘上的一个特定扇区时
Dialogue: 0,0:02:59.58,0:03:03.40,English,,0,0,0,,You have to specify the cylinder and the track and the surface
Dialogue: 0,0:02:59.58,0:03:03.40,Chinese,,0,0,0,,你必须指定柱面、磁道和盘面
Dialogue: 0,0:03:04.98,0:03:09.06,English,,0,0,0,,But we saw that the view that disk controllers present is actually different
Dialogue: 0,0:03:04.98,0:03:09.06,Chinese,,0,0,0,,但是我们看到磁盘控制器显示的视图实际上不是这样的
Dialogue: 0,0:03:09.06,0:03:11.96,English,,0,0,0,,It's a virtualized view of the disk
Dialogue: 0,0:03:09.06,0:03:11.96,Chinese,,0,0,0,,它是磁盘的虚拟化视图
Dialogue: 0,0:03:12.54,0:03:18.68,English,,0,0,0,,And the controller instead presents to the kernel a view of the disk as a series of a sequence of logical blocks
Dialogue: 0,0:03:12.54,0:03:18.68,Chinese,,0,0,0,,而磁盘控制器则将磁盘抽象成一系列逻辑块的形式提供给内核
Dialogue: 0,0:03:21.04,0:03:27.48,English,,0,0,0,,And it presents that view by intercepting the requests from the kernel for I/O
Dialogue: 0,0:03:21.04,0:03:27.48,Chinese,,0,0,0,,它通过拦截来自内核的读写请求来呈现该视图
Dialogue: 0,0:03:28.24,0:03:34.58,English,,0,0,0,,And changing those logical block numbers that the kernel sends into the actual physical address
Dialogue: 0,0:03:28.24,0:03:34.58,Chinese,,0,0,0,,并将内核发送的逻辑块号转换为实际的物理地址
Dialogue: 0,0:03:34.76,0:03:43.72,English,,0,0,0,,Ok so that's a very important example of virtualization in a system
Dialogue: 0,0:03:34.76,0:03:43.72,Chinese,,0,0,0,,好的，这是系统中虚拟化的一个非常重要的例子
Dialogue: 0,0:03:44.08,0:03:52.96,English,,0,0,0,,Now the memory is a very ... is a crucial resource in the system
Dialogue: 0,0:03:44.08,0:03:52.96,Chinese,,0,0,0,,现在内存是系统中的关键资源
Dialogue: 0,0:03:52.96,0:03:57.94,English,,0,0,0,,And what we found is that it's useful to virtualize that memory resource
Dialogue: 0,0:03:52.96,0:03:57.94,Chinese,,0,0,0,,我们发现，虚拟化内存资源非常有用
Dialogue: 0,0:03:59.76,0:04:01.14,English,,0,0,0,,And the way this is done
Dialogue: 0,0:03:59.76,0:04:01.14,Chinese,,0,0,0,,这样做的方式
Dialogue: 0,0:04:02.40,0:04:08.50,English,,0,0,0,,Remember before we virtualized the disk by having the disk controller intercept request
Dialogue: 0,0:04:02.40,0:04:08.50,Chinese,,0,0,0,,之前我们通过让磁盘控制器拦截请求，来实现磁盘虚拟化
Dialogue: 0,0:04:09.44,0:04:12.00,English,,0,0,0,,In the case of the main memory resource
Dialogue: 0,0:04:09.44,0:04:12.00,Chinese,,0,0,0,,对于主存储器资源
Dialogue: 0,0:04:13.26,0:04:18.90,English,,0,0,0,,The requests are actually intercepted by a piece of hardware called the MMU, the memory management unit
Dialogue: 0,0:04:13.26,0:04:18.90,Chinese,,0,0,0,,这些请求实际上是由一块称为 MMU 的内存管理单元的硬件来处理的
Dialogue: 0,0:04:19.98,0:04:24.16,English,,0,0,0,,So the way this works is that the CPU executes an instruction
Dialogue: 0,0:04:19.98,0:04:24.16,Chinese,,0,0,0,,所以它的工作方式是，当 CPU 执行一条指令时
Dialogue: 0,0:04:24.86,0:04:28.26,English,,0,0,0,,Say it's a move instruction that generates some effective address
Dialogue: 0,0:04:24.86,0:04:28.26,Chinese,,0,0,0,,比如说它是一个移动指令，产生某个有效地址
Dialogue: 0,0:04:29.30,0:04:31.04,English,,0,0,0,,So this is actually a virtual address
Dialogue: 0,0:04:29.30,0:04:31.04,Chinese,,0,0,0,,这实际上是一个虚拟地址
Dialogue: 0,0:04:32.36,0:04:36.53,English,,0,0,0,,It's the CPU sends that address to the MMU
Dialogue: 0,0:04:32.36,0:04:36.53,Chinese,,0,0,0,,CPU 将该地址发送给 MMU
Dialogue: 0,0:04:37.38,0:04:42.10,English,,0,0,0,,Which goes through a process called address translation which will study later today
Dialogue: 0,0:04:37.38,0:04:42.10,Chinese,,0,0,0,,这是一个称为地址转换的过程，我们将在今天晚些时候学到
Dialogue: 0,0:04:42.92,0:04:49.96,English,,0,0,0,,And it converts that virtual address in this case 4100 into a physical address 4
Dialogue: 0,0:04:42.92,0:04:49.96,Chinese,,0,0,0,,在这个例子里，它将虚拟地址 4100 转换为物理地址 4
Dialogue: 0,0:04:50.22,0:04:55.82,English,,0,0,0,,Which actually corresponds to the address of that the data object that we want
Dialogue: 0,0:04:50.22,0:04:55.82,Chinese,,0,0,0,,这实际上对应于我们想要的数据对象的地址
Dialogue: 0,0:04:56.74,0:05:01.28,English,,0,0,0,,Ok so once the MMU translates the virtual address to a physical address
Dialogue: 0,0:04:56.74,0:05:01.28,Chinese,,0,0,0,,MMU 将虚拟地址转换为物理地址之后
Dialogue: 0,0:05:02.94,0:05:06.16,English,,0,0,0,,Then the memory will return the word at that address
Dialogue: 0,0:05:02.94,0:05:06.16,Chinese,,0,0,0,,然后内存将返回存储在该地址中的字
Dialogue: 0,0:05:08.90,0:05:11.14,English,,0,0,0,,So this...
Dialogue: 0,0:05:08.90,0:05:11.14,Chinese,,0,0,0,,所以这……
Dialogue: 0,0:05:12.24,0:05:14.24,English,,0,0,0,,My wonder why in the world would you want to do this
Dialogue: 0,0:05:12.24,0:05:14.24,Chinese,,0,0,0,,我们到底为什么要这么做呢
Dialogue: 0,0:05:14.24,0:05:19.36,English,,0,0,0,,Well it turns out there's all kinds of good reasons to virtualize the address space
Dialogue: 0,0:05:14.24,0:05:19.36,Chinese,,0,0,0,,事实证明，虚拟化地址空间有各种充分的理由
Dialogue: 0,0:05:20.14,0:05:22.74,English,,0,0,0,,And so before I can explain those to you
Dialogue: 0,0:05:20.14,0:05:22.74,Chinese,,0,0,0,,所以在我向你解释这些之前
Dialogue: 0,0:05:22.86,0:05:27.66,English,,0,0,0,,Let me just define a few terms
Dialogue: 0,0:05:22.86,0:05:27.66,Chinese,,0,0,0,,我来简单定义几个术语
Dialogue: 0,0:05:28.90,0:05:32.26,English,,0,0,0,,An address space is a set of addresses
Dialogue: 0,0:05:28.90,0:05:32.26,Chinese,,0,0,0,,地址空间是一个地址的集合
Dialogue: 0,0:05:32.50,0:05:34.56,English,,0,0,0,,Ok so an address spaces is a set
Dialogue: 0,0:05:32.50,0:05:34.56,Chinese,,0,0,0,,好的，地址空间是一个集合
Dialogue: 0,0:05:35.58,0:05:39.74,English,,0,0,0,,Not of data bytes but of the addresses of those bytes
Dialogue: 0,0:05:35.58,0:05:39.74,Chinese,,0,0,0,,不是数据字节的集合，而是那些字节的地址的集合
Dialogue: 0,0:05:40.64,0:05:48.88,English,,0,0,0,,And a linear address space is a contiguous set of contiguous non-negative integers
Dialogue: 0,0:05:40.64,0:05:48.88,Chinese,,0,0,0,,并且线性地址空间是连续的非负整数集合
Dialogue: 0,0:05:49.68,0:05:53.28,English,,0,0,0,,So just 0,1,2,3,4 and so on
Dialogue: 0,0:05:49.68,0:05:53.28,Chinese,,0,0,0,,只有 0,1,2,3,4 等等
Dialogue: 0,0:05:54.60,0:06:01.52,English,,0,0,0,,The virtual address space is a set of N = 2 ^ n virtual addresses. It's a linear address space
Dialogue: 0,0:05:54.60,0:06:01.52,Chinese,,0,0,0,,虚拟地址空间是包含 N = 2^n 个虚拟地址的集合，是线性地址空间
Dialogue: 0,0:06:02.48,0:06:07.70,English,,0,0,0,,And the physical address space is a set of M = 2 ^ m physical addresses ok
Dialogue: 0,0:06:02.48,0:06:07.70,Chinese,,0,0,0,,而物理地址空间是包含 M = 2^m 个物理地址的集合
Dialogue: 0,0:06:10.22,0:06:19.36,English,,0,0,0,,And so typically the virtual address space is usually much larger than the physical address space
Dialogue: 0,0:06:10.22,0:06:19.36,Chinese,,0,0,0,,通常虚拟地址空间通常比物理地址空间大得多
Dialogue: 0,0:06:19.54,0:06:24.68,English,,0,0,0,,Okay the physical address space corresponds to the amount of DRAM that you actually have in the system
Dialogue: 0,0:06:19.54,0:06:24.68,Chinese,,0,0,0,,物理地址空间对应于系统中实际拥有的 DRAM 容量
Dialogue: 0,0:06:25.34,0:06:31.52,English,,0,0,0,,The virtual address space is the same for all processes running on that system
Dialogue: 0,0:06:25.34,0:06:31.52,Chinese,,0,0,0,,对于在该系统上运行的所有进程，虚拟地址空间是相同的
Dialogue: 0,0:06:35.30,0:06:38.14,English,,0,0,0,,Why do we want to implement virtual memory
Dialogue: 0,0:06:35.30,0:06:38.14,Chinese,,0,0,0,,那为什么我们要实现虚拟内存呢
Dialogue: 0,0:06:38.14,0:06:43.48,English,,0,0,0,,Why do this, why do this level of indirection with the MMU
Dialogue: 0,0:06:38.14,0:06:43.48,Chinese,,0,0,0,,为什么这样做，为什么要增加 MMU
Dialogue: 0,0:06:44.54,0:06:46.68,English,,0,0,0,,Well there's really three big reasons so
Dialogue: 0,0:06:44.54,0:06:46.68,Chinese,,0,0,0,,有三个重要原因
Dialogue: 0,0:06:47.02,0:06:56.00,English,,0,0,0,,The first is that virtual memory uses the DRAM as a cache for the actual data stored on disk
Dialogue: 0,0:06:47.02,0:06:56.00,Chinese,,0,0,0,,第一，虚拟内存使用 DRAM 作为存储在磁盘上的实际数据的缓存
Dialogue: 0,0:06:56.82,0:07:03.14,English,,0,0,0,,Okay so you can think of virtual memory as a DRAM cache for data stored on the disk
Dialogue: 0,0:06:56.82,0:07:03.14,Chinese,,0,0,0,,你可以将虚拟内存视为存储在磁盘上的数据的 DRAM 缓存
Dialogue: 0,0:07:03.66,0:07:08.58,English,,0,0,0,,And this allows us to use the memory much more efficiently
Dialogue: 0,0:07:03.66,0:07:08.58,Chinese,,0,0,0,,这使我们能够更有效地使用内存
Dialogue: 0,0:07:09.04,0:07:12.20,English,,0,0,0,,Because we only need to cache items that are frequently used
Dialogue: 0,0:07:09.04,0:07:12.20,Chinese,,0,0,0,,因为我们只需要缓存经常使用的数据
Dialogue: 0,0:07:12.20,0:07:17.02,English,,0,0,0,,Right just the same idea that we learned when we talked about caches and locality
Dialogue: 0,0:07:12.20,0:07:17.02,Chinese,,0,0,0,,与我们在讨论缓存和局部性时学到的思想相同
Dialogue: 0,0:07:19.06,0:07:25.86,English,,0,0,0,,So that's one thing we can use the memory much more efficiently by only using the portions of the virtual address space
Dialogue: 0,0:07:19.06,0:07:25.86,Chinese,,0,0,0,,因此，通过仅使用虚拟地址空间的一部分，我们可以更有效地使用内存
Dialogue: 0,0:07:25.94,0:07:30.50,English,,0,0,0,,By only actually storing the portions of the virtual address space in the physical memory
Dialogue: 0,0:07:25.94,0:07:30.50,Chinese,,0,0,0,,仅仅将虚拟地址空间的一部分实际存储在物理存储器中
Dialogue: 0,0:07:32.26,0:07:35.16,English,,0,0,0,,Okay the second thing is it greatly simplifies memory management
Dialogue: 0,0:07:32.26,0:07:35.16,Chinese,,0,0,0,,第二，它大大简化了内存管理
Dialogue: 0,0:07:35.96,0:07:40.48,English,,0,0,0,,So we saw that every process has the same view right
Dialogue: 0,0:07:35.96,0:07:40.48,Chinese,,0,0,0,,我们可以发现，地址空间对每个进程来说都是相同的
Dialogue: 0,0:07:40.48,0:07:44.18,English,,0,0,0,,There's code loaded at code and data are always loaded at the same address
Dialogue: 0,0:07:40.48,0:07:44.18,Chinese,,0,0,0,,代码以及数据总是加载到固定的地址
Dialogue: 0,0:07:44.78,0:07:48.44,English,,0,0,0,,The stack is at the top of the user visible address space
Dialogue: 0,0:07:44.78,0:07:48.44,Chinese,,0,0,0,,堆栈位于用户可见地址空间的顶部
Dialogue: 0,0:07:49.50,0:07:54.62,English,,0,0,0,,So every process has the same similar-looking virtual address space
Dialogue: 0,0:07:49.50,0:07:54.62,Chinese,,0,0,0,,因此，每个进程都具有相同的相似外观的虚拟地址空间
Dialogue: 0,0:07:56.00,0:08:02.10,English,,0,0,0,,But in actuality that the memory that corresponds to those
Dialogue: 0,0:07:56.00,0:08:02.10,Chinese,,0,0,0,,但实际上与那些地址相对应的内容
Dialogue: 0,0:08:02.12,0:08:06.16,English,,0,0,0,,Those addresses is actually scattered all over main memory
Dialogue: 0,0:08:02.12,0:08:06.16,Chinese,,0,0,0,,分布在整个主存储器里
Dialogue: 0,0:08:06.90,0:08:14.46,English,,0,0,0,,Okay so that's a really important benefit of virtual memory
Dialogue: 0,0:08:06.90,0:08:14.46,Chinese,,0,0,0,,好的，这是虚拟内存的一个非常重要的好处
Dialogue: 0,0:08:15.88,0:08:18.56,English,,0,0,0,,And then finally it allows us to protect accesses
Dialogue: 0,0:08:15.88,0:08:18.56,Chinese,,0,0,0,,最后它允许我们对访存进行保护
Dialogue: 0,0:08:18.66,0:08:23.28,English,,0,0,0,,So remember we had to...
Dialogue: 0,0:08:18.66,0:08:23.28,Chinese,,0,0,0,,所以记住我们必须......
Dialogue: 0,0:08:24.02,0:08:28.24,English,,0,0,0,,A process we saw that a process provides the separate address space
Dialogue: 0,0:08:24.02,0:08:28.24,Chinese,,0,0,0,,我们看到一个进程提供了单独的地址空间
Dialogue: 0,0:08:28.92,0:08:32.06,English,,0,0,0,,That's protected from accesses by other processes
Dialogue: 0,0:08:28.92,0:08:32.06,Chinese,,0,0,0,,这可以防止其他进程访问
Dialogue: 0,0:08:32.54,0:08:39.02,English,,0,0,0,,Okay so virtual memory allows us to create these separate protected private address spaces
Dialogue: 0,0:08:32.54,0:08:39.02,Chinese,,0,0,0,,虚拟内存允许我们创建这些单独的受保护的私有地址空间
Dialogue: 0,0:08:40.02,0:08:43.68,English,,0,0,0,,So what we'll do today we'll look in more detail at these three ideas
Dialogue: 0,0:08:40.02,0:08:43.68,Chinese,,0,0,0,,我们今天要做的是，我们将更详细地了解这三个思想
Dialogue: 0,0:08:44.40,0:08:49.36,English,,0,0,0,,And then we'll go into the specifics of address translation
Dialogue: 0,0:08:44.40,0:08:49.36,Chinese,,0,0,0,,然后我们将详细介绍地址转换
Dialogue: 0,0:08:49.36,0:08:54.02,English,,0,0,0,,So I'm going to...for the first part of this lecture
Dialogue: 0,0:08:49.36,0:08:54.02,Chinese,,0,0,0,,本讲座的第一部分
Dialogue: 0,0:08:54.02,0:08:57.88,English,,0,0,0,,We're going to talk about address translation just in kind of high-level terms
Dialogue: 0,0:08:54.02,0:08:57.88,Chinese,,0,0,0,,我们将以在高级层面上来谈论地址转换
Dialogue: 0,0:08:58.40,0:09:02.46,English,,0,0,0,,But then we'll go into the details at the end you can see how it really works
Dialogue: 0,0:08:58.40,0:09:02.46,Chinese,,0,0,0,,但是接下来我们将详细介绍细节，你可以看到它是如何运作的
Dialogue: 0,0:09:03.24,0:09:05.78,English,,0,0,0,,Okay so let's look at VM as a tool for caching
Dialogue: 0,0:09:03.24,0:09:05.78,Chinese,,0,0,0,,好的，让我们把 VM 看作缓存工具
Dialogue: 0,0:09:07.00,0:09:13.28,English,,0,0,0,,So conceptually you can think of your virtual memory as a sequence of bytes stored on disk
Dialogue: 0,0:09:07.00,0:09:13.28,Chinese,,0,0,0,,从概念上讲，你可以将虚拟内存视为存储在磁盘上的字节序列
Dialogue: 0,0:09:15.82,0:09:24.54,English,,0,0,0,,And then the contents of that virtual memory stored on disk are cached in DRAM
Dialogue: 0,0:09:15.82,0:09:24.54,Chinese,,0,0,0,,存储在磁盘上的虚拟内存的内容缓存在 DRAM 中
Dialogue: 0,0:09:25.28,0:09:33.70,English,,0,0,0,,Okay so think of the the DRAM is a cache for this array of contiguous bytes stored on the disk
Dialogue: 0,0:09:25.28,0:09:33.70,Chinese,,0,0,0,,所以把 DRAM 看成是存储在磁盘上的这个连续字节数组的缓存
Dialogue: 0,0:09:35.18,0:09:38.44,English,,0,0,0,,And just like any cache the data is broken up into blocks
Dialogue: 0,0:09:35.18,0:09:38.44,Chinese,,0,0,0,,就像任何缓存一样，数据被分解成块
Dialogue: 0,0:09:40.62,0:09:42.72,English,,0,0,0,,Okay and then we have so... so here we have the...
Dialogue: 0,0:09:40.62,0:09:42.72,Chinese,,0,0,0,,所以在这里……
Dialogue: 0,0:09:43.32,0:09:46.16,English,,0,0,0,,And those blocks for virtual memory systems are called pages
Dialogue: 0,0:09:43.32,0:09:46.16,Chinese,,0,0,0,,虚拟内存系统中的那些块称为页面
Dialogue: 0,0:09:47.30,0:09:53.64,English,,0,0,0,,They're typically much larger than the cache blocks that we studied
Dialogue: 0,0:09:47.30,0:09:53.64,Chinese,,0,0,0,,它们通常比我们学过的缓存块大得多
Dialogue: 0,0:09:54.46,0:09:58.28,English,,0,0,0,,So 4k bytes typically instead of the 64 bytes
Dialogue: 0,0:09:54.46,0:09:58.28,Chinese,,0,0,0,,通常是 4096 个字节而不是 64 字节
Dialogue: 0,0:09:58.58,0:10:01.36,English,,0,0,0,,Like that we learned about in when we studied cache memories
Dialogue: 0,0:09:58.58,0:10:01.36,Chinese,,0,0,0,,就像我们在研究缓存时所学到的那样
Dialogue: 0,0:10:02.64,0:10:08.30,English,,0,0,0,,So this virtual memory conceptually you can think of it as being a sequence of pages stored on the disk
Dialogue: 0,0:10:02.64,0:10:08.30,Chinese,,0,0,0,,从概念上讲，这个虚拟内存可以看作存储在磁盘上的一系列页面
Dialogue: 0,0:10:09.44,0:10:10.88,English,,0,0,0,,So called virtual pages
Dialogue: 0,0:10:09.44,0:10:10.88,Chinese,,0,0,0,,这就是所谓的虚拟页面
Dialogue: 0,0:10:11.66,0:10:18.86,English,,0,0,0,,And each of these pages will identify with a number so here's virtual page 0,virtual page 1
Dialogue: 0,0:10:11.66,0:10:18.86,Chinese,,0,0,0,,并且这些页面中的每一个都将标识一个数字，这里是虚拟页面 0，虚拟页面 1
Dialogue: 0,0:10:20.00,0:10:25.66,English,,0,0,0,,And then a subset of those pages are stored in the physical memory, in the physical DRAM memory
Dialogue: 0,0:10:20.00,0:10:25.66,Chinese,,0,0,0,,然后，这些页面中的一部分存储在物理 DRAM 存储器中
Dialogue: 0,0:10:27.08,0:10:29.46,English,,0,0,0,,And then there's some mapping function
Dialogue: 0,0:10:27.08,0:10:29.46,Chinese,,0,0,0,,然后有一些映射
Dialogue: 0,0:10:30.00,0:10:33.20,English,,0,0,0,,That tells us which pages have been cached
Dialogue: 0,0:10:30.00,0:10:33.20,Chinese,,0,0,0,,告诉我们哪些页面已被缓存
Dialogue: 0,0:10:33.90,0:10:36.38,English,,0,0,0,,Ok so in this case I've just shown a snapshot
Dialogue: 0,0:10:33.90,0:10:36.38,Chinese,,0,0,0,,好的，在这种情况下，我刚刚展示了一个快照
Dialogue: 0,0:10:36.88,0:10:41.44,English,,0,0,0,,Where we have three virtual pages cached somewhere in DRAM
Dialogue: 0,0:10:36.88,0:10:41.44,Chinese,,0,0,0,,我们在 DRAM 中的某个地方缓存了三个虚拟页面
Dialogue: 0,0:10:42.50,0:10:49.60,English,,0,0,0,,Okay and there's no relation between the virtual page number and the the physical page number that it's mapped to
Dialogue: 0,0:10:42.50,0:10:49.60,Chinese,,0,0,0,,好的，虚拟页号与它映射到的物理页号之间没有关系
Dialogue: 0,0:10:51.44,0:10:55.52,English,,0,0,0,,Some of these pages are not cached so they're still stored on disk
Dialogue: 0,0:10:51.44,0:10:55.52,Chinese,,0,0,0,,其中一些页面未缓存，因此它们仍存储在磁盘上
Dialogue: 0,0:10:56.54,0:11:00.62,English,,0,0,0,,So in this case VP2 is still stored on disk
Dialogue: 0,0:10:56.54,0:11:00.62,Chinese,,0,0,0,,所以在这个例子里，VP 2 仍然存储在磁盘上
Dialogue: 0,0:11:00.94,0:11:05.08,English,,0,0,0,,And there's some pages which aren't even allocated, so they don't exist on the disk yet
Dialogue: 0,0:11:00.94,0:11:05.08,Chinese,,0,0,0,,有一些页面甚至没有分配，因此它们不存在于磁盘上
Dialogue: 0,0:11:05.36,0:11:06.42,English,,0,0,0,,It's a way to think of that
Dialogue: 0,0:11:05.36,0:11:06.42,Chinese,,0,0,0,,这是一种思考方式
Dialogue: 0,0:11:06.94,0:11:11.15,English,,0,0,0,,Because we really wouldn't want to store every single page in address space
Dialogue: 0,0:11:06.94,0:11:11.15,Chinese,,0,0,0,,因为我们真的不想把地址空间的每个页面都存储起来
Dialogue: 0,0:11:11.15,0:11:13.24,English,,0,0,0,,With that's to the size to the 48th
Dialogue: 0,0:11:11.15,0:11:13.24,Chinese,,0,0,0,,地址空间中的每一个地址都是 48 位的
Dialogue: 0,0:11:13.68,0:11:17.00,English,,0,0,0,,We really wouldn't want to store all those on disk
Dialogue: 0,0:11:13.68,0:11:17.00,Chinese,,0,0,0,,我们真的不想将这么多全都存储在磁盘上
Dialogue: 0,0:11:18.50,0:11:21.60,English,,0,0,0,,So most of the address space is unallocated
Dialogue: 0,0:11:18.50,0:11:21.60,Chinese,,0,0,0,,因此大多数地址空间都是未分配的
Dialogue: 0,0:11:28.44,0:11:32.98,English,,0,0,0,,So we can just think of this, so this DRAM is just a cache
Dialogue: 0,0:11:28.44,0:11:32.98,Chinese,,0,0,0,,我们可以这么想，这个 DRAM 只是一个缓存
Dialogue: 0,0:11:33.62,0:11:36.22,English,,0,0,0,,But it has a much different organization
Dialogue: 0,0:11:33.62,0:11:36.22,Chinese,,0,0,0,,但它的组织形式与我们之前
Dialogue: 0,0:11:36.44,0:11:38.34,English,,0,0,0,,Than the cache memories we studied earlier
Dialogue: 0,0:11:36.44,0:11:38.34,Chinese,,0,0,0,,所学的缓存非常不同
Dialogue: 0,0:11:38.72,0:11:43.80,English,,0,0,0,,And the difference is driven by that the enormous miss penalty when you go from
Dialogue: 0,0:11:38.72,0:11:43.80,Chinese,,0,0,0,,而这种差异是由于未命中时的巨大代价所致
Dialogue: 0,0:11:44.62,0:11:52.26,English,,0,0,0,,If you have a cache and DRAM, the miss penalty to fetch a data item from the disk is huge
Dialogue: 0,0:11:44.62,0:11:52.26,Chinese,,0,0,0,,如果你有一个缓存和 DRAM，那么在未命中时就要从磁盘中获取数据项，会消耗很多时间
Dialogue: 0,0:11:53.90,0:12:00.08,English,,0,0,0,,So the design of this virtual memory cache is totally driven by this enormous miss penalty
Dialogue: 0,0:11:53.90,0:12:00.08,Chinese,,0,0,0,,这就是虚拟内存缓存的设计动机
Dialogue: 0,0:12:01.48,0:12:04.14,English,,0,0,0,,And so as a result that blocks are larger...
Dialogue: 0,0:12:01.48,0:12:04.14,Chinese,,0,0,0,,因此，块越大……
Dialogue: 0,0:12:04.16,0:12:07.46,English,,0,0,0,,So remember we talked about that the block size is kind of a trade-off
Dialogue: 0,0:12:04.16,0:12:07.46,Chinese,,0,0,0,,请记住，块的大小是需要权衡的
Dialogue: 0,0:12:08.18,0:12:16.50,English,,0,0,0,,Between sort of useful getting used being able to usefully amortize the cost of fetching that block
Dialogue: 0,0:12:08.18,0:12:16.50,Chinese,,0,0,0,,既要让从磁盘中获取数据块的代价分摊下来足够小
Dialogue: 0,0:12:17.12,0:12:22.38,English,,0,0,0,,Versus sort of consuming too much of this scarce cache space right
Dialogue: 0,0:12:17.12,0:12:22.38,Chinese,,0,0,0,,又不要让数据块过多地占用稀缺的缓存空间
Dialogue: 0,0:12:22.40,0:12:27.54,English,,0,0,0,,So in this case our cache memories are 64 byte blocks
Dialogue: 0,0:12:22.40,0:12:27.54,Chinese,,0,0,0,,在我们的例子中，缓存的块大小是 64 字节
Dialogue: 0,0:12:28.94,0:12:36.12,English,,0,0,0,,Most virtual memory systems have like 4k byte blocks with an option to increase to 4 megabytes
Dialogue: 0,0:12:28.94,0:12:36.12,Chinese,,0,0,0,,大多数虚拟内存系统的块大小是 4 KB，有些系统是 4 MB
Dialogue: 0,0:12:36.66,0:12:38.56,English,,0,0,0,,In the case of x86
Dialogue: 0,0:12:36.66,0:12:38.56,Chinese,,0,0,0,,这是 x86 系统的普遍情况
Dialogue: 0,0:12:40.86,0:12:44.40,English,,0,0,0,,And now this cache and other consequence of the enormous missed penalty is that
Dialogue: 0,0:12:40.86,0:12:44.40,Chinese,,0,0,0,,现在，巨大的未命中代价的其他后果就是这样
Dialogue: 0,0:12:46.48,0:12:49.68,English,,0,0,0,,You really want to have as large associativity as you can
Dialogue: 0,0:12:46.48,0:12:49.68,Chinese,,0,0,0,,你希望缓存有尽可能大的关联性
Dialogue: 0,0:12:49.78,0:12:54.60,English,,0,0,0,,Remember we saw direct mapped caches that were subject to these conflict misses
Dialogue: 0,0:12:49.78,0:12:54.60,Chinese,,0,0,0,,我们之前看到的是直接映射的缓存所受到的冲突未命中的影响
Dialogue: 0,0:12:54.98,0:12:58.16,English,,0,0,0,,And if you increase the associativity of the cache
Dialogue: 0,0:12:54.98,0:12:58.16,Chinese,,0,0,0,,并且，如果你增加缓存的关联性
Dialogue: 0,0:12:58.16,0:13:01.32,English,,0,0,0,,You reduce the probability of those conflict misses
Dialogue: 0,0:12:58.16,0:13:01.32,Chinese,,0,0,0,,就可以减少这些冲突未命中的可能性
Dialogue: 0,0:13:01.84,0:13:07.44,English,,0,0,0,,But you never completely eliminate them until you have a fully associative cache with just one set
Dialogue: 0,0:13:01.84,0:13:07.44,Chinese,,0,0,0,,但是，除非缓存是全相联的，都在一个组里，否则你永远不会完全消除它们
Dialogue: 0,0:13:08.04,0:13:12.12,English,,0,0,0,,Okay so in a virtual memory,in a virtual memory cache
Dialogue: 0,0:13:08.04,0:13:12.12,Chinese,,0,0,0,,在虚拟内存中，在虚拟内存缓存中
Dialogue: 0,0:13:14.08,0:13:19.28,English,,0,0,0,,It's fully associative there's one set and each virtual page can go anywhere in the cache
Dialogue: 0,0:13:14.08,0:13:19.28,Chinese,,0,0,0,,它是全相联的，只有一个组，每个虚拟页面可能被缓存到缓存中的任何位置
Dialogue: 0,0:13:22.14,0:13:25.52,English,,0,0,0,,So this requires a really complicated mapping function
Dialogue: 0,0:13:22.14,0:13:25.52,Chinese,,0,0,0,,这需要一个非常复杂的映射函数
Dialogue: 0,0:13:25.52,0:13:30.46,English,,0,0,0,,Somehow we're going to have to keep track of where all these cached pages are
Dialogue: 0,0:13:25.52,0:13:30.46,Chinese,,0,0,0,,出于某些原因，我们必须跟踪所有这些缓存页面的位置
Dialogue: 0,0:13:32.24,0:13:36.48,English,,0,0,0,,And we can't really do a search that would be way too inexpensive
Dialogue: 0,0:13:32.24,0:13:36.48,Chinese,,0,0,0,,我们不能做一个太简单的搜索
Dialogue: 0,0:13:36.52,0:13:41.68,English,,0,0,0,,So remember when we cache memory, the hardware actually did a search within the set
Dialogue: 0,0:13:36.52,0:13:41.68,Chinese,,0,0,0,,当我们进行缓存时，硬件实际上在相应的组中进行了一次搜索
Dialogue: 0,0:13:42.32,0:13:47.30,English,,0,0,0,,A parallel search to find try to find a cache line
Dialogue: 0,0:13:42.32,0:13:47.30,Chinese,,0,0,0,,用并行搜索的方式来尝试查找缓存行
Dialogue: 0,0:13:48.26,0:13:51.70,English,,0,0,0,,But with a software cache like this that's not feasible
Dialogue: 0,0:13:48.26,0:13:51.70,Chinese,,0,0,0,,但是像这样的软件缓存是不可行的
Dialogue: 0,0:13:52.40,0:13:57.38,English,,0,0,0,,All right so somehow we're going to have to remember where these cached blocks are in this very large set
Dialogue: 0,0:13:52.40,0:13:57.38,Chinese,,0,0,0,,好吧，所以我们必须记住这些缓存块在这个非常大的组中的位置
Dialogue: 0,0:13:59.68,0:14:02.88,English,,0,0,0,,And again because it's so expensive if you make a mistake
Dialogue: 0,0:13:59.68,0:14:02.88,Chinese,,0,0,0,,因为如果你犯了错误，代价就太高了
Dialogue: 0,0:14:03.84,0:14:07.86,English,,0,0,0,,When you're trying to identify a victim page
Dialogue: 0,0:14:03.84,0:14:07.86,Chinese,,0,0,0,,当你尝试选出牺牲页时
Dialogue: 0,0:14:08.68,0:14:13.92,English,,0,0,0,,If you make a mistake and you evict a page that then is referenced again in the near future
Dialogue: 0,0:14:08.68,0:14:13.92,Chinese,,0,0,0,,如果你选错了，并且驱逐了这个页面，但是在不久的将来又再次使用它
Dialogue: 0,0:14:14.30,0:14:16.42,English,,0,0,0,,You pay a big price for it, okay
Dialogue: 0,0:14:14.30,0:14:16.42,Chinese,,0,0,0,,你就会为此付出很大的代价
Dialogue: 0,0:14:17.10,0:14:22.88,English,,0,0,0,,So virtual memory caches have much more sophisticated replacement algorithms than like simple LRU that
Dialogue: 0,0:14:17.10,0:14:22.88,Chinese,,0,0,0,,因此，虚拟内存缓存具有比简单的 LRU 更复杂的替换算法
Dialogue: 0,0:14:22.94,0:14:24.44,English,,0,0,0,,That we saw with cache memories
Dialogue: 0,0:14:22.94,0:14:24.44,Chinese,,0,0,0,,就像我们看到的那样
Dialogue: 0,0:14:25.30,0:14:28.88,English,,0,0,0,,Now they're these replacement algorithms are outside of the scope of this course
Dialogue: 0,0:14:25.30,0:14:28.88,Chinese,,0,0,0,,这些复杂的替换算法超出了本课程的范围
Dialogue: 0,0:14:29.06,0:14:31.00,English,,0,0,0,,You'll learn about them when you take OS
Dialogue: 0,0:14:29.06,0:14:31.00,Chinese,,0,0,0,,你会在操作系统课上学到这些算法
Dialogue: 0,0:14:32.34,0:14:37.68,English,,0,0,0,,But because it's in software we can afford to do very expensive replacement algorithms
Dialogue: 0,0:14:32.34,0:14:37.68,Chinese,,0,0,0,,但是因为它是软件，我们可以负担得起代价非常高的替代算法
Dialogue: 0,0:14:39.64,0:14:46.67,English,,0,0,0,,And we can take a relatively long time to execute the code for those algorithms
Dialogue: 0,0:14:39.64,0:14:46.67,Chinese,,0,0,0,,我们可以花费比较长的时间来执行这些算法的代码
Dialogue: 0,0:14:47.32,0:14:57.06,English,,0,0,0,,Because any time we spend figuring out a victim block will be much less than the cost of making a mistake
Dialogue: 0,0:14:47.32,0:14:57.06,Chinese,,0,0,0,,因为我们选出一个牺牲块所需的时间远远小于错误的选择所付出的代价
Dialogue: 0,0:14:57.44,0:15:02.58,English,,0,0,0,,And paying the access time,the miss time,the miss penalty to disk
Dialogue: 0,0:14:57.44,0:15:02.58,Chinese,,0,0,0,,这个代价包括获取块的时间，由于缓存未命中而去访问磁盘的代价
Dialogue: 0,0:15:03.54,0:15:09.92,English,,0,0,0,,And then also as a result of virtual memory systems never use write-through just it takes to one
Dialogue: 0,0:15:03.54,0:15:09.92,Chinese,,0,0,0,,由于虚拟内存系统永远不会采取直接写到磁盘的策略
Dialogue: 0,0:15:10.62,0:15:17.12,English,,0,0,0,,Right so they always use write-back and they try to defer writing anything back to the disk as long as possible
Dialogue: 0,0:15:10.62,0:15:17.12,Chinese,,0,0,0,,他们总是使用写回策略，尽可能地将写回磁盘的操作推迟
Dialogue: 0,0:15:19.74,0:15:21.64,English,,0,0,0,,Alright now how do we keep track
Dialogue: 0,0:15:19.74,0:15:21.64,Chinese,,0,0,0,,好吧，现在我们如何跟踪
Dialogue: 0,0:15:21.64,0:15:26.36,English,,0,0,0,,Somehow we have to keep track of this complicated cache and DRAM
Dialogue: 0,0:15:21.64,0:15:26.36,Chinese,,0,0,0,,我们必须跟踪这个复杂的缓存和 DRAM
Dialogue: 0,0:15:27.02,0:15:32.52,English,,0,0,0,,And the data structure that keeps track of the location of the virtual pages
Dialogue: 0,0:15:27.02,0:15:32.52,Chinese,,0,0,0,,记录虚拟页面位置的数据结构
Dialogue: 0,0:15:33.06,0:15:35.82,English,,0,0,0,,In memory is called the page table
Dialogue: 0,0:15:33.06,0:15:35.82,Chinese,,0,0,0,,称为页表，它存在于内存中
Dialogue: 0,0:15:37.14,0:15:40.26,English,,0,0,0,,Now a page table is just a data structure in memory
Dialogue: 0,0:15:37.14,0:15:40.26,Chinese,,0,0,0,,页表是内存中的一个数据结构
Dialogue: 0,0:15:41.02,0:15:44.92,English,,0,0,0,,That the kernel maintains for as part of each process context
Dialogue: 0,0:15:41.02,0:15:44.92,Chinese,,0,0,0,,由内核维护，是每个进程上下文的一部分
Dialogue: 0,0:15:45.26,0:15:47.42,English,,0,0,0,,Okay so every process has its own page table
Dialogue: 0,0:15:45.26,0:15:47.42,Chinese,,0,0,0,,所以每个进程都有自己的页表
Dialogue: 0,0:15:48.48,0:15:54.70,English,,0,0,0,,It's an array of so called page table entries or PTEs
Dialogue: 0,0:15:48.48,0:15:54.70,Chinese,,0,0,0,,它是一个称为的页表条目或 PTE 的数组
Dialogue: 0,0:15:57.32,0:16:04.80,English,,0,0,0,,Where PTE k contains the physical address of physical page k in DRAM
Dialogue: 0,0:15:57.32,0:16:04.80,Chinese,,0,0,0,,其中，PTE k 保存的是 DRAM 中物理页面 k 的物理地址
Dialogue: 0,0:16:09.60,0:16:13.70,English,,0,0,0,,So here's how it works there's this page table in DRAM
Dialogue: 0,0:16:09.60,0:16:13.70,Chinese,,0,0,0,,这是它的工作原理，这个页表在 DRAM 中
Dialogue: 0,0:16:14.90,0:16:18.04,English,,0,0,0,,There's virtual pages stored on disk
Dialogue: 0,0:16:14.90,0:16:18.04,Chinese,,0,0,0,,这些是存储在磁盘上的虚拟页面
Dialogue: 0,0:16:22.08,0:16:26.38,English,,0,0,0,,And then there's ... and then there's physical
Dialogue: 0,0:16:22.08,0:16:26.38,Chinese,,0,0,0,,这里是物理的
Dialogue: 0,0:16:26.38,0:16:30.60,English,,0,0,0,,There's virtual pages stored in various physical pages in DRAM
Dialogue: 0,0:16:26.38,0:16:30.60,Chinese,,0,0,0,,这些是存储在 DRAM 中的不同物理页面中的虚拟页面
Dialogue: 0,0:16:31.76,0:16:35.00,English,,0,0,0,,And then the page table keeps track of where those are stored
Dialogue: 0,0:16:31.76,0:16:35.00,Chinese,,0,0,0,,页表记录这些虚拟页存储的位置
Dialogue: 0,0:16:35.48,0:16:41.86,English,,0,0,0,,So here we have a case. This PTE 1 corresponds to virtual page 1
Dialogue: 0,0:16:35.48,0:16:41.86,Chinese,,0,0,0,,这里我们有一个例子。这个 PTE 1 对应虚拟页面 1
Dialogue: 0,0:16:43.18,0:16:48.60,English,,0,0,0,,And in this case it says that virtual page 1 is mapped into physical page 0
Dialogue: 0,0:16:43.18,0:16:48.60,Chinese,,0,0,0,,这里表示虚拟页面 1 被映射到物理页面 0
Dialogue: 0,0:16:50.12,0:16:55.30,English,,0,0,0,,Virtual page 2 is mapped into physical page 1 and so on
Dialogue: 0,0:16:50.12,0:16:55.30,Chinese,,0,0,0,,虚拟页面 2 被映射到物理页面 1，依此类推
Dialogue: 0,0:16:57.30,0:17:05.72,English,,0,0,0,,Ok now some of these the pages that aren't in memory are stored on disks the allocated pages
Dialogue: 0,0:16:57.30,0:17:05.72,Chinese,,0,0,0,,现在有些已分配但是不在内存中的页面，存储在磁盘上
Dialogue: 0,0:17:06.72,0:17:12.80,English,,0,0,0,,And so for those pages, the page table entry contains a pointer to the location of that page on disk
Dialogue: 0,0:17:06.72,0:17:12.80,Chinese,,0,0,0,,因此，对于那些页面，页表条目包含指向该页面在磁盘上的位置的指针
Dialogue: 0,0:17:13.26,0:17:17.94,English,,0,0,0,,So think of it as a logical block number where that page can be found on the disk
Dialogue: 0,0:17:13.26,0:17:17.94,Chinese,,0,0,0,,因此，将其视为逻辑块编号，可在磁盘上找到该页面
Dialogue: 0,0:17:18.44,0:17:20.22,English,,0,0,0,,And then some of the pages are
Dialogue: 0,0:17:18.44,0:17:20.22,Chinese,,0,0,0,,然后还有一些页面
Dialogue: 0,0:17:21.48,0:17:27.14,English,,0,0,0,,Not allocated so there's a null entry in the page table
Dialogue: 0,0:17:21.48,0:17:27.14,Chinese,,0,0,0,,是未分配的，因此这个页表中有一个空条目
Dialogue: 0,0:17:31.52,0:17:32.40,English,,0,0,0,,Now page hit
Dialogue: 0,0:17:31.52,0:17:32.40,Chinese,,0,0,0,,现在我们来讲页面命中
Dialogue: 0,0:17:32.94,0:17:35.68,English,,0,0,0,,So this is just a cache, right, so we have hits and misses
Dialogue: 0,0:17:32.94,0:17:35.68,Chinese,,0,0,0,,这是一个缓存，所以会有命中和未命中
Dialogue: 0,0:17:36.46,0:17:42.20,English,,0,0,0,,So a page hit occurs when there's a reference to a word in the virtual address space
Dialogue: 0,0:17:36.46,0:17:42.20,Chinese,,0,0,0,,当页表中存在对虚拟地址空间中的字的引用时，会发生页面命中
Dialogue: 0,0:17:42.90,0:17:46.70,English,,0,0,0,,That's contained in a page that's cached in the DRAM
Dialogue: 0,0:17:42.90,0:17:46.70,Chinese,,0,0,0,,这个字包含在缓存在 DRAM 中的页面中
Dialogue: 0,0:17:48.94,0:17:55.20,English,,0,0,0,,Okay so let's say that we have you know the CPU executes this and move instruction it generates a virtual address
Dialogue: 0,0:17:48.94,0:17:55.20,Chinese,,0,0,0,,我们知道 CPU 在执行指令时，生成一个虚拟地址
Dialogue: 0,0:17:56.78,0:17:57.96,English,,0,0,0,,The MMU
Dialogue: 0,0:17:56.78,0:17:57.96,Chinese,,0,0,0,,MMU
Dialogue: 0,0:17:59.44,0:18:07.08,English,,0,0,0,,Looks up in the page table and let's say this virtual address is somewhere within virtual page 2
Dialogue: 0,0:17:59.44,0:18:07.08,Chinese,,0,0,0,,在页表中查找，我们假设此虚拟地址位于虚拟页面 2 中的某个位置
Dialogue: 0,0:18:09.32,0:18:14.94,English,,0,0,0,,Okay so that the MMU looks up the page table entry number 2
Dialogue: 0,0:18:09.32,0:18:14.94,Chinese,,0,0,0,,那么 MMU 就去查找第 2 个页表条目
Dialogue: 0,0:18:16.06,0:18:23.52,English,,0,0,0,,And it extracts the physical address of that virtual page 2
Dialogue: 0,0:18:16.06,0:18:23.52,Chinese,,0,0,0,,然后它会得到虚拟页面 2 的物理地址
Dialogue: 0,0:18:25.68,0:18:27.26,English,,0,0,0,,Okay so that's a hit, so in this case
Dialogue: 0,0:18:25.68,0:18:27.26,Chinese,,0,0,0,,所以这是一个命中的情况，所以在这种情况下
Dialogue: 0,0:18:30.16,0:18:35.24,English,,0,0,0,,In this case the page is in memory it's cached in memory
Dialogue: 0,0:18:30.16,0:18:35.24,Chinese,,0,0,0,,在这种情况下，页面在内存中，它被缓存在内存中
Dialogue: 0,0:18:35.70,0:18:37.08,English,,0,0,0,,And so we have a hit
Dialogue: 0,0:18:35.70,0:18:37.08,Chinese,,0,0,0,,所以这是一次命中
Dialogue: 0,0:18:37.54,0:18:48.12,English,,0,0,0,,And now the memory can return that physical address to the MMU
Dialogue: 0,0:18:37.54,0:18:48.12,Chinese,,0,0,0,,现在内存可以将该物理地址返回给 MMU
Dialogue: 0,0:18:52.46,0:19:00.94,English,,0,0,0,,Now a miss is a reference to a word that's not cacheed in physical memory
Dialogue: 0,0:18:52.46,0:19:00.94,Chinese,,0,0,0,,未命中是对未在物理内存中缓存的字的引用
Dialogue: 0,0:19:00.94,0:19:08.42,English,,0,0,0,,So in this case virtual page 3 is not cached in DRAM
Dialogue: 0,0:19:00.94,0:19:08.42,Chinese,,0,0,0,,在这个例子里，虚拟页面 3 没有缓存在 DRAM 中
Dialogue: 0,0:19:08.42,0:19:10.40,English,,0,0,0,,It's stored on the disk
Dialogue: 0,0:19:08.42,0:19:10.40,Chinese,,0,0,0,,它存储在磁盘上
Dialogue: 0,0:19:13.58,0:19:18.40,English,,0,0,0,,So now that triggers an exception, ok, page fault exception
Dialogue: 0,0:19:13.58,0:19:18.40,Chinese,,0,0,0,,所以现在触发异常，缺页异常
Dialogue: 0,0:19:19.12,0:19:21.34,English,,0,0,0,,In the hardware the hardware triggers the exception
Dialogue: 0,0:19:19.12,0:19:21.34,Chinese,,0,0,0,,在硬件中，硬件触发异常
Dialogue: 0,0:19:21.66,0:19:27.66,English,,0,0,0,,And that causes the transfer of control to a chunk of code in the kernel called the page fault handler
Dialogue: 0,0:19:21.66,0:19:27.66,Chinese,,0,0,0,,这使得控制权转移给内核中称为缺页处理程序的代码
Dialogue: 0,0:19:28.84,0:19:35.54,English,,0,0,0,,Which then selects a victim to be evicted,in this case virtual page 4
Dialogue: 0,0:19:28.84,0:19:35.54,Chinese,,0,0,0,,这段代码选择要驱逐的牺牲页，在这个例子里是虚拟页面 4
Dialogue: 0,0:19:37.20,0:19:41.12,English,,0,0,0,,And it fetches virtual page 3 from the disk
Dialogue: 0,0:19:37.20,0:19:41.12,Chinese,,0,0,0,,然后它从磁盘中获取虚拟页面 3
Dialogue: 0,0:19:43.46,0:19:45.00,English,,0,0,0,,Loads it up into memory
Dialogue: 0,0:19:43.46,0:19:45.00,Chinese,,0,0,0,,将其加载到内存中
Dialogue: 0,0:19:45.72,0:19:54.80,English,,0,0,0,,And if and then changes,and then updates this page table entry to reflect the fact that virtual page 4 is now stored on disk
Dialogue: 0,0:19:45.72,0:19:54.80,Chinese,,0,0,0,,然后更新此页表条目，以反映虚拟页面 4 现在存储在磁盘上的事实
Dialogue: 0,0:19:55.72,0:20:01.64,English,,0,0,0,,And if virtual page 4 had been modified at any time it would have to write the contents of it that to disk as well
Dialogue: 0,0:19:55.72,0:20:01.64,Chinese,,0,0,0,,如果虚拟页面 4 曾经被修改过，那么必须将修改的内容写入磁盘
Dialogue: 0,0:20:06.04,0:20:12.52,English,,0,0,0,,So once the handler copies virtual page 3 into memory
Dialogue: 0,0:20:06.04,0:20:12.52,Chinese,,0,0,0,,因此，一旦处理程序将虚拟页面 3 复制到内存中
Dialogue: 0,0:20:13.40,0:20:17.95,English,,0,0,0,,The instruction that caused the page fault now can be re-executed
Dialogue: 0,0:20:13.40,0:20:17.95,Chinese,,0,0,0,,就可以重新执行导致缺页的指令
Dialogue: 0,0:20:18.82,0:20:25.30,English,,0,0,0,,Okay so once the...so when the page fault handler in the kernel returns it returns to the faulting instruction
Dialogue: 0,0:20:18.82,0:20:25.30,Chinese,,0,0,0,,所以当内核中的缺页处理程序返回时，会返回到原来产生错误的指令
Dialogue: 0,0:20:25.72,0:20:26.90,English,,0,0,0,,Which then re-executes
Dialogue: 0,0:20:25.72,0:20:26.90,Chinese,,0,0,0,,然后重新执行该指令
Dialogue: 0,0:20:28.20,0:20:35.84,English,,0,0,0,,And now that page is when the MMU checks that the PTE corresponding to that page
Dialogue: 0,0:20:28.20,0:20:35.84,Chinese,,0,0,0,,现在当 MMU 查找对应于该页面的 PTE 的时候
Dialogue: 0,0:20:36.38,0:20:38.26,English,,0,0,0,,It finds that it's indeed cache so
Dialogue: 0,0:20:36.38,0:20:38.26,Chinese,,0,0,0,,会发现它确实缓存了
Dialogue: 0,0:20:38.56,0:20:43.04,English,,0,0,0,,So now the instruction can continue and we can fetch that
Dialogue: 0,0:20:38.56,0:20:43.04,Chinese,,0,0,0,,所以现在指令可以继续，我们可以获取它
Dialogue: 0,0:20:44.80,0:20:49.30,English,,0,0,0,,Whatever word at that virtual address from the DRAM
Dialogue: 0,0:20:44.80,0:20:49.30,Chinese,,0,0,0,,无论 DRAM 中的那个虚拟地址里保存的是什么字
Dialogue: 0,0:20:54.58,0:20:57.08,English,,0,0,0,,Okay now we can allocate a new page of memories
Dialogue: 0,0:20:54.58,0:20:57.08,Chinese,,0,0,0,,好的，现在我们分配一个新的页面
Dialogue: 0,0:20:57.08,0:21:03.98,English,,0,0,0,,So in this example virtual page 5 is not allocated
Dialogue: 0,0:20:57.08,0:21:03.98,Chinese,,0,0,0,,在此示例中，虚拟页面 5 是未分配的
Dialogue: 0,0:21:06.48,0:21:12.04,English,,0,0,0,,So if you need to let's say you do malloc of a very large chunk of virtual address space
Dialogue: 0,0:21:06.48,0:21:12.04,Chinese,,0,0,0,,假如你调用了需要分配一大块虚拟地址空间的 malloc 函数
Dialogue: 0,0:21:12.62,0:21:17.54,English,,0,0,0,,If those pages, if one of those pages hasn't been allocated yet then the kernel actually
Dialogue: 0,0:21:12.62,0:21:17.54,Chinese,,0,0,0,,如果其中一个页面尚未分配，那么内核
Dialogue: 0,0:21:18.26,0:21:24.16,English,,0,0,0,,Or the malloc function has to create allocate that memory by calling a function called sbrk
Dialogue: 0,0:21:18.26,0:21:24.16,Chinese,,0,0,0,,或者 malloc 函数必须通过调用一个名为 sbrk 的函数来分配该内存
Dialogue: 0,0:21:25.38,0:21:29.26,English,,0,0,0,,Okay and then what sbrk does is actually allocates
Dialogue: 0,0:21:25.38,0:21:29.26,Chinese,,0,0,0,,sbrk 函数的功能是
Dialogue: 0,0:21:29.74,0:21:37.92,English,,0,0,0,,This page and records where it's loaded now would probably actually put it up into
Dialogue: 0,0:21:29.74,0:21:37.92,Chinese,,0,0,0,,分配这个页面，记录它现在被加载到的位置。可能会把它放入……
Dialogue: 0,0:21:40.30,0:21:45.87,English,,0,0,0,,Now I guess it wouldn't actually show up in the DRAM cache until it was that page was touched
Dialogue: 0,0:21:40.30,0:21:45.87,Chinese,,0,0,0,,我认为它实际上不会出现在 DRAM 缓存中，直到该页面真正被访问为止
Dialogue: 0,0:21:46.48,0:21:51.22,English,,0,0,0,,Okay so just allocating space just changes this page table entry
Dialogue: 0,0:21:46.48,0:21:51.22,Chinese,,0,0,0,,只需分配空间、只需更改此页表条目即可
Dialogue: 0,0:21:51.74,0:21:56.22,English,,0,0,0,,And then when that page is actually touched then it'll be brought into the cache
Dialogue: 0,0:21:51.74,0:21:56.22,Chinese,,0,0,0,,然后当实际访问该页面时，它才会被放入缓存
Dialogue: 0,0:21:58.18,0:22:02.72,English,,0,0,0,,So I don't know about you but the first time I learned about this I was
Dialogue: 0,0:21:58.18,0:22:02.72,Chinese,,0,0,0,,我不知道你们是怎么想的，但在我第一次知道这个机制时
Dialogue: 0,0:22:02.82,0:22:08.52,English,,0,0,0,,I was pretty appalled it just seemed like the most inefficient terrible idea right
Dialogue: 0,0:22:02.82,0:22:08.52,Chinese,,0,0,0,,我非常震惊，它似乎是最低效的糟糕的想法
Dialogue: 0,0:22:09.00,0:22:17.94,English,,0,0,0,,How in the world can you afford to on every single instruction that uses memory
Dialogue: 0,0:22:09.00,0:22:17.94,Chinese,,0,0,0,,对于使用内存的每一条指令，你怎么能负担得起
Dialogue: 0,0:22:18.48,0:22:22.22,English,,0,0,0,,Do all this copying back and forth and looking up in tables
Dialogue: 0,0:22:18.48,0:22:22.22,Chinese,,0,0,0,,把它们来回复制并查找页表的代价
Dialogue: 0,0:22:22.64,0:22:24.08,English,,0,0,0,,And it just seems like an awful idea
Dialogue: 0,0:22:22.64,0:22:24.08,Chinese,,0,0,0,,这似乎是一个糟糕的主意
Dialogue: 0,0:22:24.64,0:22:26.52,English,,0,0,0,,But once again locality saves us
Dialogue: 0,0:22:24.64,0:22:26.52,Chinese,,0,0,0,,但是局部性再次拯救了我们
Dialogue: 0,0:22:27.02,0:22:31.48,English,,0,0,0,,Okay and it actually works because programs have locality
Dialogue: 0,0:22:27.02,0:22:31.48,Chinese,,0,0,0,,好吧，它确实有效，因为程序有局部性
Dialogue: 0,0:22:32.44,0:22:35.70,English,,0,0,0,,Okay and it's actually fairly efficient
Dialogue: 0,0:22:32.44,0:22:35.70,Chinese,,0,0,0,,好的，它实际上相当有效
Dialogue: 0,0:22:36.92,0:22:43.34,English,,0,0,0,,And the reason is that at any point of time programs tend to access a set of pages called the working set
Dialogue: 0,0:22:36.92,0:22:43.34,Chinese,,0,0,0,,因为在任何时候程序都倾向于只访问一组称为工作集的页面
Dialogue: 0,0:22:43.88,0:22:51.04,English,,0,0,0,,Okay just by locality right by temporal locality,by the principle of temporal locality and spatial locality
Dialogue: 0,0:22:43.88,0:22:51.04,Chinese,,0,0,0,,由于时间局部性和空间局部性原理
Dialogue: 0,0:22:51.74,0:22:56.88,English,,0,0,0,,You tend to sort of reuse the same things reuse nearby things okay
Dialogue: 0,0:22:51.74,0:22:56.88,Chinese,,0,0,0,,你往往会重复使用相同的东西或者使用附近的东西
Dialogue: 0,0:22:57.14,0:23:02.42,English,,0,0,0,,And so if that working set is less than the main memory size
Dialogue: 0,0:22:57.14,0:23:02.42,Chinese,,0,0,0,,因此，如果该工作集小于主存储器大小
Dialogue: 0,0:23:02.42,0:23:06.70,English,,0,0,0,,Then all of the pages in the current were that will fit in memory and then things will be great
Dialogue: 0,0:23:02.42,0:23:06.70,Chinese,,0,0,0,,那么内存可以存放下工作集中的所有页面，然后事情就会很好
Dialogue: 0,0:23:09.50,0:23:14.92,English,,0,0,0,,Okay but if the some of the working set sizes for every process right our systems running multiple processes
Dialogue: 0,0:23:09.50,0:23:14.92,Chinese,,0,0,0,,但是，我们的系统运行多个进程，如果某些进程的一些工作集的大小
Dialogue: 0,0:23:15.40,0:23:17.20,English,,0,0,0,,If it exceeds the main memory size
Dialogue: 0,0:23:15.40,0:23:17.20,Chinese,,0,0,0,,超过主内存大小
Dialogue: 0,0:23:18.10,0:23:25.56,English,,0,0,0,,Then you have this meltdown where processes are thrashing each other and causing pages to be copied back and forth
Dialogue: 0,0:23:18.10,0:23:25.56,Chinese,,0,0,0,,然后就会很糟糕，进程互相颠簸并导致页面来回复制
Dialogue: 0,0:23:26.26,0:23:31.08,English,,0,0,0,,So you never ever know process ever gets it's working set fully into memory
Dialogue: 0,0:23:26.26,0:23:31.08,Chinese,,0,0,0,,因此，进程永远不会将其工作集完全放入内存中
Dialogue: 0,0:23:33.58,0:23:36.50,English,,0,0,0,,Okay and we'll look at a technique when we look at address translation
Dialogue: 0,0:23:33.58,0:23:36.50,Chinese,,0,0,0,,好的，当我们学习地址转换时，我们会了解一种技术
Dialogue: 0,0:23:36.50,0:23:40.62,English,,0,0,0,,We'll look at a little hardware cache called a translation look aside buffer
Dialogue: 0,0:23:36.50,0:23:40.62,Chinese,,0,0,0,,我们将学到一个称为翻译后备缓冲器的小硬件缓存
Dialogue: 0,0:23:41.00,0:23:44.92,English,,0,0,0,,That further exploits the locality property of programs
Dialogue: 0,0:23:41.00,0:23:44.92,Chinese,,0,0,0,,这进一步利用了程序的局部性
Dialogue: 0,0:23:46.58,0:23:49.34,English,,0,0,0,,Okay so that's virtual memory is a tool for caching
Dialogue: 0,0:23:46.58,0:23:49.34,Chinese,,0,0,0,,好的，虚拟内存是一种缓存工具
Dialogue: 0,0:23:49.84,0:23:53.00,English,,0,0,0,,It's also a member of tool for memory management
Dialogue: 0,0:23:49.84,0:23:53.00,Chinese,,0,0,0,,它也是内存的管理工具
Dialogue: 0,0:23:53.20,0:23:57.32,English,,0,0,0,,And it greatly simplifies all kinds of aspects of memory management for the kernel
Dialogue: 0,0:23:53.20,0:23:57.32,Chinese,,0,0,0,,它极大地简化了内核对于内存管理的各个方面
Dialogue: 0,0:23:59.72,0:24:04.38,English,,0,0,0,,So the key idea is that each process has its own virtual address space
Dialogue: 0,0:23:59.72,0:24:04.38,Chinese,,0,0,0,,一个非常关键的思想是，每个进程都有自己专属的虚拟地址空间
Dialogue: 0,0:24:05.60,0:24:11.30,English,,0,0,0,,The kernel implements this by giving each process its own separate page table
Dialogue: 0,0:24:05.60,0:24:11.30,Chinese,,0,0,0,,内核通过为每个进程提供自己独立的页表来实现这一点
Dialogue: 0,0:24:11.92,0:24:15.62,English,,0,0,0,,In the context of that process so it's just a data structure in the kernel
Dialogue: 0,0:24:11.92,0:24:15.62,Chinese,,0,0,0,,在进程的上下文中，它是内核中的数据结构
Dialogue: 0,0:24:15.96,0:24:18.74,English,,0,0,0,,That the kernel keeps for that process
Dialogue: 0,0:24:15.96,0:24:18.74,Chinese,,0,0,0,,是内核为进程所维护的
Dialogue: 0,0:24:22.54,0:24:29.84,English,,0,0,0,,And the page table for each process maps the virtual address space for that process
Dialogue: 0,0:24:22.54,0:24:29.84,Chinese,,0,0,0,,每个进程的页表都映射该进程的虚拟地址空间
Dialogue: 0,0:24:32.40,0:24:39.18,English,,0,0,0,,Now what's interesting so you have that these pages contiguous pages in the virtual address space
Dialogue: 0,0:24:32.40,0:24:39.18,Chinese,,0,0,0,,有趣的是，在虚拟地址空间中这些连续的页面
Dialogue: 0,0:24:39.54,0:24:44.08,English,,0,0,0,,Can be mapped anywhere in the DRAM,in the physical address space
Dialogue: 0,0:24:39.54,0:24:44.08,Chinese,,0,0,0,,可以映射到 DRAM 中的物理地址空间的任何位置
Dialogue: 0,0:24:44.78,0:24:47.62,English,,0,0,0,,So and they can be scattered all over the place
Dialogue: 0,0:24:44.78,0:24:47.62,Chinese,,0,0,0,,它们可以分散在各处
Dialogue: 0,0:24:48.48,0:24:55.30,English,,0,0,0,,And different virtual pages and different processes can be mapped to different physical pages
Dialogue: 0,0:24:48.48,0:24:55.30,Chinese,,0,0,0,,并且不同的虚拟页面和不同的进程可以映射到不同的物理页面
Dialogue: 0,0:24:55.30,0:25:01.38,English,,0,0,0,,So here we have virtual page 1 which is mapped to physical page 2 in process 1
Dialogue: 0,0:24:55.30,0:25:01.38,Chinese,,0,0,0,,这里，进程 1 的虚拟页面 1 映射到物理页面 2
Dialogue: 0,0:25:01.44,0:25:06.02,English,,0,0,0,,But in process 2 virtual page 1 is mapped to physical page 8
Dialogue: 0,0:25:01.44,0:25:06.02,Chinese,,0,0,0,,但在进程 2 中，虚拟页面 1 被映射到物理页面 8
Dialogue: 0,0:25:06.92,0:25:14.50,English,,0,0,0,,Okay so in this way we can present a view to each,to the programmer and to the tools
Dialogue: 0,0:25:06.92,0:25:14.50,Chinese,,0,0,0,,好的，通过这种方式，我们可以为每个程序员和工具提供一个视图
Dialogue: 0,0:25:15.66,0:25:20.54,English,,0,0,0,,That each process has a very similar address space virtual address space
Dialogue: 0,0:25:15.66,0:25:20.54,Chinese,,0,0,0,,程序员可以认为每个进程都有一个非常相似的虚拟地址空间
Dialogue: 0,0:25:20.54,0:25:23.46,English,,0,0,0,,Same size address space, code and data start at the same place
Dialogue: 0,0:25:20.54,0:25:23.46,Chinese,,0,0,0,,有相同大小的地址空间，代码和数据分别从同一个地址开始
Dialogue: 0,0:25:24.42,0:25:28.48,English,,0,0,0,,But then the actual pages that process used can be scattered in memory
Dialogue: 0,0:25:24.42,0:25:28.48,Chinese,,0,0,0,,但其实进程使用的页面实际上可能会分散在内存中
Dialogue: 0,0:25:30.30,0:25:33.48,English,,0,0,0,,Okay and then it gives us the most efficient way to use the memory
Dialogue: 0,0:25:30.30,0:25:33.48,Chinese,,0,0,0,,好的，它为我们提供了使用内存的最有效方式
Dialogue: 0,0:25:35.74,0:25:41.52,English,,0,0,0,,If we didn't have this mechanism, think about how would you keep track, let's say you had 50 processes running
Dialogue: 0,0:25:35.74,0:25:41.52,Chinese,,0,0,0,,如果我们没有这个机制，请考虑如何跟踪，比如说你有 50 个进程在运行
Dialogue: 0,0:25:41.82,0:25:43.68,English,,0,0,0,,On the machine at any point in time
Dialogue: 0,0:25:41.82,0:25:43.68,Chinese,,0,0,0,,在这个机器上
Dialogue: 0,0:25:43.84,0:25:50.36,English,,0,0,0,,How in the world would you keep track of where all of the the data those processes were using
Dialogue: 0,0:25:43.84,0:25:50.36,Chinese,,0,0,0,,你如何能跟踪这些进程使用的所有数据的位置
Dialogue: 0,0:25:51.58,0:25:57.92,English,,0,0,0,,Well one technique that you could imagine in fact it was used in the in the bad old days but before virtual memory
Dialogue: 0,0:25:51.58,0:25:57.92,Chinese,,0,0,0,,你可以想象的一种技术是在过去虚拟内存产生之前的糟糕时期使用的
Dialogue: 0,0:25:58.52,0:26:03.46,English,,0,0,0,,One thing you can imagine is that just give every process its own chunk of the physical address space
Dialogue: 0,0:25:58.52,0:26:03.46,Chinese,,0,0,0,,你可以想象的一件事是，只为每个进程提供物理地址空间的一部分
Dialogue: 0,0:26:03.98,0:26:06.46,English,,0,0,0,,Just take your physical address space partition it
Dialogue: 0,0:26:03.98,0:26:06.46,Chinese,,0,0,0,,只将你的物理地址空间分区
Dialogue: 0,0:26:07.08,0:26:11.18,English,,0,0,0,,And then each process gets loads and runs in it's own part of the address space
Dialogue: 0,0:26:07.08,0:26:11.18,Chinese,,0,0,0,,然后每个进程都只能在属于它的那一部分地址空间中加载和运行
Dialogue: 0,0:26:12.42,0:26:14.84,English,,0,0,0,,Well this has all kinds of problems right I mean you could
Dialogue: 0,0:26:12.42,0:26:14.84,Chinese,,0,0,0,,这样就有各种各样的问题，我的意思是
Dialogue: 0,0:26:15.56,0:26:17.88,English,,0,0,0,,What will you do if you add a process
Dialogue: 0,0:26:15.56,0:26:17.88,Chinese,,0,0,0,,如果你要添加一个进程，那就不太好办了
Dialogue: 0,0:26:19.66,0:26:23.20,English,,0,0,0,,So you really can't partition the address space, you really have to sort of say well
Dialogue: 0,0:26:19.66,0:26:23.20,Chinese,,0,0,0,,你真的无法分割地址空间，你可能会说
Dialogue: 0,0:26:23.70,0:26:25.64,English,,0,0,0,,Each process gets some little chunk
Dialogue: 0,0:26:23.70,0:26:25.64,Chinese,,0,0,0,,「让每个进程都得到一些小块吧」
Dialogue: 0,0:26:25.88,0:26:30.14,English,,0,0,0,,And I'm going to reserve some of the address space in case there's new processes that need memory
Dialogue: 0,0:26:25.88,0:26:30.14,Chinese,,0,0,0,,「而且我还会保留一些地址空间，以防新的进程需要内存」
Dialogue: 0,0:26:31.94,0:26:34.38,English,,0,0,0,,Another problem is that now you have to write your programs
Dialogue: 0,0:26:31.94,0:26:34.38,Chinese,,0,0,0,,另一个问题是，假如你要写程序
Dialogue: 0,0:26:35.14,0:26:37.56,English,,0,0,0,,You can't just link your program ahead of time
Dialogue: 0,0:26:35.14,0:26:37.56,Chinese,,0,0,0,,你不能提前链接你的程序
Dialogue: 0,0:26:38.40,0:26:42.06,English,,0,0,0,,Because it has to be relocated when it's loaded right
Dialogue: 0,0:26:38.40,0:26:42.06,Chinese,,0,0,0,,因为它必须在加载时重定位
Dialogue: 0,0:26:42.06,0:26:48.06,English,,0,0,0,,Because you don't...you know a process, you don't know where in the memory it's going to go, it's going to get some chunk
Dialogue: 0,0:26:42.06,0:26:48.06,Chinese,,0,0,0,,一个进程，你不知道它会加载到内存的什么位置，只知道它会使用内存的某些块
Dialogue: 0,0:26:49.12,0:26:52.28,English,,0,0,0,,So you have to either relocate all the the references
Dialogue: 0,0:26:49.12,0:26:52.28,Chinese,,0,0,0,,所以你必须要重定位所有的引用
Dialogue: 0,0:26:53.52,0:26:57.10,English,,0,0,0,,That the references to global symbols at when it's actually loaded
Dialogue: 0,0:26:53.52,0:26:57.10,Chinese,,0,0,0,,在实际加载时，重定位对全局符号的引用
Dialogue: 0,0:26:58.42,0:27:03.20,English,,0,0,0,,Or you have to create a system where all of the instructions are relative
Dialogue: 0,0:26:58.42,0:27:03.20,Chinese,,0,0,0,,或者你必须创建一个所有指令都使用相对地址的系统
Dialogue: 0,0:27:03.50,0:27:06.22,English,,0,0,0,,So there's no absolute addresses
Dialogue: 0,0:27:03.50,0:27:06.22,Chinese,,0,0,0,,没有绝对地址
Dialogue: 0,0:27:06.86,0:27:10.78,English,,0,0,0,,All addresses are relative to say the start of the program something like that
Dialogue: 0,0:27:06.86,0:27:10.78,Chinese,,0,0,0,,所有地址都表示成相对于程序的开头而言的偏移
Dialogue: 0,0:27:11.79,0:27:14.22,English,,0,0,0,,So anyway all of these things are just terribly complicated
Dialogue: 0,0:27:11.79,0:27:14.22,Chinese,,0,0,0,,所以，无论如何，所有这些事情都非常复杂
Dialogue: 0,0:27:15.24,0:27:20.04,English,,0,0,0,,And they're all solved beautifully by virtual memory
Dialogue: 0,0:27:15.24,0:27:20.04,Chinese,,0,0,0,,它们都被虚拟内存完美地解决了
Dialogue: 0,0:27:26.14,0:27:31.78,English,,0,0,0,,So the each virtual page can be mapped to any physical page so that really helps simplify things
Dialogue: 0,0:27:26.14,0:27:31.78,Chinese,,0,0,0,,因此，每个虚拟页面都可以映射到任何物理页面，这样可以真正帮助简化操作
Dialogue: 0,0:27:32.56,0:27:38.48,English,,0,0,0,,And even at different times the same virtual page can be stored in different physical pages at different times
Dialogue: 0,0:27:32.56,0:27:38.48,Chinese,,0,0,0,,甚至在不同时刻，相同的虚拟页面也可以存储在不同的物理页面中
Dialogue: 0,0:27:38.90,0:27:42.58,English,,0,0,0,,All right so if a page for it,for a while it might be cached in one physical page
Dialogue: 0,0:27:38.90,0:27:42.58,Chinese,,0,0,0,,一个页面，有一段时间可能会缓存在一个物理页面中
Dialogue: 0,0:27:42.94,0:27:45.12,English,,0,0,0,,Then it gets swapped out and the next time it's referenced
Dialogue: 0,0:27:42.94,0:27:45.12,Chinese,,0,0,0,,然后它被替换出，并在下次引用时
Dialogue: 0,0:27:45.56,0:27:50.36,English,,0,0,0,,It can get cached in a different physical page that if it's no longer available
Dialogue: 0,0:27:45.56,0:27:50.36,Chinese,,0,0,0,,如果它没有被映射，那么它可以重新被缓存到不同的物理页面中
Dialogue: 0,0:27:50.50,0:27:56.12,English,,0,0,0,,Right so it provides so the most flexible scheduling freedom
Dialogue: 0,0:27:50.50,0:27:56.12,Chinese,,0,0,0,,对，因此它提供了最灵活的调度自由度
Dialogue: 0,0:27:58.56,0:28:01.82,English,,0,0,0,,In the way that we ...the way that we manage the memory
Dialogue: 0,0:27:58.56,0:28:01.82,Chinese,,0,0,0,,通过我们对内存的管理机制
Dialogue: 0,0:28:03.04,0:28:05.54,English,,0,0,0,,And it also provides this really neat capability
Dialogue: 0,0:28:03.04,0:28:05.54,Chinese,,0,0,0,,它还提供了这种非常巧妙的功能
Dialogue: 0,0:28:05.96,0:28:08.90,English,,0,0,0,,Where you can map virtual pages to the same physical page
Dialogue: 0,0:28:05.96,0:28:08.90,Chinese,,0,0,0,,你可以将多个虚拟页面映射到同一物理页面
Dialogue: 0,0:28:09.72,0:28:18.40,English,,0,0,0,,So there's this is a very simple straightforward way for multiple processes to share certain code or data
Dialogue: 0,0:28:09.72,0:28:18.40,Chinese,,0,0,0,,因此，这是一种使多个进程可以共享某些代码或数据的非常简单直接的方式
Dialogue: 0,0:28:19.64,0:28:27.48,English,,0,0,0,,Okay and what you do is you just that the page table entry in these different processes
Dialogue: 0,0:28:19.64,0:28:27.48,Chinese,,0,0,0,,好的，你只需要让这些不同进程中的页表条目
Dialogue: 0,0:28:27.52,0:28:29.56,English,,0,0,0,,Just points to the same physical page
Dialogue: 0,0:28:27.52,0:28:29.56,Chinese,,0,0,0,,指向相同的物理页面即可
Dialogue: 0,0:28:29.56,0:28:34.52,English,,0,0,0,,So in this case virtual page 2 points to physical page 6
Dialogue: 0,0:28:29.56,0:28:34.52,Chinese,,0,0,0,,在这个例子里，虚拟页面 2 指向物理页面 6
Dialogue: 0,0:28:34.58,0:28:39.74,English,,0,0,0,,In each of the page tables for process 1 and process 2
Dialogue: 0,0:28:34.58,0:28:39.74,Chinese,,0,0,0,,在进程 1 和进程 2 的页表中，都是这样映射的
Dialogue: 0,0:28:41.04,0:28:44.02,English,,0,0,0,,So this is how shared libraries are implemented
Dialogue: 0,0:28:41.04,0:28:44.02,Chinese,,0,0,0,,这就是共享库的实现方式
Dialogue: 0,0:28:44.62,0:28:48.70,English,,0,0,0,,Right so lib.c is the same code for every process running on the system
Dialogue: 0,0:28:44.62,0:28:48.70,Chinese,,0,0,0,,对，所以 lib.c 对于系统上运行的每个进程来说都是相同的代码
Dialogue: 0,0:28:49.66,0:28:54.26,English,,0,0,0,,So lib.c just needs to be loaded once into physical into physical memory
Dialogue: 0,0:28:49.66,0:28:54.26,Chinese,,0,0,0,,所以 lib.c 只需要加载到物理内存中一次
Dialogue: 0,0:28:54.96,0:28:59.76,English,,0,0,0,,And then processes that want to access functions and data in lib.c just map
Dialogue: 0,0:28:54.96,0:28:59.76,Chinese,,0,0,0,,然后想要访问 lib.c 中的函数和数据的进程只需要映射
Dialogue: 0,0:29:00.42,0:29:05.28,English,,0,0,0,,The pages in their virtual address space to the physical pages where lib.c is actually loaded
Dialogue: 0,0:29:00.42,0:29:05.28,Chinese,,0,0,0,,让虚拟地址空间中的页面指向实际加载 lib.c 的物理页面
Dialogue: 0,0:29:06.34,0:29:09.44,English,,0,0,0,,Ok so now there's only one copy of lib.c everywhere in the system
Dialogue: 0,0:29:06.34,0:29:09.44,Chinese,,0,0,0,,好的，现在系统中只有一个 lib.c 的副本
Dialogue: 0,0:29:09.92,0:29:12.10,English,,0,0,0,,But every process thinks it's got its own copy
Dialogue: 0,0:29:09.92,0:29:12.10,Chinese,,0,0,0,,但每个过程都可以认为它有自己的副本
Dialogue: 0,0:29:16.88,0:29:23.12,English,,0,0,0,,Now this virtual memory for...
Dialogue: 0,0:29:16.88,0:29:23.12,Chinese,,0,0,0,,现在这个虚拟内存
Dialogue: 0,0:29:23.40,0:29:29.04,English,,0,0,0,,Using virtual memory to help simplify memory management greatly simplifies linking and loading
Dialogue: 0,0:29:23.40,0:29:29.04,Chinese,,0,0,0,,使用虚拟内存来帮助简化内存管理，可以大大简化链接和加载
Dialogue: 0,0:29:30.16,0:29:31.94,English,,0,0,0,,Ok for the reasons I mentioned before
Dialogue: 0,0:29:30.16,0:29:31.94,Chinese,,0,0,0,,原因我之前提到过
Dialogue: 0,0:29:31.94,0:29:37.70,English,,0,0,0,,Linkers now can assume that every program is going to be loaded at exactly the same place
Dialogue: 0,0:29:31.94,0:29:37.70,Chinese,,0,0,0,,链接器现在可以假设每个程序都将加载到完全相同的位置
Dialogue: 0,0:29:37.88,0:29:40.40,English,,0,0,0,,So the linker knows ahead of time where everything is going to be
Dialogue: 0,0:29:37.88,0:29:40.40,Chinese,,0,0,0,,所以链接器能提前知道这些东西将要加载到哪里
Dialogue: 0,0:29:41.28,0:29:45.72,English,,0,0,0,,And then it can resolve it can relocate all those references accordingly
Dialogue: 0,0:29:41.28,0:29:45.72,Chinese,,0,0,0,,然后它可以相应地重定位所有这些引用
Dialogue: 0,0:29:49.46,0:29:53.60,English,,0,0,0,,Now it really makes loading as simple
Dialogue: 0,0:29:49.46,0:29:53.60,Chinese,,0,0,0,,它确实使加载变得简单
Dialogue: 0,0:29:55.90,0:29:58.08,English,,0,0,0,,So what...so execve the loader
Dialogue: 0,0:29:55.90,0:29:58.08,Chinese,,0,0,0,,加载器 execve
Dialogue: 0,0:30:00.62,0:30:05.40,English,,0,0,0,,If you want to load a program now execve looks at the elf binary the executable binary
Dialogue: 0,0:30:00.62,0:30:05.40,Chinese,,0,0,0,,如果要加载程序，execve 会查看 elf 二进制文件，也就是可执行二进制文件
Dialogue: 0,0:30:06.50,0:30:12.80,English,,0,0,0,,Ok it sees how it identifies how big the code and the data sections in that binary are
Dialogue: 0,0:30:06.50,0:30:12.80,Chinese,,0,0,0,,它可以知道该二进制文件中的代码和数据段有多大
Dialogue: 0,0:30:14.04,0:30:18.70,English,,0,0,0,,It allocates virtual memory starting at a fixed address for the code and data
Dialogue: 0,0:30:14.04,0:30:18.70,Chinese,,0,0,0,,它从固定的地址开始为代码和数据分配虚拟内存
Dialogue: 0,0:30:21.04,0:30:24.38,English,,0,0,0,,It creates PTEs for them and marks each of them is invalid
Dialogue: 0,0:30:21.04,0:30:24.38,Chinese,,0,0,0,,它为它们创建 PTE，并把每一个 PTE 都标记为无效的
Dialogue: 0,0:30:26.14,0:30:31.62,English,,0,0,0,,Ok so each PTE contains a valid mapping
Dialogue: 0,0:30:26.14,0:30:31.62,Chinese,,0,0,0,,好的，虽然每个 PTE 都包含一个有效的映射
Dialogue: 0,0:30:31.62,0:30:37.06,English,,0,0,0,,So each PTE that's mapped to code and data contains a valid physical page number
Dialogue: 0,0:30:31.62,0:30:37.06,Chinese,,0,0,0,,映射到代码和数据的每个 PTE 都包含有效的物理页码
Dialogue: 0,0:30:38.04,0:30:42.88,English,,0,0,0,,But then the it does this trick of setting the valid bit to 0
Dialogue: 0,0:30:38.04,0:30:42.88,Chinese,,0,0,0,,但是它使用了一个伎俩，将有效位设置为 0
Dialogue: 0,0:30:45.46,0:30:50.70,English,,0,0,0,,So when the MMU encounters a PTE whose valid bit is 0
Dialogue: 0,0:30:45.46,0:30:50.70,Chinese,,0,0,0,,因此，当 MMU 遇到有效位为 0 的 PTE 时
Dialogue: 0,0:30:51.66,0:30:52.96,English,,0,0,0,,It triggers a page fault
Dialogue: 0,0:30:51.66,0:30:52.96,Chinese,,0,0,0,,它会触发缺页异常
Dialogue: 0,0:30:53.30,0:30:57.36,English,,0,0,0,,Right it looks as though that page is not been initialized yet
Dialogue: 0,0:30:53.30,0:30:57.36,Chinese,,0,0,0,,看起来好像该页面尚未初始化
Dialogue: 0,0:30:57.54,0:30:58.36,English,,0,0,0,,So it's kind of a trick
Dialogue: 0,0:30:57.54,0:30:58.36,Chinese,,0,0,0,,所以这是一个伎俩
Dialogue: 0,0:30:59.72,0:31:03.88,English,,0,0,0,,Right and then that triggers a page fault to the kernel
Dialogue: 0,0:30:59.72,0:31:03.88,Chinese,,0,0,0,,然后触发内核的缺页处理程序
Dialogue: 0,0:31:06.02,0:31:16.32,English,,0,0,0,,And then the kernel will then can then copy that that page into physical memory
Dialogue: 0,0:31:06.02,0:31:16.32,Chinese,,0,0,0,,然后内核可以将该页面复制到物理内存中
Dialogue: 0,0:31:17.14,0:31:23.86,English,,0,0,0,,Ok so this the loading actually programs and data aren't actually they're not loaded
Dialogue: 0,0:31:17.14,0:31:23.86,Chinese,,0,0,0,,好的，程序和数据实际上并不是没有加载
Dialogue: 0,0:31:24.40,0:31:26.36,English,,0,0,0,,You know they're not just like copied into memory
Dialogue: 0,0:31:24.40,0:31:26.36,Chinese,,0,0,0,,它们不是简单地复制到内存
Dialogue: 0,0:31:27.16,0:31:32.52,English,,0,0,0,,It happens as a result of of page faults, it happens as a result of misses
Dialogue: 0,0:31:27.16,0:31:32.52,Chinese,,0,0,0,,只有在缺页时才会复制它们，也就是说在未命中时复制
Dialogue: 0,0:31:34.76,0:31:39.44,English,,0,0,0,,When and it's deferred to until a byte in that page is accessed
Dialogue: 0,0:31:34.76,0:31:39.44,Chinese,,0,0,0,,只有第一次访问页面中的字节时才会复制这个页面
Dialogue: 0,0:31:40.26,0:31:42.02,English,,0,0,0,,Okay so this is called demand paging okay
Dialogue: 0,0:31:40.26,0:31:42.02,Chinese,,0,0,0,,好的，所以这叫做按需分页
Dialogue: 0,0:31:43.26,0:31:46.30,English,,0,0,0,,But it's really just like any of the other caches we've looked at right
Dialogue: 0,0:31:43.26,0:31:46.30,Chinese,,0,0,0,,但它就像我们看到的任何其他缓存一样
Dialogue: 0,0:31:46.30,0:31:53.36,English,,0,0,0,,You don't load a block into the cache until a word within that block is accessed okay
Dialogue: 0,0:31:46.30,0:31:53.36,Chinese,,0,0,0,,你不会将块加载到缓存中，直到该块中的字被访问为止
Dialogue: 0,0:31:55.98,0:32:00.96,English,,0,0,0,,So loading actually...so loading is actually this is a very efficient mechanism right because
Dialogue: 0,0:31:55.98,0:32:00.96,Chinese,,0,0,0,,所以加载实际上是一个非常高效的机制，因为
Dialogue: 0,0:32:01.54,0:32:08.42,English,,0,0,0,,You may have a program that contains a huge,say a huge array,a large array
Dialogue: 0,0:32:01.54,0:32:08.42,Chinese,,0,0,0,,你可能有一个程序，其中包含一个巨大的数组
Dialogue: 0,0:32:08.90,0:32:11.32,English,,0,0,0,,But you're only accessing a portion of that array
Dialogue: 0,0:32:08.90,0:32:11.32,Chinese,,0,0,0,,但是你只是访问该数组的一部分
Dialogue: 0,0:32:12.70,0:32:18.90,English,,0,0,0,,So that entire array won't actually be allocated the pages will only come into DRAM
Dialogue: 0,0:32:12.70,0:32:18.90,Chinese,,0,0,0,,因此，实际上不会给整个数组都分配页面，这些页面只有
Dialogue: 0,0:32:19.60,0:32:22.04,English,,0,0,0,,When they're...when a word within that page is touched
Dialogue: 0,0:32:19.60,0:32:22.04,Chinese,,0,0,0,,在其中某个字被访问时才会加载到 DRAM 中
Dialogue: 0,0:32:23.02,0:32:26.20,English,,0,0,0,,So if you're only accessing a portion of this extremely large array
Dialogue: 0,0:32:23.02,0:32:26.20,Chinese,,0,0,0,,所以如果你只是访问这个很大的数组的一部分
Dialogue: 0,0:32:27.24,0:32:31.60,English,,0,0,0,,Only the data that you access gets loaded and used
Dialogue: 0,0:32:27.24,0:32:31.60,Chinese,,0,0,0,,只有你访问的数据才会被加载和使用
Dialogue: 0,0:32:32.02,0:32:38.44,English,,0,0,0,,So it's a very very smart mechanism and extremely helpful for
Dialogue: 0,0:32:32.02,0:32:38.44,Chinese,,0,0,0,,所以这是一个非常非常聪明的机制，非常有用
Dialogue: 0,0:32:38.60,0:32:41.54,English,,0,0,0,,For allowing us to use this precious memory resource
Dialogue: 0,0:32:38.60,0:32:41.54,Chinese,,0,0,0,,便于我们使用宝贵的内存资源
Dialogue: 0,0:32:43.58,0:32:54.66,English,,0,0,0,,Okay so the third motivation for virtual memory is that it helps us protect portions of memory
Dialogue: 0,0:32:43.58,0:32:54.66,Chinese,,0,0,0,,使用虚拟内存的第三个动机是，它可以帮助我们保护内存的某些部分
Dialogue: 0,0:32:55.84,0:32:58.72,English,,0,0,0,,So you recall that our processes
Dialogue: 0,0:32:55.84,0:32:58.72,Chinese,,0,0,0,,回想一下，我们的进程
Dialogue: 0,0:32:59.32,0:33:04.56,English,,0,0,0,,You know portions of our virtual address space are read-only like the code section
Dialogue: 0,0:32:59.32,0:33:04.56,Chinese,,0,0,0,,虚拟地址空间的有些部分是只读的，比如代码段
Dialogue: 0,0:33:06.60,0:33:10.86,English,,0,0,0,,Okay and there are other portions of the address space that can only be executed by the kernel
Dialogue: 0,0:33:06.60,0:33:10.86,Chinese,,0,0,0,,地址空间中有些部分只能由内核执行
Dialogue: 0,0:33:13.38,0:33:14.30,English,,0,0,0,,So on...
Dialogue: 0,0:33:13.38,0:33:14.30,Chinese,,0,0,0,,所以
Dialogue: 0,0:33:17.96,0:33:20.98,English,,0,0,0,,On systems like x86-64
Dialogue: 0,0:33:17.96,0:33:20.98,Chinese,,0,0,0,,在像 x86-64 这样的系统上
Dialogue: 0,0:33:21.68,0:33:24.34,English,,0,0,0,,It's a 64-bit system
Dialogue: 0,0:33:21.68,0:33:24.34,Chinese,,0,0,0,,这是一个 64 位系统
Dialogue: 0,0:33:24.46,0:33:27.46,English,,0,0,0,,So the pointers and addresses are 64 bits
Dialogue: 0,0:33:24.46,0:33:27.46,Chinese,,0,0,0,,所以指针和地址是 64 位的
Dialogue: 0,0:33:28.56,0:33:32.16,English,,0,0,0,,But in actuality the real virtual address space is 48 bits
Dialogue: 0,0:33:28.56,0:33:32.16,Chinese,,0,0,0,,但实际上，真正的虚拟地址空间是 48 位的
Dialogue: 0,0:33:33.28,0:33:35.40,English,,0,0,0,,Okay so it's only..it's 2^48
Dialogue: 0,0:33:33.28,0:33:35.40,Chinese,,0,0,0,,好的，所以它只有 2^48
Dialogue: 0,0:33:36.44,0:33:42.85,English,,0,0,0,,And then the high-order bits after bit 48 are either all zeros or all ones
Dialogue: 0,0:33:36.44,0:33:42.85,Chinese,,0,0,0,,然后，48 位之后的高位比特全部为 0 或全部为 1
Dialogue: 0,0:33:46.22,0:33:51.14,English,,0,0,0,,And that's the that sort of intel's rule
Dialogue: 0,0:33:46.22,0:33:51.14,Chinese,,0,0,0,,这是英特尔的规则
Dialogue: 0,0:33:53.16,0:33:58.58,English,,0,0,0,,And so the addresses where the high order bits are all ones are reserved for the kernel
Dialogue: 0,0:33:53.16,0:33:58.58,Chinese,,0,0,0,,高位都是 1 的地址是为内核保留的
Dialogue: 0,0:33:58.80,0:34:01.18,English,,0,0,0,,The kernels code and the kernels data
Dialogue: 0,0:33:58.80,0:34:01.18,Chinese,,0,0,0,,为内核代码和内核数据保留
Dialogue: 0,0:34:02.58,0:34:05.78,English,,0,0,0,,Okay the addresses where all the bits are zero are reserved for user code
Dialogue: 0,0:34:02.58,0:34:05.78,Chinese,,0,0,0,,高位都为 0 的地址是为用户代码保留的
Dialogue: 0,0:34:06.66,0:34:11.98,English,,0,0,0,,Okay so any reference, any address that contains all ones in those higher order bits
Dialogue: 0,0:34:06.66,0:34:11.98,Chinese,,0,0,0,,根据定义，高位都是 1 的地址
Dialogue: 0,0:34:12.62,0:34:16.38,English,,0,0,0,,Is by definition either code or data in the kernel
Dialogue: 0,0:34:12.62,0:34:16.38,Chinese,,0,0,0,,是内核中的代码或数据
Dialogue: 0,0:34:17.24,0:34:22.48,English,,0,0,0,,And so you can add bits to the PTE
Dialogue: 0,0:34:17.24,0:34:22.48,Chinese,,0,0,0,,因此你可以在 PTE 中设置一些位
Dialogue: 0,0:34:23.20,0:34:28.66,English,,0,0,0,,That specify whether certain virtual pages can be accessed by user code
Dialogue: 0,0:34:23.20,0:34:28.66,Chinese,,0,0,0,,表明用户代码是否可以访问某些虚拟页面
Dialogue: 0,0:34:28.66,0:34:33.18,English,,0,0,0,,Or if they have to be accessed by the kernel, so this so-called supervisor mode
Dialogue: 0,0:34:28.66,0:34:33.18,Chinese,,0,0,0,,或者它们是否必须由内核访问，这就是所谓的管理员模式
Dialogue: 0,0:34:33.62,0:34:41.38,English,,0,0,0,,And you can also add bits that control whether that page can be read, written or executed
Dialogue: 0,0:34:33.62,0:34:41.38,Chinese,,0,0,0,,你还可以设置一些位，表示该页面是否可以读、写或执行
Dialogue: 0,0:34:42.12,0:34:49.44,English,,0,0,0,,Okay so this executes bit is new with x86-64,it didn't exist in 32-bit x86 systems
Dialogue: 0,0:34:42.12,0:34:49.44,Chinese,,0,0,0,,好的，这个执行位是 x86-64 的新功能，它在 32 位 x86 系统中不存在
Dialogue: 0,0:34:50.50,0:35:00.48,English,,0,0,0,,And this is the technique that's used now to try to prevent against attack lab code injection style attacks
Dialogue: 0,0:34:50.50,0:35:00.48,Chinese,,0,0,0,,这是现在用来防止类似 AttackLab 中代码注入攻击的技术
Dialogue: 0,0:35:01.00,0:35:02.30,English,,0,0,0,,Because it makes it impossible
Dialogue: 0,0:35:01.00,0:35:02.30,Chinese,,0,0,0,,因为它使这种攻击变得不可能
Dialogue: 0,0:35:02.64,0:35:09.30,English,,0,0,0,,If this bit is set you can't load instructions from any byte within that page
Dialogue: 0,0:35:02.64,0:35:09.30,Chinese,,0,0,0,,如果此位设为 0，则无法从该页面中的任何字节加载指令
Dialogue: 0,0:35:10.86,0:35:14.92,English,,0,0,0,,And so in fact it was this the introduction of this execute bit
Dialogue: 0,0:35:10.86,0:35:14.92,Chinese,,0,0,0,,事实上，正因为引入了这个执行位
Dialogue: 0,0:35:14.92,0:35:20.12,English,,0,0,0,,That led to things like return-oriented programming attacks like you did in your attack lab
Dialogue: 0,0:35:14.92,0:35:20.12,Chinese,,0,0,0,,才会催生出像 AttackLab 中那样的利用 ret 指令引导的攻击
Dialogue: 0,0:35:22.88,0:35:30.12,English,,0,0,0,,Okay so this by just the simple technique of adding bits to the PTE
Dialogue: 0,0:35:22.88,0:35:30.12,Chinese,,0,0,0,,好的，通过向 PTE 添加位的简单技术
Dialogue: 0,0:35:30.72,0:35:33.82,English,,0,0,0,,We provide a automatic way to protect
Dialogue: 0,0:35:30.72,0:35:33.82,Chinese,,0,0,0,,我们提供了这种自动的方式
Dialogue: 0,0:35:34.36,0:35:40.70,English,,0,0,0,,Different parts of our virtual address space from unauthorized accesses
Dialogue: 0,0:35:34.36,0:35:40.70,Chinese,,0,0,0,,保护虚拟地址空间的不同部分免受未经授权的访问
Dialogue: 0,0:35:41.60,0:35:44.84,English,,0,0,0,,And then the the MMU actually checks these bits on each access
Dialogue: 0,0:35:41.60,0:35:44.84,Chinese,,0,0,0,,MMU 在每次访问时检查这些位
Dialogue: 0,0:35:44.88,0:35:49.50,English,,0,0,0,,And if there's a problem, you know if you're trying to do a right and the right
Dialogue: 0,0:35:44.88,0:35:49.50,Chinese,,0,0,0,,如果有问题，比如你在尝试做一个操作
Dialogue: 0,0:35:50.84,0:35:56.48,English,,0,0,0,,The right bit is not enabled then it throws an exception which then the kernel deals with
Dialogue: 0,0:35:50.84,0:35:56.48,Chinese,,0,0,0,,但是相应的权限位是 0，那么它就会抛出一个异常，由内核来处理
Dialogue: 0,0:36:00.42,0:36:05.44,English,,0,0,0,,Ok so so far I've been talking about address translation, it is a kind of high-level terms
Dialogue: 0,0:36:00.42,0:36:05.44,Chinese,,0,0,0,,好，到目前为止，我一直在讨论地址翻译，这是高层次的术语
Dialogue: 0,0:36:05.44,0:36:08.66,English,,0,0,0,,So let's get down to details and see how it really works
Dialogue: 0,0:36:05.44,0:36:08.66,Chinese,,0,0,0,,所以让我们深入了解细节，看看它是如何运作的
Dialogue: 0,0:36:10.86,0:36:17.88,English,,0,0,0,,Okay so we're given a virtual address of N elements, physical address of M elements
Dialogue: 0,0:36:10.86,0:36:17.88,Chinese,,0,0,0,,好的，我们有 N 个元素的虚拟地址，M 个元素物理地址
Dialogue: 0,0:36:19.70,0:36:23.93,English,,0,0,0,,Like I said before N is usually larger than M but it doesn't have to be
Dialogue: 0,0:36:19.70,0:36:23.93,Chinese,,0,0,0,,就像我之前说的那样，N 通常比 M 大，但也不是必须这样
Dialogue: 0,0:36:25.64,0:36:29.62,English,,0,0,0,,Okay it's perfectly there's no reason. M could be much larger than N
Dialogue: 0,0:36:25.64,0:36:29.62,Chinese,,0,0,0,,这完全没有理由。M 也有可能比 N 大得多
Dialogue: 0,0:36:30.76,0:36:34.06,English,,0,0,0,,And there it's typically not but it could be
Dialogue: 0,0:36:30.76,0:36:34.06,Chinese,,0,0,0,,虽然通常不是这样，但也不是不可能
Dialogue: 0,0:36:35.52,0:36:40.84,English,,0,0,0,,And so given these two address spaces we have a map function that takes that maps from V to P
Dialogue: 0,0:36:35.52,0:36:40.84,Chinese,,0,0,0,,因此，给定这两个地址空间，我们有一个 map 函数
Dialogue: 0,0:36:41.30,0:36:45.78,English,,0,0,0,,With an optional empty set or with an additional empty set
Dialogue: 0,0:36:41.30,0:36:45.78,Chinese,,0,0,0,,可以从 V 映射到 P 与一个空元素的并
Dialogue: 0,0:36:46.80,0:36:51.28,English,,0,0,0,,And so for virtual address a, MAP(a)=a'
Dialogue: 0,0:36:46.80,0:36:51.28,Chinese,,0,0,0,,对于虚拟地址 a，如果虚拟地址 a 处的数据位于物理地址 a'
Dialogue: 0,0:36:51.72,0:36:55.76,English,,0,0,0,,If the data at virtual address a is a physical address a'
Dialogue: 0,0:36:51.72,0:36:55.76,Chinese,,0,0,0,,那么 MAP(a) = a'
Dialogue: 0,0:36:55.78,0:36:59.70,English,,0,0,0,,Okay so I mean that's just what we...it's just a little more formal way to say
Dialogue: 0,0:36:55.78,0:36:59.70,Chinese,,0,0,0,,好的，所以这就是一种关于
Dialogue: 0,0:36:59.84,0:37:03.48,English,,0,0,0,,What we've been talking about before with our diagrams
Dialogue: 0,0:36:59.84,0:37:03.48,Chinese,,0,0,0,,我们之前在图表上讨论过的更正式的形式
Dialogue: 0,0:37:04.60,0:37:09.96,English,,0,0,0,,And then map a is the empty set if the data at virtual address a is not in physical memory
Dialogue: 0,0:37:04.60,0:37:09.96,Chinese,,0,0,0,,如果虚拟地址 a 处的数据不在物理内存中，则 MAP(a) 为空集
Dialogue: 0,0:37:13.92,0:37:20.12,English,,0,0,0,,Okay so just for a summary I'm going to put up a list of all the symbols we're going to be using in address translation
Dialogue: 0,0:37:13.92,0:37:20.12,Chinese,,0,0,0,,为了总结，这里列出我们将在地址转换中使用的所有符号
Dialogue: 0,0:37:20.48,0:37:25.32,English,,0,0,0,,But this is just for summary,this is just for reference if you're using the slides later on
Dialogue: 0,0:37:20.48,0:37:25.32,Chinese,,0,0,0,,但这只是为了总结，作为你稍后使用幻灯片时的参考
Dialogue: 0,0:37:28.76,0:37:31.62,English,,0,0,0,,Okay so here's how address translation with the page table works
Dialogue: 0,0:37:28.76,0:37:31.62,Chinese,,0,0,0,,好的，这就是使用页表进行地址转换的工作原理
Dialogue: 0,0:37:34.84,0:37:36.44,English,,0,0,0,,So we're given some virtual address
Dialogue: 0,0:37:34.84,0:37:36.44,Chinese,,0,0,0,,我们给定一个虚拟地址
Dialogue: 0,0:37:38.48,0:37:40.10,English,,0,0,0,,That consists of n bits
Dialogue: 0,0:37:38.48,0:37:40.10,Chinese,,0,0,0,,它由 n 位组成
Dialogue: 0,0:37:42.80,0:37:48.52,English,,0,0,0,,And we have blocks that consists of whose size can be represented with p bits
Dialogue: 0,0:37:42.80,0:37:48.52,Chinese,,0,0,0,,我们有一个块，其大小可以用 p 位表示
Dialogue: 0,0:37:53.42,0:37:55.02,English,,0,0,0,,Okay so think about this now there
Dialogue: 0,0:37:53.42,0:37:55.02,Chinese,,0,0,0,,好的，现在想想这个
Dialogue: 0,0:37:56.48,0:38:01.32,English,,0,0,0,,So this is very similar to what we looked at when we did caching you know the address bits for a cache
Dialogue: 0,0:37:56.48,0:38:01.32,Chinese,,0,0,0,,这与我们在学习缓存时所看到的非常类似，你知道缓存有地址位
Dialogue: 0,0:38:02.46,0:38:06.82,English,,0,0,0,,So these first p bits correspond to the page offset
Dialogue: 0,0:38:02.46,0:38:06.82,Chinese,,0,0,0,,前 p 位对应于页面偏移
Dialogue: 0,0:38:06.82,0:38:10.42,English,,0,0,0,,So this is analogous to the blocks offsets that we saw with caches
Dialogue: 0,0:38:06.82,0:38:10.42,Chinese,,0,0,0,,这类似于我们在学习缓存时看到的块偏移量
Dialogue: 0,0:38:13.92,0:38:18.12,English,,0,0,0,,And then the remaining bits correspond to the virtual page number
Dialogue: 0,0:38:13.92,0:38:18.12,Chinese,,0,0,0,,然后剩余的位对应于虚拟页号
Dialogue: 0,0:38:19.06,0:38:23.62,English,,0,0,0,,Remember this is fully associative, right, so there's only one set
Dialogue: 0,0:38:19.06,0:38:23.62,Chinese,,0,0,0,,这是全相联的，所以只有一组
Dialogue: 0,0:38:24.20,0:38:28.86,English,,0,0,0,,So in a fully associative cache everything after the block offset is tagged
Dialogue: 0,0:38:24.20,0:38:28.86,Chinese,,0,0,0,,在全相联的缓存中，块偏移之后的所有内容都是标签
Dialogue: 0,0:38:29.30,0:38:30.78,English,,0,0,0,,So think of this as like a tag
Dialogue: 0,0:38:29.30,0:38:30.78,Chinese,,0,0,0,,所以把它看作一个标签
Dialogue: 0,0:38:30.96,0:38:34.60,English,,0,0,0,,This is the...this is what uniquely identifies this block
Dialogue: 0,0:38:30.96,0:38:34.60,Chinese,,0,0,0,,这是对这个块的唯一标识
Dialogue: 0,0:38:36.88,0:38:41.00,English,,0,0,0,,And we in virtual memory parlance we refer to it as a virtual page number
Dialogue: 0,0:38:36.88,0:38:41.00,Chinese,,0,0,0,,我们在虚拟内存的说法中将它称为虚拟页号
Dialogue: 0,0:38:43.16,0:38:49.34,English,,0,0,0,,Now the page table the beginning of the page table is pointed to by this page table based register
Dialogue: 0,0:38:43.16,0:38:49.34,Chinese,,0,0,0,,页表的开头是由这个页表基地址寄存器指向的
Dialogue: 0,0:38:49.36,0:38:53.70,English,,0,0,0,,On intel systems that's it's called CR3 control register 3
Dialogue: 0,0:38:49.36,0:38:53.70,Chinese,,0,0,0,,在英特尔系统上，它被称为 CR3，控制寄存器 3
Dialogue: 0,0:38:54.60,0:39:00.43,English,,0,0,0,,But this register contains the physical address of the page table in memory
Dialogue: 0,0:38:54.60,0:39:00.43,Chinese,,0,0,0,,该寄存器保存内存中页表的物理地址
Dialogue: 0,0:39:01.34,0:39:02.44,English,,0,0,0,,The beginning of that...
Dialogue: 0,0:39:01.34,0:39:02.44,Chinese,,0,0,0,,也就是页表的起始位置
Dialogue: 0,0:39:04.50,0:39:10.62,English,,0,0,0,,And so when the when the CPU presents a virtual page, a virtual address to the MMU
Dialogue: 0,0:39:04.50,0:39:10.62,Chinese,,0,0,0,,因此，当 CPU 传递一个虚拟地址给 MMU
Dialogue: 0,0:39:11.98,0:39:14.28,English,,0,0,0,,It takes the virtual page number
Dialogue: 0,0:39:11.98,0:39:14.28,Chinese,,0,0,0,,MMU 得到虚拟页号
Dialogue: 0,0:39:15.16,0:39:18.38,English,,0,0,0,,And uses that as an index into the page table
Dialogue: 0,0:39:15.16,0:39:18.38,Chinese,,0,0,0,,并将其作为页表的索引
Dialogue: 0,0:39:20.98,0:39:28.68,English,,0,0,0,,Ok and then it...and that identifies a page table entry which contains if this is mapped into memory
Dialogue: 0,0:39:20.98,0:39:28.68,Chinese,,0,0,0,,这个索引标识一个页表条目，其中包含是否映射到内存中的信息
Dialogue: 0,0:39:29.02,0:39:33.24,English,,0,0,0,,I contains the physical address of the corresponding physical page
Dialogue: 0,0:39:29.02,0:39:33.24,Chinese,,0,0,0,,还包含对应物理页面的物理地址
Dialogue: 0,0:39:36.48,0:39:40.60,English,,0,0,0,,Ok so the whole purpose of address translation is to come up you're given a virtual address
Dialogue: 0,0:39:36.48,0:39:40.60,Chinese,,0,0,0,,地址转换的目的是为了对于给定的一个虚拟地址
Dialogue: 0,0:39:41.44,0:39:43.86,English,,0,0,0,,And you want to come up with a corresponding physical address
Dialogue: 0,0:39:41.44,0:39:43.86,Chinese,,0,0,0,,得到相应的物理地址
Dialogue: 0,0:39:46.42,0:39:54.00,English,,0,0,0,,Ok so the physical address,the physical page number portion of the physical address comes out of the page table entry
Dialogue: 0,0:39:46.42,0:39:54.00,Chinese,,0,0,0,,物理地址中的物理页号部分来自页表条目
Dialogue: 0,0:39:55.52,0:40:02.96,English,,0,0,0,,And this is interesting the the physical page offset portion of the physical address comes out of the virtual page offset
Dialogue: 0,0:39:55.52,0:40:02.96,Chinese,,0,0,0,,有趣的是，物理地址的物理页面偏移部分来自虚拟页面偏移
Dialogue: 0,0:40:03.02,0:40:04.58,English,,0,0,0,,And it those bits are identical
Dialogue: 0,0:40:03.02,0:40:04.58,Chinese,,0,0,0,,这两个偏移是相同的
Dialogue: 0,0:40:06.44,0:40:11.94,English,,0,0,0,,Okay so now you should convince yourself that this is true right
Dialogue: 0,0:40:06.44,0:40:11.94,Chinese,,0,0,0,,好的，现在你应该说服自己这是对的
Dialogue: 0,0:40:13.96,0:40:18.80,English,,0,0,0,,The offset in a virtual block is going to be the same as the offset in a physical block
Dialogue: 0,0:40:13.96,0:40:18.80,Chinese,,0,0,0,,虚拟块中的偏移量将与物理块中的偏移量相同
Dialogue: 0,0:40:19.26,0:40:20.66,English,,0,0,0,,They're the same size blocks
Dialogue: 0,0:40:19.26,0:40:20.66,Chinese,,0,0,0,,它们的大小相同
Dialogue: 0,0:40:26.00,0:40:28.50,English,,0,0,0,,And you can also see why this virtual page number
Dialogue: 0,0:40:26.00,0:40:28.50,Chinese,,0,0,0,,而且你也可以看到为什么这个虚拟页号
Dialogue: 0,0:40:29.74,0:40:35.66,English,,0,0,0,,Identifies the page number in the page table
Dialogue: 0,0:40:29.74,0:40:35.66,Chinese,,0,0,0,,标识页表中的页号
Dialogue: 0,0:40:36.56,0:40:40.78,English,,0,0,0,,So imagine a virtual address that's all zeros
Dialogue: 0,0:40:36.56,0:40:40.78,Chinese,,0,0,0,,所以想象一下全部为零的虚拟地址
Dialogue: 0,0:40:42.60,0:40:43.60,English,,0,0,0,,Okay all zeros
Dialogue: 0,0:40:42.60,0:40:43.60,Chinese,,0,0,0,,全是零
Dialogue: 0,0:40:44.70,0:40:46.16,English,,0,0,0,,So it's virtual address zero
Dialogue: 0,0:40:44.70,0:40:46.16,Chinese,,0,0,0,,所以它的虚拟地址为零
Dialogue: 0,0:40:47.84,0:40:52.10,English,,0,0,0,,And now that will have a virtual page number of zero
Dialogue: 0,0:40:47.84,0:40:52.10,Chinese,,0,0,0,,虚拟页面号也是零
Dialogue: 0,0:40:53.76,0:40:56.40,English,,0,0,0,,And the byte at that address will be at offset zero
Dialogue: 0,0:40:53.76,0:40:56.40,Chinese,,0,0,0,,并且该地址处在的字节将在零偏移处
Dialogue: 0,0:40:58.80,0:41:01.32,English,,0,0,0,,Okay now increment by one virtual address one
Dialogue: 0,0:40:58.80,0:41:01.32,Chinese,,0,0,0,,好的，现在将虚拟地址增加 1
Dialogue: 0,0:41:02.58,0:41:07.54,English,,0,0,0,,So that will be in an offset of 1 and it will be in the same virtual page of zero
Dialogue: 0,0:41:02.58,0:41:07.54,Chinese,,0,0,0,,因此，它的偏移量是 1，并且它仍在虚拟页面 0 中
Dialogue: 0,0:41:08.12,0:41:13.18,English,,0,0,0,,Right now keep incrementing until all of the bits in the virtual page offset are ones
Dialogue: 0,0:41:08.12,0:41:13.18,Chinese,,0,0,0,,现在继续递增，直到虚拟页面偏移中的所有位都是 1
Dialogue: 0,0:41:14.22,0:41:16.38,English,,0,0,0,,And the virtual page numbers is zero
Dialogue: 0,0:41:14.22,0:41:16.38,Chinese,,0,0,0,,虚拟页号为零
Dialogue: 0,0:41:16.50,0:41:20.88,English,,0,0,0,,Okay so this is the last byte in that virtual page zero
Dialogue: 0,0:41:16.50,0:41:20.88,Chinese,,0,0,0,,好的，这是虚拟页面 0 的最后一个字节
Dialogue: 0,0:41:21.84,0:41:23.42,English,,0,0,0,,Now increment one more time
Dialogue: 0,0:41:21.84,0:41:23.42,Chinese,,0,0,0,,现在再增加 1
Dialogue: 0,0:41:26.16,0:41:30.90,English,,0,0,0,,The one bit carries over to the virtual page number so now we go to the next virtual page
Dialogue: 0,0:41:26.16,0:41:30.90,Chinese,,0,0,0,,进一位到虚拟页码，就转到了下一个虚拟页面
Dialogue: 0,0:41:31.86,0:41:34.24,English,,0,0,0,,And it's at an offset of zero okay so
Dialogue: 0,0:41:31.86,0:41:34.24,Chinese,,0,0,0,,它的偏移量为零，所以
Dialogue: 0,0:41:35.30,0:41:39.38,English,,0,0,0,,So can you see it's sort of sort of obvious when you think about it like that
Dialogue: 0,0:41:35.30,0:41:39.38,Chinese,,0,0,0,,所以，想想看这是不是很明显
Dialogue: 0,0:41:40.30,0:41:46.86,English,,0,0,0,,You know why we can just take these bits after the virtual page offset and use them to uniquely identify
Dialogue: 0,0:41:40.30,0:41:46.86,Chinese,,0,0,0,,为什么我们可以用虚拟页号进行唯一标识
Dialogue: 0,0:41:47.14,0:41:50.20,English,,0,0,0,,What virtual page were we're working with
Dialogue: 0,0:41:47.14,0:41:50.20,Chinese,,0,0,0,,我们正在使用什么虚拟页面
Dialogue: 0,0:41:51.46,0:41:53.66,English,,0,0,0,,Okay so let's see how I
Dialogue: 0,0:41:51.46,0:41:53.66,Chinese,,0,0,0,,好的，让我们看看
Dialogue: 0,0:41:53.78,0:41:56.32,English,,0,0,0,,Let's see how it works in this system in more detail
Dialogue: 0,0:41:53.78,0:41:56.32,Chinese,,0,0,0,,让我们更详细地了解它在该系统中的工作原理
Dialogue: 0,0:41:57.48,0:42:02.40,English,,0,0,0,,So our system our CPU sends a virtual address to the MMU as a result of executing
Dialogue: 0,0:41:57.48,0:42:02.40,Chinese,,0,0,0,,我们的系统 CPU 会在执行指令时向 MMU 发送虚拟地址
Dialogue: 0,0:42:02.64,0:42:08.78,English,,0,0,0,,A move instruction or call or return or any kind of control transfer
Dialogue: 0,0:42:02.64,0:42:08.78,Chinese,,0,0,0,,可能是移动指令，或者是调用、返回或其他任何类型的控制转移
Dialogue: 0,0:42:09.50,0:42:10.70,English,,0,0,0,,The MMU
Dialogue: 0,0:42:09.50,0:42:10.70,Chinese,,0,0,0,,MMU
Dialogue: 0,0:42:13.62,0:42:19.64,English,,0,0,0,,Looks up the PTE, so it fetches the PTE from the page table stored in memory
Dialogue: 0,0:42:13.62,0:42:19.64,Chinese,,0,0,0,,MMU 查看 PTE，因此它从存储在内存中的页表中获取 PTE
Dialogue: 0,0:42:20.04,0:42:25.52,English,,0,0,0,,So this is actually going off the chip onto memory into this PTE stored in memory
Dialogue: 0,0:42:20.04,0:42:25.52,Chinese,,0,0,0,,所以控制逻辑将从芯片中转移到在存储器中，转移到 PTE 中
Dialogue: 0,0:42:26.50,0:42:34.50,English,,0,0,0,,It fetches the PTE, extracts it, and uses that PTE to construct the physical address
Dialogue: 0,0:42:26.50,0:42:34.50,Chinese,,0,0,0,,它获取 PTE 并使用该 PTE 构造物理地址
Dialogue: 0,0:42:35.90,0:42:40.88,English,,0,0,0,,Okay and then it sends that physical address to the cache and memory system
Dialogue: 0,0:42:35.90,0:42:40.88,Chinese,,0,0,0,,好的，然后它将该物理地址发送到缓存和内存系统
Dialogue: 0,0:42:41.34,0:42:44.98,English,,0,0,0,,Which eventually results in the data being returned back to the CPU
Dialogue: 0,0:42:41.34,0:42:44.98,Chinese,,0,0,0,,这最终会导致数据返回到 CPU
Dialogue: 0,0:42:46.10,0:42:50.30,English,,0,0,0,,Okay so even for a hit,we still have memory references
Dialogue: 0,0:42:46.10,0:42:50.30,Chinese,,0,0,0,,好的，即使是页命中的情况，我们仍然需要访问内存
Dialogue: 0,0:42:50.72,0:42:53.58,English,,0,0,0,,Right because we have to fetch that page table entry
Dialogue: 0,0:42:50.72,0:42:53.58,Chinese,,0,0,0,,是的，因为我们必须获取该页表条目
Dialogue: 0,0:42:57.86,0:43:02.22,English,,0,0,0,,Now a miss in this parlance is called a page fault
Dialogue: 0,0:42:57.86,0:43:02.22,Chinese,,0,0,0,,现在页未命中在这里被称为缺页错误
Dialogue: 0,0:43:02.96,0:43:08.94,English,,0,0,0,,So in this case the same thing happens as before that the CPU sends the virtual address to the MMU
Dialogue: 0,0:43:02.96,0:43:08.94,Chinese,,0,0,0,,因此，在这种情况下，CPU 同样将虚拟地址发送到 MMU
Dialogue: 0,0:43:09.44,0:43:12.86,English,,0,0,0,,The MMU fetches that the PTE from memory
Dialogue: 0,0:43:09.44,0:43:12.86,Chinese,,0,0,0,,MMU 从内存获取 PTE
Dialogue: 0,0:43:13.40,0:43:16.54,English,,0,0,0,,But then when it looks then when the MMU looks at the PTE
Dialogue: 0,0:43:13.40,0:43:16.54,Chinese,,0,0,0,,但是当 MMU 看 PTE 时
Dialogue: 0,0:43:16.78,0:43:22.14,English,,0,0,0,,It sees that there's either an invalid valid bit or a zero valid bit or the
Dialogue: 0,0:43:16.78,0:43:22.14,Chinese,,0,0,0,,它看到有效位是 0
Dialogue: 0,0:43:23.54,0:43:26.56,English,,0,0,0,,The it's indicated that the data stored on disk
Dialogue: 0,0:43:23.54,0:43:26.56,Chinese,,0,0,0,,这表明数据存储在磁盘上
Dialogue: 0,0:43:30.10,0:43:35.90,English,,0,0,0,,And so in that case the MMU triggers a page fault exception
Dialogue: 0,0:43:30.10,0:43:35.90,Chinese,,0,0,0,,因此，在这种情况下，MMU 会触发缺页异常
Dialogue: 0,0:43:36.62,0:43:39.14,English,,0,0,0,,Which transfers control to this page fault handler
Dialogue: 0,0:43:36.62,0:43:39.14,Chinese,,0,0,0,,将控制转移到缺页处理程序
Dialogue: 0,0:43:40.94,0:43:43.40,English,,0,0,0,,The handler identifies a victim and
Dialogue: 0,0:43:40.94,0:43:43.40,Chinese,,0,0,0,,处理程序选出一个牺牲页
Dialogue: 0,0:43:44.66,0:43:47.80,English,,0,0,0,,If it's been modified copies it out to disk
Dialogue: 0,0:43:44.66,0:43:47.80,Chinese,,0,0,0,,如果牺牲页已被修改，则将其复制到磁盘
Dialogue: 0,0:43:50.12,0:43:55.94,English,,0,0,0,,Then it fetches the new page from disk into memory and up through the cache hierarchy
Dialogue: 0,0:43:50.12,0:43:55.94,Chinese,,0,0,0,,然后，它将新页面从磁盘提取到内存中，然后通过缓存层次结构
Dialogue: 0,0:43:57.42,0:43:57.90,English,,0,0,0,,OK
Dialogue: 0,0:43:57.42,0:43:57.90,Chinese,,0,0,0,,好
Dialogue: 0,0:43:59.42,0:44:00.96,English,,0,0,0,,And then it did...
Dialogue: 0,0:43:59.42,0:44:00.96,Chinese,,0,0,0,,然后它
Dialogue: 0,0:44:01.42,0:44:07.00,English,,0,0,0,,And then it causes that the then the handler returns to the to the process
Dialogue: 0,0:44:01.42,0:44:07.00,Chinese,,0,0,0,,然后它导致处理程序返回到进程
Dialogue: 0,0:44:08.80,0:44:11.32,English,,0,0,0,,And when a handler for a fault returns
Dialogue: 0,0:44:08.80,0:44:11.32,Chinese,,0,0,0,,当故障的处理程序返回时
Dialogue: 0,0:44:11.70,0:44:14.96,English,,0,0,0,,It causes the faulting instruction to re-execute
Dialogue: 0,0:44:11.70,0:44:14.96,Chinese,,0,0,0,,它会让发生错误的指令重新执行
Dialogue: 0,0:44:15.00,0:44:21.56,English,,0,0,0,,So now the move instruction that faulted is re-execute, but this time there's a page hit
Dialogue: 0,0:44:15.00,0:44:21.56,Chinese,,0,0,0,,所以出现故障的移动指令会重新执行，但这次是页命中
Dialogue: 0,0:44:27.78,0:44:32.46,English,,0,0,0,,Now you may be interested how the cache is integrated into all of this
Dialogue: 0,0:44:27.78,0:44:32.46,Chinese,,0,0,0,,现在你可能会好奇，缓存如何融入这个机制里
Dialogue: 0,0:44:34.00,0:44:39.66,English,,0,0,0,,So the MMU send fetches page table entries
Dialogue: 0,0:44:34.00,0:44:39.66,Chinese,,0,0,0,,MMU 发送提取页表条目的请求
Dialogue: 0,0:44:40.20,0:44:43.14,English,,0,0,0,,So it passes page table addresses to the cache
Dialogue: 0,0:44:40.20,0:44:43.14,Chinese,,0,0,0,,所以它将页表地址传给缓存
Dialogue: 0,0:44:44.08,0:44:46.24,English,,0,0,0,,If those missed those go to memory
Dialogue: 0,0:44:44.08,0:44:46.24,Chinese,,0,0,0,,如果缓存不命中，那就要去内存查找
Dialogue: 0,0:44:48.16,0:44:51.92,English,,0,0,0,,The memory returns those page table entries to the cache
Dialogue: 0,0:44:48.16,0:44:51.92,Chinese,,0,0,0,,内存将这些页表条目返回到缓存
Dialogue: 0,0:44:52.80,0:44:55.88,English,,0,0,0,,And then ultimately to the MMU
Dialogue: 0,0:44:52.80,0:44:55.88,Chinese,,0,0,0,,然后最终传给 MMU
Dialogue: 0,0:44:56.66,0:45:02.26,English,,0,0,0,,The MMU constructs that physical address and then its sends that physical address to the cache
Dialogue: 0,0:44:56.66,0:45:02.26,Chinese,,0,0,0,,MMU 构造该物理地址，然后将该物理地址传递给缓存
Dialogue: 0,0:45:02.36,0:45:07.66,English,,0,0,0,,Right so with caching the way we've been caching is done using physical addresses
Dialogue: 0,0:45:02.36,0:45:07.66,Chinese,,0,0,0,,使用该物理地址去缓存里查找数据
Dialogue: 0,0:45:10.52,0:45:15.70,English,,0,0,0,,Okay in this case it's also possible to construct caches that work with virtual addresses but yes
Dialogue: 0,0:45:10.52,0:45:15.70,Chinese,,0,0,0,,好的，在这种情况下，也可以构建使用虚拟地址的缓存，但是
Dialogue: 0,0:45:15.70,0:45:25.08,English,,0,0,0,,[student speaking]
Dialogue: 0,0:45:15.70,0:45:25.08,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:45:25.18,0:45:27.30,English,,0,0,0,,Yeah so, it will get into that...
Dialogue: 0,0:45:25.18,0:45:27.30,Chinese,,0,0,0,,是的，它会进入......
Dialogue: 0,0:45:27.30,0:45:32.24,English,,0,0,0,,Okay so the question is how is the virtual address space implemented on disk
Dialogue: 0,0:45:27.30,0:45:32.24,Chinese,,0,0,0,,好的，问题是如何在磁盘上实现虚拟地址空间
Dialogue: 0,0:45:33.16,0:45:39.86,English,,0,0,0,,And it when it actually does a much more efficient thing than the sort of an abstract model that I described
Dialogue: 0,0:45:33.16,0:45:39.86,Chinese,,0,0,0,,它实际上比我描述的那种抽象模型更有效
Dialogue: 0,0:45:40.38,0:45:44.92,English,,0,0,0,,So most pages there's an option when you allocate a new virtual memory page
Dialogue: 0,0:45:40.38,0:45:44.92,Chinese,,0,0,0,,因此，当你分配新的虚拟内存页面时，大多数页面都有一个选项
Dialogue: 0,0:45:45.44,0:45:47.94,English,,0,0,0,,You can allocate it, so that it's all zeros
Dialogue: 0,0:45:45.44,0:45:47.94,Chinese,,0,0,0,,你可以在分配它时让它初始化为 0
Dialogue: 0,0:45:49.58,0:45:54.32,English,,0,0,0,,Okay so there's a special you can say I want this I want to allocate a page of all zeros
Dialogue: 0,0:45:49.58,0:45:54.32,Chinese,,0,0,0,,好的，所以有这种选择，你可以说我想要分配一个全零的页面
Dialogue: 0,0:45:54.82,0:45:57.50,English,,0,0,0,,In that case you know that page doesn't need to ever get stored on disk
Dialogue: 0,0:45:54.82,0:45:57.50,Chinese,,0,0,0,,在这种情况下，该页面不需要存储在磁盘上
Dialogue: 0,0:45:57.94,0:46:02.58,English,,0,0,0,,Right it's just the memory it's as though it was created on disk and then loaded into memory
Dialogue: 0,0:45:57.94,0:46:02.58,Chinese,,0,0,0,,它只在内存里，但是看起来好像是在磁盘上创建然后加载到内存中一样
Dialogue: 0,0:46:03.28,0:46:07.57,English,,0,0,0,,So those pages that are all zeros don't exist on disk
Dialogue: 0,0:46:03.28,0:46:07.57,Chinese,,0,0,0,,因此，这些全零的页面在磁盘上不存在
Dialogue: 0,0:46:08.50,0:46:10.80,English,,0,0,0,,You know when pages are modified
Dialogue: 0,0:46:08.50,0:46:10.80,Chinese,,0,0,0,,当页面被修改
Dialogue: 0,0:46:13.72,0:46:21.70,English,,0,0,0,,It's a little more... Pages can be mapped to particular files for example when we load an elf binary
Dialogue: 0,0:46:13.72,0:46:21.70,Chinese,,0,0,0,,页面可以映射到特定的文件，例如，当我们加载 elf 二进制文件时
Dialogue: 0,0:46:22.64,0:46:27.70,English,,0,0,0,,The pages that correspond to the code are actually mapped to the bytes in the binary
Dialogue: 0,0:46:22.64,0:46:27.70,Chinese,,0,0,0,,含有代码段的页面实际上映射到二进制文件中
Dialogue: 0,0:46:28.73,0:46:30.60,English,,0,0,0,,That contain the code
Dialogue: 0,0:46:28.73,0:46:30.60,Chinese,,0,0,0,,包含代码的那些字节
Dialogue: 0,0:46:31.66,0:46:35.36,English,,0,0,0,,So that when you miss on that page it brings in those code pages
Dialogue: 0,0:46:31.66,0:46:35.36,Chinese,,0,0,0,,所以，那个页面未命中时，那些代码页就会加载到内存里
Dialogue: 0,0:46:35.86,0:46:41.58,English,,0,0,0,,Okay so pages can be mapped to user level files on disk
Dialogue: 0,0:46:35.86,0:46:41.58,Chinese,,0,0,0,,好的，所以页面可以映射到磁盘上的用户级文件
Dialogue: 0,0:46:42.64,0:46:45.53,English,,0,0,0,,Or not they can be anonymous and not mapped
Dialogue: 0,0:46:42.64,0:46:45.53,Chinese,,0,0,0,,或者不映射，他们可以不映射
Dialogue: 0,0:46:46.50,0:46:48.82,English,,0,0,0,,So if they're mapped to user level
Dialogue: 0,0:46:46.50,0:46:48.82,Chinese,,0,0,0,,因此，如果他们被映射到用户级文件
Dialogue: 0,0:46:50.70,0:46:53.68,English,,0,0,0,,If they're mapped to user level files and you write to a page
Dialogue: 0,0:46:50.70,0:46:53.68,Chinese,,0,0,0,,如果它们映射到用户级文件并且你往一个页面中写入数据
Dialogue: 0,0:46:54.02,0:47:00.04,English,,0,0,0,,Then it will get written back to the page that it's mapped to
Dialogue: 0,0:46:54.02,0:47:00.04,Chinese,,0,0,0,,它将会被写回到它映射到的磁盘中的页面上
Dialogue: 0,0:47:00.58,0:47:06.90,English,,0,0,0,,If it's not mapped to any page, it's stored in this area called the swap area or the swap file okay
Dialogue: 0,0:47:00.58,0:47:06.90,Chinese,,0,0,0,,如果它没有映射到任何页面，它就存储在这个称为交换区域或交换文件的区域中
Dialogue: 0,0:47:07.30,0:47:07.70,English,,0,0,0,,yes
Dialogue: 0,0:47:07.30,0:47:07.70,Chinese,,0,0,0,,请说
Dialogue: 0,0:47:07.70,0:47:18.98,English,,0,0,0,,[student speaking]
Dialogue: 0,0:47:07.70,0:47:18.98,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:47:18.98,0:47:23.28,English,,0,0,0,,Oh yeah so the question is when you load a page from disk into memory
Dialogue: 0,0:47:18.98,0:47:23.28,Chinese,,0,0,0,,哦,你的问题是，当你从磁盘加载一个页面到内存
Dialogue: 0,0:47:23.28,0:47:26.92,English,,0,0,0,,Does it also get cached in the cache memory hierarchy and the answer is yes
Dialogue: 0,0:47:23.28,0:47:26.92,Chinese,,0,0,0,,它是否也缓存在缓存内存层次结构中？答案是肯定的
Dialogue: 0,0:47:27.66,0:47:29.18,English,,0,0,0,,So if you load an entire page
Dialogue: 0,0:47:27.66,0:47:29.18,Chinese,,0,0,0,,因此，如果你加载整个页面
Dialogue: 0,0:47:29.92,0:47:33.68,English,,0,0,0,,That page will be broken up into blocks 64 byte blocks
Dialogue: 0,0:47:29.92,0:47:33.68,Chinese,,0,0,0,,该页面将被分成 64 字节的块
Dialogue: 0,0:47:34.28,0:47:37.32,English,,0,0,0,,And and load it into the cache
Dialogue: 0,0:47:34.28,0:47:37.32,Chinese,,0,0,0,,并将其加载到缓存中
Dialogue: 0,0:47:37.94,0:47:41.90,English,,0,0,0,,So everything that you fetch from the
Dialogue: 0,0:47:37.94,0:47:41.90,Chinese,,0,0,0,,因此，你从内存中获取的所有内容
Dialogue: 0,0:47:42.40,0:47:45.64,English,,0,0,0,,From the memory goes through the cache hierarchy
Dialogue: 0,0:47:42.40,0:47:45.64,Chinese,,0,0,0,,从内存中获取的内容都会通过缓存层次结构
Dialogue: 0,0:47:52.92,0:48:01.02,English,,0,0,0,,Okay so I claim that virtual memory works
Dialogue: 0,0:47:52.92,0:48:01.02,Chinese,,0,0,0,,好的，我说虚拟内存是有效的
Dialogue: 0,0:48:01.94,0:48:05.48,English,,0,0,0,,Because of locality and that's true but if we still had to fetch
Dialogue: 0,0:48:01.94,0:48:05.48,Chinese,,0,0,0,,因为有局部性，这毫无疑问，但如果我们仍然需要访存
Dialogue: 0,0:48:06.46,0:48:08.92,English,,0,0,0,,If every time we had a miss we still had to go to memory
Dialogue: 0,0:48:06.46,0:48:08.92,Chinese,,0,0,0,,每当遇到一次缓存不命中，我们仍然需要访存
Dialogue: 0,0:48:09.22,0:48:10.66,English,,0,0,0,,It would be too inefficient
Dialogue: 0,0:48:09.22,0:48:10.66,Chinese,,0,0,0,,这效率就太低了
Dialogue: 0,0:48:11.74,0:48:20.20,English,,0,0,0,,Okay so the the MMU speeds up this translation process by caching page table entries
Dialogue: 0,0:48:11.74,0:48:20.20,Chinese,,0,0,0,,好，MMU 通过缓存页表条目来加速这个翻译过程
Dialogue: 0,0:48:21.18,0:48:27.02,English,,0,0,0,,In a hardware cache within the MMU called the translation look-aside buffer or TLB
Dialogue: 0,0:48:21.18,0:48:27.02,Chinese,,0,0,0,,页表条目缓存在 MMU 内的一个硬件缓存中，称为转换后备缓冲区或 TLB
Dialogue: 0,0:48:28.34,0:48:35.08,English,,0,0,0,,So the TLB is a hardware cache that caches is PTEs page table entries
Dialogue: 0,0:48:28.34,0:48:35.08,Chinese,,0,0,0,,TLB 是一个硬件缓存，缓存的内容是 PTE 页表条目
Dialogue: 0,0:48:37.06,0:48:40.90,English,,0,0,0,,And it contains like it contains a cache of the most recently
Dialogue: 0,0:48:37.06,0:48:40.90,Chinese,,0,0,0,,它缓存了最近的
Dialogue: 0,0:48:41.58,0:48:47.22,English,,0,0,0,,You know it's just like any other cache so it contains a cache of the most recently used page table entries
Dialogue: 0,0:48:41.58,0:48:47.22,Chinese,,0,0,0,,它包含最近使用的页表条目的缓存，就像其他缓存一样
Dialogue: 0,0:48:49.20,0:48:57.74,English,,0,0,0,,And so the MMU... remember the unique part of a virtual address that defines a virtual page is the virtual page number bits
Dialogue: 0,0:48:49.20,0:48:57.74,Chinese,,0,0,0,,虚拟页号位虚拟地址中对虚拟页面的唯一标识
Dialogue: 0,0:48:58.86,0:49:09.10,English,,0,0,0,,Okay so the TLB uses the VPN portion of the virtual address to access it
Dialogue: 0,0:48:58.86,0:49:09.10,Chinese,,0,0,0,,好的，TLB 使用虚拟地址的 VPN 部分来访问它
Dialogue: 0,0:49:09.54,0:49:15.98,English,,0,0,0,,And so that just like any other set, it has set index bits which are just determined by how many
Dialogue: 0,0:49:09.54,0:49:15.98,Chinese,,0,0,0,,它有一段组索引位，位数只取决于
Dialogue: 0,0:49:16.28,0:49:19.98,English,,0,0,0,,How many entries that or how many sets that the TLB has
Dialogue: 0,0:49:16.28,0:49:19.98,Chinese,,0,0,0,,TLB 具有多少组条目
Dialogue: 0,0:49:21.62,0:49:30.26,English,,0,0,0,,And it has a tag with for the remaining bits to disambiguate any cache lines or PTEs
Dialogue: 0,0:49:21.62,0:49:30.26,Chinese,,0,0,0,,并且它有一段标记位，用于区分不同的缓冲行
Dialogue: 0,0:49:30.82,0:49:32.18,English,,0,0,0,,That are mapped to the same set
Dialogue: 0,0:49:30.82,0:49:32.18,Chinese,,0,0,0,,或者说映射到同一组的不同 PTE
Dialogue: 0,0:49:33.78,0:49:40.64,English,,0,0,0,,Okay so the the VPN or the TLBI (TLB index) maps to this particular set
Dialogue: 0,0:49:33.78,0:49:40.64,Chinese,,0,0,0,,好的，所以 VPN 或者说 TLBI（TLB 索引）映射到这个特定的集合
Dialogue: 0,0:49:42.18,0:49:45.12,English,,0,0,0,,And then it uses the...
Dialogue: 0,0:49:42.18,0:49:45.12,Chinese,,0,0,0,,然后它使用...
Dialogue: 0,0:49:45.44,0:49:59.20,English,,0,0,0,,The TLB uses the TLBT bits to disambiguate and determine if the PTE that it's looking for is, it is really stored in the cache
Dialogue: 0,0:49:45.44,0:49:59.20,Chinese,,0,0,0,,TLB 使用 TLBT 位消除歧义并确定它正在寻找的 PTE 是否真的存储在缓存中
Dialogue: 0,0:50:00.90,0:50:02.50,English,,0,0,0,,Okay so the way this works is
Dialogue: 0,0:50:00.90,0:50:02.50,Chinese,,0,0,0,,好的，它的工作原理是
Dialogue: 0,0:50:03.68,0:50:06.74,English,,0,0,0,,CPU generates a virtual address it goes through the MMU
Dialogue: 0,0:50:03.68,0:50:06.74,Chinese,,0,0,0,,CPU 生成一个虚拟地址，传递给 MMU
Dialogue: 0,0:50:07.06,0:50:12.66,English,,0,0,0,,The MMU instead of looking in memory and directly going to the page table entry
Dialogue: 0,0:50:07.06,0:50:12.66,Chinese,,0,0,0,,MMU 不会直接查看内存中的页表条目
Dialogue: 0,0:50:13.56,0:50:17.24,English,,0,0,0,,It first asks the TLB if it has that, it sends it the VPN
Dialogue: 0,0:50:13.56,0:50:17.24,Chinese,,0,0,0,,它首先询问 TLB 是否有这个页表条目，它把 VPN 发送给 TLB
Dialogue: 0,0:50:17.44,0:50:21.38,English,,0,0,0,,And so do you have this virtual page the PTE for this virtual page
Dialogue: 0,0:50:17.44,0:50:21.38,Chinese,,0,0,0,,查询 TLB 是否缓存了这个虚拟页面的 PTE
Dialogue: 0,0:50:22.76,0:50:25.08,English,,0,0,0,,And if it does the TLB returns a hit
Dialogue: 0,0:50:22.76,0:50:25.08,Chinese,,0,0,0,,如果确实缓存了，则 TLB 返回命中
Dialogue: 0,0:50:25.32,0:50:30.72,English,,0,0,0,,And it returns that page table entry which the MMU can then use to construct the physical address
Dialogue: 0,0:50:25.32,0:50:30.72,Chinese,,0,0,0,,然后它返回可以让 MMU 构造物理地址的页表条目
Dialogue: 0,0:50:31.26,0:50:34.24,English,,0,0,0,,To send to the cache and memory system
Dialogue: 0,0:50:31.26,0:50:34.24,Chinese,,0,0,0,,然后物理地址发送到缓存和内存系统
Dialogue: 0,0:50:35.10,0:50:37.66,English,,0,0,0,,Eventually I result in that the data being sent back
Dialogue: 0,0:50:35.10,0:50:37.66,Chinese,,0,0,0,,最终数据被传回 CPU
Dialogue: 0,0:50:39.82,0:50:46.00,English,,0,0,0,,Now when you have a miss then there's this one the MMU checks with the TLB for the PTE
Dialogue: 0,0:50:39.82,0:50:46.00,Chinese,,0,0,0,,现在，当 MMU 在 TLB 中查询 PTE，然后发现不命中时
Dialogue: 0,0:50:46.64,0:50:50.88,English,,0,0,0,,It misses so then the MEMU has to go to memory just like before okay so this is
Dialogue: 0,0:50:46.64,0:50:50.88,Chinese,,0,0,0,,它不命中，所以 MMU 必须像以前一样去内存找PTE
Dialogue: 0,0:50:51.92,0:50:59.66,English,,0,0,0,,And then everything is the same, the memory returns the PTE to the MMU which stashes it in the TLB
Dialogue: 0,0:50:51.92,0:50:59.66,Chinese,,0,0,0,,然后一切都是相同的，内存将 PTE 返回到 MMU，并将其存储在 TLB 中
Dialogue: 0,0:51:00.88,0:51:04.04,English,,0,0,0,,And just like before if there's no room in the
Dialogue: 0,0:51:00.88,0:51:04.04,Chinese,,0,0,0,,就像以前一样，如果没有空间的话（就需要在 TLB 中选择牺牲的 PTE）
Dialogue: 0,0:51:07.14,0:51:13.98,English,,0,0,0,,If yeah if a PTE has been modified then it has to be written back, okay just like any other cache
Dialogue: 0,0:51:07.14,0:51:13.98,Chinese,,0,0,0,,如果选出的 PTE 已被修改，则必须将其写回，就像任何其他缓存一样
Dialogue: 0,0:51:15.78,0:51:20.58,English,,0,0,0,,And eventually the MMU uses that to construct a physical address and then the data gets sent back
Dialogue: 0,0:51:15.78,0:51:20.58,Chinese,,0,0,0,,最终，MMU 使用它来构建物理地址，然后将数据发回 CPU
Dialogue: 0,0:51:24.16,0:51:28.44,English,,0,0,0,,Okay if you've been paying attention unlike a couple people
Dialogue: 0,0:51:24.16,0:51:28.44,Chinese,,0,0,0,,好吧，如果你一直在注意
Dialogue: 0,0:51:31.76,0:51:33.12,English,,0,0,0,,If you've been paying attention
Dialogue: 0,0:51:31.76,0:51:33.12,Chinese,,0,0,0,,如果你一直在关注
Dialogue: 0,0:51:34.14,0:51:37.60,English,,0,0,0,,You're going to be very concerned about the size of these page tables
Dialogue: 0,0:51:34.14,0:51:37.60,Chinese,,0,0,0,,你将非常关注这些页表的大小
Dialogue: 0,0:51:38.20,0:51:40.68,English,,0,0,0,,Right that I mean
Dialogue: 0,0:51:38.20,0:51:40.68,Chinese,,0,0,0,,对，我的意思是
Dialogue: 0,0:51:41.90,0:51:46.76,English,,0,0,0,,We've got 4k bytes suppose we have 4k bytes pages
Dialogue: 0,0:51:41.90,0:51:46.76,Chinese,,0,0,0,,我们有 4 KB，假设我们的页面大小是 4 KB
Dialogue: 0,0:51:47.58,0:51:52.76,English,,0,0,0,,And our effective address space is 48 bits like it is with an x86-64 system
Dialogue: 0,0:51:47.58,0:51:52.76,Chinese,,0,0,0,,我们的有效地址空间是 48 位，就像 x86-64 系统一样
Dialogue: 0,0:51:54.38,0:51:58.36,English,,0,0,0,,Then and we have an 8-byte page table entry
Dialogue: 0,0:51:54.38,0:51:58.36,Chinese,,0,0,0,,然后，我们的页表条目是 8 字节的
Dialogue: 0,0:51:59.70,0:52:03.60,English,,0,0,0,,We need a page table 512 gigabytes
Dialogue: 0,0:51:59.70,0:52:03.60,Chinese,,0,0,0,,我们就需要一个 512 GB 的页表
Dialogue: 0,0:52:04.84,0:52:08.54,English,,0,0,0,,Okay the address space 2^48 bytes
Dialogue: 0,0:52:04.84,0:52:08.54,Chinese,,0,0,0,,地址空间 2^48 个字节
Dialogue: 0,0:52:10.48,0:52:13.94,English,,0,0,0,,Divided by 2^12 bytes per page
Dialogue: 0,0:52:10.48,0:52:13.94,Chinese,,0,0,0,,除以每页 2^12 个字节
Dialogue: 0,0:52:14.22,0:52:17.00,English,,0,0,0,,Okay so that's the number of page table entries that we need
Dialogue: 0,0:52:14.22,0:52:17.00,Chinese,,0,0,0,,好的，这就是我们需要的页表条目数
Dialogue: 0,0:52:17.42,0:52:20.00,English,,0,0,0,,And then the size of each page table entry is 8 bytes
Dialogue: 0,0:52:17.42,0:52:20.00,Chinese,,0,0,0,,然后每个页表条目的大小为 8 个字节
Dialogue: 0,0:52:21.67,0:52:27.66,English,,0,0,0,,So we need almost a terabyte of of DRAM just to hold the page table right so
Dialogue: 0,0:52:21.67,0:52:27.66,Chinese,,0,0,0,,因此，我们需要几乎 1 TB 的 DRAM 来保存页表
Dialogue: 0,0:52:28.56,0:52:29.92,English,,0,0,0,,So then obviously it's not going to work
Dialogue: 0,0:52:28.56,0:52:29.92,Chinese,,0,0,0,,那么显然这么做是没用的
Dialogue: 0,0:52:31.32,0:52:34.98,English,,0,0,0,,And it's obviously not how their page tables are really implemented
Dialogue: 0,0:52:31.32,0:52:34.98,Chinese,,0,0,0,,这显然不是页表真正实现的方式
Dialogue: 0,0:52:35.82,0:52:39.54,English,,0,0,0,,So the solution is to to use a hierarchy of page tables
Dialogue: 0,0:52:35.82,0:52:39.54,Chinese,,0,0,0,,所以解决方案是使用页表的层次结构
Dialogue: 0,0:52:41.24,0:52:44.92,English,,0,0,0,,So in it so we if we have a two level page table
Dialogue: 0,0:52:41.24,0:52:44.92,Chinese,,0,0,0,,所以，如果我们有一个两级页表
Dialogue: 0,0:52:46.12,0:52:50.64,English,,0,0,0,,The there's a top of first level page table called the level 1 table
Dialogue: 0,0:52:46.12,0:52:50.64,Chinese,,0,0,0,,第一层级的页表称为一级页表
Dialogue: 0,0:52:51.00,0:52:54.12,English,,0,0,0,,Which is always in memory ok it's never never page down
Dialogue: 0,0:52:51.00,0:52:54.12,Chinese,,0,0,0,,一级页表总是在内存中，它永远不会丢失
Dialogue: 0,0:52:55.00,0:53:00.54,English,,0,0,0,,And then there's a sequence of level 2 page tables and they're all the same size
Dialogue: 0,0:52:55.00,0:53:00.54,Chinese,,0,0,0,,然后就是一系列二级页表，它们的大小都相同
Dialogue: 0,0:53:03.66,0:53:09.18,English,,0,0,0,,Right and the first level 1 table points to the beginning of the first level 2 table
Dialogue: 0,0:53:03.66,0:53:09.18,Chinese,,0,0,0,,一级页表的第 1 项指向第 1 个二级页表的起始地址
Dialogue: 0,0:53:09.68,0:53:12.86,English,,0,0,0,,So it contains a physical address that points to the base
Dialogue: 0,0:53:09.68,0:53:12.86,Chinese,,0,0,0,,它包含指向起始位置的物理地址
Dialogue: 0,0:53:14.18,0:53:20.32,English,,0,0,0,,The second level 1 table points to the second level 2 table and so on okay
Dialogue: 0,0:53:14.18,0:53:20.32,Chinese,,0,0,0,,一级页表的第 2 项指向第 2 个二级页表，依此类推
Dialogue: 0,0:53:23.82,0:53:28.76,English,,0,0,0,,So if we have this kind of system remember most of the virtual address space is unused
Dialogue: 0,0:53:23.82,0:53:28.76,Chinese,,0,0,0,,因此，如果我们有这种系统，请记住大部分虚拟地址空间未使用
Dialogue: 0,0:53:30.60,0:53:36.28,English,,0,0,0,,Right so if we have this kind of system we can avoid creating many unnecessary page tables
Dialogue: 0,0:53:30.60,0:53:36.28,Chinese,,0,0,0,,如果我们有这种系统，我们可以避免创建许多不必要的页表
Dialogue: 0,0:53:38.24,0:53:40.38,English,,0,0,0,,Okay so imagine if we have a two level hierarchy
Dialogue: 0,0:53:38.24,0:53:40.38,Chinese,,0,0,0,,好的，想象一下，如果我们有一个两级层次结构
Dialogue: 0,0:53:42.30,0:53:46.92,English,,0,0,0,,So let's look at our virtual address space in this example
Dialogue: 0,0:53:42.30,0:53:46.92,Chinese,,0,0,0,,让我们看一下这个例子中的虚拟地址空间
Dialogue: 0,0:53:47.64,0:53:52.48,English,,0,0,0,,And what I've allocated 2k pages for code and data for this program
Dialogue: 0,0:53:47.64,0:53:52.48,Chinese,,0,0,0,,我为这个程序的代码和数据分配了 2048 个页
Dialogue: 0,0:53:53.74,0:53:57.32,English,,0,0,0,,And then there's their 6k unallocated pages
Dialogue: 0,0:53:53.74,0:53:57.32,Chinese,,0,0,0,,然后这里有 6144 个未分配页面
Dialogue: 0,0:53:58.66,0:54:02.64,English,,0,0,0,,And then the stack then there's a page that's allocated for the stack
Dialogue: 0,0:53:58.66,0:54:02.64,Chinese,,0,0,0,,然后有一个分配给堆栈的页面
Dialogue: 0,0:54:05.08,0:54:11.00,English,,0,0,0,,I'm sorry there's a 1024 pages allocated for the stack
Dialogue: 0,0:54:05.08,0:54:11.00,Chinese,,0,0,0,,对不起，这个堆栈分配了 1024 个页面
Dialogue: 0,0:54:11.56,0:54:18.00,English,,0,0,0,,Most of which are...I'm sorry...there's a region of memory that
Dialogue: 0,0:54:11.56,0:54:18.00,Chinese,,0,0,0,,抱歉……有一个内存区域
Dialogue: 0,0:54:18.88,0:54:22.86,English,,0,0,0,,That's the size of 1024 pages
Dialogue: 0,0:54:18.88,0:54:22.86,Chinese,,0,0,0,,大小是 1024 个页
Dialogue: 0,0:54:22.86,0:54:28.90,English,,0,0,0,,But most of them are unallocated and I've only allocated one for the top of the stack
Dialogue: 0,0:54:22.86,0:54:28.90,Chinese,,0,0,0,,但是大多数都是未分配的，我只为堆栈顶部分配了一个页
Dialogue: 0,0:54:30.46,0:54:33.62,English,,0,0,0,,Okay so given this layout for my process
Dialogue: 0,0:54:30.46,0:54:33.62,Chinese,,0,0,0,,好的，已知这个进程的内存布局是这样的
Dialogue: 0,0:54:35.48,0:54:38.50,English,,0,0,0,,I only need three level two page tables
Dialogue: 0,0:54:35.48,0:54:38.50,Chinese,,0,0,0,,我只需要 3 个二级页表
Dialogue: 0,0:54:39.36,0:54:44.92,English,,0,0,0,,Okay the first page table covers this region of my code and data
Dialogue: 0,0:54:39.36,0:54:44.92,Chinese,,0,0,0,,好的，第一页表格涵盖了我的代码和数据的这个区域
Dialogue: 0,0:54:45.86,0:54:47.94,English,,0,0,0,,The first 1024 pages
Dialogue: 0,0:54:45.86,0:54:47.94,Chinese,,0,0,0,,涵盖了前 1024 个页
Dialogue: 0,0:54:48.86,0:54:53.54,English,,0,0,0,,The next page table covers the remaining thousand 24 pages
Dialogue: 0,0:54:48.86,0:54:53.54,Chinese,,0,0,0,,下一个二级页表涵盖剩余的 1024 页
Dialogue: 0,0:54:54.38,0:54:59.66,English,,0,0,0,,Okay so these two level two page tables cover all of the code and data
Dialogue: 0,0:54:54.38,0:54:59.66,Chinese,,0,0,0,,好的，所以这两个二级页表涵盖了所有的代码和数据
Dialogue: 0,0:55:02.06,0:55:05.98,English,,0,0,0,,Okay and similarly the what I need for my stack I just need one page table
Dialogue: 0,0:55:02.06,0:55:05.98,Chinese,,0,0,0,,好吧，类似地我只需要一个二级页表来负责堆栈
Dialogue: 0,0:55:06.76,0:55:11.27,English,,0,0,0,,And it only has one valid PTE it's the very last one
Dialogue: 0,0:55:06.76,0:55:11.27,Chinese,,0,0,0,,它只有一个有效的 PTE，就是最后一个
Dialogue: 0,0:55:12.10,0:55:17.12,English,,0,0,0,,Okay and then I have a single level one table that points to the three level two tables
Dialogue: 0,0:55:12.10,0:55:17.12,Chinese,,0,0,0,,好的，这样一来我有一个一级页表，指向 3 个二级页表
Dialogue: 0,0:55:18.18,0:55:22.80,English,,0,0,0,,Okay so I've...with four page tables I've covered the entire virtual address space
Dialogue: 0,0:55:18.18,0:55:22.80,Chinese,,0,0,0,,所以只用四个页表，我就已经覆盖了整个虚拟地址空间
Dialogue: 0,0:55:24.80,0:55:34.22,English,,0,0,0,,Now the way that the MMU uses these multiple page tables to do address translation is as follows
Dialogue: 0,0:55:24.80,0:55:34.22,Chinese,,0,0,0,,现在，MMU 使用这些多级页表进行地址转换的方式如下
Dialogue: 0,0:55:35.38,0:55:40.42,English,,0,0,0,,Again we have a virtual page offset which consists of the first p bit
Dialogue: 0,0:55:35.38,0:55:40.42,Chinese,,0,0,0,,我们有一个虚拟页面偏移量，它由虚拟地址的低 p 位组成
Dialogue: 0,0:55:41.98,0:55:47.52,English,,0,0,0,,And then the VPN the remaining bits give the VPN
Dialogue: 0,0:55:41.98,0:55:47.52,Chinese,,0,0,0,,然后剩下的位都是 VPN
Dialogue: 0,0:55:48.68,0:55:53.73,English,,0,0,0,,For a k level page table are broken up into k sub vpns
Dialogue: 0,0:55:48.68,0:55:53.73,Chinese,,0,0,0,,对于 k 级页表，VPN 被分解为 k 个子 VPN
Dialogue: 0,0:55:55.40,0:55:57.88,English,,0,0,0,,Okay and each is the same size
Dialogue: 0,0:55:55.40,0:55:57.88,Chinese,,0,0,0,,每个都有相同的大小
Dialogue: 0,0:56:00.28,0:56:06.72,English,,0,0,0,,And so now in this system the upper VPN one which consists of the uppermost bits of the VPN
Dialogue: 0,0:56:00.28,0:56:06.72,Chinese,,0,0,0,,现在在这个系统中，VPN1 由 VPN 的最高位组成
Dialogue: 0,0:56:07.82,0:56:11.02,English,,0,0,0,,Are an offset into the level 1 table
Dialogue: 0,0:56:07.82,0:56:11.02,Chinese,,0,0,0,,是一级页表的偏移量
Dialogue: 0,0:56:11.58,0:56:15.56,English,,0,0,0,,Which is as before is pointed to by the page table base register
Dialogue: 0,0:56:11.58,0:56:15.56,Chinese,,0,0,0,,一级页表的基地址保存在页表基址寄存器中
Dialogue: 0,0:56:16.44,0:56:21.58,English,,0,0,0,,Okay so VPN1 is the index into the level 1 page table
Dialogue: 0,0:56:16.44,0:56:21.58,Chinese,,0,0,0,,好的，所以 VPN1 是一级页表的索引
Dialogue: 0,0:56:22.56,0:56:25.92,English,,0,0,0,,Remember the level 1 page table points to the address of the level 2
Dialogue: 0,0:56:22.56,0:56:25.92,Chinese,,0,0,0,,请记住，一级页表条目指向二级页表的基地址
Dialogue: 0,0:56:26.66,0:56:29.58,English,,0,0,0,,A PTE in the level 1 table
Dialogue: 0,0:56:26.66,0:56:29.58,Chinese,,0,0,0,,一级页表中的 PTE
Dialogue: 0,0:56:30.04,0:56:33.62,English,,0,0,0,,Points to the address of some level 2 page table
Dialogue: 0,0:56:30.04,0:56:33.62,Chinese,,0,0,0,,指向某个二级页表的基地址
Dialogue: 0,0:56:34.04,0:56:37.40,English,,0,0,0,,Or it contains the address of some level 2 page table
Dialogue: 0,0:56:34.04,0:56:37.40,Chinese,,0,0,0,,或者它包含某些二级页表的地址
Dialogue: 0,0:56:39.26,0:56:42.34,English,,0,0,0,,So that points to the base of this level 2 page table
Dialogue: 0,0:56:39.26,0:56:42.34,Chinese,,0,0,0,,所以指向这个二级页表的基地址
Dialogue: 0,0:56:42.34,0:56:49.06,English,,0,0,0,,And then the vpn 2 bits are used as an index into that level 2 table right and so on
Dialogue: 0,0:56:42.34,0:56:49.06,Chinese,,0,0,0,,然后将 VPN2 用作该二级页表的索引，依此类推
Dialogue: 0,0:56:50.64,0:56:58.06,English,,0,0,0,,Ok so eventually you get at the a PTE and the level k-1 table
Dialogue: 0,0:56:50.64,0:56:58.06,Chinese,,0,0,0,,所以最终你得到了一个 PTE 和 (k-1) 级页表
Dialogue: 0,0:56:58.38,0:57:01.08,English,,0,0,0,,Points to the beginning of the level k page table
Dialogue: 0,0:56:58.38,0:57:01.08,Chinese,,0,0,0,,指向第 k 级页表的开头
Dialogue: 0,0:57:01.72,0:57:06.58,English,,0,0,0,,And VPN k points to an offset within that table
Dialogue: 0,0:57:01.72,0:57:06.58,Chinese,,0,0,0,,VPN k 指向该表中的偏移量
Dialogue: 0,0:57:07.32,0:57:12.06,English,,0,0,0,,Which finally contains the physical address of the page that we want to access
Dialogue: 0,0:57:07.32,0:57:12.06,Chinese,,0,0,0,,最后找到的页表条目包含我们要访问的页面的物理地址
Dialogue: 0,0:57:13.06,0:57:19.80,English,,0,0,0,,Okay and then that physical address is used to form the PPN portion of the physical address
Dialogue: 0,0:57:13.06,0:57:19.80,Chinese,,0,0,0,,好的，然后该物理地址用于形成物理地址的 PPN 部分
Dialogue: 0,0:57:20.30,0:57:26.44,English,,0,0,0,,And just like before the virtual page offset is just copied directly unchanged to the physical page offset
Dialogue: 0,0:57:20.30,0:57:26.44,Chinese,,0,0,0,,就像之前一样，虚拟页面偏移直接复制到物理页面偏移
Dialogue: 0,0:57:29.36,0:57:30.46,English,,0,0,0,,So is that clear to everybody
Dialogue: 0,0:57:29.36,0:57:30.46,Chinese,,0,0,0,,大家都听懂了吗
Dialogue: 0,0:57:31.08,0:57:31.78,English,,0,0,0,,Yes question
Dialogue: 0,0:57:31.08,0:57:31.78,Chinese,,0,0,0,,好，请提问
Dialogue: 0,0:57:31.78,0:57:41.66,English,,0,0,0,,[student speaking]
Dialogue: 0,0:57:31.78,0:57:41.66,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:57:41.66,0:57:44.36,English,,0,0,0,,Let's see is it always a power of 2 yes
Dialogue: 0,0:57:41.66,0:57:44.36,Chinese,,0,0,0,,让我们看看它是否总是 2 的幂次？是的
Dialogue: 0,0:57:44.72,0:57:49.02,English,,0,0,0,,At least and it's defined by the architecture,so for intel it's a four level system
Dialogue: 0,0:57:44.72,0:57:49.02,Chinese,,0,0,0,,至少它是由架构定义的，因此对于 Intel 来说它是一个四级系统
Dialogue: 0,0:57:50.06,0:57:55.64,English,,0,0,0,,Now why would it be and then the quick could it will...it always be less than 6
Dialogue: 0,0:57:50.06,0:57:55.64,Chinese,,0,0,0,,现在为什么会这样，然后它会快速……它总是小于 6
Dialogue: 0,0:58:03.94,0:58:06.42,English,,0,0,0,,Oh give us a 64-bit system yeah
Dialogue: 0,0:58:03.94,0:58:06.42,Chinese,,0,0,0,,哦，我们讨论的是一个 64 位的系统
Dialogue: 0,0:58:06.74,0:58:11.58,English,,0,0,0,,Yeah there's only the block size is fixed
Dialogue: 0,0:58:06.74,0:58:11.58,Chinese,,0,0,0,,是的，只有块大小是固定的
Dialogue: 0,0:58:12.40,0:58:16.46,English,,0,0,0,,Right so that there's 12 bits here 2^12 is 4k
Dialogue: 0,0:58:12.40,0:58:16.46,Chinese,,0,0,0,,是的，这里有 12 位，2^12 是 4096
Dialogue: 0,0:58:17.34,0:58:22.08,English,,0,0,0,,So the remaining it's that you actually have 48 bits to play with
Dialogue: 0,0:58:17.34,0:58:22.08,Chinese,,0,0,0,,所以你实际上剩下 48 位可以用
Dialogue: 0,0:58:24.74,0:58:32.66,English,,0,0,0,,So the remaining 48 bits could that's right so if it was 4 if it was 8  it would be 6 so you're right
Dialogue: 0,0:58:24.74,0:58:32.66,Chinese,,0,0,0,,所以剩下的 48 位，如果每个子 VPN 是 8 位，那么它将有 6 级，所以你是对的
Dialogue: 0,0:58:34.06,0:58:38.60,English,,0,0,0,,In this scheme it could be at most 6 turns out in practice it's set at 4
Dialogue: 0,0:58:34.06,0:58:38.60,Chinese,,0,0,0,,在这个方案中，它最多可以是 6 级，实际上人们设定的是四级页表
Dialogue: 0,0:58:40.12,0:58:41.48,English,,0,0,0,,And there was a question over here
Dialogue: 0,0:58:40.12,0:58:41.48,Chinese,,0,0,0,,你有问题吗
Dialogue: 0,0:58:41.50,0:58:50.42,English,,0,0,0,,[student speaking]
Dialogue: 0,0:58:41.50,0:58:50.42,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:58:50.44,0:58:52.34,English,,0,0,0,,Have it like this multi-level system
Dialogue: 0,0:58:50.44,0:58:52.34,Chinese,,0,0,0,,这个多级系统……
Dialogue: 0,0:58:52.88,0:58:54.86,English,,0,0,0,,Oh okay so the question
Dialogue: 0,0:58:52.88,0:58:54.86,Chinese,,0,0,0,,哦好的，所以问题是
Dialogue: 0,0:58:59.08,0:59:00.86,English,,0,0,0,,Is yeah the question is how does it save you space
Dialogue: 0,0:58:59.08,0:59:00.86,Chinese,,0,0,0,,问题是它是如何为你节省空间的
Dialogue: 0,0:59:01.30,0:59:07.70,English,,0,0,0,,So the reason it saves you space is you go back to this other figure maybe I didn't explain this well enough
Dialogue: 0,0:59:01.30,0:59:07.70,Chinese,,0,0,0,,所以它为你节省空间的原因是，让我们回到这一页，也许我没解释清楚
Dialogue: 0,0:59:16.96,0:59:20.18,English,,0,0,0,,So you see this
Dialogue: 0,0:59:16.96,0:59:20.18,Chinese,,0,0,0,,所以看这里
Dialogue: 0,0:59:25.64,0:59:31.04,English,,0,0,0,,If we...okay so let's say we wanted to map this virtual address space with a single page table
Dialogue: 0,0:59:25.64,0:59:31.04,Chinese,,0,0,0,,假设我们想用单级页表来映射这个虚拟地址空间
Dialogue: 0,0:59:32.36,0:59:35.54,English,,0,0,0,,We would need a PTE for every page within that address
Dialogue: 0,0:59:32.36,0:59:35.54,Chinese,,0,0,0,,我们需要为该地址内的每个页面提供 PTE
Dialogue: 0,0:59:36.34,0:59:37.62,English,,0,0,0,,Whether it was used or not
Dialogue: 0,0:59:36.34,0:59:37.62,Chinese,,0,0,0,,不论页面是否使用过
Dialogue: 0,0:59:39.76,0:59:47.56,English,,0,0,0,,Okay it goes back if we had a 48-bit address space
Dialogue: 0,0:59:39.76,0:59:47.56,Chinese,,0,0,0,,好，如果我们有一个 48 位的地址空间
Dialogue: 0,0:59:49.12,0:59:57.08,English,,0,0,0,,We'd need enough,we need a page table entry for each page virtual page in that address space
Dialogue: 0,0:59:49.12,0:59:57.08,Chinese,,0,0,0,,该地址空间中的每个虚拟页面都需要一个页表条目
Dialogue: 0,1:00:00.82,1:00:08.50,English,,0,0,0,,Okay whether that page was used or not,so let me think about it 2^48 is a x several exabytes
Dialogue: 0,1:00:00.82,1:00:08.50,Chinese,,0,0,0,,不管是否使用过这个页面，让我估计一下，2^48 是若干个 EB
Dialogue: 0,1:00:10.44,1:00:14.72,English,,0,0,0,,We need a page table that would have an entry for each virtual page
Dialogue: 0,1:00:10.44,1:00:14.72,Chinese,,0,0,0,,我们需要一个页表，每个虚拟页面都有一个条目
Dialogue: 0,1:00:15.28,1:00:17.20,English,,0,0,0,,In that to the 48 bit address space
Dialogue: 0,1:00:15.28,1:00:17.20,Chinese,,0,0,0,,为 48 位地址空间都创建页表条目
Dialogue: 0,1:00:18.48,1:00:22.36,English,,0,0,0,,And most of those pages by far the vast majority would never ever be used
Dialogue: 0,1:00:18.48,1:00:22.36,Chinese,,0,0,0,,到目前为止，大多数这些页面绝大多数都不会被使用
Dialogue: 0,1:00:23.58,1:00:25.16,English,,0,0,0,,Okay so that's where the waste comes in
Dialogue: 0,1:00:23.58,1:00:25.16,Chinese,,0,0,0,,好的，这就带来了很大的浪费
Dialogue: 0,1:00:26.40,1:00:32.22,English,,0,0,0,,Okay so here with a multi-level page system with this multi-level scheme
Dialogue: 0,1:00:26.40,1:00:32.22,Chinese,,0,0,0,,好的，这里有一个多级页表系统的方案
Dialogue: 0,1:00:32.96,1:00:37.92,English,,0,0,0,,You only need to generate in this case these level two if it's a two-level system
Dialogue: 0,1:00:32.96,1:00:37.92,Chinese,,0,0,0,,如果是两级系统，在这种情况下你只需要生成这 3 个二级页表
Dialogue: 0,1:00:38.36,1:00:40.82,English,,0,0,0,,You only need to generate level two page tables
Dialogue: 0,1:00:38.36,1:00:40.82,Chinese,,0,0,0,,你只需要生成二级页表
Dialogue: 0,1:00:40.90,1:00:45.78,English,,0,0,0,,Enough level two pages to cover the portion of the virtual address space that you're actually using
Dialogue: 0,1:00:40.90,1:00:45.78,Chinese,,0,0,0,,只需要足够的二级页表来覆盖你实际使用的虚拟地址空间部分
Dialogue: 0,1:00:46.34,1:00:50.96,English,,0,0,0,,Okay and that portion of the virtual address space that you're not using at this gap right here
Dialogue: 0,1:00:46.34,1:00:50.96,Chinese,,0,0,0,,好的，没有使用的那部分虚拟地址空间就是这些空白部分
Dialogue: 0,1:00:51.96,1:00:53.92,English,,0,0,0,,There's no need to have a page table
Dialogue: 0,1:00:51.96,1:00:53.92,Chinese,,0,0,0,,没有必要为它们创建页表
Dialogue: 0,1:00:57.65,1:01:04.04,English,,0,0,0,,Is that clear?that that's a really good important question,but you look unconvinced
Dialogue: 0,1:00:57.65,1:01:04.04,Chinese,,0,0,0,,明白了吗？这是一个非常重要的问题，但你看起来并不明白
Dialogue: 0,1:01:04.08,1:01:14.00,English,,0,0,0,,[student speaking]
Dialogue: 0,1:01:04.08,1:01:14.00,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:01:14.02,1:01:17.82,English,,0,0,0,,Well yeah yeah you still need you still need a page table that has
Dialogue: 0,1:01:14.02,1:01:17.82,Chinese,,0,0,0,,好吧是的，你仍然需要一个页表
Dialogue: 0,1:01:22.70,1:01:27.22,English,,0,0,0,,Let's see in this case there's 4KB page, 4 byte PTE
Dialogue: 0,1:01:22.70,1:01:27.22,Chinese,,0,0,0,,在这里有 4 KB 的一级页表，每个 PTE 是 4 字节
Dialogue: 0,1:01:27.24,1:01:31.86,English,,0,0,0,,So there's 1k, you have 1k PTEs
Dialogue: 0,1:01:27.24,1:01:31.86,Chinese,,0,0,0,,所以有 1024 个 PTE
Dialogue: 0,1:01:32.44,1:01:39.62,English,,0,0,0,,So you still need you still need a level 1 page table that has 1k PTEs
Dialogue: 0,1:01:32.44,1:01:39.62,Chinese,,0,0,0,,因此，你仍然需要一个具有 1024 个 PTE 的一级页表
Dialogue: 0,1:01:40.18,1:01:42.16,English,,0,0,0,,But those are only 8 bytes right I mean
Dialogue: 0,1:01:40.18,1:01:42.16,Chinese,,0,0,0,,这里的两个 PTE 只有 8 个字节
Dialogue: 0,1:01:43.92,1:01:46.28,English,,0,0,0,,So you still need to have space
Dialogue: 0,1:01:43.92,1:01:46.28,Chinese,,0,0,0,,但你仍然需要提供空间
Dialogue: 0,1:01:46.38,1:01:51.94,English,,0,0,0,,Because you're not sure which of these address space you're going to need to cover
Dialogue: 0,1:01:46.38,1:01:51.94,Chinese,,0,0,0,,因为你不确定这些地址空间的哪些部分需要覆盖
Dialogue: 0,1:01:53.02,1:01:54.52,English,,0,0,0,,Ok and it's the same thing for
Dialogue: 0,1:01:53.02,1:01:54.52,Chinese,,0,0,0,,好的，这种情况也一样
Dialogue: 0,1:01:55.78,1:02:00.00,English,,0,0,0,,Here in this case, in these first two level 2 page tables
Dialogue: 0,1:01:55.78,1:02:00.00,Chinese,,0,0,0,,在这种情况下，在前两个二级页表中
Dialogue: 0,1:02:02.06,1:02:05.40,English,,0,0,0,,Their portion of the address space was actually all being used
Dialogue: 0,1:02:02.06,1:02:05.40,Chinese,,0,0,0,,它们对应的地址空间的部分都是在使用中的
Dialogue: 0,1:02:06.02,1:02:13.44,English,,0,0,0,,Right so each one of these PTEs at level 2 had to be allocated had to be initialized and used
Dialogue: 0,1:02:06.02,1:02:13.44,Chinese,,0,0,0,,因此这两个二级页表中的每个 PTE 都必须被初始化和使用
Dialogue: 0,1:02:14.22,1:02:18.78,English,,0,0,0,,Right but in this portion of the address space that contain the stack
Dialogue: 0,1:02:14.22,1:02:18.78,Chinese,,0,0,0,,但是在包含堆栈的这一部分地址空间中
Dialogue: 0,1:02:19.80,1:02:25.48,English,,0,0,0,,This third level 2 page table has most of its PTEs or no
Dialogue: 0,1:02:19.80,1:02:25.48,Chinese,,0,0,0,,这里第 3 个二级页表有大部分的 PTE 是不指向任何地址空间的
Dialogue: 0,1:02:28.62,1:02:31.08,English,,0,0,0,,You still have to allocate space for them but they're no
Dialogue: 0,1:02:28.62,1:02:31.08,Chinese,,0,0,0,,你仍然需要为他们分配空间，但他们不指向任何地址
Dialogue: 0,1:02:35.68,1:02:40.24,English,,0,0,0,,Ok that's a really good question it's important that I hope that's clear
Dialogue: 0,1:02:35.68,1:02:40.24,Chinese,,0,0,0,,好的，这是一个非常好的问题，很重要，我希望我讲清楚了
Dialogue: 0,1:02:44.10,1:02:47.74,English,,0,0,0,,Any other questions will we go on
Dialogue: 0,1:02:44.10,1:02:47.74,Chinese,,0,0,0,,还有问题吗？我们继续？
Dialogue: 0,1:02:51.38,1:02:52.76,English,,0,0,0,,Sorry oh okay question
Dialogue: 0,1:02:51.38,1:02:52.76,Chinese,,0,0,0,,哦，好的，请提问
Dialogue: 0,1:02:52.86,1:03:06.46,English,,0,0,0,,[student speaking]
Dialogue: 0,1:02:52.86,1:03:06.46,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:03:06.46,1:03:07.28,English,,0,0,0,,Exactly
Dialogue: 0,1:03:06.46,1:03:07.28,Chinese,,0,0,0,,完全正确
Dialogue: 0,1:03:08.32,1:03:12.16,English,,0,0,0,,Just like here the MMU members doing all of this this is all hardware logic
Dialogue: 0,1:03:08.32,1:03:12.16,Chinese,,0,0,0,,就像这里，这些都是 MMU 所做的，一切都是硬件逻辑
Dialogue: 0,1:03:13.76,1:03:20.16,English,,0,0,0,,So it and the number of page tables levels is defined by the architecture okay
Dialogue: 0,1:03:13.76,1:03:20.16,Chinese,,0,0,0,,所以它和页表级别的数量都是由架构定义的
Dialogue: 0,1:03:21.98,1:03:27.74,English,,0,0,0,,So the MMU takes the virtual address that's presented to it
Dialogue: 0,1:03:21.98,1:03:27.74,Chinese,,0,0,0,,因此，MMU 获取传递给它的虚拟地址
Dialogue: 0,1:03:29.12,1:03:37.02,English,,0,0,0,,And it uses a portion a subset of those bits to access each page table okay
Dialogue: 0,1:03:29.12,1:03:37.02,Chinese,,0,0,0,,并且它使用这些位的一部分来访问每个页表
Dialogue: 0,1:03:38.88,1:03:40.74,English,,0,0,0,,So it's just like...did I answer your question?okay
Dialogue: 0,1:03:38.88,1:03:40.74,Chinese,,0,0,0,,所以就像……我回答你的问题了吗？好的
Dialogue: 0,1:03:42.04,1:03:43.48,English,,0,0,0,,So it's just like before that
Dialogue: 0,1:03:42.04,1:03:43.48,Chinese,,0,0,0,,所以就像之前一样
Dialogue: 0,1:03:44.54,1:03:53.80,English,,0,0,0,,The level k,VPN k is used to compute an index into the level k page table yes
Dialogue: 0,1:03:44.54,1:03:53.80,Chinese,,0,0,0,,VPN k 用于计算第 k 级页表中的索引
Dialogue: 0,1:03:53.80,1:04:04.40,English,,0,0,0,,[student speaking]
Dialogue: 0,1:03:53.80,1:04:04.40,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:04:04.40,1:04:08.28,English,,0,0,0,,Okay the question is why are the indices arranged right to left on which diagram
Dialogue: 0,1:04:04.40,1:04:08.28,Chinese,,0,0,0,,好的，问题是为什么索引从右到左排列？在哪个图表上？
Dialogue: 0,1:04:08.28,1:04:13.16,English,,0,0,0,,[student speaking]
Dialogue: 0,1:04:08.28,1:04:13.16,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:04:13.18,1:04:16.66,English,,0,0,0,,Oh these are the bits,this is the least significant bit it's always bit zero
Dialogue: 0,1:04:13.18,1:04:16.66,Chinese,,0,0,0,,哦，这些是位，这是最不重要的位，它总是为零
Dialogue: 0,1:04:17.84,1:04:20.08,English,,0,0,0,,Yeah that's a good question, so the question was why do these
Dialogue: 0,1:04:17.84,1:04:20.08,Chinese,,0,0,0,,是的，这是一个很好的问题，所以问题是为什么这些
Dialogue: 0,1:04:20.94,1:04:25.52,English,,0,0,0,,In this diagram why are these these bits labeled right to left starting at zero
Dialogue: 0,1:04:20.94,1:04:25.52,Chinese,,0,0,0,,在此图中，为什么这些位从零开始从右到左标记
Dialogue: 0,1:04:26.10,1:04:29.82,English,,0,0,0,,And the answer is that we're indicating the bit position
Dialogue: 0,1:04:26.10,1:04:29.82,Chinese,,0,0,0,,答案是我们是在标明位的位置
Dialogue: 0,1:04:30.42,1:04:35.88,English,,0,0,0,,So zero is the least significant bit and n-1 is the most significant bit
Dialogue: 0,1:04:30.42,1:04:35.88,Chinese,,0,0,0,,因此，0 是最低位，n-1 是最高位
Dialogue: 0,1:04:38.04,1:04:38.64,English,,0,0,0,,Yes question
Dialogue: 0,1:04:38.04,1:04:38.64,Chinese,,0,0,0,,好的，请提问
Dialogue: 0,1:04:38.66,1:04:47.58,English,,0,0,0,,[student speaking]
Dialogue: 0,1:04:38.66,1:04:47.58,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:04:47.58,1:04:51.98,English,,0,0,0,,Yeah so the question is what's the overhead involved in these when you have these multiple levels
Dialogue: 0,1:04:47.58,1:04:51.98,Chinese,,0,0,0,,是的，问题是当你有这些多级页表时，其中有哪些开销
Dialogue: 0,1:04:52.38,1:04:54.94,English,,0,0,0,,Now are you talking about overhead to
Dialogue: 0,1:04:52.38,1:04:54.94,Chinese,,0,0,0,,你指的是什么的开销
Dialogue: 0,1:04:54.96,1:05:03.58,English,,0,0,0,,[student speaking]
Dialogue: 0,1:04:54.96,1:05:03.58,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:05:03.58,1:05:09.06,English,,0,0,0,,Yeah well so there's clearly if you don't get TLB hits
Dialogue: 0,1:05:03.58,1:05:09.06,Chinese,,0,0,0,,是的，如果你查找 TLB 不命中，那就很明显了
Dialogue: 0,1:05:10.52,1:05:11.93,English,,0,0,0,,It would be a lot of overhead
Dialogue: 0,1:05:10.52,1:05:11.93,Chinese,,0,0,0,,这将是一个很大的开销
Dialogue: 0,1:05:12.60,1:05:17.88,English,,0,0,0,,Because it would be you would be fetching PTEs from multiple page tables from memory
Dialogue: 0,1:05:12.60,1:05:17.88,Chinese,,0,0,0,,因为你将从内存中通过多级页表获取 PTE
Dialogue: 0,1:05:19.22,1:05:24.06,English,,0,0,0,,So that but because of locality the chances are almost the...
Dialogue: 0,1:05:19.22,1:05:24.06,Chinese,,0,0,0,,但由于局部性，这种情况出现的概率很小
Dialogue: 0,1:05:24.38,1:05:27.52,English,,0,0,0,,The chances this level one table covers the entire address space
Dialogue: 0,1:05:24.38,1:05:27.52,Chinese,,0,0,0,,这个一级页表覆盖整个地址空间
Dialogue: 0,1:05:28.08,1:05:31.84,English,,0,0,0,,So it's always going to be in the in the PTE, in the TLB
Dialogue: 0,1:05:28.08,1:05:31.84,Chinese,,0,0,0,,所以它总是会出现在 TLB 中
Dialogue: 0,1:05:32.64,1:05:38.88,English,,0,0,0,,These level two tables are covering a huge swath of the address space
Dialogue: 0,1:05:32.64,1:05:38.88,Chinese,,0,0,0,,这些二级页表覆盖了大量的地址空间
Dialogue: 0,1:05:39.66,1:05:43.70,English,,0,0,0,,So chances are they're going to be in the TLB too
Dialogue: 0,1:05:39.66,1:05:43.70,Chinese,,0,0,0,,所以他们很有可能也在 TLB 中
Dialogue: 0,1:05:44.42,1:05:49.24,English,,0,0,0,,So as long as your program has reasonable locality
Dialogue: 0,1:05:44.42,1:05:49.24,Chinese,,0,0,0,,所以只要你的程序有合理的局部性
Dialogue: 0,1:05:49.70,1:05:55.24,English,,0,0,0,,Most of these lookups are going to hit in the TLB
Dialogue: 0,1:05:49.70,1:05:55.24,Chinese,,0,0,0,,这些查找大多都会在 TLB 命中
Dialogue: 0,1:05:56.30,1:06:03.16,English,,0,0,0,,Okay so it turns out that the overhead with reasonably written programs is negligible
Dialogue: 0,1:05:56.30,1:06:03.16,Chinese,,0,0,0,,事实证明，对于合理编写程序，这种开销可以忽略不计
Dialogue: 0,1:06:06.74,1:06:09.72,English,,0,0,0,,But that's a very it's a very important consideration
Dialogue: 0,1:06:06.74,1:06:09.72,Chinese,,0,0,0,,但这是一个非常重要的考虑因素
Dialogue: 0,1:06:10.62,1:06:16.10,English,,0,0,0,,You know maybe that's maybe that speaks against increasing at some point if you had too many page tables
Dialogue: 0,1:06:10.62,1:06:16.10,Chinese,,0,0,0,,如果你有太多层级页表，也许就不适合再增加页表层数了
Dialogue: 0,1:06:16.94,1:06:20.26,English,,0,0,0,,You might increase the probability of misses in the TLB
Dialogue: 0,1:06:16.94,1:06:20.26,Chinese,,0,0,0,,你可能会增加 TLB 未命中的可能性
Dialogue: 0,1:06:20.26,1:06:24.42,English,,0,0,0,,So it's probably something they very carefully considered
Dialogue: 0,1:06:20.26,1:06:24.42,Chinese,,0,0,0,,所以这可能是他们非常仔细考虑的事情
Dialogue: 0,1:06:27.78,1:06:29.78,English,,0,0,0,,Okay any other questions yeah
Dialogue: 0,1:06:27.78,1:06:29.78,Chinese,,0,0,0,,好的，还有其他任何问题吗
Dialogue: 0,1:06:29.90,1:06:35.50,English,,0,0,0,,[student speaking] So if we use segmentation plus paging, is there address in page table
Dialogue: 0,1:06:29.90,1:06:35.50,Chinese,,0,0,0,,[学生说话]如果我们使用分段加分页，页表中有地址吗？
Dialogue: 0,1:06:35.68,1:06:39.94,English,,0,0,0,,[student speaking] The segmented linear address are real physical address
Dialogue: 0,1:06:35.68,1:06:39.94,Chinese,,0,0,0,,[学生说话]分段的线性地址是实际的物理地址
Dialogue: 0,1:06:39.96,1:06:45.24,English,,0,0,0,,Oh boy the question was how does segmentation fit into this and
Dialogue: 0,1:06:39.96,1:06:45.24,Chinese,,0,0,0,,你的问题是分段机制如何与融入分页机制
Dialogue: 0,1:06:46.56,1:06:50.08,English,,0,0,0,,We're not going to go there
Dialogue: 0,1:06:46.56,1:06:50.08,Chinese,,0,0,0,,我们不会讲到那个
Dialogue: 0,1:06:50.48,1:06:53.20,English,,0,0,0,,So in earlier intel systems
Dialogue: 0,1:06:50.48,1:06:53.20,Chinese,,0,0,0,,在早期的英特尔系统
Dialogue: 0,1:06:56.08,1:07:01.60,English,,0,0,0,,Such as the actually the first intel system I programmed was a 286
Dialogue: 0,1:06:56.08,1:07:01.60,Chinese,,0,0,0,,比如实际上我编程的第一个英特尔系统是 286
Dialogue: 0,1:07:03.00,1:07:06.65,English,,0,0,0,,So the 286... no it was the 8086
Dialogue: 0,1:07:03.00,1:07:06.65,Chinese,,0,0,0,,哦不，是 8086
Dialogue: 0,1:07:07.28,1:07:11.00,English,,0,0,0,,Anyway earlier intel systems had 16-bit addresses
Dialogue: 0,1:07:07.28,1:07:11.00,Chinese,,0,0,0,,无论如何，早期的英特尔系统有 16 位地址
Dialogue: 0,1:07:11.82,1:07:13.02,English,,0,0,0,,Which is tiny right
Dialogue: 0,1:07:11.82,1:07:13.02,Chinese,,0,0,0,,非常小
Dialogue: 0,1:07:13.04,1:07:16.38,English,,0,0,0,,It's only 2^16 for your address space
Dialogue: 0,1:07:13.04,1:07:16.38,Chinese,,0,0,0,,你的地址空间只有 2^16
Dialogue: 0,1:07:17.12,1:07:22.41,English,,0,0,0,,And so as a hack to try to increase the effective size of the
Dialogue: 0,1:07:17.12,1:07:22.41,Chinese,,0,0,0,,因此，作为一个系统开发者，为了增加地址空间的大小
Dialogue: 0,1:07:23.10,1:07:26.74,English,,0,0,0,,Of this address space the introduced the notion of segmentation
Dialogue: 0,1:07:23.10,1:07:26.74,Chinese,,0,0,0,,他们引入了分段的概念
Dialogue: 0,1:07:27.90,1:07:31.78,English,,0,0,0,,And so there were 4 bits
Dialogue: 0,1:07:27.90,1:07:31.78,Chinese,,0,0,0,,所以有 4 个位
Dialogue: 0,1:07:32.64,1:07:38.40,English,,0,0,0,,There was segment registers that contain 4 bits that could be applied to the address
Dialogue: 0,1:07:32.64,1:07:38.40,Chinese,,0,0,0,,段寄存器包含可应用于地址分段的 4 个位
Dialogue: 0,1:07:39.36,1:07:45.64,English,,0,0,0,,So an address was the combination of the segment
Dialogue: 0,1:07:39.36,1:07:45.64,Chinese,,0,0,0,,所以一个实际地址是段和地址的组合
Dialogue: 0,1:07:49.16,1:07:51.56,English,,0,0,0,,Yeah you need the segment formed
Dialogue: 0,1:07:49.16,1:07:51.56,Chinese,,0,0,0,,是的，你需要段
Dialogue: 0,1:07:52.46,1:07:56.76,English,,0,0,0,,The address then was a combination of the segment bits plus the address
Dialogue: 0,1:07:52.46,1:07:56.76,Chinese,,0,0,0,,实际地址是段位加地址的组合
Dialogue: 0,1:07:57.48,1:08:00.70,English,,0,0,0,,So you could use the segment bits to create an offset
Dialogue: 0,1:07:57.48,1:08:00.70,Chinese,,0,0,0,,因此，你可以利用段位和偏移量来决定实际地址
Dialogue: 0,1:08:01.12,1:08:05.62,English,,0,0,0,,So it was effectively a 20 bit address space
Dialogue: 0,1:08:01.12,1:08:05.62,Chinese,,0,0,0,,所以它实际上是一个 20 位的地址空间
Dialogue: 0,1:08:06.22,1:08:11.56,English,,0,0,0,,But you can only address, you can only access it in 2^16 chunks right so the
Dialogue: 0,1:08:06.22,1:08:11.56,Chinese,,0,0,0,,但你每次只能在 2^16 字节的块内部访问地址，所以
Dialogue: 0,1:08:12.74,1:08:22.50,English,,0,0,0,,The segment would determine an offset into the 20-bit address space
Dialogue: 0,1:08:12.74,1:08:22.50,Chinese,,0,0,0,,一个段将确定该 20 位地址空间中目标地址相对于段基址的偏移量
Dialogue: 0,1:08:22.50,1:08:25.98,English,,0,0,0,,And then from that you could address 16 bits
Dialogue: 0,1:08:22.50,1:08:25.98,Chinese,,0,0,0,,然后从段基址开始，进行 16 位的寻址
Dialogue: 0,1:08:27.20,1:08:33.16,English,,0,0,0,,So it was this very unsatisfying devilishly hard to program thing because
Dialogue: 0,1:08:27.20,1:08:33.16,Chinese,,0,0,0,,因此，这非常令人不满意，非常难以编程
Dialogue: 0,1:08:33.82,1:08:36.50,English,,0,0,0,,You can only access 16 bit chunks at a time
Dialogue: 0,1:08:33.82,1:08:36.50,Chinese,,0,0,0,,因为你一次只能访问 16 位的块
Dialogue: 0,1:08:37.94,1:08:46.72,English,,0,0,0,,So anyway a few years later they came to their senses and just created a real virtual memory system with linear address spaces
Dialogue: 0,1:08:37.94,1:08:46.72,Chinese,,0,0,0,,几年后他们开始意识到并创建了一个拥有线性地址空间的虚拟内存系统
Dialogue: 0,1:08:50.54,1:08:54.30,English,,0,0,0,,But you know really there
Dialogue: 0,1:08:50.54,1:08:54.30,Chinese,,0,0,0,,但你知道的确……
Dialogue: 0,1:09:02.20,1:09:03.62,English,,0,0,0,,Yeah I don't know we're just did
Dialogue: 0,1:09:02.20,1:09:03.62,Chinese,,0,0,0,,嗯，我不知道我们只是……
Dialogue: 0,1:09:06.66,1:09:11.40,English,,0,0,0,,I'm not even sure if they do address translation on those actually
Dialogue: 0,1:09:06.66,1:09:11.40,Chinese,,0,0,0,,我甚至不确定他们是否真的解决了这些问题
Dialogue: 0,1:09:11.58,1:09:14.08,English,,0,0,0,,So I'm not sure but you really don't want to go there
Dialogue: 0,1:09:11.58,1:09:14.08,Chinese,,0,0,0,,我不确定，但你一定不想讨论这个
Dialogue: 0,1:09:14.88,1:09:17.98,English,,0,0,0,,[student speaking]
Dialogue: 0,1:09:14.88,1:09:17.98,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:09:18.02,1:09:21.71,English,,0,0,0,,Yeah oh it does it does so the question is it doesn't exist anymore
Dialogue: 0,1:09:18.02,1:09:21.71,Chinese,,0,0,0,,是的，它确实如此，问题是它不再存在了
Dialogue: 0,1:09:22.08,1:09:28.88,English,,0,0,0,,Everything intel's been incredibly good about maintaining backward compatibility
Dialogue: 0,1:09:22.08,1:09:28.88,Chinese,,0,0,0,,英特尔在保持向后兼容性方面一直非常出色
Dialogue: 0,1:09:29.74,1:09:31.90,English,,0,0,0,,So that stuff's all in there
Dialogue: 0,1:09:29.74,1:09:31.90,Chinese,,0,0,0,,那些东西都在那里
Dialogue: 0,1:09:33.88,1:09:39.14,English,,0,0,0,,But there's a mode bit when you boot your system up you set a bit that says I want a linear address space
Dialogue: 0,1:09:33.88,1:09:39.14,Chinese,,0,0,0,,但是当你启动系统时有一个模式位，你设置了这个位，说明你想要一个线性地址空间
Dialogue: 0,1:09:43.38,1:09:56.28,English,,0,0,0,,Okay any other question
Dialogue: 0,1:09:43.38,1:09:56.28,Chinese,,0,0,0,,还有其他问题吗
Dialogue: 0,1:09:56.46,1:09:58.52,English,,0,0,0,,Oh no VPN too is the offset
Dialogue: 0,1:09:56.46,1:09:58.52,Chinese,,0,0,0,,哦，VPN 也是偏移量
Dialogue: 0,1:10:01.54,1:10:07.48,English,,0,0,0,,Okay so the question is why do we care about VPN2 since that it points to the level 2 table
Dialogue: 0,1:10:01.54,1:10:07.48,Chinese,,0,0,0,,好吧，问题是为什么我们关心 VPN 2，因为它指向 2 级表
Dialogue: 0,1:10:08.00,1:10:15.68,English,,0,0,0,,So what gives you the beginning of the level 2 table is the PTE entry in the level 1 table
Dialogue: 0,1:10:08.00,1:10:15.68,Chinese,,0,0,0,,那么为你提供二级页表基址的是一级页表中的 PTE 条目
Dialogue: 0,1:10:17.28,1:10:22.06,English,,0,0,0,,Okay so the level 1 table points to the beginning of that level 2 table
Dialogue: 0,1:10:17.28,1:10:22.06,Chinese,,0,0,0,,好的，所以一级页表指向该二级页表的开头
Dialogue: 0,1:10:22.68,1:10:27.58,English,,0,0,0,,And VPN to gives you the offset into that the level 2 table
Dialogue: 0,1:10:22.68,1:10:27.58,Chinese,,0,0,0,,并且 VPN 为你提供了二级页表中目标 PTE 的偏移量
Dialogue: 0,1:10:28.58,1:10:32.34,English,,0,0,0,,So the it finds the address by taking the base address
Dialogue: 0,1:10:28.58,1:10:32.34,Chinese,,0,0,0,,所以它先找到二级页表的基地址
Dialogue: 0,1:10:33.10,1:10:35.64,English,,0,0,0,,And then VPN2 times the PTE size
Dialogue: 0,1:10:33.10,1:10:35.64,Chinese,,0,0,0,,然后再加上用 VPN 2 乘以 PTE 的大小
Dialogue: 0,1:10:39.28,1:10:41.80,English,,0,0,0,,Okay good good any other questions
Dialogue: 0,1:10:39.28,1:10:41.80,Chinese,,0,0,0,,好的，还有其他问题吗
Dialogue: 0,1:10:49.82,1:10:52.96,English,,0,0,0,,Okay well that'll do it for today
Dialogue: 0,1:10:49.82,1:10:52.96,Chinese,,0,0,0,,好，这就是今天的内容
Dialogue: 0,1:10:54.02,1:10:57.16,English,,0,0,0,,Next week on Thursday we'll look at
Dialogue: 0,1:10:54.02,1:10:57.16,Chinese,,0,0,0,,下周四我们会讲
Dialogue: 0,1:10:57.94,1:11:03.78,English,,0,0,0,,How virtual memory is implemented in real systems and in Linux
Dialogue: 0,1:10:57.94,1:11:03.78,Chinese,,0,0,0,,虚拟内存如何在实际的系​​统和 Linux 中实现
