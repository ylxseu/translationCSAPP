[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 11  The Memory Hierarchy.mp4
Video File: ../../../../Desktop/csapp/Lecture 11  The Memory Hierarchy.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 1495
Active Line: 1501
Video Position: 123465

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Noto Sans CJK SC Black,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,1.5,1.2,2,10,10,10,1
Style: Chinese,Noto Sans CJK SC Black,40,&H00FFFF00,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.2,1.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:02.08,English,,0,0,0,,All right good afternoon everybody
Dialogue: 0,0:00:00.00,0:00:02.08,Chinese,,0,0,0,,大家下午好
Dialogue: 0,0:00:03.26,0:00:04.76,English,,0,0,0,,Welcome!good to see you
Dialogue: 0,0:00:03.26,0:00:04.76,Chinese,,0,0,0,,欢迎！很高兴见到你们
Dialogue: 0,0:00:05.88,0:00:07.98,English,,0,0,0,,Hope you all have started your attack labs
Dialogue: 0,0:00:05.88,0:00:07.98,Chinese,,0,0,0,,希望你们已经开始你们的「attack labs」
Dialogue: 0,0:00:09.30,0:00:14.06,English,,0,0,0,,Everybody started? be a good time to start I think
Dialogue: 0,0:00:09.30,0:00:14.06,Chinese,,0,0,0,,每个人都开始了吗？我想现在是个好时候开始了
Dialogue: 0,0:00:15.52,0:00:20.06,English,,0,0,0,,Anyway I hope you're enjoying it, that's a that's a new one this semester that's
Dialogue: 0,0:00:15.52,0:00:20.06,Chinese,,0,0,0,,不管怎样，希望你们喜欢，这个实验在本学期是新设计的
Dialogue: 0,0:00:20.60,0:00:24.24,English,,0,0,0,,I think really interesting and modern and current
Dialogue: 0,0:00:20.60,0:00:24.24,Chinese,,0,0,0,,我认为这个实验非常有趣，也很新鲜很前卫
Dialogue: 0,0:00:26.36,0:00:28.34,English,,0,0,0,,Okay today we're going to...
Dialogue: 0,0:00:26.36,0:00:28.34,Chinese,,0,0,0,,今天我们要讲的是……
Dialogue: 0,0:00:29.64,0:00:32.18,English,,0,0,0,,Today we're going to talk about something called the memory hierarchy
Dialogue: 0,0:00:29.64,0:00:32.18,Chinese,,0,0,0,,今天我们要讲的话题是关于存储器层次结构的
Dialogue: 0,0:00:32.84,0:00:36.92,English,,0,0,0,,Now so far in the class we've thought of memory
Dialogue: 0,0:00:32.84,0:00:36.92,Chinese,,0,0,0,,至今为止，我们在课上讨论的内存
Dialogue: 0,0:00:37.00,0:00:39.48,English,,0,0,0,,When we're looking at our assembly language programs
Dialogue: 0,0:00:37.00,0:00:39.48,Chinese,,0,0,0,,当我们在学习汇编语言程序的时候
Dialogue: 0,0:00:39.48,0:00:42.10,English,,0,0,0,,We've thought of memory as an array of bytes
Dialogue: 0,0:00:39.48,0:00:42.10,Chinese,,0,0,0,,我们仅仅是把内存当作一个字节数组
Dialogue: 0,0:00:42.40,0:00:48.28,English,,0,0,0,,It's the big array of bytes that we can access with that an index called an address
Dialogue: 0,0:00:42.40,0:00:48.28,Chinese,,0,0,0,,可以用地址作为下标来访问的一个大的字节数组
Dialogue: 0,0:00:50.88,0:00:56.36,English,,0,0,0,,But in actuality the memory system is a very complex hierarchy of devices
Dialogue: 0,0:00:50.88,0:00:56.36,Chinese,,0,0,0,,但实际上存储系统是一个非常复杂的设备层次结构
Dialogue: 0,0:00:57.04,0:01:00.68,English,,0,0,0,,That provides this abstraction of this this large linear array
Dialogue: 0,0:00:57.04,0:01:00.68,Chinese,,0,0,0,,提供了一个抽象，把内存结构抽象成一个大的线性数组
Dialogue: 0,0:01:00.98,0:01:04.70,English,,0,0,0,,And so today we're going to look at how memory hierarchies are built
Dialogue: 0,0:01:00.98,0:01:04.70,Chinese,,0,0,0,,所以，我们今天要探寻存储器层次结构是怎么构建的
Dialogue: 0,0:01:05.40,0:01:08.86,English,,0,0,0,,And why they're built the way they are
Dialogue: 0,0:01:05.40,0:01:08.86,Chinese,,0,0,0,,至于为什么要这么做
Dialogue: 0,0:01:09.20,0:01:17.98,English,,0,0,0,,And what we'll see is that this sort of beautiful confluence of the properties of storage devices
Dialogue: 0,0:01:09.20,0:01:17.98,Chinese,,0,0,0,,我们可以体会到多种存储设备之间属性的美妙融合
Dialogue: 0,0:01:18.64,0:01:24.38,English,,0,0,0,,And the properties of programs come together to create this...
Dialogue: 0,0:01:18.64,0:01:24.38,Chinese,,0,0,0,,以及程序的属性在这当中起到的作用
Dialogue: 0,0:01:24.72,0:01:27.26,English,,0,0,0,,This beautiful design called a memory hierarchy
Dialogue: 0,0:01:24.72,0:01:27.26,Chinese,,0,0,0,,这个美妙的设计被称为存储器系统结构
Dialogue: 0,0:01:28.48,0:01:33.98,English,,0,0,0,,So we're going to quickly kind of do a high-level tour of storage technologies and trends
Dialogue: 0,0:01:28.48,0:01:33.98,Chinese,,0,0,0,,所以我们现在以一个较高的视角快速地概览存储技术和趋势
Dialogue: 0,0:01:34.48,0:01:36.22,English,,0,0,0,,We're not going to go into a whole lot of detail
Dialogue: 0,0:01:34.48,0:01:36.22,Chinese,,0,0,0,,我们现在不会陷入一大堆的细节
Dialogue: 0,0:01:37.44,0:01:44.04,English,,0,0,0,,The point in looking at these at these the properties of these technologies is that
Dialogue: 0,0:01:37.44,0:01:44.04,Chinese,,0,0,0,,学习这些技术和属性，关键点是
Dialogue: 0,0:01:44.38,0:01:47.88,English,,0,0,0,,There are some fundamental properties that determine their performance and their speed
Dialogue: 0,0:01:44.38,0:01:47.88,Chinese,,0,0,0,,有一些决定着性能和运行速度的，最基本最核心的属性
Dialogue: 0,0:01:48.25,0:01:51.48,English,,0,0,0,,And determine limits on their performance and speed
Dialogue: 0,0:01:48.25,0:01:51.48,Chinese,,0,0,0,,也决定了性能和速度的限制
Dialogue: 0,0:01:51.92,0:01:58.74,English,,0,0,0,,And so I want you to have a,you know, just some high-level idea of what those what those properties are
Dialogue: 0,0:01:51.92,0:01:58.74,Chinese,,0,0,0,,所以我希望你们首先对这些概念和属性有一个高层次的理解
Dialogue: 0,0:01:59.72,0:02:03.62,English,,0,0,0,,And then we'll look at a property of programs called locality of reference
Dialogue: 0,0:01:59.72,0:02:03.62,Chinese,,0,0,0,,然后我们会学习一个程序所具有的属性，叫做程序的局部性
Dialogue: 0,0:02:04.22,0:02:09.68,English,,0,0,0,,And we'll see how that locality and the properties of storage devices
Dialogue: 0,0:02:04.22,0:02:09.68,Chinese,,0,0,0,,我们将会看到局部性和存储设备的特性
Dialogue: 0,0:02:09.68,0:02:15.06,English,,0,0,0,,Come together to suggest this design of memory systems as a hierarchy
Dialogue: 0,0:02:09.68,0:02:15.06,Chinese,,0,0,0,,合在一起，建议把内存系统设计成一种层次结构
Dialogue: 0,0:02:17.00,0:02:18.46,English,,0,0,0,,Okay so we'll look at memories first
Dialogue: 0,0:02:17.00,0:02:18.46,Chinese,,0,0,0,,好的，下面我们首先来看一下内存的概念
Dialogue: 0,0:02:18.46,0:02:23.06,English,,0,0,0,,Now the the workhorse memory is called a random access memory or RAM
Dialogue: 0,0:02:18.46,0:02:23.06,Chinese,,0,0,0,,现在大多数人所熟悉的内存其实叫做随机访问存储器（RAM）
Dialogue: 0,0:02:23.54,0:02:26.34,English,,0,0,0,,it's traditionally packaged up as a chip
Dialogue: 0,0:02:23.54,0:02:26.34,Chinese,,0,0,0,,它一般都是被打包成芯片
Dialogue: 0,0:02:26.62,0:02:30.66,English,,0,0,0,,And then you put multiple chips together to form your main memory
Dialogue: 0,0:02:26.62,0:02:30.66,Chinese,,0,0,0,,然后你有很多个这样的芯片，组合起来就成为你的主存
Dialogue: 0,0:02:31.14,0:02:35.96,English,,0,0,0,,And there's a basic storage unit called a cell which where each cell stores one bit
Dialogue: 0,0:02:31.14,0:02:35.96,Chinese,,0,0,0,,最基本的存储单位称为单元，一个单元存储一个 bit
Dialogue: 0,0:02:36.94,0:02:41.54,English,,0,0,0,,Okay now there's a RAM comes in two varieties
Dialogue: 0,0:02:36.94,0:02:41.54,Chinese,,0,0,0,,RAM 可以分为两种
Dialogue: 0,0:02:41.54,0:02:46.86,English,,0,0,0,,There's a SRAM and DRAM and they're distinguished by the way that those cells are implemented
Dialogue: 0,0:02:41.54,0:02:46.86,Chinese,,0,0,0,,一种是 SRAM 另一种是 DRAM，它们之间是根据存储单元实现方式来区分的
Dialogue: 0,0:02:48.40,0:02:48.78,English,,0,0,0,,So in
Dialogue: 0,0:02:48.40,0:02:48.78,Chinese,,0,0,0,,所以...
Dialogue: 0,0:02:50.14,0:03:04.08,English,,0,0,0,,and SRAM requires it's more complex than DRAM it requires like 4,6 transistors per bit whereas DRAM only requires a one transistor
Dialogue: 0,0:02:50.14,0:03:04.08,Chinese,,0,0,0,,例如，DRAM 只需要一个晶体管去存储一比特，而 SRAM 更复杂，需要约 4 或 6 个晶体管
Dialogue: 0,0:03:04.78,0:03:11.20,English,,0,0,0,,Okay so you'll see that SRAM are going to be more expensive lots more expensive
Dialogue: 0,0:03:04.78,0:03:11.20,Chinese,,0,0,0,,所以 SRAM 的成本会高得多
Dialogue: 0,0:03:11.48,0:03:15.08,English,,0,0,0,,Because they're more complex each cell is more complex
Dialogue: 0,0:03:11.48,0:03:15.08,Chinese,,0,0,0,,因为 SRAM 的每一个存储单元都比 DRAM 复杂的多
Dialogue: 0,0:03:15.34,0:03:21.28,English,,0,0,0,,But they're also much faster like ten order magnitude faster than DRAMs
Dialogue: 0,0:03:15.34,0:03:21.28,Chinese,,0,0,0,,但 SRAM 的速度也比 DRAM 快一个数量级
Dialogue: 0,0:03:21.90,0:03:24.84,English,,0,0,0,,And they have there's some other properties too like
Dialogue: 0,0:03:21.90,0:03:24.84,Chinese,,0,0,0,,他俩也有一些其他的性质
Dialogue: 0,0:03:25.52,0:03:28.88,English,,0,0,0,,SRAM constantly,a DRAM constantly needs to be refreshed
Dialogue: 0,0:03:25.52,0:03:28.88,Chinese,,0,0,0,,DRAM 是需要被刷新的
Dialogue: 0,0:03:28.88,0:03:34.26,English,,0,0,0,,If you don't hit it with a voltage
Dialogue: 0,0:03:28.88,0:03:34.26,Chinese,,0,0,0,,如果你没有用一定的电​​压去充电
Dialogue: 0,0:03:34.26,0:03:39.12,English,,0,0,0,,It loses the charge whereas DRAM while it needs to be plugged in
Dialogue: 0,0:03:34.26,0:03:39.12,Chinese,,0,0,0,,它就会丢失电荷，丢失所保存的信息，所以 DRAM 是需要插着电用的
Dialogue: 0,0:03:39.74,0:03:42.90,English,,0,0,0,,And and have an electric charge it doesn't need to be refreshed
Dialogue: 0,0:03:39.74,0:03:42.90,Chinese,,0,0,0,,如果有在充电，那就不需要被刷新
Dialogue: 0,0:03:43.44,0:03:47.22,English,,0,0,0,,SRAM is a lot more reliable than DRAM so it
Dialogue: 0,0:03:43.44,0:03:47.22,Chinese,,0,0,0,,SRAM 就比 DRAM 更加地可靠
Dialogue: 0,0:03:47.70,0:03:49.92,English,,0,0,0,,There's less need for error detection and correction
Dialogue: 0,0:03:47.70,0:03:49.92,Chinese,,0,0,0,,所以不太需要进行错误检测和纠正
Dialogue: 0,0:03:50.66,0:03:59.98,English,,0,0,0,,And there and so because of this difference right the SRAMs are costlier smaller and faster than DRAMs
Dialogue: 0,0:03:50.66,0:03:59.98,Chinese,,0,0,0,,因此。SRAM 比 DRAM 更小，速度更快
Dialogue: 0,0:04:01.48,0:04:08.78,English,,0,0,0,,We find SRAMs being used in these small fast memories on chip called cache memories
Dialogue: 0,0:04:01.48,0:04:08.78,Chinese,,0,0,0,,所以，我们将 SRAM 用于那些内存容量小但速度非常快的芯片中，叫做高速缓存
Dialogue: 0,0:04:09.30,0:04:12.70,English,,0,0,0,,And we're going to learn all about those on Thursday
Dialogue: 0,0:04:09.30,0:04:12.70,Chinese,,0,0,0,,我们将在星期四学习这些有关高速缓存的话题
Dialogue: 0,0:04:14.04,0:04:24.06,English,,0,0,0,,And then DRAM is the workhorse used in main memories and the frame buffers associated with graphics cards
Dialogue: 0,0:04:14.04,0:04:24.06,Chinese,,0,0,0,,相比之下，DRAM 被广泛运用于主存，以及图形显卡中的帧缓存中
Dialogue: 0,0:04:25.24,0:04:33.52,English,,0,0,0,,Now DRAM and SRAM are volatile in the sense that if they're powered off they lose all the information right so this is why
Dialogue: 0,0:04:25.24,0:04:33.52,Chinese,,0,0,0,,现在 DRAM 和 SRAM 都是易失的，意味着如果断电，就会丢失它们所保存的信息
Dialogue: 0,0:04:33.68,0:04:37.72,English,,0,0,0,,When you turn your computer off you have to you lose everything in your memory
Dialogue: 0,0:04:33.68,0:04:37.72,Chinese,,0,0,0,,这也是为什么当你关掉电脑后，你会丢掉所有内存中的东西
Dialogue: 0,0:04:37.72,0:04:43.34,English,,0,0,0,,And you have to when you turn it back on you have to sort of reload everything from your disk
Dialogue: 0,0:04:37.72,0:04:43.34,Chinese,,0,0,0,,再把电脑打开后，你需要从硬盘中重新加载所有东西
Dialogue: 0,0:04:44.08,0:04:50.30,English,,0,0,0,,There's a different another kind of memory called a nonvolatile memory which retains its information when it's powered off
Dialogue: 0,0:04:44.08,0:04:50.30,Chinese,,0,0,0,,有另一种存储器，称为非易失性存储器，即使断电的情况下也可以保存其中的内容
Dialogue: 0,0:04:50.90,0:04:57.02,English,,0,0,0,,And there's a whole bunch of these things that so called up read-only memory
Dialogue: 0,0:04:50.90,0:04:57.02,Chinese,,0,0,0,,很多这些东西被称为只读内存
Dialogue: 0,0:04:57.02,0:05:02.08,English,,0,0,0,,So the generic name for these nonvolatile memories is read only memories ROM
Dialogue: 0,0:04:57.02,0:05:02.08,Chinese,,0,0,0,,因此，这些非易失性存储器的通用名称是只读存储器（ROM）
Dialogue: 0,0:05:02.08,0:05:10.98,English,,0,0,0,,And there's a whole bunch of different kinds sort of going back in time the original read only memories were ROMs
Dialogue: 0,0:05:02.08,0:05:10.98,Chinese,,0,0,0,,在以前，很多最初的不同类型的 ROM
Dialogue: 0,0:05:10.98,0:05:14.10,English,,0,0,0,,And they can only be programmed once when the chip was produced
Dialogue: 0,0:05:10.98,0:05:14.10,Chinese,,0,0,0,,它们只可以在其芯片生产期间被硬编码一次
Dialogue: 0,0:05:14.60,0:05:17.82,English,,0,0,0,,And then over time gradually over period of like 20 or 30 years
Dialogue: 0,0:05:14.60,0:05:17.82,Chinese,,0,0,0,,然后可以用 20 或 30 年的时间
Dialogue: 0,0:05:18.26,0:05:23.04,English,,0,0,0,,There were improvements in the way that ROMs could be programmed and in how they were erased
Dialogue: 0,0:05:18.26,0:05:23.04,Chinese,,0,0,0,,现在，ROM 的编程方式和删除方式都有所改进
Dialogue: 0,0:05:23.30,0:05:24.88,English,,0,0,0,,So they could be reprogrammed
Dialogue: 0,0:05:23.30,0:05:24.88,Chinese,,0,0,0,,它们可以被重新编码
Dialogue: 0,0:05:25.78,0:05:31.04,English,,0,0,0,,The what we have today the the modern form of read only memories is called flash memory
Dialogue: 0,0:05:25.78,0:05:31.04,Chinese,,0,0,0,,今天我们拥有的现代形式的只读内存被称为闪存
Dialogue: 0,0:05:32.78,0:05:41.34,English,,0,0,0,,Which provides the capability of erasing you can erase just chunks of the the flash memory called blocks
Dialogue: 0,0:05:32.78,0:05:41.34,Chinese,,0,0,0,,它提供了擦除功能，你可以删除闪存上面的存储块
Dialogue: 0,0:05:43.12,0:05:49.16,English,,0,0,0,,And then the downside is that these things wear out after about a hundred thousand erasers
Dialogue: 0,0:05:43.12,0:05:49.16,Chinese,,0,0,0,,缺点是闪存约在十万次擦除之后就会磨损了
Dialogue: 0,0:05:49.50,0:05:57.44,English,,0,0,0,,Okay so you can erase and reprogram a hundred thousand times and then it's your bricked
Dialogue: 0,0:05:49.50,0:05:57.44,Chinese,,0,0,0,,你可以擦除然后重新编码约十万次后它就会损坏
Dialogue: 0,0:05:58.76,0:06:04.36,English,,0,0,0,,Now that these nonvolatile memories are show up in with
Dialogue: 0,0:05:58.76,0:06:04.36,Chinese,,0,0,0,,非易失性存储器可以在固件和软件中使用
Dialogue: 0,0:06:04.36,0:06:06.76,English,,0,0,0,,So called firmware which is software
Dialogue: 0,0:06:04.36,0:06:06.76,Chinese,,0,0,0,,非易失性存储器可以在固件和软件中使用
Dialogue: 0,0:06:07.48,0:06:09.78,English,,0,0,0,,That's that's programmed into a ROM
Dialogue: 0,0:06:07.48,0:06:09.78,Chinese,,0,0,0,,可以对 ROM 进行硬编码
Dialogue: 0,0:06:10.34,0:06:14.22,English,,0,0,0,,And you see those in the BIOS of computers so when you power on your computer
Dialogue: 0,0:06:10.34,0:06:14.22,Chinese,,0,0,0,,当你开启电脑时会调用的 BIOS
Dialogue: 0,0:06:15.18,0:06:19.14,English,,0,0,0,,The very first instructions that execute are stored in a ROM right
Dialogue: 0,0:06:15.18,0:06:19.14,Chinese,,0,0,0,,以及开机后执行的最初的指令，都存储在 ROM 中
Dialogue: 0,0:06:19.14,0:06:22.80,English,,0,0,0,,If you're wondered like where do those things come from so they're stored in ROM
Dialogue: 0,0:06:19.14,0:06:22.80,Chinese,,0,0,0,,如果你想知道这些东西来自哪里，那么它们就存储在 ROM 中
Dialogue: 0,0:06:23.18,0:06:26.76,English,,0,0,0,,And then there's a boot process where gradually more and more information is
Dialogue: 0,0:06:23.18,0:06:26.76,Chinese,,0,0,0,,然后有一个 boot 引导程序
Dialogue: 0,0:06:27.50,0:06:30.36,English,,0,0,0,,And instructions are loaded into memory
Dialogue: 0,0:06:27.50,0:06:30.36,Chinese,,0,0,0,,越来越多的信息和指令都被装载到内存中
Dialogue: 0,0:06:32.28,0:06:37.52,English,,0,0,0,,You know IO. IO devices have little computers in them call controllers
Dialogue: 0,0:06:32.28,0:06:37.52,Chinese,,0,0,0,,你们知道 I/O 吧？I/O 设备中也有小型的计算机，称为控制器
Dialogue: 0,0:06:38.19,0:06:41.98,English,,0,0,0,,These controllers consist of instructions and data that are that are stored in ROMs
Dialogue: 0,0:06:38.19,0:06:41.98,Chinese,,0,0,0,,控制器由存储在 ROM 中的指令和数据组成
Dialogue: 0,0:06:43.24,0:06:48.62,English,,0,0,0,,And you see them all over the place in these solid state disks
Dialogue: 0,0:06:43.24,0:06:48.62,Chinese,,0,0,0,,你还可以在这些固态硬盘（SSD）中看到它们
Dialogue: 0,0:06:49.66,0:06:55.56,English,,0,0,0,,That to the system look like a rotating disk
Dialogue: 0,0:06:49.66,0:06:55.56,Chinese,,0,0,0,,系统仍然把它们当作旋转的硬盘
Dialogue: 0,0:06:55.98,0:06:58.10,English,,0,0,0,,But they're built of flash memories
Dialogue: 0,0:06:55.98,0:06:58.10,Chinese,,0,0,0,,但它们实际上是由闪存构成的
Dialogue: 0,0:06:59.80,0:07:03.98,English,,0,0,0,,Okay and these are you see these in thumb drives, smart phones, tablets and laptops
Dialogue: 0,0:06:59.80,0:07:03.98,Chinese,,0,0,0,,就是你在 U 盘、智能手机、平板电脑和笔记本电脑中能看到的那些
Dialogue: 0,0:07:03.98,0:07:06.70,English,,0,0,0,,And they're even starting to show up in servers now
Dialogue: 0,0:07:03.98,0:07:06.70,Chinese,,0,0,0,,现在，它们甚至也在服务器中被使用
Dialogue: 0,0:07:14.62,0:07:22.02,English,,0,0,0,,So the memories are connected to the CPU using sort of wires that are collectively called buses
Dialogue: 0,0:07:14.62,0:07:22.02,Chinese,,0,0,0,,主存是通过一些电子线路连接到 CPU 的，这被称为主线（bus）
Dialogue: 0,0:07:22.54,0:07:31.06,English,,0,0,0,,Okay so data flows across the wires back and forth from the,we have the CPU chip
Dialogue: 0,0:07:22.54,0:07:31.06,Chinese,,0,0,0,,数据流就可以从内存和 CPU 芯片之间来回传输
Dialogue: 0,0:07:32.68,0:07:38.52,English,,0,0,0,,And it consists of register file these are the general-purpose registers %rax, %rdi and so on
Dialogue: 0,0:07:32.68,0:07:38.52,Chinese,,0,0,0,,CPU 芯片中有一些寄存器，例如这些是通用寄存器：％rax，％rdi 等等
Dialogue: 0,0:07:39.36,0:07:44.82,English,,0,0,0,,And there's an arithmetic logic unit that reads and writes data from the register files
Dialogue: 0,0:07:39.36,0:07:44.82,Chinese,,0,0,0,,有一个算术逻辑单元会从寄存器文件读写数据
Dialogue: 0,0:07:45.32,0:07:51.44,English,,0,0,0,,And then manipulates that data in some way by doing some kind of arithmetic operation or some logical operation
Dialogue: 0,0:07:45.32,0:07:51.44,Chinese,,0,0,0,,然后对数据进行一定的算术运算和逻辑运算
Dialogue: 0,0:07:52.38,0:07:57.02,English,,0,0,0,,And if instructions need to access memory
Dialogue: 0,0:07:52.38,0:07:57.02,Chinese,,0,0,0,,如果指令需要访存
Dialogue: 0,0:07:57.20,0:08:04.34,English,,0,0,0,,So if there's you're doing a move,a move instruction that reads or writes to memory
Dialogue: 0,0:07:57.20,0:08:04.34,Chinese,,0,0,0,,所以你需要执行一个移动指令 (mov) ，移动指令会读写内存
Dialogue: 0,0:08:06.04,0:08:11.44,English,,0,0,0,,Then that's handled by a bus interface which is connected to a what we'll call a system bus
Dialogue: 0,0:08:06.04,0:08:11.44,Chinese,,0,0,0,,然后由总线接口处理，该接口连接与另一个接口相连接，我们称之为系统总线
Dialogue: 0,0:08:13.32,0:08:16.74,English,,0,0,0,,And then that's connected to an I/O bridge and this
Dialogue: 0,0:08:13.32,0:08:16.74,Chinese,,0,0,0,,然后它连接到 I/O 桥
Dialogue: 0,0:08:17.28,0:08:24.00,English,,0,0,0,,This is another collection of chips,Intel calls this what I'm calling the I/O bridge,they call the chipset
Dialogue: 0,0:08:17.28,0:08:24.00,Chinese,,0,0,0,,这是另一个芯片集合，我所称的 I/O 桥，英特尔称之为芯片组
Dialogue: 0,0:08:24.66,0:08:28.92,English,,0,0,0,,Okay but it's it's a collection of chips separate from the process the CPU chip
Dialogue: 0,0:08:24.66,0:08:28.92,Chinese,,0,0,0,,是与 CPU 芯片区分开来一个芯片集合
Dialogue: 0,0:08:29.80,0:08:34.84,English,,0,0,0,,And then the I/O bridge is connected to another bus called the memory bus which connects the main memory
Dialogue: 0,0:08:29.80,0:08:34.84,Chinese,,0,0,0,,然后 I/O 桥连接到另一条主线，叫做存储器主线，连接 I/O 桥与主存
Dialogue: 0,0:08:36.42,0:08:41.68,English,,0,0,0,,Okay now this is kind of an abstraction I don't want you to take this too literally
Dialogue: 0,0:08:36.42,0:08:41.68,Chinese,,0,0,0,,好的，这只是一种抽象，我不希望你们太在字面意义上较真
Dialogue: 0,0:08:41.68,0:08:45.44,English,,0,0,0,,But it gives you the idea of how information flows in the system
Dialogue: 0,0:08:41.68,0:08:45.44,Chinese,,0,0,0,,但它让你了解信息如何在系统中流动
Dialogue: 0,0:08:46.10,0:08:53.22,English,,0,0,0,,Okay modern modern systems use proprietary bus designs and they're very arcane and increasingly complex
Dialogue: 0,0:08:46.10,0:08:53.22,Chinese,,0,0,0,,现代系统使用的专有总线设计，它们非常神秘且越来越复杂
Dialogue: 0,0:08:53.72,0:09:00.46,English,,0,0,0,,So we're just going to use a fairly simple abstraction for these bus architectures
Dialogue: 0,0:08:53.72,0:09:00.46,Chinese,,0,0,0,,所以我们才在这里使用一个非常简易的总线系统抽象
Dialogue: 0,0:09:02.22,0:09:07.06,English,,0,0,0,,Now when is,now suppose you do a load operation like movq
Dialogue: 0,0:09:02.22,0:09:07.06,Chinese,,0,0,0,,现在，假设你执行了一个装载操作，像是执行 movq 指令
Dialogue: 0,0:09:07.26,0:09:11.88,English,,0,0,0,,The eight bytes at address a into %rax
Dialogue: 0,0:09:07.26,0:09:11.88,Chinese,,0,0,0,,将 A 地址处的 8 个字节加载到寄存器 %rax
Dialogue: 0,0:09:12.26,0:09:17.16,English,,0,0,0,,Okay so we call that a load because we're loading from the point of view of the CPU
Dialogue: 0,0:09:12.26,0:09:17.16,Chinese,,0,0,0,,之所以我们称之为加载（load），是从 CPU 的角度出发来考虑的
Dialogue: 0,0:09:17.46,0:09:19.90,English,,0,0,0,,We're loading data into the CPU
Dialogue: 0,0:09:17.46,0:09:19.90,Chinese,,0,0,0,,我们是加载数据到 CPU 中
Dialogue: 0,0:09:20.62,0:09:24.40,English,,0,0,0,,But we're loading and we're loading data from memory into the CPU
Dialogue: 0,0:09:20.62,0:09:24.40,Chinese,,0,0,0,,但实际上我们是从主存中加载数据到 CPU 的
Dialogue: 0,0:09:25.74,0:09:30.04,English,,0,0,0,,So when the CPU executes movq instruction like this
Dialogue: 0,0:09:25.74,0:09:30.04,Chinese,,0,0,0,,所以当 CPU 执行 movq 指令时，是像这样进行的
Dialogue: 0,0:09:30.76,0:09:33.98,English,,0,0,0,,It first places the address of A on the memory bus
Dialogue: 0,0:09:30.76,0:09:33.98,Chinese,,0,0,0,,首先，CPU 将 A 的地址放到存储器主线上
Dialogue: 0,0:09:38.22,0:09:44.82,English,,0,0,0,,And then the main memory senses that address and it reads the contents the eight bytes at address A
Dialogue: 0,0:09:38.22,0:09:44.82,Chinese,,0,0,0,,然后主存储器感知到这个信号后，读取这个地址 A 处 8 字节的内容
Dialogue: 0,0:09:45.72,0:09:50.76,English,,0,0,0,,So it retrieves the word 8 byte word from address a and places it back on the bus
Dialogue: 0,0:09:45.72,0:09:50.76,Chinese,,0,0,0,,也就是它会从该地址取得一个 8 字节的字的内容然后将其放回总线上
Dialogue: 0,0:09:52.70,0:09:58.10,English,,0,0,0,,The those bits travel through the I/O bridge to the bus interface
Dialogue: 0,0:09:52.70,0:09:58.10,Chinese,,0,0,0,,这些比特会在 I/O 桥上传递回总线接口
Dialogue: 0,0:09:59.84,0:10:07.20,English,,0,0,0,,And then the CPU reads the the word x from the data word x from the bus and in composition to register %rax
Dialogue: 0,0:09:59.84,0:10:07.20,Chinese,,0,0,0,,然后 CPU 从总线数据中读取这个字 x，然后放到寄存器 %rax 中
Dialogue: 0,0:10:07.46,0:10:11.72,English,,0,0,0,,Okay so it's now writing is is similar again
Dialogue: 0,0:10:07.46,0:10:11.72,Chinese,,0,0,0,,然后写入是一个相似的过程
Dialogue: 0,0:10:12.28,0:10:20.08,English,,0,0,0,,So here we're doing a move instruction movq from %rax into address A main memory
Dialogue: 0,0:10:12.28,0:10:20.08,Chinese,,0,0,0,,这里我们执行一个指令 movq，将寄存器 %rax 的内容写入主存中地址为 A 的位置
Dialogue: 0,0:10:21.16,0:10:25.66,English,,0,0,0,,Okay so the the CPU starts as before by placing the address a on the bus
Dialogue: 0,0:10:21.16,0:10:25.66,Chinese,,0,0,0,,像以前一样，起初，CPU 也将地址写到总线上
Dialogue: 0,0:10:27.46,0:10:31.65,English,,0,0,0,,Main memory reads that address and then it waits for the data to arrive on the bus
Dialogue: 0,0:10:27.46,0:10:31.65,Chinese,,0,0,0,,主存读取这个地址，然后等待数据到达总线
Dialogue: 0,0:10:31.65,0:10:35.50,English,,0,0,0,,So the CPU then places the contents of %rax on the bus
Dialogue: 0,0:10:31.65,0:10:35.50,Chinese,,0,0,0,,然后 CPU 将寄存器 %rax 的内容放到总线上
Dialogue: 0,0:10:36.42,0:10:39.54,English,,0,0,0,,Those contents travel across to main memory
Dialogue: 0,0:10:36.42,0:10:39.54,Chinese,,0,0,0,,这些数据传输到主存
Dialogue: 0,0:10:39.96,0:10:45.08,English,,0,0,0,,Which then reads the reads that word from the bus and stores it at address A
Dialogue: 0,0:10:39.96,0:10:45.08,Chinese,,0,0,0,,主存读取这些数据，将其存放到地址 A 处
Dialogue: 0,0:10:45.58,0:10:51.06,English,,0,0,0,,Ok so that the point of all this is that operations that occur
Dialogue: 0,0:10:45.58,0:10:51.06,Chinese,,0,0,0,,好，其中的关键点在于其中的操作
Dialogue: 0,0:10:52.48,0:10:54.24,English,,0,0,0,,You know reads and writes of registers
Dialogue: 0,0:10:52.48,0:10:54.24,Chinese,,0,0,0,,也就是寄存器的读写
Dialogue: 0,0:10:55.66,0:11:01.90,English,,0,0,0,,Because the register file is very close to the ALU, these happen in on the order of a few cycles
Dialogue: 0,0:10:55.66,0:11:01.90,Chinese,,0,0,0,,因为寄存器文件是很接近算术逻辑单元的，这一切都发生在大约几个 CPU 周期内
Dialogue: 0,0:11:02.70,0:11:06.38,English,,0,0,0,,Ok register,the register very close to the ALU
Dialogue: 0,0:11:02.70,0:11:06.38,Chinese,,0,0,0,,寄存器文件很接近算术逻辑单元
Dialogue: 0,0:11:06.74,0:11:10.28,English,,0,0,0,,So those operations are very happened very quickly
Dialogue: 0,0:11:06.74,0:11:10.28,Chinese,,0,0,0,,所以这些操作的速度都很快
Dialogue: 0,0:11:11.32,0:11:19.40,English,,0,0,0,,Whereas memories actually this is a set of chips that are very far away relatively speaking from the CPU
Dialogue: 0,0:11:11.32,0:11:19.40,Chinese,,0,0,0,,然而，内存实际上是非常远离 CPU 的一些芯片组
Dialogue: 0,0:11:20.90,0:11:24.68,English,,0,0,0,,And there's a lot going on in when if you have to read or write memory there's
Dialogue: 0,0:11:20.90,0:11:24.68,Chinese,,0,0,0,,当你需要读写内存时，那么会发生很多事情
Dialogue: 0,0:11:25.10,0:11:32.22,English,,0,0,0,,It you have to do multiple operations on the bus,data has to travel propagate across that bus all this stuff takes time
Dialogue: 0,0:11:25.10,0:11:32.22,Chinese,,0,0,0,,你必须在总线上做多个操作，数据必须通过该总线传播，所有这些操作都需要时间
Dialogue: 0,0:11:32.82,0:11:36.28,English,,0,0,0,,So memory operations reads and writes are typically
Dialogue: 0,0:11:32.82,0:11:36.28,Chinese,,0,0,0,,所以，对于内存的读写，典型地都需要大约 50 或 100 纳秒
Dialogue: 0,0:11:36.64,0:11:45.78,English,,0,0,0,,You know maybe 50 nanoseconds 100 nanoseconds whereas operations that occur between registers are sub nanosecond
Dialogue: 0,0:11:36.64,0:11:45.78,Chinese,,0,0,0,,而寄存器之间的一些操作所需时间甚至不到 1 纳秒
Dialogue: 0,0:11:47.84,0:11:52.78,English,,0,0,0,,On the order of so you're talking about a one to two orders of magnitude difference
Dialogue: 0,0:11:47.84,0:11:52.78,Chinese,,0,0,0,,所以它们之间大约差了两个数量级
Dialogue: 0,0:11:53.86,0:11:56.94,English,,0,0,0,,If you have to go off chip to to retrieve something from memory
Dialogue: 0,0:11:53.86,0:11:56.94,Chinese,,0,0,0,,如果你需要离开 CPU 芯片，到主存那儿去取一些东西
Dialogue: 0,0:11:56.94,0:12:03.24,English,,0,0,0,,Ok so that's the first sort of big takeaway item about memory systems
Dialogue: 0,0:11:56.94,0:12:03.24,Chinese,,0,0,0,,好，这就是内存系统引入的第一个损耗
Dialogue: 0,0:12:04.46,0:12:08.16,English,,0,0,0,,Now another popular storage technology is rotating disks
Dialogue: 0,0:12:04.46,0:12:08.16,Chinese,,0,0,0,,现在还有另一项广泛应用的存储技术就是硬盘
Dialogue: 0,0:12:09.14,0:12:14.08,English,,0,0,0,,And I don't know if you've ever torn one apart they're kind of interesting there's a series of platters
Dialogue: 0,0:12:09.14,0:12:14.08,Chinese,,0,0,0,,不知道你们有没有拆过硬盘，蛮有趣的，硬盘其实是一系列的盘片
Dialogue: 0,0:12:15.08,0:12:18.18,English,,0,0,0,,Each platter is coated with a magnetic material
Dialogue: 0,0:12:15.08,0:12:18.18,Chinese,,0,0,0,,每个盘片都涂有磁性材料
Dialogue: 0,0:12:19.14,0:12:25.30,English,,0,0,0,,And then and then bits ones and zeros are encoded in that magnetic material
Dialogue: 0,0:12:19.14,0:12:25.30,Chinese,,0,0,0,,然后在该磁性材料中编码 1 和 0 的二进制位
Dialogue: 0,0:12:26.04,0:12:31.79,English,,0,0,0,,And then there's this arm that can it's it's hinged right here
Dialogue: 0,0:12:26.04,0:12:31.79,Chinese,,0,0,0,,有一个部件叫做传动臂，铰接在这里
Dialogue: 0,0:12:32.38,0:12:38.50,English,,0,0,0,,And then it can it floats over the platter so it floats on a thin layer of air over the platter
Dialogue: 0,0:12:32.38,0:12:38.50,Chinese,,0,0,0,,然后它可以漂浮在盘片上，它漂浮在盘片上方的薄薄一层空气中
Dialogue: 0,0:12:38.50,0:12:45.26,English,,0,0,0,,And there's a read/write head at the very end that can sense the changes in the magnetic field that encode the bits
Dialogue: 0,0:12:38.50,0:12:45.26,Chinese,,0,0,0,,在最末端有一个读/写头，可以感知编码位的磁场变化
Dialogue: 0,0:12:45.74,0:12:52.62,English,,0,0,0,,Okay so these platters are spinning around like counterclockwise like this, this arm can go back and forth
Dialogue: 0,0:12:45.74,0:12:52.62,Chinese,,0,0,0,,这些盘片像逆时针一样旋转，这样磁臂可以前后移动
Dialogue: 0,0:12:53.32,0:12:56.82,English,,0,0,0,,So there's a lot of mechanical gear so this is all mechanical
Dialogue: 0,0:12:53.32,0:12:56.82,Chinese,,0,0,0,,所以有很多齿轮等机械装置，这些都是机械设备
Dialogue: 0,0:12:57.46,0:13:00.34,English,,0,0,0,,So the mechanical nature of a rotating disc
Dialogue: 0,0:12:57.46,0:13:00.34,Chinese,,0,0,0,,所以旋转磁盘的机械性质
Dialogue: 0,0:13:00.82,0:13:05.42,English,,0,0,0,,Means it's going to be slower right then DRAMs and SRAMs
Dialogue: 0,0:13:00.82,0:13:05.42,Chinese,,0,0,0,,意味着它会比 DRAM 和 SRAM 慢
Dialogue: 0,0:13:06.30,0:13:10.66,English,,0,0,0,,And there's also electronics like it's like a little computer in firmware
Dialogue: 0,0:13:06.30,0:13:10.66,Chinese,,0,0,0,,而且它还有电子设备，就像固件中的一台小电脑一样
Dialogue: 0,0:13:11.08,0:13:18.80,English,,0,0,0,,That that actually controls the operation of this drive that controls how this arm goes back and forth
Dialogue: 0,0:13:11.08,0:13:18.80,Chinese,,0,0,0,,控制了驱动器的操作，该驱动器控制磁臂如何来回移动
Dialogue: 0,0:13:20.06,0:13:24.82,English,,0,0,0,,And and and controls how the data is read off of the the read/write head
Dialogue: 0,0:13:20.06,0:13:24.82,Chinese,,0,0,0,,并且控制如何从读/写头读取数据
Dialogue: 0,0:13:25.76,0:13:32.02,English,,0,0,0,,So just in a little more detail we can think of these disks consists of platters
Dialogue: 0,0:13:25.76,0:13:32.02,Chinese,,0,0,0,,我们来讨论一些细节，我们可以认为磁盘是由盘片组成的
Dialogue: 0,0:13:32.02,0:13:34.82,English,,0,0,0,,Each platter has two surfaces the top and a bottom
Dialogue: 0,0:13:32.02,0:13:34.82,Chinese,,0,0,0,,一个盘片有两个表面，上面和下面
Dialogue: 0,0:13:35.98,0:13:41.70,English,,0,0,0,,And then each surface consists of these trace, these are concentric rings  called tracks
Dialogue: 0,0:13:35.98,0:13:41.70,Chinese,,0,0,0,,每一个表面都包含一系列的同心圆，称之为磁道
Dialogue: 0,0:13:43.28,0:13:49.94,English,,0,0,0,,And then each track consists of us it consists of sectors which contain the data
Dialogue: 0,0:13:43.28,0:13:49.94,Chinese,,0,0,0,,每一个磁道包含很多个扇区，扇区存储着数据
Dialogue: 0,0:13:50.70,0:13:58.98,English,,0,0,0,,So typically 512,512 bits, oh I'm sorry bytes
Dialogue: 0,0:13:50.70,0:13:58.98,Chinese,,0,0,0,,典型地，一个扇区存储 512 个 bit...... 不好意思，是 512 个字节
Dialogue: 0,0:14:01.06,0:14:04.26,English,,0,0,0,,And in the set of these tracks are separated by gaps
Dialogue: 0,0:14:01.06,0:14:04.26,Chinese,,0,0,0,,在这些「磁道」之间有一些空隙（注：这里口误，应为扇区之间）
Dialogue: 0,0:14:04.96,0:14:09.00,English,,0,0,0,,That these gaps like right here that don't contain data
Dialogue: 0,0:14:04.96,0:14:09.00,Chinese,,0,0,0,,这些空隙是不保存数据的
Dialogue: 0,0:14:12.72,0:14:17.40,English,,0,0,0,,Now platters are aligned on top of each other on the spindle
Dialogue: 0,0:14:12.72,0:14:17.40,Chinese,,0,0,0,,盘片在主轴上是彼此对齐的
Dialogue: 0,0:14:18.08,0:14:21.64,English,,0,0,0,,And so tracks that are aligned on the different surfaces
Dialogue: 0,0:14:18.08,0:14:21.64,Chinese,,0,0,0,,因此，在不同表面上，轨道也是对齐的
Dialogue: 0,0:14:22.20,0:14:26.38,English,,0,0,0,,Such as this track here on those the collection of those
Dialogue: 0,0:14:22.20,0:14:26.38,Chinese,,0,0,0,,比如这条轨道，这些轨道的集合
Dialogue: 0,0:14:26.88,0:14:31.30,English,,0,0,0,,Tracks form what we call a cylinder okay because it has a cylindrical shape
Dialogue: 0,0:14:26.88,0:14:31.30,Chinese,,0,0,0,,这些轨道的集合，我们称之为一个柱面，因为它形成一个圆柱形
Dialogue: 0,0:14:33.08,0:14:37.86,English,,0,0,0,,Now the capacity of disks is that the number of bits that can be stored
Dialogue: 0,0:14:33.08,0:14:37.86,Chinese,,0,0,0,,磁盘的容量就是它可以存储的位数
Dialogue: 0,0:14:39.94,0:14:46.23,English,,0,0,0,,And vendors kind of they all dis vendors use they quote the capacity in gigabytes
Dialogue: 0,0:14:39.94,0:14:46.23,Chinese,,0,0,0,,所有供应商都以千兆字节（GB）为单位来表达磁盘容量
Dialogue: 0,0:14:46.23,0:14:57.00,English,,0,0,0,,But where a gigabyte is 10^9 bytes right instead of 2^20,okay like like you would expect
Dialogue: 0,0:14:46.23,0:14:57.00,Chinese,,0,0,0,,这里的 1GB 是 10^9 字节而不是你所想的 2^20 字节
Dialogue: 0,0:14:57.92,0:15:00.84,English,,0,0,0,,So what...I'm not sure why they do this
Dialogue: 0,0:14:57.92,0:15:00.84,Chinese,,0,0,0,,我也不确定他们为什么这样做......
Dialogue: 0,0:15:01.32,0:15:08.28,English,,0,0,0,,But it allows by by quoting their capacity and gigabytes in 10^9 bytes
Dialogue: 0,0:15:01.32,0:15:08.28,Chinese,,0,0,0,,不过，允许以 10^9 字节作为容量的单位
Dialogue: 0,0:15:08.93,0:15:11.24,English,,0,0,0,,It's a bigger number right
Dialogue: 0,0:15:08.93,0:15:11.24,Chinese,,0,0,0,,这是一个更大的数字对吧
Dialogue: 0,0:15:11.60,0:15:15.40,English,,0,0,0,,So it looks better it looks like there's more information
Dialogue: 0,0:15:11.60,0:15:15.40,Chinese,,0,0,0,,所以看起来好像可以存储更多的信息
Dialogue: 0,0:15:15.40,0:15:20.36,English,,0,0,0,,It's a little I don't really know why they do it but I think that's why it is
Dialogue: 0,0:15:15.40,0:15:20.36,Chinese,,0,0,0,,我不知道他们为什么这样做，但我认为可能原因就是那样的
Dialogue: 0,0:15:21.08,0:15:27.13,English,,0,0,0,,And it's one of those little bit annoying things that we just have to just  know about and get used to
Dialogue: 0,0:15:21.08,0:15:27.13,Chinese,,0,0,0,,有点烦人，所以我们需要了解，然后习惯这个设定
Dialogue: 0,0:15:27.98,0:15:34.80,English,,0,0,0,,Now the capacity is determined by 2 independent technology factors
Dialogue: 0,0:15:27.98,0:15:34.80,Chinese,,0,0,0,,磁盘的容量是由两个独立的因素所决定的
Dialogue: 0,0:15:35.38,0:15:43.46,English,,0,0,0,,One is the recording density so that's how many bits can you pack into a single sector
Dialogue: 0,0:15:35.38,0:15:43.46,Chinese,,0,0,0,,第一是记录密度，决定单独一个扇区可以存储多少比特
Dialogue: 0,0:15:44.64,0:15:50.74,English,,0,0,0,,Or ... or at least a portion of a track
Dialogue: 0,0:15:44.64,0:15:50.74,Chinese,,0,0,0,,或者至少是一个磁道的一部分
Dialogue: 0,0:15:51.56,0:15:56.78,English,,0,0,0,,And then the track density which is sort of how close can you put those tracks together
Dialogue: 0,0:15:51.56,0:15:56.78,Chinese,,0,0,0,,然后是磁道密度，指可以将相邻的磁道放置得多临近
Dialogue: 0,0:15:57.64,0:16:02.90,English,,0,0,0,,And then the product of those two is what's called the areal density and that determines the overall capacity of the disc
Dialogue: 0,0:15:57.64,0:16:02.90,Chinese,,0,0,0,,这两者的乘积，称为面密度，决定了整个磁盘的存储容量
Dialogue: 0,0:16:03.02,0:16:10.18,English,,0,0,0,,So the higher the areal capacity the more bits you can squeeze on to that onto that surface
Dialogue: 0,0:16:03.02,0:16:10.18,Chinese,,0,0,0,,面密度越高，你就在一个磁面上可以存储越多的比特
Dialogue: 0,0:16:10.90,0:16:17.26,English,,0,0,0,,Now in the old days when aerial densities were fairly low
Dialogue: 0,0:16:10.90,0:16:17.26,Chinese,,0,0,0,,在以前，磁盘的面密度相当低
Dialogue: 0,0:16:18.16,0:16:22.22,English,,0,0,0,,Each each track on the surface would have the same number of sectors
Dialogue: 0,0:16:18.16,0:16:22.22,Chinese,,0,0,0,,磁面上每一个磁道所包含的扇区数量是相等的
Dialogue: 0,0:16:23.64,0:16:25.96,English,,0,0,0,,Okay so there was a constant number of sectors per track
Dialogue: 0,0:16:23.64,0:16:25.96,Chinese,,0,0,0,,每一个磁道所包含的扇区数是一个常数
Dialogue: 0,0:16:26.88,0:16:31.60,English,,0,0,0,,So now what happens as you as your tracks go from the
Dialogue: 0,0:16:26.88,0:16:31.60,Chinese,,0,0,0,,现在会有一种情况
Dialogue: 0,0:16:32.16,0:16:36.54,English,,0,0,0,,You know near the whole by the spindle as they go as they move outward
Dialogue: 0,0:16:32.16,0:16:36.54,Chinese,,0,0,0,,磁道有比较靠近中心也有较为边缘的
Dialogue: 0,0:16:37.56,0:16:43.88,English,,0,0,0,,Right if you have the same number of sectors with the same bit density
Dialogue: 0,0:16:37.56,0:16:43.88,Chinese,,0,0,0,,如果磁道是由相同比特密度的扇区组成
Dialogue: 0,0:16:45.08,0:16:49.64,English,,0,0,0,,That the gaps between sectors are going to get bigger and bigger as you go out
Dialogue: 0,0:16:45.08,0:16:49.64,Chinese,,0,0,0,,那么越往外，扇区间的间隙会越变越大
Dialogue: 0,0:16:49.84,0:16:52.86,English,,0,0,0,,And you're going to be wasting more and more of your space
Dialogue: 0,0:16:49.84,0:16:52.86,Chinese,,0,0,0,,你将会浪费越来越多的磁面上的空间
Dialogue: 0,0:16:53.32,0:16:57.50,English,,0,0,0,,So at when aerial densities were fairly low this was okay
Dialogue: 0,0:16:53.32,0:16:57.50,Chinese,,0,0,0,,不过如果面密度比较低的时候这还是可以接受的
Dialogue: 0,0:16:57.98,0:17:01.44,English,,0,0,0,,But after a while it just became not okay to waste that much room
Dialogue: 0,0:16:57.98,0:17:01.44,Chinese,,0,0,0,,但随着技术发展，浪费空间就不太能被接受了
Dialogue: 0,0:17:01.92,0:17:05.76,English,,0,0,0,,So what modern systems do is they partition the tracks into these
Dialogue: 0,0:17:01.92,0:17:05.76,Chinese,,0,0,0,,现代的系统为此所做的改进是
Dialogue: 0,0:17:06.16,0:17:08.06,English,,0,0,0,,So called rook recording zones
Dialogue: 0,0:17:06.16,0:17:08.06,Chinese,,0,0,0,,将磁道划分为所谓的记录区
Dialogue: 0,0:17:08.54,0:17:12.82,English,,0,0,0,,Where each recording zone such as this right here
Dialogue: 0,0:17:08.54,0:17:12.82,Chinese,,0,0,0,,这里的每一个记录区，如图所示
Dialogue: 0,0:17:13.18,0:17:17.64,English,,0,0,0,,Each recording zone has a constant number of sectors
Dialogue: 0,0:17:13.18,0:17:17.64,Chinese,,0,0,0,,每一个记录区包含相同数量的扇区
Dialogue: 0,0:17:18.24,0:17:22.04,English,,0,0,0,,So each track in a recording zone has the same number of sectors
Dialogue: 0,0:17:18.24,0:17:22.04,Chinese,,0,0,0,,所以一个记录区里的每一条磁道都有相同数量的扇区
Dialogue: 0,0:17:22.86,0:17:27.92,English,,0,0,0,,And of course as you move outward if you move outward in the recording zone
Dialogue: 0,0:17:22.86,0:17:27.92,Chinese,,0,0,0,,当然，对于越靠外的记录区
Dialogue: 0,0:17:28.68,0:17:30.60,English,,0,0,0,,You're going to have bigger and bigger gaps
Dialogue: 0,0:17:28.68,0:17:30.60,Chinese,,0,0,0,,将扇区之间的空隙会越来越大
Dialogue: 0,0:17:30.72,0:17:33.72,English,,0,0,0,,But then you start a new recording zone
Dialogue: 0,0:17:30.72,0:17:33.72,Chinese,,0,0,0,,但是在这里看这个新的记录区
Dialogue: 0,0:17:34.12,0:17:39.52,English,,0,0,0,,That will have more sectors per track and then within that
Dialogue: 0,0:17:34.12,0:17:39.52,Chinese,,0,0,0,,它的每一条磁道里会有更多的扇区
Dialogue: 0,0:17:40.32,0:17:46.08,English,,0,0,0,,So you can see in this outer in this outer zone you have more you have more sectors
Dialogue: 0,0:17:40.32,0:17:46.08,Chinese,,0,0,0,,你可以发现，在靠外的磁道，会比靠内的磁道有着更多的扇区
Dialogue: 0,0:17:46.56,0:17:48.18,English,,0,0,0,,Than you do on this inner zone
Dialogue: 0,0:17:46.56,0:17:48.18,Chinese,,0,0,0,,你可以发现，在靠外的磁道，会比靠内的磁道有着更多的扇区
Dialogue: 0,0:17:49.18,0:17:56.66,English,,0,0,0,,Okay so that's a way to kind of deal with that sort of that growth in the gaps to keep it from getting too large
Dialogue: 0,0:17:49.18,0:17:56.66,Chinese,,0,0,0,,这就是处理扇区之间的间隙变得过大的方法
Dialogue: 0,0:17:57.42,0:18:03.90,English,,0,0,0,,And so because we don't really have the number of sectors per track isn't constant
Dialogue: 0,0:17:57.42,0:18:03.90,Chinese,,0,0,0,,因为采用了此技术，每一条磁道所包含的扇区数不再是一个常数
Dialogue: 0,0:18:03.90,0:18:07.22,English,,0,0,0,,We'll use an average, the average sectors per track across
Dialogue: 0,0:18:03.90,0:18:07.22,Chinese,,0,0,0,,于是我们使用平均值，也就是每条磁道平均包含的扇区数
Dialogue: 0,0:18:07.78,0:18:11.58,English,,0,0,0,,all recording zones when we do serve our capacity estimates
Dialogue: 0,0:18:07.78,0:18:11.58,Chinese,,0,0,0,,用所有记录区的平均每条磁道扇区数来估计整个磁盘的容量
Dialogue: 0,0:18:13.38,0:18:18.32,English,,0,0,0,,Okay so you can imagine the formula for computing the disk capacity is fairly straightforward
Dialogue: 0,0:18:13.38,0:18:18.32,Chinese,,0,0,0,,好的，你可以想象计算磁盘容量的公式是相当简单的
Dialogue: 0,0:18:18.70,0:18:21.28,English,,0,0,0,,It's the number of bytes per sector
Dialogue: 0,0:18:18.70,0:18:21.28,Chinese,,0,0,0,,它是每个扇区的字节数
Dialogue: 0,0:18:22.50,0:18:24.90,English,,0,0,0,,Times the average number of sectors per track
Dialogue: 0,0:18:22.50,0:18:24.90,Chinese,,0,0,0,,乘以每个磁道上的平均扇区数
Dialogue: 0,0:18:26.10,0:18:30.08,English,,0,0,0,,Times the average number of tracks per surface times the number of surfaces per platter
Dialogue: 0,0:18:26.10,0:18:30.08,Chinese,,0,0,0,,再乘以每个盘面的平均磁道数，再乘以一个盘片的盘面数
Dialogue: 0,0:18:30.66,0:18:32.80,English,,0,0,0,,Times the number of platters per disk okay
Dialogue: 0,0:18:30.66,0:18:32.80,Chinese,,0,0,0,,最后在乘以磁盘中盘片的数量
Dialogue: 0,0:18:35.78,0:18:37.58,English,,0,0,0,,Now let's look at how just work
Dialogue: 0,0:18:35.78,0:18:37.58,Chinese,,0,0,0,,现在让我们来看看它是如何工作的
Dialogue: 0,0:18:39.04,0:18:42.78,English,,0,0,0,,So these these surfaces are spinning at a fixed rotational rate
Dialogue: 0,0:18:39.04,0:18:42.78,Chinese,,0,0,0,,这些表面都以一个固定的频率在旋转
Dialogue: 0,0:18:42.78,0:18:49.92,English,,0,0,0,,Now a typical rate may be 7200 rpm s is a fairly common rotational rate
Dialogue: 0,0:18:42.78,0:18:49.92,Chinese,,0,0,0,,现在典型的速率可能是 7200 转/分钟，这是相当常见的转速
Dialogue: 0,0:18:51.06,0:18:59.25,English,,0,0,0,,So the disc is spinning around you can see this pretty proud of that
Dialogue: 0,0:18:51.06,0:18:59.25,Chinese,,0,0,0,,如你所见磁盘是这样旋转的，我还（对这个PPT）挺自豪的
Dialogue: 0,0:19:00.08,0:19:04.04,English,,0,0,0,,So it's spinning around counter clockwise and then the arm
Dialogue: 0,0:19:00.08,0:19:04.04,Chinese,,0,0,0,,像这样逆时针旋转，然后，磁臂
Dialogue: 0,0:19:05.52,0:19:10.60,English,,0,0,0,,Moves radially here we go
Dialogue: 0,0:19:05.52,0:19:10.60,Chinese,,0,0,0,,磁臂沿着半径轴前后移动
Dialogue: 0,0:19:10.68,0:19:14.22,English,,0,0,0,,The arm moves radially and it can go over any of the tracks
Dialogue: 0,0:19:10.68,0:19:14.22,Chinese,,0,0,0,,磁臂沿着半径轴前后移动，可以定位到任何一个磁道上
Dialogue: 0,0:19:16.72,0:19:17.84,English,,0,0,0,,Okay all right that's enough
Dialogue: 0,0:19:16.72,0:19:17.84,Chinese,,0,0,0,,好的这部分讲到这里
Dialogue: 0,0:19:20.58,0:19:24.20,English,,0,0,0,,Okay now when you have multiple platters
Dialogue: 0,0:19:20.58,0:19:24.20,Chinese,,0,0,0,,好，现在考虑多个盘片的情况
Dialogue: 0,0:19:24.90,0:19:32.14,English,,0,0,0,,Each one of these there's actually multiple arms and there's a read/write head on each surface
Dialogue: 0,0:19:24.90,0:19:32.14,Chinese,,0,0,0,,每一个盘片都有磁臂，实际上都有多个臂，每个表面上都有一个读/写头
Dialogue: 0,0:19:32.14,0:19:38.70,English,,0,0,0,,So if the platters has two - if - if each side of the platter
Dialogue: 0,0:19:32.14,0:19:38.70,Chinese,,0,0,0,,所以一个盘片有两个（磁头），上面下面各一个
Dialogue: 0,0:19:39.24,0:19:42.84,English,,0,0,0,,Is coated with this magnetic material then
Dialogue: 0,0:19:39.24,0:19:42.84,Chinese,,0,0,0,,涂上这种磁性材料
Dialogue: 0,0:19:42.84,0:19:45.86,English,,0,0,0,,You'll have you have a read/write head on each side
Dialogue: 0,0:19:42.84,0:19:45.86,Chinese,,0,0,0,,会在每一侧都有一个读/写头
Dialogue: 0,0:19:46.32,0:19:48.70,English,,0,0,0,,And then these are all connected they kind of move together
Dialogue: 0,0:19:46.32,0:19:48.70,Chinese,,0,0,0,,然后这些都是连接在一起的，一起移动
Dialogue: 0,0:19:49.12,0:19:53.84,English,,0,0,0,,Now originally these these read/write heads would be they were rigid
Dialogue: 0,0:19:49.12,0:19:53.84,Chinese,,0,0,0,,现在，原始的这种读/写头将是很死板的
Dialogue: 0,0:19:54.76,0:19:57.34,English,,0,0,0,,Right because the densities tracked densities weren't that high
Dialogue: 0,0:19:54.76,0:19:57.34,Chinese,,0,0,0,,因为那时候的磁道密度没有那么高
Dialogue: 0,0:19:58.04,0:20:03.18,English,,0,0,0,,So they could they could just sort of likes and even though the tracks didn't align perfectly
Dialogue: 0,0:19:58.04,0:20:03.18,Chinese,,0,0,0,,所以即使磁道没有很好地对齐
Dialogue: 0,0:20:03.48,0:20:07.80,English,,0,0,0,,They could just sort of they could they could still cover
Dialogue: 0,0:20:03.48,0:20:07.80,Chinese,,0,0,0,,它们还是可以全部覆盖
Dialogue: 0,0:20:07.90,0:20:14.40,English,,0,0,0,,The read/write heads could still cover the tracks with these fixed arms
Dialogue: 0,0:20:07.90,0:20:14.40,Chinese,,0,0,0,,读/写磁头仍然可以用这种固定的磁臂覆盖所有磁道
Dialogue: 0,0:20:14.40,0:20:17.84,English,,0,0,0,,But nowadays that the densities are so high
Dialogue: 0,0:20:14.40,0:20:17.84,Chinese,,0,0,0,,但现如今，磁道密度如此之高
Dialogue: 0,0:20:18.06,0:20:22.54,English,,0,0,0,,That they actually the controller can actually move the read/write heads a little bit
Dialogue: 0,0:20:18.06,0:20:22.54,Chinese,,0,0,0,,实际上控制器实际上可以移动读/写头一点点
Dialogue: 0,0:20:22.66,0:20:27.24,English,,0,0,0,,So that it matches up with that all of the tracks on all of the surfaces
Dialogue: 0,0:20:22.66,0:20:27.24,Chinese,,0,0,0,,这样它就匹配了所有表面上的所有轨道
Dialogue: 0,0:20:30.52,0:20:34.24,English,,0,0,0,,Okay so let's look at how this works how we read data
Dialogue: 0,0:20:30.52,0:20:34.24,Chinese,,0,0,0,,好的，一起来看一下我们读取数据的方式
Dialogue: 0,0:20:36.18,0:20:37.34,English,,0,0,0,,So we have our
Dialogue: 0,0:20:36.18,0:20:37.34,Chinese,,0,0,0,,首先，我们有
Dialogue: 0,0:20:38.98,0:20:42.96,English,,0,0,0,,This is our this is our arm and the tip of the arrow is the read/write head
Dialogue: 0,0:20:38.98,0:20:42.96,Chinese,,0,0,0,,这是我们的这是我们的磁臂，箭头的尖端是读/写头
Dialogue: 0,0:20:43.38,0:20:48.44,English,,0,0,0,,And it's positioned and the platter is rotating counterclockwise
Dialogue: 0,0:20:43.38,0:20:48.44,Chinese,,0,0,0,,并且它被定位并且盘片逆时针旋转
Dialogue: 0,0:20:49.30,0:20:52.48,English,,0,0,0,,And its position just ready to read the blue sector
Dialogue: 0,0:20:49.30,0:20:52.48,Chinese,,0,0,0,,读写头当前的位置正好可以读这个蓝色的扇区
Dialogue: 0,0:20:53.50,0:20:57.18,English,,0,0,0,,So it as the blue sector spins underneath the read/write head
Dialogue: 0,0:20:53.50,0:20:57.18,Chinese,,0,0,0,,当蓝色扇区在读/写头下旋转
Dialogue: 0,0:20:57.60,0:21:03.52,English,,0,0,0,,It senses those bits and sends them up to the controller which passes them back up to the  the CPU
Dialogue: 0,0:20:57.60,0:21:03.52,Chinese,,0,0,0,,它会检测这些比特，并将它们发送到控制器，控制器将它们传递回CPU
Dialogue: 0,0:21:04.26,0:21:07.42,English,,0,0,0,,And now the CPU is requested that the disk
Dialogue: 0,0:21:04.26,0:21:07.42,Chinese,,0,0,0,,现在，CPU请求磁盘
Dialogue: 0,0:21:07.80,0:21:10.58,English,,0,0,0,,It's requested the red data from the red sector
Dialogue: 0,0:21:07.80,0:21:10.58,Chinese,,0,0,0,,它要求磁盘读写红色扇区的数据
Dialogue: 0,0:21:11.82,0:21:15.14,English,,0,0,0,,So we have to take the controller takes that read/write head
Dialogue: 0,0:21:11.82,0:21:15.14,Chinese,,0,0,0,,所以，控制器需要操控读/写头
Dialogue: 0,0:21:15.84,0:21:18.74,English,,0,0,0,,Moves it back to reds track
Dialogue: 0,0:21:15.84,0:21:18.74,Chinese,,0,0,0,,先将其移回红色扇区所在的磁道
Dialogue: 0,0:21:19.86,0:21:22.40,English,,0,0,0,,And then waits for it to spin around and
Dialogue: 0,0:21:19.86,0:21:22.40,Chinese,,0,0,0,,然后等待磁盘旋转
Dialogue: 0,0:21:24.82,0:21:26.70,English,,0,0,0,,And to the to the read/write head
Dialogue: 0,0:21:24.82,0:21:26.70,Chinese,,0,0,0,,等到该扇区旋转到读写头的下方
Dialogue: 0,0:21:29.26,0:21:33.26,English,,0,0,0,,And then it reads that that red that red sector
Dialogue: 0,0:21:29.26,0:21:33.26,Chinese,,0,0,0,,然后读取红色扇区中的数据
Dialogue: 0,0:21:34.70,0:21:38.82,English,,0,0,0,,Okay so when we first so there's really three components going on here that determine
Dialogue: 0,0:21:34.70,0:21:38.82,Chinese,,0,0,0,,所以这里一共有三个因素
Dialogue: 0,0:21:38.82,0:21:41.12,English,,0,0,0,,How long it takes to read one of these sectors
Dialogue: 0,0:21:38.82,0:21:41.12,Chinese,,0,0,0,,决定着阅读其中一个扇区需要多长时间
Dialogue: 0,0:21:43.06,0:21:46.80,English,,0,0,0,,The when we move the head that's called a seek
Dialogue: 0,0:21:43.06,0:21:46.80,Chinese,,0,0,0,,移动磁头的时间称为寻道时间
Dialogue: 0,0:21:47.62,0:21:51.98,English,,0,0,0,,When we waited for the red track to sort of rotate around
Dialogue: 0,0:21:47.62,0:21:51.98,Chinese,,0,0,0,,我们等待磁盘旋转，等红色扇区旋转到读写头下方
Dialogue: 0,0:21:51.98,0:21:55.36,English,,0,0,0,,That's called the rotational latency so how often long it takes
Dialogue: 0,0:21:51.98,0:21:55.36,Chinese,,0,0,0,,这部分称为旋转延迟，它通常有多长时间呢
Dialogue: 0,0:21:56.18,0:22:01.12,English,,0,0,0,,On average it will be half of the half of the time
Dialogue: 0,0:21:56.18,0:22:01.12,Chinese,,0,0,0,,平均情况下就是磁盘旋转一整圈所花费的时间的一半
Dialogue: 0,0:22:01.88,0:22:05.28,English,,0,0,0,,It takes for the entire to circle all the way around
Dialogue: 0,0:22:01.88,0:22:05.28,Chinese,,0,0,0,,平均情况下就是磁盘旋转一整圈所花费的时间的一半
Dialogue: 0,0:22:06.08,0:22:08.44,English,,0,0,0,,And then there's the data transfer which is
Dialogue: 0,0:22:06.08,0:22:08.44,Chinese,,0,0,0,,最后一个因素是传送时间，是指
Dialogue: 0,0:22:08.96,0:22:10.46,English,,0,0,0,,Sort of how long it takes for that
Dialogue: 0,0:22:08.96,0:22:10.46,Chinese,,0,0,0,,是指该轨道在读/写头下通过的时间
Dialogue: 0,0:22:11.10,0:22:13.38,English,,0,0,0,,For that track to pass under the read/write head
Dialogue: 0,0:22:11.10,0:22:13.38,Chinese,,0,0,0,,是指该轨道在读/写头下通过的时间
Dialogue: 0,0:22:15.90,0:22:18.46,English,,0,0,0,,Now the reason the reason it's important to know this is that
Dialogue: 0,0:22:15.90,0:22:18.46,Chinese,,0,0,0,,知道这些的重要原因是
Dialogue: 0,0:22:19.20,0:22:23.48,English,,0,0,0,,These three components you add them together and that's the that's what your average
Dialogue: 0,0:22:19.20,0:22:23.48,Chinese,,0,0,0,,这三个因素，将它们加在一起，这就是你的平均值
Dialogue: 0,0:22:23.62,0:22:25.70,English,,0,0,0,,X time it takes to access data
Dialogue: 0,0:22:23.62,0:22:25.70,Chinese,,0,0,0,,磁盘访问数据的平均时间
Dialogue: 0,0:22:27.04,0:22:30.22,English,,0,0,0,,That time is dominated by the seek time
Dialogue: 0,0:22:27.04,0:22:30.22,Chinese,,0,0,0,,磁盘访问数据的时间主要是寻道时间
Dialogue: 0,0:22:30.54,0:22:34.42,English,,0,0,0,,So seek times are measured in milliseconds right so we're moving this head there's
Dialogue: 0,0:22:30.54,0:22:34.42,Chinese,,0,0,0,,所以寻找时间是以毫秒为单位测量的。寻道就是把磁头移到那里
Dialogue: 0,0:22:35.14,0:22:40.34,English,,0,0,0,,This there's a servo that has to fire up and there's actual mechanical motion
Dialogue: 0,0:22:35.14,0:22:40.34,Chinese,,0,0,0,,这是一个伺服系统，是实际的机械运动
Dialogue: 0,0:22:40.36,0:22:42.82,English,,0,0,0,,And that that takes time
Dialogue: 0,0:22:40.36,0:22:42.82,Chinese,,0,0,0,,这就要花时间
Dialogue: 0,0:22:43.34,0:22:50.64,English,,0,0,0,,And it's on the order of three to nine milliseconds and this has been true for decades
Dialogue: 0,0:22:43.34,0:22:50.64,Chinese,,0,0,0,,它大约在 3 到 9 毫秒之间，这已经存在了几十年
Dialogue: 0,0:22:50.86,0:22:53.84,English,,0,0,0,,Right so this this value is not changing right
Dialogue: 0,0:22:50.86,0:22:53.84,Chinese,,0,0,0,,这个值是改不了的
Dialogue: 0,0:22:53.84,0:22:56.66,English,,0,0,0,,There's just sort of fundamental mechanical limits
Dialogue: 0,0:22:53.84,0:22:56.66,Chinese,,0,0,0,,这是一种基本的机械限制
Dialogue: 0,0:22:57.36,0:23:03.64,English,,0,0,0,,That make it very difficult to to decrease this this value
Dialogue: 0,0:22:57.36,0:23:03.64,Chinese,,0,0,0,,这使得降低这个值非常困难
Dialogue: 0,0:23:04.40,0:23:05.82,English,,0,0,0,,Now the rotational latency
Dialogue: 0,0:23:04.40,0:23:05.82,Chinese,,0,0,0,,下面谈谈旋转延迟
Dialogue: 0,0:23:08.82,0:23:16.38,English,,0,0,0,,The time that it takes to spin around will we'll call that the t average rotation
Dialogue: 0,0:23:08.82,0:23:16.38,Chinese,,0,0,0,,旋转所需的时间我们称之为 Tavg rotation（平均旋转时间）
Dialogue: 0,0:23:16.38,0:23:20.16,English,,0,0,0,,And then the time it takes to read the the bits will call t average transfer
Dialogue: 0,0:23:16.38,0:23:20.16,Chinese,,0,0,0,,然后，磁头读取这些比特所需的时间称为 Tavg transfer（平均传输时间）
Dialogue: 0,0:23:20.16,0:23:27.42,English,,0,0,0,,Okay so we have t average seek which is this seek time, rotational latency and transfer time
Dialogue: 0,0:23:20.16,0:23:27.42,Chinese,,0,0,0,,好的，所以我们的搜索时间包含三个部分，即寻道时间、旋转延迟和传输时间
Dialogue: 0,0:23:30.10,0:23:34.50,English,,0,0,0,,And now if we just take some typical numbers   and plug those in
Dialogue: 0,0:23:30.10,0:23:34.50,Chinese,,0,0,0,,现在，我们取一些真正的数字来做一些运算
Dialogue: 0,0:23:35.60,0:23:39.32,English,,0,0,0,,You see that our seek time is on the order of milliseconds
Dialogue: 0,0:23:35.60,0:23:39.32,Chinese,,0,0,0,,你看，我们的寻道时间是毫秒级
Dialogue: 0,0:23:39.96,0:23:42.78,English,,0,0,0,,The rotational rate is also on the order of milliseconds right
Dialogue: 0,0:23:39.96,0:23:42.78,Chinese,,0,0,0,,旋转延迟也是毫秒级
Dialogue: 0,0:23:42.78,0:23:47.26,English,,0,0,0,,So there's there's also mechanical limits and how fast you can you can spin these around
Dialogue: 0,0:23:42.78,0:23:47.26,Chinese,,0,0,0,,有机械限制，限制了你可以用多快的速度旋转它们
Dialogue: 0,0:23:48.12,0:23:53.84,English,,0,0,0,,The access time and the transfer time  is very small
Dialogue: 0,0:23:48.12,0:23:53.84,Chinese,,0,0,0,,传输时间是非常短的
Dialogue: 0,0:23:53.92,0:24:00.62,English,,0,0,0,,So it's orders of magnitude smaller because you just have to read a few that the bits that are in one sector
Dialogue: 0,0:23:53.92,0:24:00.62,Chinese,,0,0,0,,所以它的数量级要小一些，因为你只需要读扇区中的一些位
Dialogue: 0,0:24:02.30,0:24:10.14,English,,0,0,0,,Okay so if you look you can see that the total access time is dominated by seek  and rotational latency
Dialogue: 0,0:24:02.30,0:24:10.14,Chinese,,0,0,0,,好的，你可以看到总访问时间主要是寻道时间和旋转延迟
Dialogue: 0,0:24:10.78,0:24:15.56,English,,0,0,0,,So you know a good rule of thumb just for sort of estimating how long it takes to read from a disk
Dialogue: 0,0:24:10.78,0:24:15.56,Chinese,,0,0,0,,所以这儿有一个好的经验法则，用于估计从磁盘读取数据所需的时间
Dialogue: 0,0:24:15.56,0:24:19.40,English,,0,0,0,,It is just take twice the seek the seek time and you'll be pretty close
Dialogue: 0,0:24:15.56,0:24:19.40,Chinese,,0,0,0,,就是两倍的寻道时间，就很精准了
Dialogue: 0,0:24:20.20,0:24:24.60,English,,0,0,0,,And basically the transfer time is you get that for free
Dialogue: 0,0:24:20.20,0:24:24.60,Chinese,,0,0,0,,基本上传输时间可以忽略不计的
Dialogue: 0,0:24:26.66,0:24:29.26,English,,0,0,0,,Now here's the here's the important thing to know about disks
Dialogue: 0,0:24:26.66,0:24:29.26,Chinese,,0,0,0,,现在，这里要讲一些有关于磁盘的重要信息
Dialogue: 0,0:24:30.70,0:24:36.20,English,,0,0,0,,We SRAM access times about four nanoseconds to get a double word
Dialogue: 0,0:24:30.70,0:24:36.20,Chinese,,0,0,0,,访问 SRAM 取得一个 double 类型的双字，时间大约为 4 纳秒
Dialogue: 0,0:24:36.62,0:24:40.24,English,,0,0,0,,Dram is about 60 nanoseconds
Dialogue: 0,0:24:36.62,0:24:40.24,Chinese,,0,0,0,,在 DRAM 上大约是 60 纳秒
Dialogue: 0,0:24:40.24,0:24:45.42,English,,0,0,0,,So DRAM is about an order of magnitude slower than SRAM
Dialogue: 0,0:24:40.24,0:24:45.42,Chinese,,0,0,0,,所以 DRAM 比 SRAM 慢一个数量级
Dialogue: 0,0:24:47.18,0:24:50.70,English,,0,0,0,,But disk is 40,000 times slower than SRAM
Dialogue: 0,0:24:47.18,0:24:50.70,Chinese,,0,0,0,,但是磁盘比 SRAM 慢 40,000 倍
Dialogue: 0,0:24:51.32,0:24:54.06,English,,0,0,0,,So that's 4,000 orders of magnitude difference
Dialogue: 0,0:24:51.32,0:24:54.06,Chinese,,0,0,0,,这就是 4,000 倍的差异
Dialogue: 0,0:24:54.94,0:25:01.42,English,,0,0,0,,That's huge and it's it's 250 times orders of magnitude slower than DRAMs
Dialogue: 0,0:24:54.94,0:25:01.42,Chinese,,0,0,0,,这个时间差是非常巨大的，它比 DRAM 慢 250 倍
Dialogue: 0,0:25:02.82,0:25:07.30,English,,0,0,0,,So the there's a big gap between DRAM and SRAM
Dialogue: 0,0:25:02.82,0:25:07.30,Chinese,,0,0,0,,所以 DRAM 和 SRAM 之间存在很大差距
Dialogue: 0,0:25:07.30,0:25:15.16,English,,0,0,0,,And there's an even bigger gap between disk and other memory types
Dialogue: 0,0:25:07.30,0:25:15.16,Chinese,,0,0,0,,磁盘和其他内存类型之间存在更大的差距
Dialogue: 0,0:25:17.12,0:25:20.08,English,,0,0,0,,Now modern disks present a much simpler view
Dialogue: 0,0:25:17.12,0:25:20.08,Chinese,,0,0,0,,现在，现代磁盘呈现出更简单的视图
Dialogue: 0,0:25:20.48,0:25:29.08,English,,0,0,0,,Than so we then this track cylinder sector geometry
Dialogue: 0,0:25:20.48,0:25:29.08,Chinese,,0,0,0,,我们这里学到的磁道、柱面、扇区等几何描述
Dialogue: 0,0:25:29.72,0:25:32.67,English,,0,0,0,,So modern modern disk controllers actually present
Dialogue: 0,0:25:29.72,0:25:32.67,Chinese,,0,0,0,,实际上现代磁盘控制器
Dialogue: 0,0:25:33.22,0:25:36.80,English,,0,0,0,,To the CPU they present the disk as a sequence of logical blocks
Dialogue: 0,0:25:33.22,0:25:36.80,Chinese,,0,0,0,,是将磁盘作为一系列逻辑块提供给 CPU
Dialogue: 0,0:25:37.82,0:25:40.70,English,,0,0,0,,Where each block is is a multiple of a sector size
Dialogue: 0,0:25:37.82,0:25:40.70,Chinese,,0,0,0,,每个块是扇区大小的整数倍
Dialogue: 0,0:25:40.70,0:25:45.18,English,,0,0,0,,So this in simplest case a block is just a logical block is one sector
Dialogue: 0,0:25:40.70,0:25:45.18,Chinese,,0,0,0,,所以在最简单的情况下，块只是一个逻辑块就是一个扇区
Dialogue: 0,0:25:45.64,0:25:47.64,English,,0,0,0,,And then blocks are numbered starting at zero
Dialogue: 0,0:25:45.64,0:25:47.64,Chinese,,0,0,0,,块从零开始编号
Dialogue: 0,0:25:47.64,0:25:50.76,English,,0,0,0,,And they just go all the way up to some to some large number
Dialogue: 0,0:25:47.64,0:25:50.76,Chinese,,0,0,0,,块号是一系列增长的数字
Dialogue: 0,0:25:53.58,0:25:58.72,English,,0,0,0,,And then the the disk controller keeps the mapping maintains the mapping between logical blocks
Dialogue: 0,0:25:53.58,0:25:58.72,Chinese,,0,0,0,,然后磁盘控制器保持映射保持物理扇区和逻辑块之间的映射
Dialogue: 0,0:25:58.88,0:26:00.64,English,,0,0,0,,And the actual physical sectors
Dialogue: 0,0:25:58.88,0:26:00.64,Chinese,,0,0,0,,然后磁盘控制器保持映射保持物理扇区和逻辑块之间的映射
Dialogue: 0,0:26:03.44,0:26:10.06,English,,0,0,0,,So as in the old saying is you know most interesting ideas in computer science are involve some form of indirection
Dialogue: 0,0:26:03.44,0:26:10.06,Chinese,,0,0,0,,计算机科学中古老的有趣的智慧就是涉及某种形式的间接
Dialogue: 0,0:26:10.28,0:26:12.02,English,,0,0,0,,So this is a level of indirection
Dialogue: 0,0:26:10.28,0:26:12.02,Chinese,,0,0,0,,所以这是一个间接层面
Dialogue: 0,0:26:12.50,0:26:16.28,English,,0,0,0,,That provides you know this mapping between logical blocks and physical blocks
Dialogue: 0,0:26:12.50,0:26:16.28,Chinese,,0,0,0,,让你了解逻辑块和物理块之间的映射
Dialogue: 0,0:26:17.04,0:26:21.48,English,,0,0,0,,So it allows disk controllers to take some cylinders and reserve them as spare cylinders
Dialogue: 0,0:26:17.04,0:26:21.48,Chinese,,0,0,0,,它允许磁盘控制器将一些柱面保留为备用柱面
Dialogue: 0,0:26:22.10,0:26:24.04,English,,0,0,0,,That aren't mapped it in logical blocks
Dialogue: 0,0:26:22.10,0:26:24.04,Chinese,,0,0,0,,这些柱面没有被映射为逻辑块
Dialogue: 0,0:26:24.90,0:26:29.54,English,,0,0,0,,And then if there's if one of the sectors goes bad in a cylinder
Dialogue: 0,0:26:24.90,0:26:29.54,Chinese,,0,0,0,,如果有个柱面的一个扇区坏了
Dialogue: 0,0:26:29.96,0:26:38.22,English,,0,0,0,,That the disk controller can just copy the data over to a spare cylinder and then just keep going right
Dialogue: 0,0:26:29.96,0:26:38.22,Chinese,,0,0,0,,磁盘控制器可以将数据复制到备用柱面，然后磁盘就可以继续正常工作
Dialogue: 0,0:26:38.22,0:26:46.18,English,,0,0,0,,So this is why your formatted capacity is less than sort of the if you know if you counted the number of actual cylinders on the disk
Dialogue: 0,0:26:38.22,0:26:46.18,Chinese,,0,0,0,,这就是为什么磁盘的“格式容量”会比实际容量要小，如果你去数实际的柱面数的话
Dialogue: 0,0:26:46.50,0:26:49.52,English,,0,0,0,,Your formatted capacity is less than the maximum capacity
Dialogue: 0,0:26:46.50,0:26:49.52,Chinese,,0,0,0,,“格式容量”会比实际容量要小
Dialogue: 0,0:26:49.72,0:26:53.62,English,,0,0,0,,Because some of those cylinders are being reserved for failures
Dialogue: 0,0:26:49.72,0:26:53.62,Chinese,,0,0,0,,因为其中一些柱面是为故障处理而预留的
Dialogue: 0,0:26:57.80,0:27:04.18,English,,0,0,0,,Now devices like disks are connected to the to the CPU and the memory
Dialogue: 0,0:26:57.80,0:27:04.18,Chinese,,0,0,0,,现在，像磁盘这样的设备连接到 CPU 和内存
Dialogue: 0,0:27:05.54,0:27:09.82,English,,0,0,0,,Via the I/O bridge over another kind of bus called an I/O bus
Dialogue: 0,0:27:05.54,0:27:09.82,Chinese,,0,0,0,,通过 I/O 桥，通过另一种称为 I/O 总线的总线
Dialogue: 0,0:27:11.46,0:27:19.50,English,,0,0,0,,This what I'm showing you now is actually not representative of modern systems
Dialogue: 0,0:27:11.46,0:27:19.50,Chinese,,0,0,0,,我现在向你展示的内容实际上并不代表现代系统就是这么简单的
Dialogue: 0,0:27:19.50,0:27:23.82,English,,0,0,0,,It's representative of what was called the pci bus about five years ago
Dialogue: 0,0:27:19.50,0:27:23.82,Chinese,,0,0,0,,它代表了大约五年前所谓的 PCI 总线
Dialogue: 0,0:27:24.26,0:27:31.36,English,,0,0,0,,Modern buses now are the pci bus is a broadcast bus meaning it's just a single set of wires
Dialogue: 0,0:27:24.26,0:27:31.36,Chinese,,0,0,0,,现代总线是……PCI 总线是广播总线，这意味着它只是单一线路
Dialogue: 0,0:27:32.12,0:27:36.78,English,,0,0,0,,So if any device us changes the values on those wires
Dialogue: 0,0:27:32.12,0:27:36.78,Chinese,,0,0,0,,因此，如果这根总线上的任何设备更改了某个值
Dialogue: 0,0:27:37.08,0:27:39.84,English,,0,0,0,,Every device on that bus can see those values
Dialogue: 0,0:27:37.08,0:27:39.84,Chinese,,0,0,0,,该总线上的每个设备都可以看到这些值
Dialogue: 0,0:27:41.48,0:27:46.26,English,,0,0,0,,Okay that's called a broadcast bus and it's a simplest kind of way to hook things together
Dialogue: 0,0:27:41.48,0:27:46.26,Chinese,,0,0,0,,好的，它被称为广播总线，它是将事物连接在一起的最简单的方式
Dialogue: 0,0:27:47.84,0:27:51.76,English,,0,0,0,,Modern systems use a bus structure called pci express
Dialogue: 0,0:27:47.84,0:27:51.76,Chinese,,0,0,0,,现代系统使用称为 PCI Express 的总线结构
Dialogue: 0,0:27:52.32,0:27:56.18,English,,0,0,0,,Which although it has the word pci and it's completely different it's point-to-point
Dialogue: 0,0:27:52.32,0:27:56.18,Chinese,,0,0,0,,虽然它有 PCI 这个词，但它是完全不同的，它是点对点的
Dialogue: 0,0:27:56.30,0:28:00.08,English,,0,0,0,,So devices are connected by a set of point-to-point connections
Dialogue: 0,0:27:56.30,0:28:00.08,Chinese,,0,0,0,,因此，设备通过一组点对点连接进行连接
Dialogue: 0,0:28:00.32,0:28:04.30,English,,0,0,0,,Arbitrated by a-- by some kind of a switch
Dialogue: 0,0:28:00.32,0:28:04.30,Chinese,,0,0,0,,通过某种开关仲裁
Dialogue: 0,0:28:04.80,0:28:09.84,English,,0,0,0,,And we won't go into it it's the same idea it it's a much more efficient design
Dialogue: 0,0:28:04.80,0:28:09.84,Chinese,,0,0,0,,我们不会深入探究其细节，它是一个更有效的设计
Dialogue: 0,0:28:10.30,0:28:16.86,English,,0,0,0,,It's much faster and but it provides the same capability mainly it just attaches up
Dialogue: 0,0:28:10.30,0:28:16.86,Chinese,,0,0,0,,它更快，但它提供相同的功能，
Dialogue: 0,0:28:17.42,0:28:21.32,English,,0,0,0,,It allows you to attach all of your devices to your to your CPU
Dialogue: 0,0:28:17.42,0:28:21.32,Chinese,,0,0,0,,它允许你将所有设备连接到 CPU
Dialogue: 0,0:28:22.26,0:28:25.72,English,,0,0,0,,So just think of this bus as this sort of a single set of wires
Dialogue: 0,0:28:22.26,0:28:25.72,Chinese,,0,0,0,,因此，只需将此总线视为一组电子线路即可
Dialogue: 0,0:28:26.44,0:28:28.00,English,,0,0,0,,Where each wire carries a bit
Dialogue: 0,0:28:26.44,0:28:28.00,Chinese,,0,0,0,,每根电线都带有一个比特的信息
Dialogue: 0,0:28:28.74,0:28:33.30,English,,0,0,0,,And every device attached to it can see all the values of all the wires
Dialogue: 0,0:28:28.74,0:28:33.30,Chinese,,0,0,0,,并且连接在总线上的每个设备都可以看到所有电线上的所有值
Dialogue: 0,0:28:34.32,0:28:41.10,English,,0,0,0,,And so it there's some devices that are just built it directly into the motherboard and they attach to the bus like
Dialogue: 0,0:28:34.32,0:28:41.10,Chinese,,0,0,0,,有一些设备是直接焊接在主板上的，直接连接到总线上
Dialogue: 0,0:28:41.52,0:28:46.72,English,,0,0,0,,You know disks have just plugged directly into sockets on a motherboard
Dialogue: 0,0:28:41.52,0:28:46.72,Chinese,,0,0,0,,磁盘是直接插入主板上的插槽
Dialogue: 0,0:28:46.94,0:28:50.64,English,,0,0,0,,And you know your graphics adapter and the USB controller
Dialogue: 0,0:28:46.94,0:28:50.64,Chinese,,0,0,0,,还有诸如图形适配器和 USB 控制器
Dialogue: 0,0:28:50.92,0:28:53.06,English,,0,0,0,,And then the system presents an interface
Dialogue: 0,0:28:50.92,0:28:53.06,Chinese,,0,0,0,,然后系统提供一个接口
Dialogue: 0,0:28:53.06,0:28:58.76,English,,0,0,0,,So you can plug mouse things like mice and keyboards into the USB controller
Dialogue: 0,0:28:53.06,0:28:58.76,Chinese,,0,0,0,,因此，你可以将鼠标和键盘等插入 USB 控制器
Dialogue: 0,0:28:59.24,0:29:03.58,English,,0,0,0,,And then there's expansion slots that allow you that are
Dialogue: 0,0:28:59.24,0:29:03.58,Chinese,,0,0,0,,然后还有扩展插槽
Dialogue: 0,0:29:04.24,0:29:07.90,English,,0,0,0,,Connect to the wires in the in the bus that allow you to add other devices right
Dialogue: 0,0:29:04.24,0:29:07.90,Chinese,,0,0,0,,允许你添加其他设备，将其连接到总线上
Dialogue: 0,0:29:08.64,0:29:11.38,English,,0,0,0,,Maybe network you know if you want to put a network adapter there
Dialogue: 0,0:29:08.64,0:29:11.38,Chinese,,0,0,0,,例如你想在那里放一个网络适配器
Dialogue: 0,0:29:14.14,0:29:16.60,English,,0,0,0,,Now what happens when we want to read a disk sector
Dialogue: 0,0:29:14.14,0:29:16.60,Chinese,,0,0,0,,当我们想要读取磁盘扇区时会发生什么
Dialogue: 0,0:29:17.34,0:29:21.14,English,,0,0,0,,Well the CPU initiates this read by writing a triple
Dialogue: 0,0:29:17.34,0:29:21.14,Chinese,,0,0,0,,那么 CPU 通过编写三元组来启动此读取行为
Dialogue: 0,0:29:21.38,0:29:25.22,English,,0,0,0,,So it writes three different values it writes a command like say read
Dialogue: 0,0:29:21.38,0:29:25.22,Chinese,,0,0,0,,所以它写了三个不同的值。首先是写了个指令，比如说 read
Dialogue: 0,0:29:26.04,0:29:27.94,English,,0,0,0,,It writes a logical block number
Dialogue: 0,0:29:26.04,0:29:27.94,Chinese,,0,0,0,,它还写入一个逻辑块号
Dialogue: 0,0:29:28.24,0:29:30.32,English,,0,0,0,,So I want to read a logical block number
Dialogue: 0,0:29:28.24,0:29:30.32,Chinese,,0,0,0,,是我想读取的那个逻辑块的块号
Dialogue: 0,0:29:30.78,0:29:35.12,English,,0,0,0,,And I want to place the contents of that logical block at a certain address in memory
Dialogue: 0,0:29:30.78,0:29:35.12,Chinese,,0,0,0,,然后我想将该逻辑块的内容放在内存中的某个地址
Dialogue: 0,0:29:36.46,0:29:41.90,English,,0,0,0,,Okay so it's a command, logical block number, in a memory address
Dialogue: 0,0:29:36.46,0:29:41.90,Chinese,,0,0,0,,好的，三要素就是指令、逻辑块号和内存地址
Dialogue: 0,0:29:43.00,0:29:49.70,English,,0,0,0,,The disk controller reads the whatever sector corresponds to that logical block
Dialogue: 0,0:29:43.00,0:29:49.70,Chinese,,0,0,0,,磁盘控制器读取与该逻辑块对应的任何扇区
Dialogue: 0,0:29:49.92,0:29:54.78,English,,0,0,0,,So we'll assume that logical blocks are consists of one sector
Dialogue: 0,0:29:49.92,0:29:54.78,Chinese,,0,0,0,,所以我们假设一个逻辑块由一个扇区组成
Dialogue: 0,0:29:56.36,0:30:00.52,English,,0,0,0,,And then it does this interesting thing it copies it takes control of the bus
Dialogue: 0,0:29:56.36,0:30:00.52,Chinese,,0,0,0,,然后它做了这个有趣的事情，它取得总线的控制权
Dialogue: 0,0:30:01.16,0:30:03.90,English,,0,0,0,,And it copies the data this is the disk controller now
Dialogue: 0,0:30:01.16,0:30:03.90,Chinese,,0,0,0,,它现在复制数据，这是磁盘控制器
Dialogue: 0,0:30:04.64,0:30:12.58,English,,0,0,0,,Copies the data across the I/O bus through the I/O bridge and directly to main memory without ever notifying the CPU
Dialogue: 0,0:30:04.64,0:30:12.58,Chinese,,0,0,0,,通过 I/O 桥将数据复制到 I/O 总线，直接复制到主存储器，而无需通知 CPU
Dialogue: 0,0:30:12.58,0:30:20.28,English,,0,0,0,,So the CPU is completely oblivious to the fact that this transfer is going on
Dialogue: 0,0:30:12.58,0:30:20.28,Chinese,,0,0,0,,所以 CPU 完全忘记了这种传输正在进行的事实
Dialogue: 0,0:30:22.68,0:30:25.68,English,,0,0,0,,And then once it's once its transfer the data to main memory
Dialogue: 0,0:30:22.68,0:30:25.68,Chinese,,0,0,0,,然后，一旦它将数据传输到主存储器
Dialogue: 0,0:30:26.26,0:30:30.46,English,,0,0,0,,Then it notifies the CPU using this mechanism called an interrupt
Dialogue: 0,0:30:26.26,0:30:30.46,Chinese,,0,0,0,,然后它使用这种称为中断的机制来通知 CPU
Dialogue: 0,0:30:31.36,0:30:35.82,English,,0,0,0,,So it actually asserts a pin on the the actual CPU chip itself
Dialogue: 0,0:30:31.36,0:30:35.82,Chinese,,0,0,0,,所以它实际上 CPU 芯片本身上用了一个引脚
Dialogue: 0,0:30:36.40,0:30:39.92,English,,0,0,0,,So it it changes the value of that pin from 0 to 1
Dialogue: 0,0:30:36.40,0:30:39.92,Chinese,,0,0,0,,它将该引脚的值从 0 更改为 1
Dialogue: 0,0:30:40.62,0:30:48.84,English,,0,0,0,,And that trigger is an interrupt and which notifies the CPU that sector has been copy
Dialogue: 0,0:30:40.62,0:30:48.84,Chinese,,0,0,0,,该触发器是一个中断，它通知 CPU，该扇区已被复制
Dialogue: 0,0:30:50.02,0:30:56.04,English,,0,0,0,,Ok so then the CPU if there's some program somewhere waiting for that data to be read into memory
Dialogue: 0,0:30:50.02,0:30:56.04,Chinese,,0,0,0,,好的，对于 CPU 来说，现在某处有某个程序正在等待，将数据读入内存
Dialogue: 0,0:30:56.04,0:31:01.44,English,,0,0,0,,So now the CPU can execute that program and deal with that memory
Dialogue: 0,0:30:56.04,0:31:01.44,Chinese,,0,0,0,,所以现在 CPU 可以执行该程序并处理该内存
Dialogue: 0,0:31:02.00,0:31:04.90,English,,0,0,0,,So what this what this mechanism allows
Dialogue: 0,0:31:02.00,0:31:04.90,Chinese,,0,0,0,,那么这个机制有什么好处？
Dialogue: 0,0:31:05.80,0:31:11.63,English,,0,0,0,,And the reason they do this is because disks are just so god-awful slow
Dialogue: 0,0:31:05.80,0:31:11.63,Chinese,,0,0,0,,他们这样做的原因是因为从磁盘读取数据实在是太慢了
Dialogue: 0,0:31:12.54,0:31:19.40,English,,0,0,0,,The within 10 milliseconds a system could be executing millions and millions of instructions
Dialogue: 0,0:31:12.54,0:31:19.40,Chinese,,0,0,0,,在 10 毫秒内，系统可以执行数百万条指令
Dialogue: 0,0:31:19.40,0:31:22.74,English,,0,0,0,,The CPU could be executing millions and millions of instructions
Dialogue: 0,0:31:19.40,0:31:22.74,Chinese,,0,0,0,,CPU可能正在执行数百万条指令
Dialogue: 0,0:31:22.74,0:31:26.88,English,,0,0,0,,It will be a terrible waste if the CPU waited for that data to come off the disk
Dialogue: 0,0:31:22.74,0:31:26.88,Chinese,,0,0,0,,如果要让 CPU 停下来，等待从磁盘上读取数据完毕，那将是一个可怕的浪费
Dialogue: 0,0:31:27.88,0:31:33.18,English,,0,0,0,,So what it does is it it issues this request to the disk controller
Dialogue: 0,0:31:27.88,0:31:33.18,Chinese,,0,0,0,,这个机制做的事情就是它将此请求发送给磁盘控制器
Dialogue: 0,0:31:33.88,0:31:37.74,English,,0,0,0,,And then while that well that really slow laborious process is going on
Dialogue: 0,0:31:33.88,0:31:37.74,Chinese,,0,0,0,,然后，虽然那个非常缓慢的磁盘读取过程正在进行
Dialogue: 0,0:31:38.16,0:31:42.14,English,,0,0,0,,The CPU can be executing other instructions and doing other useful work
Dialogue: 0,0:31:38.16,0:31:42.14,Chinese,,0,0,0,,但 CPU 可以同时执行其他指令，执行其他有用的工作
Dialogue: 0,0:31:43.94,0:31:49.18,English,,0,0,0,,So this is really essential to just sort of getting reasonable performance
Dialogue: 0,0:31:43.94,0:31:49.18,Chinese,,0,0,0,,所以这对于获得合理的性能非常重要
Dialogue: 0,0:31:49.18,0:31:53.58,English,,0,0,0,,And from keeping this really slow disk system from slowing the system down
Dialogue: 0,0:31:49.18,0:31:53.58,Chinese,,0,0,0,,防止这个非常慢的磁盘系统减慢整个系统速度
Dialogue: 0,0:31:54.64,0:32:02.22,English,,0,0,0,,Now there's another interesting hype kind of disk called a solid-state disk
Dialogue: 0,0:31:54.64,0:32:02.22,Chinese,,0,0,0,,现在有另一个有趣的很火热的类型的磁盘称为固态磁盘
Dialogue: 0,0:32:02.22,0:32:09.68,English,,0,0,0,,Which is kind of halfway between rotating and rotating discs  and DRAM memories
Dialogue: 0,0:32:02.22,0:32:09.68,Chinese,,0,0,0,,大概是旋转磁盘与 DRAM 存储器的中间点
Dialogue: 0,0:32:10.38,0:32:14.07,English,,0,0,0,,In a solid-state disk to the to the CPU
Dialogue: 0,0:32:10.38,0:32:14.07,Chinese,,0,0,0,,在 CPU 看来，一个固态磁盘
Dialogue: 0,0:32:14.07,0:32:17.96,English,,0,0,0,,It looks exactly like a rotating disk it has the same socket plug
Dialogue: 0,0:32:14.07,0:32:17.96,Chinese,,0,0,0,,它看起来与旋转磁盘完全相同，它具有相同的接口
Dialogue: 0,0:32:18.20,0:32:22.40,English,,0,0,0,,It has the same physical interface that has the same packaging
Dialogue: 0,0:32:18.20,0:32:22.40,Chinese,,0,0,0,,它具有相同的物理接口，具有相同的包装
Dialogue: 0,0:32:22.82,0:32:24.83,English,,0,0,0,,It looks like a rotating disk
Dialogue: 0,0:32:22.82,0:32:24.83,Chinese,,0,0,0,,在 CPU 看来就好像是一个旋转磁盘
Dialogue: 0,0:32:25.18,0:32:31.66,English,,0,0,0,,But instead of having all these mechanical parts it's actually built entirely out of flash memory
Dialogue: 0,0:32:25.18,0:32:31.66,Chinese,,0,0,0,,但它没有所有这些机械部件，而是完全由闪存构建
Dialogue: 0,0:32:31.96,0:32:36.82,English,,0,0,0,,And firmware that acts as the the controller
Dialogue: 0,0:32:31.96,0:32:36.82,Chinese,,0,0,0,,和充当控制器的固件
Dialogue: 0,0:32:37.42,0:32:44.60,English,,0,0,0,,So inside of a solid-state disk there's a firmware a set of firmware called the flash translation layer
Dialogue: 0,0:32:37.42,0:32:44.60,Chinese,,0,0,0,,因此，在固态磁盘内部有一组固件，称为闪存翻译层
Dialogue: 0,0:32:44.72,0:32:51.86,English,,0,0,0,,Which serves the purpose as the same purpose as the disk controller does in a rotating disk
Dialogue: 0,0:32:44.72,0:32:51.86,Chinese,,0,0,0,,其作用与旋转磁盘的磁盘控制器相同
Dialogue: 0,0:32:54.70,0:32:57.06,English,,0,0,0,,And then the memory itself the read
Dialogue: 0,0:32:54.70,0:32:57.06,Chinese,,0,0,0,,然后内存本身......
Dialogue: 0,0:32:58.60,0:33:03.74,English,,0,0,0,,Data can be read and written from the flash memory in units of pages
Dialogue: 0,0:32:58.60,0:33:03.74,Chinese,,0,0,0,,可以以页为单位从闪存读取和写入数据
Dialogue: 0,0:33:04.34,0:33:08.94,English,,0,0,0,,Which depending on the technology can be 512 kbytes to 4 k bytes
Dialogue: 0,0:33:04.34,0:33:08.94,Chinese,,0,0,0,,页的大小取决于技术的不同，可以是 512 千字节到 4 千字节
Dialogue: 0,0:33:11.12,0:33:14.92,English,,0,0,0,,And then a sequence of pages forms a block
Dialogue: 0,0:33:11.12,0:33:14.92,Chinese,,0,0,0,,然后一系列的页形成一个块
Dialogue: 0,0:33:15.92,0:33:21.50,English,,0,0,0,,Now these blocks are different from the logical blocks that the CPU does
Dialogue: 0,0:33:15.92,0:33:21.50,Chinese,,0,0,0,,这里提到的块与 CPU 所认为的逻辑块是不同的
Dialogue: 0,0:33:21.50,0:33:24.24,English,,0,0,0,,So it's kind of an unfortunate overlap of terms
Dialogue: 0,0:33:21.50,0:33:24.24,Chinese,,0,0,0,,所以这是一个不幸的术语重叠
Dialogue: 0,0:33:26.78,0:33:35.48,English,,0,0,0,,But the the trick is or the I guess the limitation is that data is written in units of pages
Dialogue: 0,0:33:26.78,0:33:35.48,Chinese,,0,0,0,,但这里有个诀窍是，我猜这里的限制是在固态硬盘中，数据是以页为单位写入的
Dialogue: 0,0:33:36.74,0:33:41.06,English,,0,0,0,,But a page can only be written after the entire block has been erased
Dialogue: 0,0:33:36.74,0:33:41.06,Chinese,,0,0,0,,一个页只能在所属的整个块都被擦除之后，才能写这一页
Dialogue: 0,0:33:43.86,0:33:46.98,English,,0,0,0,,Okay so that's that seems kind of weird but that's that's the way it works
Dialogue: 0,0:33:43.86,0:33:46.98,Chinese,,0,0,0,,好的，这似乎有点奇怪，但这就是它的工作方式
Dialogue: 0,0:33:47.68,0:33:49.85,English,,0,0,0,,So what that means is if you want to write
Dialogue: 0,0:33:47.68,0:33:49.85,Chinese,,0,0,0,,那么这意味着你想要对固态硬盘进行写入
Dialogue: 0,0:33:51.30,0:33:57.54,English,,0,0,0,,If you want to write to a page you have to find a block somewhere that's been erased
Dialogue: 0,0:33:51.30,0:33:57.54,Chinese,,0,0,0,,如果你想写一个页，你必须找到一个被擦除的块
Dialogue: 0,0:33:59.00,0:34:05.40,English,,0,0,0,,You have to copy all of the other pages in your target block over to that new block and then you can do the right
Dialogue: 0,0:33:59.00,0:34:05.40,Chinese,,0,0,0,,你必须将目标块中的所有其他页面复制到该新块，才能正确执行
Dialogue: 0,0:34:07.10,0:34:14.04,English,,0,0,0,,Okay so you can see that write now become fairly complex operation. Reads you can read anything
Dialogue: 0,0:34:07.10,0:34:14.04,Chinese,,0,0,0,,好的，你可以看到现在写操作变得相当复杂。读操作没改变，你还是可以读任何东西
Dialogue: 0,0:34:15.30,0:34:21.50,English,,0,0,0,,And then like all flash a so it's kind of an efficient right because you're writing one page
Dialogue: 0,0:34:15.30,0:34:21.50,Chinese,,0,0,0,,然后像所有闪存一样，这是一种有效的机制，因为，你正在写一页
Dialogue: 0,0:34:22.70,0:34:28.58,English,,0,0,0,,But to do that you have to sort of copy all the other pages in it block and you have to erase the whole
Dialogue: 0,0:34:22.70,0:34:28.58,Chinese,,0,0,0,,但要做到这一点，你必须复制该块中的其他所有页面，你必须擦除整体
Dialogue: 0,0:34:29.18,0:34:33.86,English,,0,0,0,,And then when you finish then you erase this block so it can be used for for other writes yes
Dialogue: 0,0:34:29.18,0:34:33.86,Chinese,,0,0,0,,然后当你完成后，你擦除这个块，以便它可以用于其他写入
Dialogue: 0,0:34:34.92,0:34:38.88,English,,0,0,0,,So eventually after a hundred thousand repeated writes these we're out
Dialogue: 0,0:34:34.92,0:34:38.88,Chinese,,0,0,0,,所以最终在经过十万次重复写入后，这个块就会磨损
Dialogue: 0,0:34:40.24,0:34:43.40,English,,0,0,0,,Now the flash translation layer in modern systems
Dialogue: 0,0:34:40.24,0:34:43.40,Chinese,,0,0,0,,现代系统的闪存翻译层
Dialogue: 0,0:34:43.96,0:34:50.32,English,,0,0,0,,Do all kinds of fancy proprietary algorithms to sort of extend the life. They use caching
Dialogue: 0,0:34:43.96,0:34:50.32,Chinese,,0,0,0,,实现了各种花里胡哨的专有算法，以延长 SSD 的使用生命，例如缓存技术
Dialogue: 0,0:34:50.78,0:34:54.58,English,,0,0,0,,And and various tricks to extend the life of these SSD
Dialogue: 0,0:34:50.78,0:34:54.58,Chinese,,0,0,0,,并且还有各种技巧来延长这些 SSD 的使用寿命
Dialogue: 0,0:34:54.58,0:34:58.76,English,,0,0,0,,So in practice it's not really a problem, which I'll show you in a second
Dialogue: 0,0:34:54.58,0:34:58.76,Chinese,,0,0,0,,所以在实践中，这不是一个大问题。我接下来就会展示
Dialogue: 0,0:35:00.42,0:35:04.28,English,,0,0,0,,So the performance characteristics of SSDs
Dialogue: 0,0:35:00.42,0:35:04.28,Chinese,,0,0,0,,下面介绍 SSD 的性能特点
Dialogue: 0,0:35:04.74,0:35:08.66,English,,0,0,0,,Now you can think of a typical hard drive you might be able to get
Dialogue: 0,0:35:04.74,0:35:08.66,Chinese,,0,0,0,,现在你可以想到一个典型的硬盘，它的读写速度大概
Dialogue: 0,0:35:09.98,0:35:12.94,English,,0,0,0,,You know I mean what if when I measure them when I measure my drives
Dialogue: 0,0:35:09.98,0:35:12.94,Chinese,,0,0,0,,你知道我的意思，是指去测量磁盘驱动器（的读写速度）
Dialogue: 0,0:35:12.94,0:35:16.34,English,,0,0,0,,I maybe forty, fifty megabytes per second that would be a typical rate
Dialogue: 0,0:35:12.94,0:35:16.34,Chinese,,0,0,0,,可能是每秒 40 或 50 MB，这是一个典型的速度
Dialogue: 0,0:35:17.34,0:35:21.16,English,,0,0,0,,Okay these SSDs are 10 times faster than that
Dialogue: 0,0:35:17.34,0:35:21.16,Chinese,,0,0,0,,而 SSD 的速度要快 10 倍
Dialogue: 0,0:35:22.06,0:35:25.18,English,,0,0,0,,So for sequential reads you can get about 550 megabytes
Dialogue: 0,0:35:22.06,0:35:25.18,Chinese,,0,0,0,,因此对于顺序读取，你可以获得大约 550MB/s 的速度
Dialogue: 0,0:35:26.04,0:35:28.78,English,,0,0,0,,Sequential writes are a little bit slower
Dialogue: 0,0:35:26.04,0:35:28.78,Chinese,,0,0,0,,顺序写入有点慢
Dialogue: 0,0:35:31.08,0:35:36.18,English,,0,0,0,,Random access whether you're reading or writing is a little bit slower than sequential access
Dialogue: 0,0:35:31.08,0:35:36.18,Chinese,,0,0,0,,如果是随机访问，无论是读或写都比顺序访问慢一点
Dialogue: 0,0:35:37.02,0:35:39.80,English,,0,0,0,,And as we'll see this is that this is fairly common
Dialogue: 0,0:35:37.02,0:35:39.80,Chinese,,0,0,0,,而且我们会看到这是相当普遍的
Dialogue: 0,0:35:39.82,0:35:45.90,English,,0,0,0,,It's it's in memory systems it's almost always better to do things sequentially  than to jump around
Dialogue: 0,0:35:39.82,0:35:45.90,Chinese,,0,0,0,,就是在内存系统中，按顺序执行操作几乎总是比在内存中跳来跳去更好
Dialogue: 0,0:35:48.06,0:35:53.62,English,,0,0,0,,And erasing random writes are slower because erase erasing takes about a millisecond right
Dialogue: 0,0:35:48.06,0:35:53.62,Chinese,,0,0,0,,随机写入速度较慢，是因为擦除的存在，擦除需要大约一毫秒的时间
Dialogue: 0,0:35:53.62,0:35:59.20,English,,0,0,0,,So now we're back up to that that millisecond range which is which is slow
Dialogue: 0,0:35:53.62,0:35:59.20,Chinese,,0,0,0,,所以现在我们又回到那个毫秒级的范围，这就很慢了
Dialogue: 0,0:35:59.82,0:36:06.80,English,,0,0,0,,And as I mentioned yet if you modify one page after all the other pages in that block have to be copy
Dialogue: 0,0:35:59.82,0:36:06.80,Chinese,,0,0,0,,正如我所提到的那样，如果你修改某一页，该页所在块中的所有其他页都必须被复制
Dialogue: 0,0:36:07.94,0:36:18.24,English,,0,0,0,,Now earlier SSDs had a huge gap between random writes and sequential reads
Dialogue: 0,0:36:07.94,0:36:18.24,Chinese,,0,0,0,,早期的 SSD 在随机写入和顺序读取的速度存在巨大差距
Dialogue: 0,0:36:19.10,0:36:23.28,English,,0,0,0,,But they because of sort of improvements in the flash translation layer
Dialogue: 0,0:36:19.10,0:36:23.28,Chinese,,0,0,0,,但因为闪存翻译层的改进，这一差距有所缩小
Dialogue: 0,0:36:23.66,0:36:29.12,English,,0,0,0,,These are really that that difference right reading and writing it's it's writing is slower
Dialogue: 0,0:36:23.66,0:36:29.12,Chinese,,0,0,0,,读写操作肯定存在时间差异的，写入更慢，对吧？
Dialogue: 0,0:36:29.52,0:36:34.36,English,,0,0,0,,But they're doing all kinds of interesting amazing things to get these numbers fairly close
Dialogue: 0,0:36:29.52,0:36:34.36,Chinese,,0,0,0,,但他们正在做各种有趣的的改进，以使这些数字相当接近
Dialogue: 0,0:36:35.76,0:36:42.42,English,,0,0,0,,Ok so er... when we have a model of SSDs we really don't need to distinguish anymore that between reads and writes
Dialogue: 0,0:36:35.76,0:36:42.42,Chinese,,0,0,0,,好吧，当我们有了 SSD 模型，我们真的不需要再区分读和写
Dialogue: 0,0:36:45.14,0:36:48.10,English,,0,0,0,,Okay so, SSDs because they have no moving parts
Dialogue: 0,0:36:45.14,0:36:48.10,Chinese,,0,0,0,,因为 SSD 没有移动的部件
Dialogue: 0,0:36:48.16,0:36:51.76,English,,0,0,0,,They're faster they take less power they're more rugged
Dialogue: 0,0:36:48.16,0:36:51.76,Chinese,,0,0,0,,所以它们的读写速度非常快，消耗的电能也少，同时也更结实
Dialogue: 0,0:36:52.22,0:36:54.78,English,,0,0,0,,You know which is why they're good for thumb drives
Dialogue: 0,0:36:52.22,0:36:54.78,Chinese,,0,0,0,,这就是为什么 SSD 用在 U 盘中是有好处的
Dialogue: 0,0:36:55.52,0:36:57.70,English,,0,0,0,,And you know ipods and things like that
Dialogue: 0,0:36:55.52,0:36:57.70,Chinese,,0,0,0,,像是 IPods 和类似的东西
Dialogue: 0,0:36:58.24,0:37:01.06,English,,0,0,0,,But they have this potential to wear out
Dialogue: 0,0:36:58.24,0:37:01.06,Chinese,,0,0,0,,但它们有可能磨损
Dialogue: 0,0:37:01.26,0:37:05.34,English,,0,0,0,,Which could be a problem but in practice it's not
Dialogue: 0,0:37:01.26,0:37:05.34,Chinese,,0,0,0,,这可能是一个问题，但实际情况也不是大问题
Dialogue: 0,0:37:05.34,0:37:10.00,English,,0,0,0,,For example, Intel guarantees that you can do 128 petabytes of writes
Dialogue: 0,0:37:05.34,0:37:10.00,Chinese,,0,0,0,,英特尔保证，在对于他们的产品，在损毁之前，你可以执行 128 PB 的写入
Dialogue: 0,0:37:10.64,0:37:13.46,English,,0,0,0,,Before your SSD is no longer good
Dialogue: 0,0:37:10.64,0:37:13.46,Chinese,,0,0,0,,英特尔保证，在对于他们的产品，在损毁之前，你可以执行 128 PB 的写入
Dialogue: 0,0:37:14.24,0:37:19.92,English,,0,0,0,,So that's a lot of data to write I mean think about how many years it would take to write that much data
Dialogue: 0,0:37:14.24,0:37:19.92,Chinese,,0,0,0,,那是很大量的数，我的意思是考虑一下要写那么多的数据够你写多少年了
Dialogue: 0,0:37:21.46,0:37:25.48,English,,0,0,0,,And as of 2015 as of now
Dialogue: 0,0:37:21.46,0:37:25.48,Chinese,,0,0,0,,截至目前，2015年
Dialogue: 0,0:37:25.76,0:37:28.67,English,,0,0,0,,They're a lot more expensive per byte than rotating disks
Dialogue: 0,0:37:25.76,0:37:28.67,Chinese,,0,0,0,,SSD 存储每个字节的价格比旋转磁盘贵很多
Dialogue: 0,0:37:29.18,0:37:32.88,English,,0,0,0,,So rotating disks are much bigger but they're slower
Dialogue: 0,0:37:29.18,0:37:32.88,Chinese,,0,0,0,,所以旋转磁盘的容量要大得多，但速度更慢一些
Dialogue: 0,0:37:33.52,0:37:35.72,English,,0,0,0,,SSDs are smaller and faster
Dialogue: 0,0:37:33.52,0:37:35.72,Chinese,,0,0,0,,SSD 更小更快
Dialogue: 0,0:37:39.28,0:37:40.98,English,,0,0,0,,Now if you take...
Dialogue: 0,0:37:39.28,0:37:40.98,Chinese,,0,0,0,,现在，如果你看一下
Dialogue: 0,0:37:42.10,0:37:48.22,English,,0,0,0,,If you look at the performance characteristics of these different storage devices relative to CPU
Dialogue: 0,0:37:42.10,0:37:48.22,Chinese,,0,0,0,,如果你看一下这些不同存储设备相对于 CPU 的性能特征
Dialogue: 0,0:37:48.62,0:37:52.10,English,,0,0,0,,Over time you get this really interesting graph
Dialogue: 0,0:37:48.62,0:37:52.10,Chinese,,0,0,0,,随着时间的推移，你会得到这个非常有趣的图表
Dialogue: 0,0:37:53.58,0:38:03.14,English,,0,0,0,,Now this graph shows on the y-axis access time in nanoseconds  or in a log scale
Dialogue: 0,0:37:53.58,0:38:03.14,Chinese,,0,0,0,,此图的 y 轴标识访存所需要的时间，单位为纳秒，以 10 的指数为尺度
Dialogue: 0,0:38:03.14,0:38:14.44,English,,0,0,0,,Okay so each one of these each change in units from 1,000 to 10,000 represents a order of magnitude difference in access time
Dialogue: 0,0:38:03.14,0:38:14.44,Chinese,,0,0,0,,好的，y 轴上相邻一格的变化，都表示访问时间的一个数量级差异
Dialogue: 0,0:38:15.52,0:38:22.98,English,,0,0,0,,On the x-axis I've plotted time going from 1985 to 2015
Dialogue: 0,0:38:15.52,0:38:22.98,Chinese,,0,0,0,,在 x 轴上，我绘制了从 1985 年到 2015 年的时间
Dialogue: 0,0:38:24.20,0:38:29.36,English,,0,0,0,,And then I've plotted the sort of the the access time or the cycle time of
Dialogue: 0,0:38:24.20,0:38:29.36,Chinese,,0,0,0,,然后我绘制了各种设备访存需要花费的时间或 CPU 周期时间
Dialogue: 0,0:38:30.10,0:38:35.16,English,,0,0,0,,The access time of the these devices, disk, SSD, DRAM and SRAM
Dialogue: 0,0:38:30.10,0:38:35.16,Chinese,,0,0,0,,绘制了硬盘、SSD、DRAN 和 SRAM 访存的时间
Dialogue: 0,0:38:36.00,0:38:38.12,English,,0,0,0,,And the cycle time of processors
Dialogue: 0,0:38:36.00,0:38:38.12,Chinese,,0,0,0,,和一个 CPU 周期的时间
Dialogue: 0,0:38:38.16,0:38:44.31,English,,0,0,0,,So let's look at on the bottom we have the the cycle time of processors over time
Dialogue: 0,0:38:38.16,0:38:44.31,Chinese,,0,0,0,,让我们先看图表的下方，是 CPU 周期的时间随着历史的发展的变化
Dialogue: 0,0:38:45.22,0:38:52.04,English,,0,0,0,,And what you see is it's going down at is this sort of exponential rate  from 1985 to 2003
Dialogue: 0,0:38:45.22,0:38:52.04,Chinese,,0,0,0,,你所看到的是一个 CPU 周期的时间从 1985 年到 2003 年以这种指数速度在下降
Dialogue: 0,0:38:52.82,0:39:00.27,English,,0,0,0,,There's the doubling basically every 18 months or two years in clock frequency and a resulting
Dialogue: 0,0:38:52.82,0:39:00.27,Chinese,,0,0,0,,基本上每 18 个月或两年，时钟频率就会加倍，结果是
Dialogue: 0,0:39:00.80,0:39:06.88,English,,0,0,0,,Halving of the cycle time over this 18-month to two year period
Dialogue: 0,0:39:00.80,0:39:06.88,Chinese,,0,0,0,,大约过 18 个月到两年，一个 CPU 周期的时间会减半
Dialogue: 0,0:39:08.16,0:39:14.12,English,,0,0,0,,So this so what what manufacturers did until 2003
Dialogue: 0,0:39:08.16,0:39:14.12,Chinese,,0,0,0,,所以这就是制造商在 2003 年之前所做的事情
Dialogue: 0,0:39:15.02,0:39:18.92,English,,0,0,0,,To make their processors faster was a but they would just double the clock frequency
Dialogue: 0,0:39:15.02,0:39:18.92,Chinese,,0,0,0,,为了使他们的处理器更快，他们只会使时钟频率加倍
Dialogue: 0,0:39:19.60,0:39:23.28,English,,0,0,0,,They decrease the feature size of the chips that they were making
Dialogue: 0,0:39:19.60,0:39:23.28,Chinese,,0,0,0,,它们减小了它们制造的芯片的特征尺寸
Dialogue: 0,0:39:24.00,0:39:26.94,English,,0,0,0,,And that would allow them to put things closer together
Dialogue: 0,0:39:24.00,0:39:26.94,Chinese,,0,0,0,,这可以让制造商把更多的部件放的更紧密
Dialogue: 0,0:39:26.94,0:39:35.82,English,,0,0,0,,And then have that and then increase the clock frequency by a proportional amount
Dialogue: 0,0:39:26.94,0:39:35.82,Chinese,,0,0,0,,然后按比例增加时钟频率
Dialogue: 0,0:39:36.92,0:39:42.48,English,,0,0,0,,Now this all ended 2003 was an interesting year in computer history
Dialogue: 0,0:39:36.92,0:39:42.48,Chinese,,0,0,0,,现在这一切都在 2003 年结束，这是计算机历史上有趣的一年
Dialogue: 0,0:39:43.16,0:39:48.92,English,,0,0,0,,Because of this there's a sort of unfortunate property that the power that you consume
Dialogue: 0,0:39:43.16,0:39:48.92,Chinese,,0,0,0,,因为有一种不幸的特性，就是 CPU 消耗的电能
Dialogue: 0,0:39:49.22,0:39:50.98,English,,0,0,0,,Is proportional to your frequency
Dialogue: 0,0:39:49.22,0:39:50.98,Chinese,,0,0,0,,与其时钟频率成正比
Dialogue: 0,0:39:50.98,0:39:55.62,English,,0,0,0,,Okay so the more power I mean the higher the frequency the more power you consume
Dialogue: 0,0:39:50.98,0:39:55.62,Chinese,,0,0,0,,CPU 越强，其时钟频率越高，消耗的功率越大
Dialogue: 0,0:39:56.52,0:40:04.30,English,,0,0,0,,By 2003 the processor that Intel was getting ready to ship was going to burn about 800 watts of power
Dialogue: 0,0:39:56.52,0:40:04.30,Chinese,,0,0,0,,到 2003 年，英特尔准备新出品的处理器将耗费大约 800 瓦的功率
Dialogue: 0,0:40:05.08,0:40:10.42,English,,0,0,0,,Think about 800 watt light bulbs inside your laptop and
Dialogue: 0,0:40:05.08,0:40:10.42,Chinese,,0,0,0,,想象一下，你的笔记本电脑里面有一个 800 瓦的灯泡（笑
Dialogue: 0,0:40:11.92,0:40:16.38,English,,0,0,0,,I actually saw an early prototype of one of these devices
Dialogue: 0,0:40:11.92,0:40:16.38,Chinese,,0,0,0,,我实际上看到了其中一个设备的早期原型
Dialogue: 0,0:40:16.68,0:40:25.40,English,,0,0,0,,And the the heatsink to absorb the power from the chip was about this big it was about four square inches
Dialogue: 0,0:40:16.68,0:40:25.40,Chinese,,0,0,0,,吸收芯片热量的散热器大约是四平方英寸大
Dialogue: 0,0:40:25.40,0:40:28.26,English,,0,0,0,,It's a giant thing just sitting on the motherboard
Dialogue: 0,0:40:25.40,0:40:28.26,Chinese,,0,0,0,,这在主板上简直是一个庞然大物
Dialogue: 0,0:40:29.78,0:40:36.70,English,,0,0,0,,So that's what we what we say is that processor design hit the power wall in 2003
Dialogue: 0,0:40:29.78,0:40:36.70,Chinese,,0,0,0,,所以这就是我们所说的处理器设计在 2003 年触及了能源的瓶颈
Dialogue: 0,0:40:36.70,0:40:40.62,English,,0,0,0,,They could no longer just continue to increase clock frequencies
Dialogue: 0,0:40:36.70,0:40:40.62,Chinese,,0,0,0,,他们再也不能继续增加时钟频率
Dialogue: 0,0:40:41.40,0:40:45.90,English,,0,0,0,,To to get faster to make faster computers
Dialogue: 0,0:40:41.40,0:40:45.90,Chinese,,0,0,0,,为了制作更快的计算机
Dialogue: 0,0:40:46.50,0:40:49.26,English,,0,0,0,,And what so what they had to do after 2003
Dialogue: 0,0:40:46.50,0:40:49.26,Chinese,,0,0,0,,那么他们在 2003 年之后必须做些什么
Dialogue: 0,0:40:49.68,0:40:55.42,English,,0,0,0,,Instead of increasing the clock frequency and try and set up doubling the clock frequency
Dialogue: 0,0:40:49.68,0:40:55.42,Chinese,,0,0,0,,而不是增加时钟频率，尝试设置加倍时钟频率
Dialogue: 0,0:40:56.22,0:40:59.58,English,,0,0,0,,They put more processor cores onto the chips
Dialogue: 0,0:40:56.22,0:40:59.58,Chinese,,0,0,0,,他们在芯片上放置了更多处理器内核
Dialogue: 0,0:41:00.22,0:41:05.08,English,,0,0,0,,So now they subdivided a CPU chip into individual processor cores
Dialogue: 0,0:41:00.22,0:41:05.08,Chinese,,0,0,0,,所以现在他们将 CPU 芯片细分为单独的处理器内核
Dialogue: 0,0:41:05.08,0:41:07.52,English,,0,0,0,,Each one could execute its own instructions
Dialogue: 0,0:41:05.08,0:41:07.52,Chinese,,0,0,0,,每个核心都可以执行自己的指令
Dialogue: 0,0:41:09.64,0:41:13.24,English,,0,0,0,,And then so and by running in parallel
Dialogue: 0,0:41:09.64,0:41:13.24,Chinese,,0,0,0,,然后通过并行运行
Dialogue: 0,0:41:13.54,0:41:18.70,English,,0,0,0,,You could do more effective work so the effective cycle time could continue to go down
Dialogue: 0,0:41:13.54,0:41:18.70,Chinese,,0,0,0,,CPU 可以更有效地工作，因此有效的周期时间可能会继续下降
Dialogue: 0,0:41:18.70,0:41:22.54,English,,0,0,0,,So what I've what I plotted here on the bottom is the effective cycle time
Dialogue: 0,0:41:18.70,0:41:22.54,Chinese,,0,0,0,,所以我在底部绘制的是有效循环时间
Dialogue: 0,0:41:22.54,0:41:26.40,English,,0,0,0,,So basically the the cycle time divided by the number of cores
Dialogue: 0,0:41:22.54,0:41:26.40,Chinese,,0,0,0,,换言之，是循环时间除以核心数
Dialogue: 0,0:41:27.46,0:41:30.80,English,,0,0,0,,So here in 2005 that the first systems use two cores
Dialogue: 0,0:41:27.46,0:41:30.80,Chinese,,0,0,0,,所以在 2005 年，出现了第一个使用两个核心的系统
Dialogue: 0,0:41:31.36,0:41:34.60,English,,0,0,0,,So now you can run two independent threads or two independent programs
Dialogue: 0,0:41:31.36,0:41:34.60,Chinese,,0,0,0,,所以你可以运行两个独立的线程或两个独立的程序
Dialogue: 0,0:41:35.30,0:41:40.10,English,,0,0,0,,And currently it's about four cores server class systems you can get eight cores
Dialogue: 0,0:41:35.30,0:41:40.10,Chinese,,0,0,0,,当前，它发展到了四核服务器级系统，你可以获得八个核心
Dialogue: 0,0:41:40.58,0:41:43.94,English,,0,0,0,,And there's even some 12 core chips
Dialogue: 0,0:41:40.58,0:41:43.94,Chinese,,0,0,0,,甚至还有 12 核芯片
Dialogue: 0,0:41:44.74,0:41:50.60,English,,0,0,0,,So in the future what's going to happen is that the the clock frequencies are going to stay fairly constant
Dialogue: 0,0:41:44.74,0:41:50.60,Chinese,,0,0,0,,因此，未来的趋势将会是时钟频率将保持相当的稳定
Dialogue: 0,0:41:50.60,0:41:54.56,English,,0,0,0,,So you can see the the cycle times are
Dialogue: 0,0:41:50.60,0:41:54.56,Chinese,,0,0,0,,你可以看到 CPU 周期时间
Dialogue: 0,0:41:55.24,0:42:00.48,English,,0,0,0,,They actually increased a little bit here and then they're slowly going down but it's generally flat
Dialogue: 0,0:41:55.24,0:42:00.48,Chinese,,0,0,0,,它们实际上在这里增加了一点，然后它们慢慢地下降，但是通常是平的
Dialogue: 0,0:42:02.20,0:42:04.78,English,,0,0,0,,And so the only way to really get more performance
Dialogue: 0,0:42:02.20,0:42:04.78,Chinese,,0,0,0,,所以真正获得更多性能的唯一途径
Dialogue: 0,0:42:04.94,0:42:07.48,English,,0,0,0,,Go forward is to increase the number of independent course
Dialogue: 0,0:42:04.94,0:42:07.48,Chinese,,0,0,0,,是增加独立核心的数量
Dialogue: 0,0:42:08.28,0:42:13.54,English,,0,0,0,,And that's just that's just the way it's got to be
Dialogue: 0,0:42:08.28,0:42:13.54,Chinese,,0,0,0,,这就是它的方式
Dialogue: 0,0:42:14.88,0:42:20.32,English,,0,0,0,,Now here in the the black circle the second line I've plotted the access time for SRAM over time
Dialogue: 0,0:42:14.88,0:42:20.32,Chinese,,0,0,0,,现在，看第二行的黑色圆圈中，我绘制了 SRAM 访问时间的发展过程
Dialogue: 0,0:42:22.24,0:42:25.54,English,,0,0,0,,And you can see that SRAM is tracking CPU pretty good
Dialogue: 0,0:42:22.24,0:42:25.54,Chinese,,0,0,0,,你可以看到 SRAM 的情况和 CPU 跟踪地非常好
Dialogue: 0,0:42:25.94,0:42:29.68,English,,0,0,0,,And it and there's it's an order of magnitude slower but
Dialogue: 0,0:42:25.94,0:42:29.68,Chinese,,0,0,0,,虽然它的速度要慢一些些
Dialogue: 0,0:42:30.12,0:42:34.22,English,,0,0,0,,It's tracking the CPU performance pretty well
Dialogue: 0,0:42:30.12,0:42:34.22,Chinese,,0,0,0,,它很好地跟上了 CPU 性能的发展
Dialogue: 0,0:42:34.72,0:42:40.92,English,,0,0,0,,DRAM, you can see there's a huge gap between the CPU and the DRAM several orders of magnitude
Dialogue: 0,0:42:34.72,0:42:40.92,Chinese,,0,0,0,,至于 DRAM，你可以看到 CPU 和 DRAM 之间存在几个数量级的巨大差距
Dialogue: 0,0:42:41.50,0:42:44.08,English,,0,0,0,,And in the last few years DRAMs have gotten a little better
Dialogue: 0,0:42:41.50,0:42:44.08,Chinese,,0,0,0,,在过去的几年里，DRAM 已经变得更好了
Dialogue: 0,0:42:44.08,0:42:49.64,English,,0,0,0,,But they've proven surprisingly difficult to to make faster
Dialogue: 0,0:42:44.08,0:42:49.64,Chinese,,0,0,0,,但也已经证明非常难以更快地速度进步了
Dialogue: 0,0:42:53.24,0:42:56.48,English,,0,0,0,,SSDs are kind of in between disks and DRAM
Dialogue: 0,0:42:53.24,0:42:56.48,Chinese,,0,0,0,,SSD 介于磁盘和 DRAM 之间
Dialogue: 0,0:42:56.48,0:43:02.44,English,,0,0,0,,And then disks up here you can see at a million nanoseconds that's the that's a millisecond
Dialogue: 0,0:42:56.48,0:43:02.44,Chinese,,0,0,0,,然后看这里的磁盘的曲线，你可以看到一百万纳秒，就是毫秒级别
Dialogue: 0,0:43:02.44,0:43:11.93,English,,0,0,0,,So you can see disks are sort of in this in this sort of millisecond range with access times
Dialogue: 0,0:43:02.44,0:43:11.93,Chinese,,0,0,0,,你可以看到磁盘的访问时间在毫秒范围
Dialogue: 0,0:43:12.30,0:43:16.46,English,,0,0,0,,And those those that they've gone down a little bit but not really too much
Dialogue: 0,0:43:12.30,0:43:16.46,Chinese,,0,0,0,,曲线下降了一点点，但还是不怎么够
Dialogue: 0,0:43:17.30,0:43:24.90,English,,0,0,0,,So the point I want to make is that there's this huge gap between DRAM  SSD disk in and CPUs
Dialogue: 0,0:43:17.30,0:43:24.90,Chinese,,0,0,0,,所以我想说的是 DRAM、SSD、磁盘和 CPU 之间存在着访问时间的巨大差距
Dialogue: 0,0:43:25.38,0:43:31.34,English,,0,0,0,,And in some cases it's even getting worse as time goes by so that's a problem right how
Dialogue: 0,0:43:25.38,0:43:31.34,Chinese,,0,0,0,,而且在某些情况下，随着时间的推移，它甚至会变得越来越糟，因此这是一个问题
Dialogue: 0,0:43:33.08,0:43:37.24,English,,0,0,0,,Our programs all need data our data is stored in memory and disk
Dialogue: 0,0:43:33.08,0:43:37.24,Chinese,,0,0,0,,我们的程序都需要数据，我们的数据存储在内存和磁盘中
Dialogue: 0,0:43:38.50,0:43:41.20,English,,0,0,0,,So if if our if our computers are getting faster
Dialogue: 0,0:43:38.50,0:43:41.20,Chinese,,0,0,0,,所以如果你的计算机变得越来越快
Dialogue: 0,0:43:41.94,0:43:47.95,English,,0,0,0,,And our storage devices are are staying relatively the same or relatively slower
Dialogue: 0,0:43:41.94,0:43:47.95,Chinese,,0,0,0,,我们的存储设备的访问速度却保持相对不变，甚至变得相对较慢
Dialogue: 0,0:43:48.42,0:43:53.16,English,,0,0,0,,Then we've got a problem right increases in in our in computer performance won't
Dialogue: 0,0:43:48.42,0:43:53.16,Chinese,,0,0,0,,然后我们就遇到了一个问题，就是我们的计算机性能实际上不会增加
Dialogue: 0,0:43:53.32,0:43:56.06,English,,0,0,0,,It'll be hard to make our programs run faster
Dialogue: 0,0:43:53.32,0:43:56.06,Chinese,,0,0,0,,很难让我们的程序运行得更快
Dialogue: 0,0:43:56.20,0:43:59.76,English,,0,0,0,,Because we'll be limited by the time it takes to to access the data
Dialogue: 0,0:43:56.20,0:43:59.76,Chinese,,0,0,0,,因为我们会受到访问数据所需时间的限制
Dialogue: 0,0:44:01.18,0:44:04.62,English,,0,0,0,,Ok so that's that that's sort of the fundamental problem that we have to deal with
Dialogue: 0,0:44:01.18,0:44:04.62,Chinese,,0,0,0,,好的，这就是我们必须处理的基本问题
Dialogue: 0,0:44:05.80,0:44:12.86,English,,0,0,0,,And it turns out that the key to bridging this this gap between the CPU and and memory
Dialogue: 0,0:44:05.80,0:44:12.86,Chinese,,0,0,0,,事实证明，弥合 CPU 和内存之间差距的关键
Dialogue: 0,0:44:13.52,0:44:18.86,English,,0,0,0,,Is this is this very basic fundamental property of programs called locality
Dialogue: 0,0:44:13.52,0:44:18.86,Chinese,,0,0,0,,是这个非常根本的程序的基本属性——程序的局部性
Dialogue: 0,0:44:19.62,0:44:25.02,English,,0,0,0,,Okay and so this is an essential sort of fundamental enduring property of programs
Dialogue: 0,0:44:19.62,0:44:25.02,Chinese,,0,0,0,,好的，这是程序的一个基本的，持久的属性
Dialogue: 0,0:44:31.60,0:44:36.28,English,,0,0,0,,So we say that so programs have this property called locality
Dialogue: 0,0:44:31.60,0:44:36.28,Chinese,,0,0,0,,所以我们说，程序有这个属性，叫做局部性
Dialogue: 0,0:44:37.22,0:44:38.96,English,,0,0,0,,And what this means is that...
Dialogue: 0,0:44:37.22,0:44:38.96,Chinese,,0,0,0,,这意味着什么......
Dialogue: 0,0:44:41.00,0:44:44.66,English,,0,0,0,,I'm sorry I'll just I have to read it because it's it's really accurate definition
Dialogue: 0,0:44:41.00,0:44:44.66,Chinese,,0,0,0,,对不起，在我给你们讲之前我只需要读一读，因为它是非常准确的定义
Dialogue: 0,0:44:44.66,0:44:53.38,English,,0,0,0,,So programs tend to use data and instructions whose addresses are near or equal to those that they have used recently
Dialogue: 0,0:44:44.66,0:44:53.38,Chinese,,0,0,0,,因此，程序倾向于使用其地址接近或等于最近使用过的数据和指令的那些数据和地址
Dialogue: 0,0:44:54.86,0:45:00.14,English,,0,0,0,,Okay so if a program access is a data item the chances are very high
Dialogue: 0,0:44:54.86,0:45:00.14,Chinese,,0,0,0,,好的，如果程序访问是一个数据项，那么
Dialogue: 0,0:45:01.06,0:45:06.78,English,,0,0,0,,That it's going to access that data item or a nearby data item sometime in the near future
Dialogue: 0,0:45:01.06,0:45:06.78,Chinese,,0,0,0,,它将在不久的将来的某个时间访问该数据项或附近的数据项的可能性非常高
Dialogue: 0,0:45:09.24,0:45:14.72,English,,0,0,0,,Okay that likelihood that the program is going to access that data item or nearby a data item In the near future
Dialogue: 0,0:45:09.24,0:45:14.72,Chinese,,0,0,0,,在不久的将来，该程序可能会访问该数据项或附近的数据项
Dialogue: 0,0:45:14.78,0:45:18.68,English,,0,0,0,,that is this property called locality
Dialogue: 0,0:45:14.78,0:45:18.68,Chinese,,0,0,0,,这个属性称为局部性
Dialogue: 0,0:45:19.74,0:45:24.90,English,,0,0,0,,So well does we just typically distinguish two two different kinds of locality
Dialogue: 0,0:45:19.74,0:45:24.90,Chinese,,0,0,0,,通常，局部性有两种不同的形式
Dialogue: 0,0:45:25.42,0:45:33.00,English,,0,0,0,,Temporal locality is the property that recently referenced items are likely to be referenced again in the near future
Dialogue: 0,0:45:25.42,0:45:33.00,Chinese,,0,0,0,,时间局部性是最近引用的存储器位置可能在不久的将来再次被引用的属性
Dialogue: 0,0:45:33.50,0:45:35.53,English,,0,0,0,,case is if so if you read a variable
Dialogue: 0,0:45:33.50,0:45:35.53,Chinese,,0,0,0,,例如，你读取了一个变量
Dialogue: 0,0:45:36.16,0:45:38.50,English,,0,0,0,,Chances are you're going to read that variable again
Dialogue: 0,0:45:36.16,0:45:38.50,Chinese,,0,0,0,,你有可能再次阅读该变量
Dialogue: 0,0:45:39.24,0:45:42.74,English,,0,0,0,,For example suppose you're summing into a variable inside of a loop
Dialogue: 0,0:45:39.24,0:45:42.74,Chinese,,0,0,0,,例如，假设你在循环内，不断累加结果到一个变量
Dialogue: 0,0:45:42.96,0:45:46.46,English,,0,0,0,,Each loop iteration you're going to access that that variable okay
Dialogue: 0,0:45:42.96,0:45:46.46,Chinese,,0,0,0,,那循环中的每一次迭代都会访问那个变量，对吧
Dialogue: 0,0:45:47.28,0:45:55.06,English,,0,0,0,,Spatial locality is that the tendency for items with nearby addresses up that
Dialogue: 0,0:45:47.28,0:45:55.06,Chinese,,0,0,0,,空间局部性是指引用临近存储器位置的倾向
Dialogue: 0,0:45:55.34,0:46:01.70,English,,0,0,0,,That items if we access if we access one item chances are high we're going to access a nearby item
Dialogue: 0,0:45:55.34,0:46:01.70,Chinese,,0,0,0,,如果我们访问了一个存储器位置，那么有很高的可能性我们在将来会访问一个临近位置
Dialogue: 0,0:46:05.86,0:46:13.46,English,,0,0,0,,Okay so let's look at this little snippet of code and see if we can identify all the different kinds of locality in this code
Dialogue: 0,0:46:05.86,0:46:13.46,Chinese,,0,0,0,,让我们看看这段代码，看看我们是否可以在此代码中识别出所有不同类型的局部性
Dialogue: 0,0:46:14.72,0:46:18.04,English,,0,0,0,,So we have two different kinds of of references there's data references
Dialogue: 0,0:46:14.72,0:46:18.04,Chinese,,0,0,0,,所以我们有两种不同类型引用，首先是数据的引用
Dialogue: 0,0:46:18.64,0:46:22.08,English,,0,0,0,,And then there's instructions right so we're reading instructions out of memory
Dialogue: 0,0:46:18.64,0:46:22.08,Chinese,,0,0,0,,然后是对数据的引用，所以我们正在读取内存中的指令
Dialogue: 0,0:46:22.36,0:46:24.22,English,,0,0,0,,And those instructions are referencing data okay
Dialogue: 0,0:46:22.36,0:46:24.22,Chinese,,0,0,0,,这些指令再引用数据
Dialogue: 0,0:46:26.96,0:46:32.70,English,,0,0,0,,So first of all notice that we're we're referencing the elements of an array in succession
Dialogue: 0,0:46:26.96,0:46:32.70,Chinese,,0,0,0,,首先要注意的是，我们在引用的数组里的元素是连续的
Dialogue: 0,0:46:33.70,0:46:36.42,English,,0,0,0,,So we're increasing i by one each time and then we're
Dialogue: 0,0:46:33.70,0:46:36.42,Chinese,,0,0,0,,所以我们每次对变量 i 增加 1
Dialogue: 0,0:46:36.76,0:46:41.20,English,,0,0,0,,So we're incrementing i through the loop and we're reading a[i]
Dialogue: 0,0:46:36.76,0:46:41.20,Chinese,,0,0,0,,循环的每一次迭代都自增变量 i，然后读取 a[i]
Dialogue: 0,0:46:42.32,0:46:45.98,English,,0,0,0,,Okay so this is called a stride-1 reference pattern the
Dialogue: 0,0:46:42.32,0:46:45.98,Chinese,,0,0,0,,好的，所以这被称为步长为 1 的引用模式
Dialogue: 0,0:46:46.66,0:46:50.82,English,,0,0,0,,The stride is how much we're incrementing this this index
Dialogue: 0,0:46:46.66,0:46:50.82,Chinese,,0,0,0,,步长是指我们将这个索引递增多少
Dialogue: 0,0:46:50.82,0:46:54.64,English,,0,0,0,,So we're since we're incrementing it by one we call that a stride one pattern
Dialogue: 0,0:46:50.82,0:46:54.64,Chinese,,0,0,0,,因为我们这里的变量i每次递增 1，所以是步长为 1 的引用模式
Dialogue: 0,0:46:55.46,0:47:05.38,English,,0,0,0,,So what kind of what kind of locality is the these repeated references to a[i]? Spatial or temporal?
Dialogue: 0,0:46:55.46,0:47:05.38,Chinese,,0,0,0,,对于 a[i] 的这些重复引用，是属于哪一种程序的局部性？空间局部性还是时间局部性？
Dialogue: 0,0:47:07.54,0:47:10.08,English,,0,0,0,,That spatial, right? Because we're accessing nearby items
Dialogue: 0,0:47:07.54,0:47:10.08,Chinese,,0,0,0,,是空间局部性，对吧？因为我们正在访问附近的存储器地址
Dialogue: 0,0:47:12.10,0:47:16.02,English,,0,0,0,,Okay what about the referencing this this variable sum inside the loop
Dialogue: 0,0:47:12.10,0:47:16.02,Chinese,,0,0,0,,好的，那对于在循环内部，不断引用 sum 这个变量
Dialogue: 0,0:47:17.00,0:47:17.96,English,,0,0,0,,That's temporal
Dialogue: 0,0:47:17.00,0:47:17.96,Chinese,,0,0,0,,就体现了程序的时间局部性
Dialogue: 0,0:47:19.48,0:47:20.84,English,,0,0,0,,Now what about instructions
Dialogue: 0,0:47:19.48,0:47:20.84,Chinese,,0,0,0,,那现在来考虑一下指令
Dialogue: 0,0:47:21.48,0:47:28.02,English,,0,0,0,,So we're referencing, where each loop iteration where reference we're executing a sequence of instructions
Dialogue: 0,0:47:21.48,0:47:28.02,Chinese,,0,0,0,,循环中的每一次迭代，我们引用的都是一系列（相同的）指令
Dialogue: 0,0:47:28.86,0:47:30.52,English,,0,0,0,,So what kind of locality is that
Dialogue: 0,0:47:28.86,0:47:30.52,Chinese,,0,0,0,,这体现了哪一种程序局部性原理？
Dialogue: 0,0:47:34.06,0:47:37.86,English,,0,0,0,,Within each loop iteration?  that's spatial, right?
Dialogue: 0,0:47:34.06,0:47:37.86,Chinese,,0,0,0,,在每个循环迭代中？是空间局部性对吧？
Dialogue: 0,0:47:37.86,0:47:42.93,English,,0,0,0,,Because we're just executing a sequence of instructions within each loop iteration
Dialogue: 0,0:47:37.86,0:47:42.93,Chinese,,0,0,0,,因为我们只是在每次循环迭代中执行一系列（相同的）指令
Dialogue: 0,0:47:43.52,0:47:45.74,English,,0,0,0,,But then we cycle through the loop repeatedly
Dialogue: 0,0:47:43.52,0:47:45.74,Chinese,,0,0,0,,但是我们反复地执行这个循环
Dialogue: 0,0:47:46.48,0:47:52.58,English,,0,0,0,,So we'll chances so each loop iteration we're going to access each of those instructions
Dialogue: 0,0:47:46.48,0:47:52.58,Chinese,,0,0,0,,因此，在每次循环迭代，我们很有可能将访问那些指令
Dialogue: 0,0:47:53.32,0:47:55.78,English,,0,0,0,,That we access the previous loop iteration right
Dialogue: 0,0:47:53.32,0:47:55.78,Chinese,,0,0,0,,每次迭代都访问上一次迭代访问过的指令
Dialogue: 0,0:47:55.94,0:47:59.58,English,,0,0,0,,So we go up we just keep at we're just going to keep executing the same
Dialogue: 0,0:47:55.94,0:47:59.58,Chinese,,0,0,0,,随着程序进行，我们只是执行相同的指令
Dialogue: 0,0:48:00.02,0:48:03.48,English,,0,0,0,,Assembly language instructions that implement this loop body
Dialogue: 0,0:48:00.02,0:48:03.48,Chinese,,0,0,0,,执行的是相同的，实现此循环体的汇编语言指令
Dialogue: 0,0:48:04.16,0:48:06.48,English,,0,0,0,,Now in this simple example it's probably this one instruction
Dialogue: 0,0:48:04.16,0:48:06.48,Chinese,,0,0,0,,现在在这个简单的例子中，它可能就是一条指令
Dialogue: 0,0:48:06.48,0:48:10.32,English,,0,0,0,,But in general your loop can have multiple instructions
Dialogue: 0,0:48:06.48,0:48:10.32,Chinese,,0,0,0,,但一般来说，你的循环可以有多个指令
Dialogue: 0,0:48:13.72,0:48:20.40,English,,0,0,0,,Now when I claim to you I'm one of the one of the main sort of points of this just this whole course
Dialogue: 0,0:48:13.72,0:48:20.40,Chinese,,0,0,0,,现在，现在我想对你们说的就是这整个课程的主要观点之一
Dialogue: 0,0:48:21.54,0:48:24.26,English,,0,0,0,,Is that as a professional programmer
Dialogue: 0,0:48:21.54,0:48:24.26,Chinese,,0,0,0,,作为一个专业的程序员
Dialogue: 0,0:48:25.24,0:48:31.84,English,,0,0,0,,It's an essential skill that that you be able to look at code and so get a qualitative sense of its locality
Dialogue: 0,0:48:25.24,0:48:31.84,Chinese,,0,0,0,,这是一项必不可少的技能，你观看代码，就可以获得对其局部性的定性认识
Dialogue: 0,0:48:32.74,0:48:36.64,English,,0,0,0,,Because as we'll see good locality turns into good performance
Dialogue: 0,0:48:32.74,0:48:36.64,Chinese,,0,0,0,,因为我们会看到，好的程序局部性带来良好的性能
Dialogue: 0,0:48:37.50,0:48:39.40,English,,0,0,0,,The way that systems are built these days
Dialogue: 0,0:48:37.50,0:48:39.40,Chinese,,0,0,0,,这就是如今系统的构建方式
Dialogue: 0,0:48:40.10,0:48:46.82,English,,0,0,0,,So as a programmer it's very important for you to be able to kind of look at code and get some qualitative sense
Dialogue: 0,0:48:40.10,0:48:46.82,Chinese,,0,0,0,,因此，作为一名程序员，能够在看到代码时获得一些定性感觉对你来说非常重要
Dialogue: 0,0:48:47.30,0:48:51.56,English,,0,0,0,,Like yeah that's pretty good locality that's terrible locality right that that's
Dialogue: 0,0:48:47.30,0:48:51.56,Chinese,,0,0,0,,就像，你可以分析出来，代码的这部分局部性非常好，这部分局部性非常差，
Dialogue: 0,0:48:52.34,0:48:55.48,English,,0,0,0,,And what you want to do is avoid the terrible locality in your code
Dialogue: 0,0:48:52.34,0:48:55.48,Chinese,,0,0,0,,你需要做的是避免代码出现差的局部性
Dialogue: 0,0:48:56.28,0:48:58.34,English,,0,0,0,,So let's look at a simple example here
Dialogue: 0,0:48:56.28,0:48:58.34,Chinese,,0,0,0,,那么让我们看一个简单的例子吧
Dialogue: 0,0:48:59.10,0:49:00.52,English,,0,0,0,,To see what I mean by this
Dialogue: 0,0:48:59.10,0:49:00.52,Chinese,,0,0,0,,一起看看我用这个例子想表达什么意思
Dialogue: 0,0:49:01.62,0:49:06.66,English,,0,0,0,,So what I'm doing is I'm taking an array a two-dimensional array a
Dialogue: 0,0:49:01.62,0:49:06.66,Chinese,,0,0,0,,所以我正在做的是我有一个二维数组 a
Dialogue: 0,0:49:07.16,0:49:09.30,English,,0,0,0,,With m rows and n columns
Dialogue: 0,0:49:07.16,0:49:09.30,Chinese,,0,0,0,,数组 a 有 m 行和 n 列
Dialogue: 0,0:49:10.98,0:49:17.04,English,,0,0,0,,And within it a doubly nested loop iterating on I and j
Dialogue: 0,0:49:10.98,0:49:17.04,Chinese,,0,0,0,,并且在双重嵌套循环中，用索引 i 和 j 来迭代
Dialogue: 0,0:49:17.30,0:49:19.07,English,,0,0,0,,I'm summing the elements of that array
Dialogue: 0,0:49:17.30,0:49:19.07,Chinese,,0,0,0,,我正在求该二维数组的所有元素的总和
Dialogue: 0,0:49:19.90,0:49:24.38,English,,0,0,0,,Okay seems this a very simple operation what could go wrong right
Dialogue: 0,0:49:19.90,0:49:24.38,Chinese,,0,0,0,,好吧，这似乎是一个非常简单的操作，怎么可能出错呢？
Dialogue: 0,0:49:26.66,0:49:36.20,English,,0,0,0,,So it turns out if you write this code to have bad locality, it will run order magnitude slower
Dialogue: 0,0:49:26.66,0:49:36.20,Chinese,,0,0,0,,实际上，如果你以使其具有较差的局部性的方式编写此代码， 则它将以慢一个数量级的速度运行
Dialogue: 0,0:49:38.12,0:49:43.56,English,,0,0,0,,Okay so if just look at this if you look at this do you think this has good locality or bad locality
Dialogue: 0,0:49:38.12,0:49:43.56,Chinese,,0,0,0,,好吧，看看这段代码，你认为这段代码的局部性是好的还是差的？
Dialogue: 0,0:49:44.14,0:49:49.36,English,,0,0,0,,Let's look at the with respect to the accesses of a
Dialogue: 0,0:49:44.14,0:49:49.36,Chinese,,0,0,0,,让我们看一下关于对数组 a 的访问
Dialogue: 0,0:49:53.42,0:49:54.20,English,,0,0,0,,Good or bad ?
Dialogue: 0,0:49:53.42,0:49:54.20,Chinese,,0,0,0,,是好是坏 ？
Dialogue: 0,0:50:00.76,0:50:04.78,English,,0,0,0,,Well so how is how is a laid out in memory right
Dialogue: 0,0:50:00.76,0:50:04.78,Chinese,,0,0,0,,数组 a 在内存中是如何布局的呢？
Dialogue: 0,0:50:05.96,0:50:11.38,English,,0,0,0,,It's row wise all right so see uses used lays out a raised row wise
Dialogue: 0,0:50:05.96,0:50:11.38,Chinese,,0,0,0,,是行优先的，对吧？数组是以行优先顺序来存储的
Dialogue: 0,0:50:11.38,0:50:16.06,English,,0,0,0,,So the first all the elements of the first row followed by all the elements
Dialogue: 0,0:50:11.38,0:50:16.06,Chinese,,0,0,0,,首先是第一行的所有元素
Dialogue: 0,0:50:16.06,0:50:19.14,English,,0,0,0,,Of the second row followed by all the elements of the third row
Dialogue: 0,0:50:16.06,0:50:19.14,Chinese,,0,0,0,,然后跟着第二行的所有元素，之后是第三行的所有元素
Dialogue: 0,0:50:21.08,0:50:23.28,English,,0,0,0,,Okay so how are we accessing this array
Dialogue: 0,0:50:21.08,0:50:23.28,Chinese,,0,0,0,,好的，我们如何访问这个数组
Dialogue: 0,0:50:23.28,0:50:30.42,English,,0,0,0,,Look at we're accessing a[i][j] and we're varying j the fastest
Dialogue: 0,0:50:23.28,0:50:30.42,Chinese,,0,0,0,,看看我们正在访问 a[i][j]，我们正在以最快的速度改变 j
Dialogue: 0,0:50:30.44,0:50:33.42,English,,0,0,0,,So we hold i constant and then we vary j
Dialogue: 0,0:50:30.44,0:50:33.42,Chinese,,0,0,0,,所以我们保持 i 不变，然后我们改变 j
Dialogue: 0,0:50:33.94,0:50:38.32,English,,0,0,0,,And then we access all so we hold the I constant to access row i
Dialogue: 0,0:50:33.94,0:50:38.32,Chinese,,0,0,0,,然后我们访问所有这一行的元素，所以我们保持 i 不变来访问第 i 行
Dialogue: 0,0:50:39.10,0:50:43.44,English,,0,0,0,,And then we vary j to access all the columns in that row
Dialogue: 0,0:50:39.10,0:50:43.44,Chinese,,0,0,0,,然后我们改变 j 来访问该行中的所有列
Dialogue: 0,0:50:44.76,0:50:51.06,English,,0,0,0,,Okay so each each hitter and then we increase and then we go back and increase i
Dialogue: 0,0:50:44.76,0:50:51.06,Chinese,,0,0,0,,好的，然后我们回去增加 i
Dialogue: 0,0:50:52.60,0:50:54.46,English,,0,0,0,,So now we're accessing the next row
Dialogue: 0,0:50:52.60,0:50:54.46,Chinese,,0,0,0,,所以现在我们正在访问下一行
Dialogue: 0,0:50:56.92,0:51:04.34,English,,0,0,0,,Okay so if we were to look at the addresses of a[i][j], the sequence of addresses  that are being read
Dialogue: 0,0:50:56.92,0:51:04.34,Chinese,,0,0,0,,好的，如果我们查看 a[i][j] 的地址，查看正在被读取的地址的序列
Dialogue: 0,0:51:05.34,0:51:12.78,English,,0,0,0,,Those would correspond to a stride one access and so we'd be accessing all the elements of a sequentially in order
Dialogue: 0,0:51:05.34,0:51:12.78,Chinese,,0,0,0,,这个序列符合于步长为 1 的引用模式，因此我们将依次按顺序访问所有元素
Dialogue: 0,0:51:13.86,0:51:18.48,English,,0,0,0,,Okay so that's really good spatial locality right that's the best you can do
Dialogue: 0,0:51:13.86,0:51:18.48,Chinese,,0,0,0,,好吧，这是非常好的空间局部性，这是你能做到的最好
Dialogue: 0,0:51:19.68,0:51:25.77,English,,0,0,0,,Now what about and then we have temporal locality on sum so that's good
Dialogue: 0,0:51:19.68,0:51:25.77,Chinese,,0,0,0,,现在，对于变量 sum 来说，有很好的时间局部性，所以这是好的
Dialogue: 0,0:51:26.66,0:51:30.54,English,,0,0,0,,Right so everything about this is pretty good so this is the good case
Dialogue: 0,0:51:26.66,0:51:30.54,Chinese,,0,0,0,,对，所以这个程序的局部性都很好，所以这是好的情况
Dialogue: 0,0:51:32.36,0:51:36.06,English,,0,0,0,,Now what about this what I've done I've taken the same program
Dialogue: 0,0:51:32.36,0:51:36.06,Chinese,,0,0,0,,那这个呢，我将上一个相同的程序
Dialogue: 0,0:51:37.16,0:51:45.22,English,,0,0,0,,And I've just inverted the loops so it's a loop on j first and then on i
Dialogue: 0,0:51:37.16,0:51:45.22,Chinese,,0,0,0,,我只是颠倒了循环的顺序，它首先在 j 上循环，然后在 i 上循环
Dialogue: 0,0:51:45.82,0:51:47.90,English,,0,0,0,,And then I just have the same inner loop body
Dialogue: 0,0:51:45.82,0:51:47.90,Chinese,,0,0,0,,然后内部循环体是相同的
Dialogue: 0,0:51:52.26,0:51:57.54,English,,0,0,0,,Now what does that do to this what does that do to the spatial locality of our accesses okay
Dialogue: 0,0:51:52.26,0:51:57.54,Chinese,,0,0,0,,现在，这对我们访存的空间局部性有了什么影响呢？
Dialogue: 0,0:51:57.96,0:52:00.00,English,,0,0,0,,-Yes -Terrible special locality
Dialogue: 0,0:51:57.96,0:52:00.00,Chinese,,0,0,0,,学生：非常糟糕的空间局部性
Dialogue: 0,0:52:00.00,0:52:06.04,English,,0,0,0,,Terrible! Because it's going, you should be offended when you see this, this is awful
Dialogue: 0,0:52:00.00,0:52:06.04,Chinese,,0,0,0,,非常糟糕！对，你看到这段代码的时候应该觉得被冒犯了，简直糟糕透了
Dialogue: 0,0:52:07.60,0:52:10.24,English,,0,0,0,,But it's terrible right? Because look it
Dialogue: 0,0:52:07.60,0:52:10.24,Chinese,,0,0,0,,很糟糕，对吧？因为看起来
Dialogue: 0,0:52:11.06,0:52:14.03,English,,0,0,0,,So we're now we're holding j
Dialogue: 0,0:52:11.06,0:52:14.03,Chinese,,0,0,0,,所以我们现在做的事情就是
Dialogue: 0,0:52:14.84,0:52:21.44,English,,0,0,0,,We're holding j constant and then we're iterating through the j-th element of each row so that's skipping
Dialogue: 0,0:52:14.84,0:52:21.44,Chinese,,0,0,0,,我们保持 j 不变，然后我们遍历每一行的第 j 个元素，这是在内存中跳跃
Dialogue: 0,0:52:23.16,0:52:29.90,English,,0,0,0,,We have n we have n elements in each row so we're doing a stride n access through memory
Dialogue: 0,0:52:23.16,0:52:29.90,Chinese,,0,0,0,,我们在每行中都有 n 个元素，因此我们是以步长为 n 的模式来对内存进行访问
Dialogue: 0,0:52:30.68,0:52:31.96,English,,0,0,0,,So we're going like this
Dialogue: 0,0:52:30.68,0:52:31.96,Chinese,,0,0,0,,所以我们就像是这样
Dialogue: 0,0:52:33.38,0:52:38.48,English,,0,0,0,,And then we're incrementing then we're looking then we're incrementing the column by one and then we're doing this again
Dialogue: 0,0:52:33.38,0:52:38.48,Chinese,,0,0,0,,访问一个数，然后将列递增 1，然后我们再次这样做（步长为 n 的访问模式）
Dialogue: 0,0:52:39.46,0:52:43.60,English,,0,0,0,,So it's terrible spatial locality this is the worst spatial locality we could get
Dialogue: 0,0:52:39.46,0:52:43.60,Chinese,,0,0,0,,所以这是一个糟糕的空间局部性，这是我们可以获得的最差的空间局部性
Dialogue: 0,0:52:48.30,0:52:50.22,English,,0,0,0,,Now let's look at a three dimensional array
Dialogue: 0,0:52:48.30,0:52:50.22,Chinese,,0,0,0,,现在让我们来看一个三维数组
Dialogue: 0,0:52:52.24,0:52:54.76,English,,0,0,0,,And let me ask you that let me post the following question
Dialogue: 0,0:52:52.24,0:52:54.76,Chinese,,0,0,0,,我现在提出以下问题
Dialogue: 0,0:52:55.54,0:52:59.46,English,,0,0,0,,Can you based on this sort of qualitative idea that
Dialogue: 0,0:52:55.54,0:52:59.46,Chinese,,0,0,0,,你能否基于这种定性观念
Dialogue: 0,0:53:00.14,0:53:04.24,English,,0,0,0,,This idea that you want you want to try to get a stride one reference pattern
Dialogue: 0,0:53:00.14,0:53:04.24,Chinese,,0,0,0,,这个观念是你最好需要尝试使用步长为 1 的访问模式
Dialogue: 0,0:53:05.34,0:53:11.40,English,,0,0,0,,Okay so how would you permute these given this inner body
Dialogue: 0,0:53:05.34,0:53:11.40,Chinese,,0,0,0,,给出这个循环体，你要怎么置换
Dialogue: 0,0:53:12.48,0:53:19.38,English,,0,0,0,,a[k][i][j] how would you permute these loop indices to give stride one reference pattern
Dialogue: 0,0:53:12.48,0:53:19.38,Chinese,,0,0,0,,a[k][i][j]，你要如何置换循环的顺序，使它满足步长为 1 的引用模式
Dialogue: 0,0:53:23.46,0:53:26.08,English,,0,0,0,,Okay that's right, kij is right
Dialogue: 0,0:53:23.46,0:53:26.08,Chinese,,0,0,0,,好吧，这是正确的，循环的先后次序应该是 k、i、j
Dialogue: 0,0:53:26.60,0:53:30.28,English,,0,0,0,,So what in general we want to do is we want to go going from right to left
Dialogue: 0,0:53:26.60,0:53:30.28,Chinese,,0,0,0,,所以通常我们想做的是要从右到左
Dialogue: 0,0:53:31.22,0:53:34.94,English,,0,0,0,,We want we want those indices to be changing the fastest
Dialogue: 0,0:53:31.22,0:53:34.94,Chinese,,0,0,0,,我们希望右边的这些索引变化是最快的
Dialogue: 0,0:53:35.12,0:53:40.38,English,,0,0,0,,So we want j .. we want k and i to be held constant and then we want to change j
Dialogue: 0,0:53:35.12,0:53:40.38,Chinese,,0,0,0,,我们希望 k 和 i 保持不变，然后我们想先要改变 j
Dialogue: 0,0:53:41.10,0:53:46.24,English,,0,0,0,,Then we want to increment i and then for that value that those values of k and i
Dialogue: 0,0:53:41.10,0:53:46.24,Chinese,,0,0,0,,然后再增加 i，然后再增加 k
Dialogue: 0,0:53:46.24,0:53:51.07,English,,0,0,0,,We want to want to sequence through all the the values of j again
Dialogue: 0,0:53:46.24,0:53:51.07,Chinese,,0,0,0,,我们想要按照顺序来访问所有的 j 值
Dialogue: 0,0:53:51.86,0:53:52.52,English,,0,0,0,,Okay
Dialogue: 0,0:53:51.86,0:53:52.52,Chinese,,0,0,0,,好的
Dialogue: 0,0:53:56.41,0:54:01.92,English,,0,0,0,,Okay so we've looked at properties of technology of storage technologies
Dialogue: 0,0:53:56.41,0:54:01.92,Chinese,,0,0,0,,好的，我们已经研究了一些存储技术的技术属性
Dialogue: 0,0:54:03.18,0:54:08.84,English,,0,0,0,,And well we and there's this sort of basic sort of fundamental principle that cheaper storage
Dialogue: 0,0:54:03.18,0:54:08.84,Chinese,,0,0,0,,我们得到了这种基本原则，即更便宜的存储设备……
Dialogue: 0,0:54:09.36,0:54:13.88,English,,0,0,0,,You bigger storage higher capacity storage is cheaper
Dialogue: 0,0:54:09.36,0:54:13.88,Chinese,,0,0,0,,……存储容量越大的存储设备，越便宜
Dialogue: 0,0:54:15.82,0:54:19.22,English,,0,0,0,,More expensive storage is smaller
Dialogue: 0,0:54:15.82,0:54:19.22,Chinese,,0,0,0,,更昂贵的存储设备，其存储空间会设计得更小
Dialogue: 0,0:54:19.72,0:54:22.16,English,,0,0,0,,Because we just don't have that we don't we can't spend enough money
Dialogue: 0,0:54:19.72,0:54:22.16,Chinese,,0,0,0,,因为我们不能花太多的钱
Dialogue: 0,0:54:25.46,0:54:31.66,English,,0,0,0,,There's this gap there's this gap between our storage devices and the CPU
Dialogue: 0,0:54:25.46,0:54:31.66,Chinese,,0,0,0,,我们的存储设备和 CPU 之间存在这种访问速度的差距
Dialogue: 0,0:54:32.86,0:54:36.08,English,,0,0,0,,That is in at least in the case of disks are getting bigger
Dialogue: 0,0:54:32.86,0:54:36.08,Chinese,,0,0,0,,至少在磁盘容量变得越来越大的情况下
Dialogue: 0,0:54:38.02,0:54:40.62,English,,0,0,0,,And we have programs that exhibit locality
Dialogue: 0,0:54:38.02,0:54:40.62,Chinese,,0,0,0,,但好在，程序具有局部性这个原理
Dialogue: 0,0:54:41.98,0:54:48.34,English,,0,0,0,,Okay so these three things these properties of storage technologies
Dialogue: 0,0:54:41.98,0:54:48.34,Chinese,,0,0,0,,好的，这三件事，即存储技术的这些特性
Dialogue: 0,0:54:48.64,0:54:50.50,English,,0,0,0,,And properties of our programs
Dialogue: 0,0:54:48.64,0:54:50.50,Chinese,,0,0,0,,和我们的程序的局部性属性
Dialogue: 0,0:54:50.94,0:54:58.18,English,,0,0,0,,Complement each other in this beautiful way to suggest and inform the design of our storage systems
Dialogue: 0,0:54:50.94,0:54:58.18,Chinese,,0,0,0,,相互补充得非常完美，为人们提供一种设计怎样存储系统的建议和信息
Dialogue: 0,0:54:58.82,0:55:01.84,English,,0,0,0,,And this design is something called a memory hierarchy
Dialogue: 0,0:54:58.82,0:55:01.84,Chinese,,0,0,0,,这种设计被称为存储器层次结构
Dialogue: 0,0:55:03.96,0:55:05.98,English,,0,0,0,,Okay here's the idea of a memory hierarchy
Dialogue: 0,0:55:03.96,0:55:05.98,Chinese,,0,0,0,,好的，这是就是存储器层次结构的概念
Dialogue: 0,0:55:07.92,0:55:12.74,English,,0,0,0,,You layer instead of a flat memory system you now
Dialogue: 0,0:55:07.92,0:55:12.74,Chinese,,0,0,0,,你将内存系统分层设计，而不是单一的平层
Dialogue: 0,0:55:13.04,0:55:16.16,English,,0,0,0,,You create your memory system as a hierarchy of devices
Dialogue: 0,0:55:13.04,0:55:16.16,Chinese,,0,0,0,,将存储器系统设计为存储设备的层次结构
Dialogue: 0,0:55:17.84,0:55:20.82,English,,0,0,0,,And at the top of the at the top of this hierarchy
Dialogue: 0,0:55:17.84,0:55:20.82,Chinese,,0,0,0,,在这个层次结构的顶部
Dialogue: 0,0:55:21.54,0:55:25.94,English,,0,0,0,,You have your smaller faster and more expensive storage devices
Dialogue: 0,0:55:21.54,0:55:25.94,Chinese,,0,0,0,,你拥有存储容量较小，访问速度更快，但也更昂贵的存储设备
Dialogue: 0,0:55:25.94,0:55:28.62,English,,0,0,0,,So at the very top you have registers
Dialogue: 0,0:55:25.94,0:55:28.62,Chinese,,0,0,0,,所以在最顶层的是寄存器
Dialogue: 0,0:55:29.56,0:55:35.50,English,,0,0,0,,Which are which can be accessed and within one cycle right one instruction
Dialogue: 0,0:55:29.56,0:55:35.50,Chinese,,0,0,0,,寄存器在每一个 CPU 周期，每执行一条指令都可以被访问
Dialogue: 0,0:55:36.76,0:55:40.46,English,,0,0,0,,While that instructions executing can access read and write into a register
Dialogue: 0,0:55:36.76,0:55:40.46,Chinese,,0,0,0,,指令执行期间可以读写寄存器
Dialogue: 0,0:55:41.16,0:55:43.74,English,,0,0,0,,Okay so registers are at the top of the hierarchy
Dialogue: 0,0:55:41.16,0:55:43.74,Chinese,,0,0,0,,所以寄存器是位于存储器层次结构的顶部
Dialogue: 0,0:55:44.46,0:55:47.36,English,,0,0,0,,But because those are in custom silicon they're very expensive right
Dialogue: 0,0:55:44.46,0:55:47.36,Chinese,,0,0,0,,但由于这些都是定制芯片，因此它们非常昂贵
Dialogue: 0,0:55:47.36,0:55:51.50,English,,0,0,0,,The fabrication plants to make processors cost billions of dollars
Dialogue: 0,0:55:47.36,0:55:51.50,Chinese,,0,0,0,,生产处理器的制造工厂耗资数十亿美元
Dialogue: 0,0:55:52.16,0:55:53.98,English,,0,0,0,,Okay so this is the most expensive and
Dialogue: 0,0:55:52.16,0:55:53.98,Chinese,,0,0,0,,好的，所以这是最贵的
Dialogue: 0,0:55:54.60,0:55:59.56,English,,0,0,0,,Because of that it's also the smallest we've only got 16 registers at the top of the hierarchy
Dialogue: 0,0:55:54.60,0:55:59.56,Chinese,,0,0,0,,因为它的容量也是最小的，我们在层次结构的顶部只有 16 个寄存器
Dialogue: 0,0:56:00.60,0:56:07.00,English,,0,0,0,,Now below that we put one or more SRAM memories remember SRAM is faster
Dialogue: 0,0:56:00.60,0:56:07.00,Chinese,,0,0,0,,在接下来一层是一个或多个 SRAM，SRAM 是更快的一种内存
Dialogue: 0,0:56:08.46,0:56:10.02,English,,0,0,0,,It's the fastest kind of memory
Dialogue: 0,0:56:08.46,0:56:10.02,Chinese,,0,0,0,,SRAM 是更快的一种内存
Dialogue: 0,0:56:10.02,0:56:16.16,English,,0,0,0,,So we put one or more so-called caches cache memories built out of SRAM
Dialogue: 0,0:56:10.02,0:56:16.16,Chinese,,0,0,0,,我们设置一个或多个所谓的高速缓存存储器，是使用 SRAM 制作的
Dialogue: 0,0:56:16.78,0:56:18.80,English,,0,0,0,,in the processor chip itself
Dialogue: 0,0:56:16.78,0:56:18.80,Chinese,,0,0,0,,这也是在处理器芯片内部的
Dialogue: 0,0:56:23.44,0:56:30.82,English,,0,0,0,,And then and these caches because they're made out of SRAM they're on the order of megabytes in size
Dialogue: 0,0:56:23.44,0:56:30.82,Chinese,,0,0,0,,这些缓存，因为它们是由 SRAM 制成的，它们的大小是兆字节（单位为 MB）
Dialogue: 0,0:56:31.18,0:56:34.38,English,,0,0,0,,Okay they're much bigger than registers but they're they're megabytes
Dialogue: 0,0:56:31.18,0:56:34.38,Chinese,,0,0,0,,它们比寄存器大得多，但它们也只是兆字节这么大
Dialogue: 0,0:56:35.94,0:56:39.86,English,,0,0,0,,Okay which if we look and then beneath that is our
Dialogue: 0,0:56:35.94,0:56:39.86,Chinese,,0,0,0,,再接下来一层就是
Dialogue: 0,0:56:40.10,0:56:47.08,English,,0,0,0,,Main memory which is built out of DRAMs and those can be gigabytes, tens of gigabytes on modern systems
Dialogue: 0,0:56:40.10,0:56:47.08,Chinese,,0,0,0,,再接下来一层就是 DRAM 所做的主存，主存在现代系统中可以有十几个 GB 的大小
Dialogue: 0,0:56:47.92,0:56:49.84,English,,0,0,0,,And then below that is our local disks
Dialogue: 0,0:56:47.92,0:56:49.84,Chinese,,0,0,0,,再接下来一层就是磁盘
Dialogue: 0,0:56:50.68,0:56:57.08,English,,0,0,0,,And we can even have lower layers like web servers that are storing you know for storing stuff on google
Dialogue: 0,0:56:50.68,0:56:57.08,Chinese,,0,0,0,,我们甚至可以把像网络服务器这样的东西认为是更低的一层，例如在谷歌上存储的东西
Dialogue: 0,0:56:57.76,0:57:01.38,English,,0,0,0,,That you can think of that as just part of our our hierarchy
Dialogue: 0,0:56:57.76,0:57:01.38,Chinese,,0,0,0,,你可以将其视为我们存储器层次结构的一部分
Dialogue: 0,0:57:02.60,0:57:06.90,English,,0,0,0,,Now here's the here's the key idea and a higher in a in a memory hierarchy
Dialogue: 0,0:57:02.60,0:57:06.90,Chinese,,0,0,0,,现在要介绍一个这里是关键点，在存储器层次结构中
Dialogue: 0,0:57:07.92,0:57:14.89,English,,0,0,0,,Each level in this hierarchy holds data that's retrieved from the next lower level
Dialogue: 0,0:57:07.92,0:57:14.89,Chinese,,0,0,0,,存储器层次结构中的每一层都包含从下一个较低级别层次所检索的数据
Dialogue: 0,0:57:15.56,0:57:21.24,English,,0,0,0,,Okay so caches hold registers hold data that's that's stored in the l1 cache
Dialogue: 0,0:57:15.56,0:57:21.24,Chinese,,0,0,0,,好的，CPU 寄存器保存着从 L1 高速缓存中取出的数据
Dialogue: 0,0:57:22.12,0:57:30.00,English,,0,0,0,,The L1 cache holds data that's retrieved from the L2 cache the L3 cache holds data  that's restored
Dialogue: 0,0:57:22.12,0:57:30.00,Chinese,,0,0,0,,L1 高速缓存保存从 L2 高速缓存中检索的数据
Dialogue: 0,0:57:30.70,0:57:37.48,English,,0,0,0,,That's that's retrieved from main memory, main memory holds data that's retrieved from secondary disk and so on
Dialogue: 0,0:57:30.70,0:57:37.48,Chinese,,0,0,0,,L3 高速缓存从主存从取出数据，主存又保存着从磁盘取得的数据，依此类推
Dialogue: 0,0:57:39.46,0:57:44.10,English,,0,0,0,,Now as we'll see the that the reason memory systems are designed like this
Dialogue: 0,0:57:39.46,0:57:44.10,Chinese,,0,0,0,,内存系统设计如此的原因
Dialogue: 0,0:57:45.22,0:57:48.22,English,,0,0,0,,Is that they when you have this kind of system
Dialogue: 0,0:57:45.22,0:57:48.22,Chinese,,0,0,0,,当你拥有这种系统时
Dialogue: 0,0:57:50.68,0:57:59.28,English,,0,0,0,,This you can access in general you can access your data at the speed of the fastest item in the...
Dialogue: 0,0:57:50.68,0:57:59.28,Chinese,,0,0,0,,一般来说，在层次结构的顶部，你可以以最快的方式来访问内存
Dialogue: 0,0:57:59.74,0:58:01.20,English,,0,0,0,,And at the top of the hierarchy
Dialogue: 0,0:57:59.74,0:58:01.20,Chinese,,0,0,0,,一般来说，在层次结构的顶部，你可以以最快的方式来访问内存
Dialogue: 0,0:58:01.66,0:58:02.76,English,,0,0,0,,So that's the fastest
Dialogue: 0,0:58:01.66,0:58:02.76,Chinese,,0,0,0,,所以这是最快的
Dialogue: 0,0:58:03.66,0:58:08.80,English,,0,0,0,,But with the cost of the storage at the lower part of the hierarchy
Dialogue: 0,0:58:03.66,0:58:08.80,Chinese,,0,0,0,,但是在层次结构的较低层，访问速度较慢
Dialogue: 0,0:58:10.94,0:58:14.92,English,,0,0,0,,Okay so this this works all because of an idea called caching
Dialogue: 0,0:58:10.94,0:58:14.92,Chinese,,0,0,0,,好的，所以这一切都有效，因为一个叫做缓存的想法
Dialogue: 0,0:58:16.92,0:58:23.28,English,,0,0,0,,So a cache and ... to took to a computer scientist is a
Dialogue: 0,0:58:16.92,0:58:23.28,Chinese,,0,0,0,,所以缓存对计算机科学家来说
Dialogue: 0,0:58:23.70,0:58:32.00,English,,0,0,0,,It's a smaller faster storage device that acts as a staging area for the data in a larger slower device
Dialogue: 0,0:58:23.70,0:58:32.00,Chinese,,0,0,0,,它是一个更小的更快的存储设备，充当更慢的设备中的数据的暂存区域
Dialogue: 0,0:58:32.04,0:58:38.00,English,,0,0,0,,So just like like here you can think of your main memory is a cache for data
Dialogue: 0,0:58:32.04,0:58:38.00,Chinese,,0,0,0,,所以就像在这里一样，你可以把你的主存认为是存储在磁盘上的数据的缓存
Dialogue: 0,0:58:38.00,0:58:41.58,English,,0,0,0,,That's stored on disk right you read memory from disk and then you store it in main memory
Dialogue: 0,0:58:38.00,0:58:41.58,Chinese,,0,0,0,,你从磁盘读取数据，然后将其存储在主存中
Dialogue: 0,0:58:42.38,0:58:44.84,English,,0,0,0,,Okay you can think of the main memory as a staging area
Dialogue: 0,0:58:42.38,0:58:44.84,Chinese,,0,0,0,,对吧，你可以把主存储器想象成一个临时区域
Dialogue: 0,0:58:46.50,0:58:52.20,English,,0,0,0,,So once you get the data from the disk you don't access it again on the disk you access it in memory which is much faster
Dialogue: 0,0:58:46.50,0:58:52.20,Chinese,,0,0,0,,一旦从磁盘获取数据，就不会再在磁盘上访问它，而是在内存中访问它，速度要快得多
Dialogue: 0,0:58:52.68,0:58:55.42,English,,0,0,0,,Ok so this idea propagates all the way up the hierarchy
Dialogue: 0,0:58:52.68,0:58:55.42,Chinese,,0,0,0,,好的，这个想法一直在层次结构中传播
Dialogue: 0,0:58:59.32,0:59:02.62,English,,0,0,0,,Okay so we you can think of a cache on
Dialogue: 0,0:58:59.32,0:59:02.62,Chinese,,0,0,0,,好的，我们可以这么想象缓存
Dialogue: 0,0:59:03.92,0:59:11.28,English,,0,0,0,,One way to think of a cache is imagine your backpack when you're getting ready to come to school in the morning
Dialogue: 0,0:59:03.92,0:59:11.28,Chinese,,0,0,0,,可以通过想象你的背包来比喻缓存，当你早上要来上学的时候
Dialogue: 0,0:59:11.94,0:59:15.02,English,,0,0,0,,So you're in your apartment which is kind of far away from school
Dialogue: 0,0:59:11.94,0:59:15.02,Chinese,,0,0,0,,比如你的公寓离学校有点远
Dialogue: 0,0:59:16.40,0:59:20.24,English,,0,0,0,,So before you come into school you take items from from your house
Dialogue: 0,0:59:16.40,0:59:20.24,Chinese,,0,0,0,,所以在你上学之前，你要带一些东西
Dialogue: 0,0:59:20.72,0:59:23.02,English,,0,0,0,,And you put them in your backpack right
Dialogue: 0,0:59:20.72,0:59:23.02,Chinese,,0,0,0,,你把它们放在你的背包里
Dialogue: 0,0:59:24.08,0:59:28.92,English,,0,0,0,,Then you come to school if you need those items you get there in your backpack
Dialogue: 0,0:59:24.08,0:59:28.92,Chinese,,0,0,0,,你背着包来上学，然后如果你需要用到那些东西你就从背包中拿出来
Dialogue: 0,0:59:29.56,0:59:30.92,English,,0,0,0,,You know if you didn't do that
Dialogue: 0,0:59:29.56,0:59:30.92,Chinese,,0,0,0,,如果你不这样做
Dialogue: 0,0:59:31.20,0:59:35.88,English,,0,0,0,,Every time you needed something you'd have to walk back home and get it  and then walk back to school
Dialogue: 0,0:59:31.20,0:59:35.88,Chinese,,0,0,0,,每次你需要用到某样东西，你都必须走回家拿，然后再带回学校
Dialogue: 0,0:59:36.44,0:59:41.24,English,,0,0,0,,All right so it's so the idea of caching is very you know it's a very familiar kind of simple notion
Dialogue: 0,0:59:36.44,0:59:41.24,Chinese,,0,0,0,,好吧所以这就是缓存的概念，你知道它是一种非常熟悉的简单概念
Dialogue: 0,0:59:41.58,0:59:47.28,English,,0,0,0,,But it turns out to be quite powerful and it shows up in all parts of computer systems
Dialogue: 0,0:59:41.58,0:59:47.28,Chinese,,0,0,0,,但事实证明它非常强大，并且它出现在计算机系统的所有部分中
Dialogue: 0,0:59:50.56,0:59:54.44,English,,0,0,0,,Okay so so what we say is that for each level k in the hierarchy
Dialogue: 0,0:59:50.56,0:59:54.44,Chinese,,0,0,0,,对于存储器层次结构中的每一层，我们现在设为第 k 层
Dialogue: 0,0:59:55.08,0:59:58.94,English,,0,0,0,,The the faster, smaller device at level k serves as a cache
Dialogue: 0,0:59:55.08,0:59:58.94,Chinese,,0,0,0,,第 k 层的，更快更小的存储设备，都是缓存
Dialogue: 0,0:59:59.50,1:00:02.67,English,,0,0,0,,For the larger slower device at level k+1
Dialogue: 0,0:59:59.50,1:00:02.67,Chinese,,0,0,0,,都是对于第 k + 1 级较大较慢的存储设备的缓存
Dialogue: 0,1:00:03.26,1:00:07.46,English,,0,0,0,,And remember our our levels go from so l0 is the highest
Dialogue: 0,1:00:03.26,1:00:07.46,Chinese,,0,0,0,,要记住，体系的层次中从 L0 开始是最高的
Dialogue: 0,1:00:07.46,1:00:10.60,English,,0,0,0,,So this the smallest lowest level is actually the highest
Dialogue: 0,1:00:07.46,1:00:10.60,Chinese,,0,0,0,,所以这个最小的数字实际上是最高的级别
Dialogue: 0,1:00:11.56,1:00:15.36,English,,0,0,0,,The further step in the ... in the hierarchy and as we increase the levels
Dialogue: 0,1:00:11.56,1:00:15.36,Chinese,,0,0,0,,层次结构中每进一步，我们提高级别
Dialogue: 0,1:00:15.84,1:00:17.60,English,,0,0,0,,We're going down the hierarchy
Dialogue: 0,1:00:15.84,1:00:17.60,Chinese,,0,0,0,,在层次结构中不断深入
Dialogue: 0,1:00:20.44,1:00:25.22,English,,0,0,0,,Now why do they work so this is this is a really fundamental idea
Dialogue: 0,1:00:20.44,1:00:25.22,Chinese,,0,0,0,,现在他们为什么这么做，所以这是一个非常基本的想法
Dialogue: 0,1:00:25.88,1:00:27.42,English,,0,0,0,,They work because of locality
Dialogue: 0,1:00:25.88,1:00:27.42,Chinese,,0,0,0,,这个结构之所以有效就是由于程序的局部性原理
Dialogue: 0,1:00:28.84,1:00:34.72,English,,0,0,0,,So because of locality programs tend to access data that's stored at level k
Dialogue: 0,1:00:28.84,1:00:34.72,Chinese,,0,0,0,,由于局部性原理，程序倾向于访问存储在第 k 层的数据
Dialogue: 0,1:00:36.28,1:00:39.32,English,,0,0,0,,More often than they access data at level k+1 o
Dialogue: 0,1:00:36.28,1:00:39.32,Chinese,,0,0,0,,比访问第 k + 1 级的数据更常见
Dialogue: 0,1:00:41.06,1:00:43.86,English,,0,0,0,,Okay so if we access an item at level +1
Dialogue: 0,1:00:41.06,1:00:43.86,Chinese,,0,0,0,,好的，如果我们访问第 k + 1 层存储单元
Dialogue: 0,1:00:44.82,1:00:50.35,English,,0,0,0,,We can move it up to level k chances are because of locality we're going to access it again
Dialogue: 0,1:00:44.82,1:00:50.35,Chinese,,0,0,0,,我们会将其拷贝到第 k 层，因为我们很有可能将再次访问它
Dialogue: 0,1:00:51.26,1:01:01.30,English,,0,0,0,,Okay so now we're accessing the data at level k multiple times at the rate at the speed of level k
Dialogue: 0,1:00:51.26,1:01:01.30,Chinese,,0,0,0,,好的，现在我们以第 k 层的设备访问速度，多次访问第 k 层的数据
Dialogue: 0,1:01:01.44,1:01:03.74,English,,0,0,0,,Okay not at the speed of level k plus one okay so that's
Dialogue: 0,1:01:01.44,1:01:03.74,Chinese,,0,0,0,,而不是以第 k + 1 层的速度
Dialogue: 0,1:01:04.60,1:01:08.48,English,,0,0,0,,That's the fun the fundal fundamental idea
Dialogue: 0,1:01:04.60,1:01:08.48,Chinese,,0,0,0,,这就是这个层次结构概念的有趣之处
Dialogue: 0,1:01:08.60,1:01:12.46,English,,0,0,0,,And because we're not accessing data at level k+1 as often
Dialogue: 0,1:01:08.60,1:01:12.46,Chinese,,0,0,0,,而且因为我们不经常访问第 k + 1 层的数据
Dialogue: 0,1:01:12.76,1:01:18.14,English,,0,0,0,,We can afford to use slower storage devices which are cheaper
Dialogue: 0,1:01:12.76,1:01:18.14,Chinese,,0,0,0,,我们可以负担得起使用更便宜的速度较慢的存储设备
Dialogue: 0,1:01:20.80,1:01:24.22,English,,0,0,0,,In this and thus we c0an make them bigger and cheaper per bit
Dialogue: 0,1:01:20.80,1:01:24.22,Chinese,,0,0,0,,在这方面，因此我们可以使它们容量更大，存储每比特的价格更便宜
Dialogue: 0,1:01:26.30,1:01:29.98,English,,0,0,0,,So what this does is the hierarchy creates a a large pool of storage
Dialogue: 0,1:01:26.30,1:01:29.98,Chinese,,0,0,0,,层次结构创建了一个大型存储池
Dialogue: 0,1:01:30.06,1:01:33.06,English,,0,0,0,,That's roughly about the size of the lowest level
Dialogue: 0,1:01:30.06,1:01:33.06,Chinese,,0,0,0,,其存储容量大小大约等于最底层存储设备的大小
Dialogue: 0,1:01:34.42,1:01:37.10,English,,0,0,0,,That can be accessed at the speed at the highest level
Dialogue: 0,1:01:34.42,1:01:37.10,Chinese,,0,0,0,,却可以以最高层存储设备的速度来访问
Dialogue: 0,1:01:41.88,1:01:45.60,English,,0,0,0,,All right let's let's look at how caching works in a general way
Dialogue: 0,1:01:41.88,1:01:45.60,Chinese,,0,0,0,,好吧让我们来看看缓存的一般方式工作
Dialogue: 0,1:01:46.34,1:01:51.20,English,,0,0,0,,And then we'll see on thursday how these hardware cache memories work
Dialogue: 0,1:01:46.34,1:01:51.20,Chinese,,0,0,0,,然后我们将在星期四学习其中的细节
Dialogue: 0,1:01:51.56,1:01:57.80,English,,0,0,0,,Okay but like I said caching is a very general idea that can be applied at all levels in the hierarchy
Dialogue: 0,1:01:51.56,1:01:57.80,Chinese,,0,0,0,,但就像我说的，缓存是一个非常通用的概念，可以应用于存储器层次结构中的所有层
Dialogue: 0,1:01:59.04,1:02:05.68,English,,0,0,0,,So here we have a cache - so the in all kinds of most caches there's some kind of transfer unit
Dialogue: 0,1:01:59.04,1:02:05.68,Chinese,,0,0,0,,所以这里我们有一个缓存，在各种缓存中都有某种传输单元
Dialogue: 0,1:02:06.86,1:02:08.72,English,,0,0,0,,To go from one level to the next
Dialogue: 0,1:02:06.86,1:02:08.72,Chinese,,0,0,0,,在层级之间来回拷贝
Dialogue: 0,1:02:08.72,1:02:13.94,English,,0,0,0,,So here we have at this at this upper level
Dialogue: 0,1:02:08.72,1:02:13.94,Chinese,,0,0,0,,所以我们在上层有这个
Dialogue: 0,1:02:14.76,1:02:18.86,English,,0,0,0,,We have a what we'll call the cache that can hold four blocks
Dialogue: 0,1:02:14.76,1:02:18.86,Chinese,,0,0,0,,我们有一个称之为可以容纳四个块的缓存
Dialogue: 0,1:02:19.56,1:02:23.76,English,,0,0,0,,So our our memory and then at the lower level we have memory
Dialogue: 0,1:02:19.56,1:02:23.76,Chinese,,0,0,0,,我们又有在底层的内存
Dialogue: 0,1:02:24.76,1:02:28.90,English,,0,0,0,,And this memory is partitioned into blocks of some fixed size that's this
Dialogue: 0,1:02:24.76,1:02:28.90,Chinese,,0,0,0,,并且这个内存被划分为一些固定大小的块
Dialogue: 0,1:02:29.84,1:02:36.36,English,,0,0,0,,That's the way cache is at nearly near the upper part of the hierarchy work
Dialogue: 0,1:02:29.84,1:02:36.36,Chinese,,0,0,0,,这就是接近存储器层次结构上层的缓存的工作方式
Dialogue: 0,1:02:37.02,1:02:43.58,English,,0,0,0,,Now at the lower levels like if you're accessing data say from a web server
Dialogue: 0,1:02:37.02,1:02:43.58,Chinese,,0,0,0,,若处于较低级别，就像你从 Web 服务器访问数据一样
Dialogue: 0,1:02:43.92,1:02:47.40,English,,0,0,0,,Then the the data is partitioned into files typically
Dialogue: 0,1:02:43.92,1:02:47.40,Chinese,,0,0,0,,在这个例子中，通常将数据划分为文件
Dialogue: 0,1:02:47.40,1:02:53.14,English,,0,0,0,,Okay but it upper levels the data is partitioned into blocks so just suppose this is main memory
Dialogue: 0,1:02:47.40,1:02:53.14,Chinese,,0,0,0,,但它的上层数据被分区为块，所以假设这是主存
Dialogue: 0,1:02:54.08,1:02:58.68,English,,0,0,0,,And then above that we have a that consists of a bunch of these blocks
Dialogue: 0,1:02:54.08,1:02:58.68,Chinese,,0,0,0,,然后，在这之上，有由一堆这些块组成的（高速缓存）
Dialogue: 0,1:02:58.68,1:03:05.84,English,,0,0,0,,So we just take the memory and partition into blocks where each block is the same number of bytes
Dialogue: 0,1:02:58.68,1:03:05.84,Chinese,,0,0,0,,所以我们只需将内存分成一个个的块，每个块的字节数相同
Dialogue: 0,1:03:07.84,1:03:12.74,English,,0,0,0,,And then data will be transferred between memory and the cache in block size transfer units
Dialogue: 0,1:03:07.84,1:03:12.74,Chinese,,0,0,0,,然后，数据将以块大小为传输单位在内存和高速缓存之间传输
Dialogue: 0,1:03:13.34,1:03:18.68,English,,0,0,0,,Okay so if you need data from the memory if the cache needs data from the memory it'll grab a whole block
Dialogue: 0,1:03:13.34,1:03:18.68,Chinese,,0,0,0,,如果你需要来自内存的数据，如果告诉缓存需要来自主存的数据，那么它将获取整个块
Dialogue: 0,1:03:19.96,1:03:26.12,English,,0,0,0,,And then at any point in time the cache holds a subset of the the blocks in main memory
Dialogue: 0,1:03:19.96,1:03:26.12,Chinese,,0,0,0,,然后在任何时间点，高速缓存都保存主存储器中块的一个子集
Dialogue: 0,1:03:27.56,1:03:33.16,English,,0,0,0,,Okay so this this cache is much faster but it's also much slower
Dialogue: 0,1:03:27.56,1:03:33.16,Chinese,,0,0,0,,好的，所以这个缓存要快得多，但速度也慢得多（口误，应该是容量更小）
Dialogue: 0,1:03:35.78,1:03:38.58,English,,0,0,0,,And because of that and it's much smaller
Dialogue: 0,1:03:35.78,1:03:38.58,Chinese,,0,0,0,,因此，它的存储容量要小得多......
Dialogue: 0,1:03:39.50,1:03:44.78,English,,0,0,0,,I'm sorry it's much faster but it's it's much more expensive because it's faster it's more expensive
Dialogue: 0,1:03:39.50,1:03:44.78,Chinese,,0,0,0,,抱歉，它的速度要快得多，但它的价格却要贵得多
Dialogue: 0,1:03:45.20,1:03:47.32,English,,0,0,0,,And because it's more expensive it's smaller
Dialogue: 0,1:03:45.20,1:03:47.32,Chinese,,0,0,0,,而且因为它更贵，所以它存储容量更小
Dialogue: 0,1:03:51.98,1:04:01.30,English,,0,0,0,,Now suppose the cache wants to reference say that the CPU asks for data that's contained in block four
Dialogue: 0,1:03:51.98,1:04:01.30,Chinese,,0,0,0,,现在假设缓存要引用某个内存块，假设 CPU 现在要求第 4 块中包含的数据
Dialogue: 0,1:04:04.80,1:04:08.90,English,,0,0,0,,So it looks it looks to see if the data is in the cache it's not
Dialogue: 0,1:04:04.80,1:04:08.90,Chinese,,0,0,0,,CPU 首先查看这个数据是否存在于高速缓存中
Dialogue: 0,1:04:08.90,1:04:12.06,English,,0,0,0,,So the cache asks the memory to give it block four
Dialogue: 0,1:04:08.90,1:04:12.06,Chinese,,0,0,0,,（第 4 块不存在于高速缓存中）所以缓存要求主存给它第 4 块
Dialogue: 0,1:04:13.20,1:04:17.16,English,,0,0,0,,So that block is copied from memory into the cache
Dialogue: 0,1:04:13.20,1:04:17.16,Chinese,,0,0,0,,这样这个块就会从内存复制到缓存中
Dialogue: 0,1:04:17.80,1:04:22.58,English,,0,0,0,,Overwriting the one of the existing in this case block eight it will overwrite block eight
Dialogue: 0,1:04:17.80,1:04:22.58,Chinese,,0,0,0,,覆盖缓存其中一个现有的块 8
Dialogue: 0,1:04:22.58,1:04:26.36,English,,0,0,0,,So now now block four is is in our cache
Dialogue: 0,1:04:22.58,1:04:26.36,Chinese,,0,0,0,,所以现在块 4 存在于我们的缓存中
Dialogue: 0,1:04:28.56,1:04:35.36,English,,0,0,0,,Now suppose now now suppose the CPU asks for a some data that's in block ten
Dialogue: 0,1:04:28.56,1:04:35.36,Chinese,,0,0,0,,现在假设 CPU 请求第 10 块中的一些数据
Dialogue: 0,1:04:35.94,1:04:39.90,English,,0,0,0,,That gets copied up and and we overwrite that that block
Dialogue: 0,1:04:35.94,1:04:39.90,Chinese,,0,0,0,,这样第 10 块会被复制，又覆盖掉缓存中的那个（第 14）块
Dialogue: 0,1:04:41.00,1:04:46.70,English,,0,0,0,,Now the whole idea of storing it in the cache is that we're hoping that the program that's executing on the CPU
Dialogue: 0,1:04:41.00,1:04:46.70,Chinese,,0,0,0,,现在将块复制到缓存中的想法是，我们希望在 CPU 上执行的程序
Dialogue: 0,1:04:47.14,1:04:49.80,English,,0,0,0,,Will reuse one of those blocks we just spent all the time
Dialogue: 0,1:04:47.14,1:04:49.80,Chinese,,0,0,0,,将重用我们复制到高速缓存中的一个块
Dialogue: 0,1:04:50.26,1:04:55.78,English,,0,0,0,,We went to all this trouble to copy it from memory to to this cache  and we know that's slow
Dialogue: 0,1:04:50.26,1:04:55.78,Chinese,,0,0,0,,我们费力地从内存复制块到缓存，我们知道这很慢
Dialogue: 0,1:04:58.38,1:05:06.78,English,,0,0,0,,So now suppose that the CPU needs some data in block  b in this case fourteen
Dialogue: 0,1:04:58.38,1:05:06.78,Chinese,,0,0,0,,所以现在假设 CPU 需要块 b 中的一些数据，在这个例子下是块号为 14 的块
Dialogue: 0,1:05:08.92,1:05:16.60,English,,0,0,0,,Okay so it needs a memory word that's stored that was originally stored in memory it in block fourteen
Dialogue: 0,1:05:08.92,1:05:16.60,Chinese,,0,0,0,,好吧所以它需要存储第 14 块中的一个字
Dialogue: 0,1:05:18.38,1:05:23.44,English,,0,0,0,,Well now this cache can just return that's what we call a hit right so the
Dialogue: 0,1:05:18.38,1:05:23.44,Chinese,,0,0,0,,现在缓存内有这个块，因此可以直接返回，我们称之为缓存命中（cache hit）
Dialogue: 0,1:05:23.56,1:05:28.04,English,,0,0,0,,Block that we access is in the cache so that's good hits are good
Dialogue: 0,1:05:23.56,1:05:28.04,Chinese,,0,0,0,,我们要访问的块正位于缓存中，这叫缓存命中，这是很好的
Dialogue: 0,1:05:28.50,1:05:33.08,English,,0,0,0,,Because now we can return that block directly to CPU
Dialogue: 0,1:05:28.50,1:05:33.08,Chinese,,0,0,0,,因为现在我们可以将该块直接返回给CPU
Dialogue: 0,1:05:33.76,1:05:39.92,English,,0,0,0,,And this this memory is much faster than if we had to go all the way to main memory to the DRAM
Dialogue: 0,1:05:33.76,1:05:39.92,Chinese,,0,0,0,,而且使用高速缓存的访问速度比如果要去访问 DRAM 主存要快得多
Dialogue: 0,1:05:40.16,1:05:43.16,English,,0,0,0,,Okay so the SRAM much faster than the DRAM
Dialogue: 0,1:05:40.16,1:05:43.16,Chinese,,0,0,0,,SRAM 比 DRAM 快得多
Dialogue: 0,1:05:43.74,1:05:47.90,English,,0,0,0,,So the CPU gets that block 14 much faster than it would have
Dialogue: 0,1:05:43.74,1:05:47.90,Chinese,,0,0,0,,相比要到主存中去取得这个块，通过这种方式 CPU 非常迅速地取得第 14 个块
Dialogue: 0,1:05:48.26,1:05:49.86,English,,0,0,0,,If it had just gone all the way to memory
Dialogue: 0,1:05:48.26,1:05:49.86,Chinese,,0,0,0,,相比要到主存中去取得这个块，通过这种方式 CPU 非常迅速地取得第 14 个块
Dialogue: 0,1:05:51.56,1:05:56.58,English,,0,0,0,,Okay the sort of other the the opposite of a hit is a miss
Dialogue: 0,1:05:51.56,1:05:56.58,Chinese,,0,0,0,,好吧，与缓存命中刚好相反的是缓存不命中（cache miss）
Dialogue: 0,1:05:57.84,1:06:00.40,English,,0,0,0,,So suppose the CPU s for block twelve
Dialogue: 0,1:05:57.84,1:06:00.40,Chinese,,0,0,0,,假设 CPU 现在请求第 12 块
Dialogue: 0,1:06:01.62,1:06:04.32,English,,0,0,0,,The cache looks for that block can't find it
Dialogue: 0,1:06:01.62,1:06:04.32,Chinese,,0,0,0,,在高速缓存中查无此块
Dialogue: 0,1:06:04.98,1:06:10.84,English,,0,0,0,,That's a miss, so the the cash has to ask that the main memory the DRAM for block 12
Dialogue: 0,1:06:04.98,1:06:10.84,Chinese,,0,0,0,,这就是缓存不命中，高速缓存需要从主存中取出第 12 块
Dialogue: 0,1:06:11.52,1:06:14.56,English,,0,0,0,,Where it gets copied into the cache and then it can return that
Dialogue: 0,1:06:11.52,1:06:14.56,Chinese,,0,0,0,,复制第 12 块到高速缓存中，然后可以返回给 CPU
Dialogue: 0,1:06:16.58,1:06:22.56,English,,0,0,0,,So that takes longer right so the CPU has to wait for that block to be ex(tracted) to be fetched from memory
Dialogue: 0,1:06:16.58,1:06:22.56,Chinese,,0,0,0,,所以这需要更长的时间，因此 CPU 必须等待高速缓存从内存中取出该块
Dialogue: 0,1:06:23.08,1:06:26.18,English,,0,0,0,,And so misses are slow so hits are good because they're fast
Dialogue: 0,1:06:23.08,1:06:26.18,Chinese,,0,0,0,,所以一旦出现缓存不命中，访问速度就会很慢。所以缓存命中很好，因为很快
Dialogue: 0,1:06:26.84,1:06:28.90,English,,0,0,0,,Misses are bad because they're they're slow
Dialogue: 0,1:06:26.84,1:06:28.90,Chinese,,0,0,0,,缓存不命中很糟糕，因为会很慢
Dialogue: 0,1:06:31.44,1:06:36.40,English,,0,0,0,,Now we typically distinguish between several different kinds of caches
Dialogue: 0,1:06:31.44,1:06:36.40,Chinese,,0,0,0,,我们通常区分几种不同的缓存不命中的种类
Dialogue: 0,1:06:37.32,1:06:40.94,English,,0,0,0,,So the first kind of miss is a cold miss or a compulsory miss
Dialogue: 0,1:06:37.32,1:06:40.94,Chinese,,0,0,0,,因此，第一种是冷不命中（cold miss）或强制不命中（compulsory miss）
Dialogue: 0,1:06:41.78,1:06:44.76,English,,0,0,0,,Which is caused because there's just nothing in the cache
Dialogue: 0,1:06:41.78,1:06:44.76,Chinese,,0,0,0,,这是因为高速缓存中没有任何的数据
Dialogue: 0,1:06:44.98,1:06:48.48,English,,0,0,0,,Initially caches they're empty they have no blocks and as we fetch
Dialogue: 0,1:06:44.98,1:06:48.48,Chinese,,0,0,0,,最初缓存它们是空的，没有存储任何块，当我们要读取数据时
Dialogue: 0,1:06:49.44,1:06:53.84,English,,0,0,0,,As we fetch blocks from the lower level from the next the next level and put them in the cache
Dialogue: 0,1:06:49.44,1:06:53.84,Chinese,,0,0,0,,当我们要读取数据时就要从下一级获取块，将它们放入缓存中
Dialogue: 0,1:06:54.68,1:06:57.00,English,,0,0,0,,The cache will slowly fill up with blocks
Dialogue: 0,1:06:54.68,1:06:57.00,Chinese,,0,0,0,,缓存将慢慢填满
Dialogue: 0,1:06:57.64,1:07:00.06,English,,0,0,0,,And we'll get and that will increase the likelihood of hits
Dialogue: 0,1:06:57.64,1:07:00.06,Chinese,,0,0,0,,也就增加了缓存命中的可能性
Dialogue: 0,1:07:00.62,1:07:03.58,English,,0,0,0,,But when the cache is empty we're going to miss every time, right?
Dialogue: 0,1:07:00.62,1:07:03.58,Chinese,,0,0,0,,但是当缓存为空时，每一次访存都肯定会缓存不命中，对吧？
Dialogue: 0,1:07:03.58,1:07:07.04,English,,0,0,0,,So there's just no way to avoid cold misses right you got
Dialogue: 0,1:07:03.58,1:07:07.04,Chinese,,0,0,0,,所以没有办法避免冷不命中
Dialogue: 0,1:07:07.46,1:07:11.28,English,,0,0,0,,Oh so this is called warming up your cache so as you load data items into the cache
Dialogue: 0,1:07:07.46,1:07:11.28,Chinese,,0,0,0,,将数据项加载到空的缓存中，这称为缓存的暖身
Dialogue: 0,1:07:11.88,1:07:17.66,English,,0,0,0,,Initially it's cold and as you add more items you're warming it up meaning that you're increasing the likelihood of a hit
Dialogue: 0,1:07:11.88,1:07:17.66,Chinese,,0,0,0,,最初缓存是空的，当往里添加越多的数据块，热身意味着增加了缓存命中的可能性
Dialogue: 0,1:07:19.18,1:07:29.56,English,,0,0,0,,Now there's a there's another sort of symmetric kind of miss which is called a capacity miss
Dialogue: 0,1:07:19.18,1:07:29.56,Chinese,,0,0,0,,还有一种与冷不命中对应的情况，称为容量不命中（capacity miss）
Dialogue: 0,1:07:30.22,1:07:35.48,English,,0,0,0,,And these misses are due to the fact that the cache is just a certain size right you just can't
Dialogue: 0,1:07:30.22,1:07:35.48,Chinese,,0,0,0,,容量不命中的原因是高速缓存的大小是有限的，你不能（容纳超过缓存大小的工作集）
Dialogue: 0,1:07:35.96,1:07:38.28,English,,0,0,0,,In the example we looked at we only had four blocks
Dialogue: 0,1:07:35.96,1:07:38.28,Chinese,,0,0,0,,在我们看到的例子中，我们的高速缓存只有四个块的大小
Dialogue: 0,1:07:39.96,1:07:48.04,English,,0,0,0,,So if we're trying, if our, if our temporal locality involves eight blocks
Dialogue: 0,1:07:39.96,1:07:48.04,Chinese,,0,0,0,,如果我们的程序的局部性需要用到包含 8 个块的数据
Dialogue: 0,1:07:48.94,1:07:54.10,English,,0,0,0,,You know say if the loop that we're accessing is  is accessing elements in array
Dialogue: 0,1:07:48.94,1:07:54.10,Chinese,,0,0,0,,假设我们正在循环访问数组中的元素，这个数组包含 8 个块的数据，
Dialogue: 0,1:07:55.42,1:08:00.96,English,,0,0,0,,That that consists of eight blocks there's just not enough room to store eight blocks and that four block cache
Dialogue: 0,1:07:55.42,1:08:00.96,Chinese,,0,0,0,,那么自然容量仅有 4 个块的高速缓存无法放下整个 8 个块的数组
Dialogue: 0,1:08:01.44,1:08:07.52,English,,0,0,0,,So we're going to get misses right we would need a bigger cache to be able to satisfy and store those eight blocks
Dialogue: 0,1:08:01.44,1:08:07.52,Chinese,,0,0,0,,因此，我们将会遇到容量不命中，我们需要更大的缓存才能存储这 8 个块
Dialogue: 0,1:08:08.02,1:08:13.40,English,,0,0,0,,And if we had a big enough cache then we get good hit rate right if we could store all the blocks
Dialogue: 0,1:08:08.02,1:08:13.40,Chinese,,0,0,0,,如果我们有足够大的缓存，那么就会有良好的命中率
Dialogue: 0,1:08:14.42,1:08:23.02,English,,0,0,0,,In our cache then we then the cache could take advantage of the spatial and temporal locality within that program
Dialogue: 0,1:08:14.42,1:08:23.02,Chinese,,0,0,0,,如果我们可以在缓存中存储所有块，然后缓存可以利用该程序中的空间和时间局部性
Dialogue: 0,1:08:24.00,1:08:28.96,English,,0,0,0,,So in general what we call this set of blocks at any point in time when a program is running
Dialogue: 0,1:08:24.00,1:08:28.96,Chinese,,0,0,0,,所以一般来说，在程序运行的任何时候，
Dialogue: 0,1:08:29.50,1:08:34.73,English,,0,0,0,,We call the set of blocks that are sort of being accessed over and over again the working set
Dialogue: 0,1:08:29.50,1:08:34.73,Chinese,,0,0,0,,我们将这一些不断被程序访问的块称之为工作集（working set）
Dialogue: 0,1:08:35.48,1:08:42.14,English,,0,0,0,,And so your working set and the working set will change you know as you go from loop to loop  from function to function
Dialogue: 0,1:08:35.48,1:08:42.14,Chinese,,0,0,0,,工作集是会改变的，当你的程序从一个循环执行到另一个循环，从一个函数到另一个函数时
Dialogue: 0,1:08:42.74,1:08:45.41,English,,0,0,0,,But at a point in time in your program when
Dialogue: 0,1:08:42.74,1:08:45.41,Chinese,,0,0,0,,但是在程序执行中的某个时间点
Dialogue: 0,1:08:46.28,1:08:51.30,English,,0,0,0,,It you have this idea of a working set which is sort of the blocks that you need to have stored in your cache
Dialogue: 0,1:08:46.28,1:08:51.30,Chinese,,0,0,0,,有一个工作集的概念，它就是你需要存储在缓存中的块
Dialogue: 0,1:08:54.00,1:08:59.28,English,,0,0,0,,Ok and well so when you're working set size exceeds your cache size then you get capacity misses
Dialogue: 0,1:08:54.00,1:08:59.28,Chinese,,0,0,0,,好的，所以当你的工作集大小超过你的缓存大小时，就会发生容量不命中
Dialogue: 0,1:09:00.36,1:09:04.12,English,,0,0,0,,There's this other kind of weird miss called the conflict miss
Dialogue: 0,1:09:00.36,1:09:04.12,Chinese,,0,0,0,,还有另一种奇怪的缓存不命中，称为冲突未命中
Dialogue: 0,1:09:04.88,1:09:08.24,English,,0,0,0,,Which has to do with the way that caches are often implemented
Dialogue: 0,1:09:04.88,1:09:08.24,Chinese,,0,0,0,,这与缓存的实现方式有关
Dialogue: 0,1:09:09.52,1:09:15.88,English,,0,0,0,,So the idea is that most caches especially hardware caches because they're they have to be simple
Dialogue: 0,1:09:09.52,1:09:15.88,Chinese,,0,0,0,,这里的概念是，大多数缓存，特别是硬件缓存，因为它们必须设计地较为简单
Dialogue: 0,1:09:17.42,1:09:23.50,English,,0,0,0,,They have they limit where a block can be placed to some
Dialogue: 0,1:09:17.42,1:09:23.50,Chinese,,0,0,0,,限制了块可以被放置的位置
Dialogue: 0,1:09:24.26,1:09:27.22,English,,0,0,0,,Small set of positions in the cache
Dialogue: 0,1:09:24.26,1:09:27.22,Chinese,,0,0,0,,块可以被放在缓存中的一小组位置
Dialogue: 0,1:09:28.50,1:09:32.04,English,,0,0,0,,So like one of the the simplest models is to just take
Dialogue: 0,1:09:28.50,1:09:32.04,Chinese,,0,0,0,,像最简单的模型之一就是
Dialogue: 0,1:09:33.00,1:09:39.94,English,,0,0,0,,Block I can only be placed in block I mod the cache size
Dialogue: 0,1:09:33.00,1:09:39.94,Chinese,,0,0,0,,块号为 i 的第 i 块只能放在（i mod 缓存大小）处
Dialogue: 0,1:09:40.12,1:09:43.75,English,,0,0,0,,So in our that that little cache we saw that had four blocks
Dialogue: 0,1:09:40.12,1:09:43.75,Chinese,,0,0,0,,所以假设我们有一个缓存，可以容纳四个块
Dialogue: 0,1:09:44.56,1:09:50.26,English,,0,0,0,,We would take we would take block I from memory and we would stick it at block I mod 4
Dialogue: 0,1:09:44.56,1:09:50.26,Chinese,,0,0,0,,当我们从主存中读取一个块号为 i 的块时，会将其放到缓存中的（i mod 4）处
Dialogue: 0,1:09:50.26,1:09:54.02,English,,0,0,0,,So block 0 would go at block 0 in our cache
Dialogue: 0,1:09:50.26,1:09:54.02,Chinese,,0,0,0,,所以主存中取出的块 0 将存在我们的缓存中的块 0 处
Dialogue: 0,1:09:55.00,1:10:03.42,English,,0,0,0,,As would block 4 and as would block 8. Block 9 would go into block 1 in the cache
Dialogue: 0,1:09:55.00,1:10:03.42,Chinese,,0,0,0,,第 4、第 8 块都会放在 cache 中的第 0 块，第 9 块将放在 cache 中的第 1 块
Dialogue: 0,1:10:03.92,1:10:13.84,English,,0,0,0,,And that's when that happens suppose suppose we use that model
Dialogue: 0,1:10:03.92,1:10:13.84,Chinese,,0,0,0,,假设我们使用该模型，当发生这种情况时
Dialogue: 0,1:10:14.82,1:10:18.50,English,,0,0,0,,So we're going to take block i and we're going to put it we can only place it in the cache
Dialogue: 0,1:10:14.82,1:10:18.50,Chinese,,0,0,0,,对于块号为 i 的块，我们只能将其放在 cache 中的（i mod 4）处
Dialogue: 0,1:10:19.28,1:10:21.60,English,,0,0,0,,At block i mod 4
Dialogue: 0,1:10:19.28,1:10:21.60,Chinese,,0,0,0,,对于块号为 i 的块，我们只能将其放在 cache 中的（i mod 4）处
Dialogue: 0,1:10:22.94,1:10:30.40,English,,0,0,0,,Now suppose our suppose our reference pattern involves from memory block zero block four and block eight
Dialogue: 0,1:10:22.94,1:10:30.40,Chinese,,0,0,0,,假设我们从主存中要引用的数据对象是块 0、块 4、块 8
Dialogue: 0,1:10:31.68,1:10:38.34,English,,0,0,0,,It's only three blocks so we have we have enough room in the cache to store those three blocks
Dialogue: 0,1:10:31.68,1:10:38.34,Chinese,,0,0,0,,只引用三个块，所以我们在缓存中有足够的空间来存储这三个区块
Dialogue: 0,1:10:38.60,1:10:43.46,English,,0,0,0,,But because of the way we've decided to place blocks each block will be will evict
Dialogue: 0,1:10:38.60,1:10:43.46,Chinese,,0,0,0,,但由于映射缓存块的方式，每一次拷贝新的块到 cache 时都会导致驱逐另一个块
Dialogue: 0,1:10:44.36,1:10:48.82,English,,0,0,0,,When we access block four it'll go into block zero in the cache
Dialogue: 0,1:10:44.36,1:10:48.82,Chinese,,0,0,0,,当我们访问第 4 块时，它将进入高速缓存中第 0 块已经占有的位置
Dialogue: 0,1:10:50.16,1:10:52.16,English,,0,0,0,,When we access blocked four in the cache
Dialogue: 0,1:10:50.16,1:10:52.16,Chinese,,0,0,0,,当我们在高速缓存中访问第 4 块时
Dialogue: 0,1:10:52.84,1:10:56.92,English,,0,0,0,,It'll overwrite that block and it'll go into block zero in the cache
Dialogue: 0,1:10:52.84,1:10:56.92,Chinese,,0,0,0,,它会覆盖第 0 块所在的位置
Dialogue: 0,1:10:57.42,1:11:04.08,English,,0,0,0,,And so because of this it's really the access pattern conspiring with the  algorithm
Dialogue: 0,1:10:57.42,1:11:04.08,Chinese,,0,0,0,,因此，这种访问模式与用于映射块的算法密切相关
Dialogue: 0,1:11:04.08,1:11:05.58,English,,0,0,0,,That we're using for placing blocks
Dialogue: 0,1:11:04.08,1:11:05.58,Chinese,,0,0,0,,因此，这种访问模式与用于映射块的算法密切相关
Dialogue: 0,1:11:06.92,1:11:09.42,English,,0,0,0,,Okay so because of this we have plenty of room in the cache
Dialogue: 0,1:11:06.92,1:11:09.42,Chinese,,0,0,0,,因此，即使我们有足够大的缓存
Dialogue: 0,1:11:09.86,1:11:15.74,English,,0,0,0,,But because of this sort of the access pattern conspiring with the placement algorithm
Dialogue: 0,1:11:09.86,1:11:15.74,Chinese,,0,0,0,,但由于这种访问模式和映射算法
Dialogue: 0,1:11:16.08,1:11:17.48,English,,0,0,0,,We get misses every time
Dialogue: 0,1:11:16.08,1:11:17.48,Chinese,,0,0,0,,缓存会一直不命中
Dialogue: 0,1:11:19.54,1:11:25.14,English,,0,0,0,,We'll see how conflict miss works in detail when we study your caches tomorrow
Dialogue: 0,1:11:19.54,1:11:25.14,Chinese,,0,0,0,,我们将在明天研究 cache 中冲突不命中的细节
Dialogue: 0,1:11:28.24,1:11:31.59,English,,0,0,0,,So
Dialogue: 0,1:11:28.24,1:11:31.59,Chinese,,0,0,0,,所以
Dialogue: 0,1:11:32.10,1:11:36.62,English,,0,0,0,,So this is these these caches exist everywhere in the memory hierarchy and
Dialogue: 0,1:11:32.10,1:11:36.62,Chinese,,0,0,0,,所以这就是缓存存在于存储器层次结构中的任何地方的体现
Dialogue: 0,1:11:38.42,1:11:41.96,English,,0,0,0,,So all of them are caches of one form or another right
Dialogue: 0,1:11:38.42,1:11:41.96,Chinese,,0,0,0,,所以它们都是各种形式的缓存
Dialogue: 0,1:11:42.66,1:11:45.64,English,,0,0,0,,So you can think of the registers as a type of cache
Dialogue: 0,1:11:42.66,1:11:45.64,Chinese,,0,0,0,,你可以将寄存器视为一种缓存
Dialogue: 0,1:11:46.28,1:11:48.52,English,,0,0,0,,What are they cache for eight byte words
Dialogue: 0,1:11:46.28,1:11:48.52,Chinese,,0,0,0,,它们缓存的是八个字节的字
Dialogue: 0,1:11:49.64,1:11:53.14,English,,0,0,0,,Okay where's it cached it's cached right on the CPU itself
Dialogue: 0,1:11:49.64,1:11:53.14,Chinese,,0,0,0,,好吧，它被缓存于何处？在 CPU 上
Dialogue: 0,1:11:54.56,1:11:58.92,English,,0,0,0,,What's the latency? It's instant and happens within an instruction
Dialogue: 0,1:11:54.56,1:11:58.92,Chinese,,0,0,0,,延迟呢？没有延迟，发送在一条指令的执行周期内
Dialogue: 0,1:12:00.20,1:12:03.46,English,,0,0,0,,And then who manages the cache somebody has to manage the cache when
Dialogue: 0,1:12:00.20,1:12:03.46,Chinese,,0,0,0,,然后是谁管理缓存？必须要有东西管理缓存
Dialogue: 0,1:12:03.86,1:12:07.50,English,,0,0,0,,When there's a request to load an item from the lower level in the hierarchy
Dialogue: 0,1:12:03.86,1:12:07.50,Chinese,,0,0,0,,当有请求从层次结构中的较低层读取内容时
Dialogue: 0,1:12:08.08,1:12:12.60,English,,0,0,0,,Something has to decide what to do with that where to put it in the cache that's called managing the cache
Dialogue: 0,1:12:08.08,1:12:12.60,Chinese,,0,0,0,,必须有一个过程决定如何处理这个请求， 如何将其放入的缓存中的某一位置，我们称之为缓存管理
Dialogue: 0,1:12:13.40,1:12:16.52,English,,0,0,0,,Well in this case the compiler manages the cache
Dialogue: 0,1:12:13.40,1:12:16.52,Chinese,,0,0,0,,在这种情况下，由编译器管理缓存
Dialogue: 0,1:12:17.08,1:12:21.42,English,,0,0,0,,When you when you compile your C code the compiler figures out which register
Dialogue: 0,1:12:17.08,1:12:21.42,Chinese,,0,0,0,,当你编译 C 语言代码时，编译器会确定由哪个寄存器
Dialogue: 0,1:12:21.96,1:12:24.44,English,,0,0,0,,Data items from memory are going to go into okay
Dialogue: 0,1:12:21.96,1:12:24.44,Chinese,,0,0,0,,编译器会确定由哪个寄存器来存储来自内存的数据项
Dialogue: 0,1:12:25.08,1:12:32.84,English,,0,0,0,,So TLB this is something this is a cache that's used in virtual memory
Dialogue: 0,1:12:25.08,1:12:32.84,Chinese,,0,0,0,,TLB（翻译后备缓冲，Translation Lookaside Buffer）      是一个在虚拟内存中使用的缓存
Dialogue: 0,1:12:33.78,1:12:37.40,English,,0,0,0,,Then there's these hardware caches called l1 and l2 caches
Dialogue: 0,1:12:33.78,1:12:37.40,Chinese,,0,0,0,,然后是这些称为 L1 和 L2 缓存的硬件缓存
Dialogue: 0,1:12:38.32,1:12:43.04,English,,0,0,0,,So they store 64 byte blocks on modern Intel systems
Dialogue: 0,1:12:38.32,1:12:43.04,Chinese,,0,0,0,,它们在现代英特尔系统上存储 64 字节块
Dialogue: 0,1:12:43.86,1:12:50.18,English,,0,0,0,,And they're cached on the CPU chip itself in SRAM that are built right into the CPU chip
Dialogue: 0,1:12:43.86,1:12:50.18,Chinese,,0,0,0,,它们被缓存于 CPU 芯片上，由 SRAM 制成，集成在 CPU 上
Dialogue: 0,1:12:51.44,1:12:58.23,English,,0,0,0,,And depending on whether l1 caches to on core i7s have a latency of 4 cycles
Dialogue: 0,1:12:51.44,1:12:58.23,Chinese,,0,0,0,,L1 缓存在酷睿 i7 上的延迟是 4 个时钟周期
Dialogue: 0,1:12:58.68,1:13:01.14,English,,0,0,0,,And l2 has a latency of 10 cycles
Dialogue: 0,1:12:58.68,1:13:01.14,Chinese,,0,0,0,,L2 缓存的延迟是 10 个 CPU 周期
Dialogue: 0,1:13:02.28,1:13:04.64,English,,0,0,0,,And both of these are managed by hardware
Dialogue: 0,1:13:02.28,1:13:04.64,Chinese,,0,0,0,,这两者都是由硬件管理的
Dialogue: 0,1:13:05.44,1:13:11.60,English,,0,0,0,,So when you when the CPU fetches an item from the l1 cache hardware figure finds it
Dialogue: 0,1:13:05.44,1:13:11.60,Chinese,,0,0,0,,所以，当 CPU 要从 L1 缓存中读取一个内容时，由硬件来管理
Dialogue: 0,1:13:12.40,1:13:17.74,English,,0,0,0,,And if there's a miss and a block is loaded from l2, hardware in the l1 cache figures out where to put it
Dialogue: 0,1:13:12.40,1:13:17.74,Chinese,,0,0,0,,如果出现了未命中，就会从 L2 缓存中加载一个块，L1 缓存中的硬件来决定在哪里存放这个块
Dialogue: 0,1:13:17.88,1:13:22.48,English,,0,0,0,,Ok so all this is done without any intervention, by hardware
Dialogue: 0,1:13:17.88,1:13:22.48,Chinese,,0,0,0,,好的，所有这些都是在没有硬件干预的情况下完成的
Dialogue: 0,1:13:24.80,1:13:28.82,English,,0,0,0,,Disks contain buffer operating systems maintain buffer caches
Dialogue: 0,1:13:24.80,1:13:28.82,Chinese,,0,0,0,,磁盘包含由操作系统维护的缓冲区缓存
Dialogue: 0,1:13:29.54,1:13:32.10,English,,0,0,0,,So in this case what's cached is portions of files
Dialogue: 0,1:13:29.54,1:13:32.10,Chinese,,0,0,0,,在这种情况下，缓存的是文件的一部分
Dialogue: 0,1:13:33.50,1:13:36.34,English,,0,0,0,,Ok and they're cached in main memory
Dialogue: 0,1:13:33.50,1:13:36.34,Chinese,,0,0,0,,好的，他们被缓存在主存中
Dialogue: 0,1:13:37.16,1:13:42.42,English,,0,0,0,,And latency to main memories about a hundred cycles or so
Dialogue: 0,1:13:37.16,1:13:42.42,Chinese,,0,0,0,,缓存到主存的延迟大约一百个时钟周期左右
Dialogue: 0,1:13:43.60,1:13:45.76,English,,0,0,0,,And these are managed by the operating system
Dialogue: 0,1:13:43.60,1:13:45.76,Chinese,,0,0,0,,这些都是由操作系统管理的
Dialogue: 0,1:13:46.32,1:13:51.34,English,,0,0,0,,So the operating system reserves a portion of memory to store files that you've loaded so
Dialogue: 0,1:13:46.32,1:13:51.34,Chinese,,0,0,0,,因此，操作系统会保留一部分内存来存储你已加载的文件
Dialogue: 0,1:13:52.30,1:13:56.46,English,,0,0,0,,So the operating system exploits locality if you if you read a file
Dialogue: 0,1:13:52.30,1:13:56.46,Chinese,,0,0,0,,因此，如果你读取文件，操作系统将利用本地性
Dialogue: 0,1:13:57.64,1:14:03.54,English,,0,0,0,,And then start reading, referencing bytes from that file. It will actually be served from the
Dialogue: 0,1:13:57.64,1:14:03.54,Chinese,,0,0,0,,然后开始从该文件中读取字节，它实际上将从主存中的文件缓存被读取
Dialogue: 0,1:14:03.92,1:14:06.42,English,,0,0,0,,file cache and it won't go out to disk
Dialogue: 0,1:14:03.92,1:14:06.42,Chinese,,0,0,0,,而不是去磁盘上读取
Dialogue: 0,1:14:08.40,1:14:16.66,English,,0,0,0,,Networks maintain caches like things like NFS and AFS maintain local caches on disk
Dialogue: 0,1:14:08.40,1:14:16.66,Chinese,,0,0,0,,网络也维护着一份本地地盘的缓存，例如网络文件系统（Network File System）和安德鲁文件系统（Andrew File System）
Dialogue: 0,1:14:17.92,1:14:23.64,English,,0,0,0,,Your browser has a cache so when it fetches files from from servers
Dialogue: 0,1:14:17.92,1:14:23.64,Chinese,,0,0,0,,浏览器有缓存机制，因此从服务器获取文件时
Dialogue: 0,1:14:23.94,1:14:27.88,English,,0,0,0,,It stores those files locally on disk so if you reference those web pages again
Dialogue: 0,1:14:23.94,1:14:27.88,Chinese,,0,0,0,,浏览器将会把这些文件本地存储在磁盘上，以便再次引用这些网页
Dialogue: 0,1:14:28.10,1:14:31.84,English,,0,0,0,,They're served from from your local disk rather than going all the way across the network
Dialogue: 0,1:14:28.10,1:14:31.84,Chinese,,0,0,0,,然后这些文件就会从你的本地磁盘读取，而不是一直通过网络重新请求
Dialogue: 0,1:14:33.16,1:14:39.60,English,,0,0,0,,Ok so the point is that these caches exist everywhere in the memory hierarchy
Dialogue: 0,1:14:33.16,1:14:39.60,Chinese,,0,0,0,,好的，这里的理念就是，缓存机制存在于存储器层次结构中的任何位置
Dialogue: 0,1:14:39.86,1:14:43.84,English,,0,0,0,,And they're all based on the same principles they're just implemented in different ways
Dialogue: 0,1:14:39.86,1:14:43.84,Chinese,,0,0,0,,而且它们都基于相同的原则，它们只是以不同的方式来实现
Dialogue: 0,1:14:46.78,1:14:50.42,English,,0,0,0,,Ok so just to summarize what we've what we've done today
Dialogue: 0,1:14:46.78,1:14:50.42,Chinese,,0,0,0,,好的，现在总结一下我们今天所学的东西
Dialogue: 0,1:14:51.82,1:14:57.12,English,,0,0,0,,We've seen that there's there's a gap between the CPU and our storage devices that continues to increase
Dialogue: 0,1:14:51.82,1:14:57.12,Chinese,,0,0,0,,我们学习了 CPU 和存储器设备之间存在着访问速度的巨大差距，而且在不断扩大
Dialogue: 0,1:14:58.38,1:15:02.90,English,,0,0,0,,We've seen that well-written programs have this property called locality
Dialogue: 0,1:14:58.38,1:15:02.90,Chinese,,0,0,0,,我们学习了编写良好的程序具有称为程序性的属性
Dialogue: 0,1:15:03.86,1:15:08.98,English,,0,0,0,,And we've seen that caching by taking by using caching
Dialogue: 0,1:15:03.86,1:15:08.98,Chinese,,0,0,0,,我们了解了缓存的概念
Dialogue: 0,1:15:08.98,1:15:12.80,English,,0,0,0,,We can build a memory hierarchy that takes advantage of locality and programs
Dialogue: 0,1:15:08.98,1:15:12.80,Chinese,,0,0,0,,利用缓存的概念和程序的局部性原理，我们可以构建存储器层次结构
Dialogue: 0,1:15:13.66,1:15:19.70,English,,0,0,0,,And allows us to build storage systems that where we can access data at the rate of the fastest device
Dialogue: 0,1:15:13.66,1:15:19.70,Chinese,,0,0,0,,允许我们构建存储系统，以便我们以最快的设备速率访问数据
Dialogue: 0,1:15:20.36,1:15:25.14,English,,0,0,0,,But at the cost and capacity of the devices at the the lowest level
Dialogue: 0,1:15:20.36,1:15:25.14,Chinese,,0,0,0,,但却有着底层设备容量大，造价低廉的优点
Dialogue: 0,1:15:26.28,1:15:35.48,English,,0,0,0,,Ok so thursday we're going to look at a very specific part of the hierarchy called cache memories
Dialogue: 0,1:15:26.28,1:15:35.48,Chinese,,0,0,0,,好的，星期四我们将具体学习存储器层次结构的一个非常具体的部分，高速缓存存储器
