[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 24  Synchronization  Basics.mp4
Video File: ../../../../Desktop/csapp/Lecture 24  Synchronization  Basics.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.125000
Scroll Position: 1275
Active Line: 1285
Video Position: 101235

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Noto Sans CJK SC Black,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,1.5,1.2,2,10,10,10,1
Style: Chinese,Noto Sans CJK SC Black,50,&H00FFFF00,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.2,1.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:01.90,0:00:04.74,English,,0,0,0,,All right well good afternoon everybody good to see you welcome
Dialogue: 0,0:00:01.90,0:00:04.74,Chinese,,0,0,0,,下午好，很高兴见到你们，欢迎
Dialogue: 0,0:00:06.54,0:00:09.10,English,,0,0,0,,Welcome to all those students watching on video as well
Dialogue: 0,0:00:06.54,0:00:09.10,Chinese,,0,0,0,,也欢迎所有观看视频的学生
Dialogue: 0,0:00:11.68,0:00:17.18,English,,0,0,0,,Before we start we were talking about joinable and detached threads
Dialogue: 0,0:00:11.68,0:00:17.18,Chinese,,0,0,0,,开始之前，我们讨论一下可结合（joinable）的线程和分离（detached）的线程（P694）
Dialogue: 0,0:00:17.36,0:00:23.96,English,,0,0,0,,And you asked the question about why you would ever want to have threads running in non detached mode
Dialogue: 0,0:00:17.36,0:00:23.96,Chinese,,0,0,0,,上次课，你问了什么情况下需要使用线程的可结合的模式
Dialogue: 0,0:00:24.00,0:00:27.12,English,,0,0,0,,You know why you'd ever run in want to have him running joinable
Dialogue: 0,0:00:24.00,0:00:27.12,Chinese,,0,0,0,,为什么要使用可结合的模式
Dialogue: 0,0:00:27.74,0:00:32.04,English,,0,0,0,,And I didn't give you a very good answer so I want to try to to answer that for you better
Dialogue: 0,0:00:27.74,0:00:32.04,Chinese,,0,0,0,,上次课我没能很好的解释，这次课我希望能解释清楚一点
Dialogue: 0,0:00:33.86,0:00:39.64,English,,0,0,0,,Turns out there's an important class of sort of parallel programming
Dialogue: 0,0:00:33.86,0:00:39.64,Chinese,,0,0,0,,实际上，有一类很重要的并发编程
Dialogue: 0,0:00:40.02,0:00:43.60,English,,0,0,0,,There's an important parallel programming model called fork and join
Dialogue: 0,0:00:40.02,0:00:43.60,Chinese,,0,0,0,,这种并发编程模型叫做「fork」和「join」 （分叉和汇合）
Dialogue: 0,0:00:44.38,0:00:47.84,English,,0,0,0,,Where program consists of a series of phases
Dialogue: 0,0:00:44.38,0:00:47.84,Chinese,,0,0,0,,在这种模型中，程序由一系列阶段组成
Dialogue: 0,0:00:50.56,0:00:56.56,English,,0,0,0,,In each phase you have a worker or a master sorry
Dialogue: 0,0:00:50.56,0:00:56.56,Chinese,,0,0,0,,在每个阶段，都有多个工作线程和一个管理线程
Dialogue: 0,0:00:57.66,0:01:00.54,English,,0,0,0,,And it creates a bunch of worker threads
Dialogue: 0,0:00:57.66,0:01:00.54,Chinese,,0,0,0,,程序会创建多个工作线程
Dialogue: 0,0:01:05.90,0:01:10.12,English,,0,0,0,,And then each of those worker threads solve some part of the problem for that phase
Dialogue: 0,0:01:05.90,0:01:10.12,Chinese,,0,0,0,,然后，每个工作线程解决该阶段的某些问题
Dialogue: 0,0:01:10.48,0:01:15.02,English,,0,0,0,,Like some maybe you take your data structure and you break it up into chunks
Dialogue: 0,0:01:10.48,0:01:15.02,Chinese,,0,0,0,,在程序中，你可能使用某种可以切分成多个部分的数据结构
Dialogue: 0,0:01:15.04,0:01:19.82,English,,0,0,0,,And then each thread updates the its own chunk of that data structure
Dialogue: 0,0:01:15.04,0:01:19.82,Chinese,,0,0,0,,然后每个线程更新其该数据结构中的某个块
Dialogue: 0,0:01:21.54,0:01:28.20,English,,0,0,0,,But for whatever reason the master then has to wait for the worker threads to finish before it can go on to the next phase
Dialogue: 0,0:01:21.54,0:01:28.20,Chinese,,0,0,0,,但出于某种原因，管理线程必须等待所有的工作线程完成才能进入下一阶段
Dialogue: 0,0:01:28.94,0:01:32.10,English,,0,0,0,,So it does join, so this is called the fork
Dialogue: 0,0:01:28.94,0:01:32.10,Chinese,,0,0,0,,这里做的事就叫做「join」，前面的叫做「fork」
Dialogue: 0,0:01:33.26,0:01:35.60,English,,0,0,0,,And then it waits for all the threads to finish
Dialogue: 0,0:01:33.26,0:01:35.60,Chinese,,0,0,0,,管理线程等待所有的工作线程完成
Dialogue: 0,0:01:37.32,0:01:40.00,English,,0,0,0,,By doing a join okay so this is called
Dialogue: 0,0:01:37.32,0:01:40.00,Chinese,,0,0,0,,通过调用 pthread_join
Dialogue: 0,0:01:41.20,0:01:43.50,English,,0,0,0,,This is called the fork and this is called the join
Dialogue: 0,0:01:41.20,0:01:43.50,Chinese,,0,0,0,,前面做的事 fork，这里做的事 ßßßßjoin
Dialogue: 0,0:01:44.32,0:01:47.26,English,,0,0,0,,And only when all of the threads have finished
Dialogue: 0,0:01:44.32,0:01:47.26,Chinese,,0,0,0,,因为只有当所有工作线程都完成时
Dialogue: 0,0:01:47.96,0:01:51.28,English,,0,0,0,,Can it go and do the next do the next phase
Dialogue: 0,0:01:47.96,0:01:51.28,Chinese,,0,0,0,,才可以去做下一阶段的工作
Dialogue: 0,0:01:56.12,0:02:00.40,English,,0,0,0,,Okay so this model is really important in things like scientific computing where
Dialogue: 0,0:01:56.12,0:02:00.40,Chinese,,0,0,0,,好的，这个模型在科学计算等方面非常重要
Dialogue: 0,0:02:01.22,0:02:06.76,English,,0,0,0,,You might...you're simulating some domain,you're simulating nature
Dialogue: 0,0:02:01.22,0:02:06.76,Chinese,,0,0,0,,在一些领域，你可能需要做一些仿真，比如仿真自然界的一些现象
Dialogue: 0,0:02:07.40,0:02:10.76,English,,0,0,0,,So you represent that as some domain like maybe you're simulating
Dialogue: 0,0:02:07.40,0:02:10.76,Chinese,,0,0,0,,你可能需要对
Dialogue: 0,0:02:11.36,0:02:15.04,English,,0,0,0,,How heat flows over a plate you know metal plate
Dialogue: 0,0:02:11.36,0:02:15.04,Chinese,,0,0,0,,热量流过金属板的现象进行仿真
Dialogue: 0,0:02:15.90,0:02:20.20,English,,0,0,0,,And so you might have these workers
Dialogue: 0,0:02:15.90,0:02:20.20,Chinese,,0,0,0,,所以你可能需要创建一些工作线程
Dialogue: 0,0:02:21.30,0:02:24.04,English,,0,0,0,,You might partition the domain amongst a set of those workers
Dialogue: 0,0:02:21.30,0:02:24.04,Chinese,,0,0,0,,每个工作线程只负责金属板的一个区域的仿真
Dialogue: 0,0:02:24.84,0:02:27.90,English,,0,0,0,,And then each one of these phases is a time step
Dialogue: 0,0:02:24.84,0:02:27.90,Chinese,,0,0,0,,然后，每一阶段代表一个时间点
Dialogue: 0,0:02:28.94,0:02:34.24,English,,0,0,0,,And then so once all the workers have finished a time step then they can advance to the next time step
Dialogue: 0,0:02:28.94,0:02:34.24,Chinese,,0,0,0,,所以，只有所有的工作线程完成了一个时间点，才可以进入到下一个时间点
Dialogue: 0,0:02:36.30,0:02:39.00,English,,0,0,0,,And so sorry I don't know why,I didn't think of it
Dialogue: 0,0:02:36.30,0:02:39.00,Chinese,,0,0,0,,对不起，我不知道为什么上次课我没想到这个例子
Dialogue: 0,0:02:39.52,0:02:41.76,English,,0,0,0,,That's a that's an important reason why you'd want this
Dialogue: 0,0:02:39.52,0:02:41.76,Chinese,,0,0,0,,所以，这就是我们为什么要使用可结合的线程
Dialogue: 0,0:02:44.04,0:02:45.16,English,,0,0,0,,Okay so we saw
Dialogue: 0,0:02:44.04,0:02:45.16,Chinese,,0,0,0,,好的
Dialogue: 0,0:02:46.36,0:02:50.30,English,,0,0,0,,We've seen the threaded programs are nice
Dialogue: 0,0:02:46.36,0:02:50.30,Chinese,,0,0,0,,我们已经看到了线程程序好的方面
Dialogue: 0,0:02:50.30,0:02:53.04,English,,0,0,0,,Because you they you can share all the global variables
Dialogue: 0,0:02:50.30,0:02:53.04,Chinese,,0,0,0,,使用线程的并发可以共享所有全局变量
Dialogue: 0,0:02:55.02,0:02:58.54,English,,0,0,0,,But this the sharing can have unintended consequences
Dialogue: 0,0:02:55.02,0:02:58.54,Chinese,,0,0,0,,但这种共享可能会产生意外的结果
Dialogue: 0,0:02:59.36,0:03:02.98,English,,0,0,0,,So somehow we need a mechanism where we can control
Dialogue: 0,0:02:59.36,0:03:02.98,Chinese,,0,0,0,,所以我们需要一种机制，可以控制
Dialogue: 0,0:03:02.98,0:03:07.08,English,,0,0,0,,How the flows of each individual thread are interleaved
Dialogue: 0,0:03:02.98,0:03:07.08,Chinese,,0,0,0,,线程交错的顺序（进程调度的顺序）
Dialogue: 0,0:03:08.28,0:03:12.52,English,,0,0,0,,So that bad things don't happen when we share data structures
Dialogue: 0,0:03:08.28,0:03:12.52,Chinese,,0,0,0,,只有这样，当我们共享数据结构时，才不会发生坏事
Dialogue: 0,0:03:12.78,0:03:17.74,English,,0,0,0,,Okay so this this process of controlling the interleaving is called synchronization
Dialogue: 0,0:03:12.78,0:03:17.74,Chinese,,0,0,0,,好的，控制进程交错的过程称为同步
Dialogue: 0,0:03:17.74,0:03:24.68,English,,0,0,0,,So we're going to look at techniques that you can use to write correct threaded programs by properly synchronizing them
Dialogue: 0,0:03:17.74,0:03:24.68,Chinese,,0,0,0,,我们将学习线程同步的一些技术，使用它们可以编写出正确的线程程序
Dialogue: 0,0:03:27.28,0:03:29.56,English,,0,0,0,,Now first though we need to have a clear idea
Dialogue: 0,0:03:27.28,0:03:29.56,Chinese,,0,0,0,,现在首先我们需要知道的是
Dialogue: 0,0:03:30.10,0:03:34.78,English,,0,0,0,,So sharing is the issue right if we have threads that aren't sharing any resources
Dialogue: 0,0:03:30.10,0:03:34.78,Chinese,,0,0,0,,只有资源共享会产生同步问题，如果我们的线程没有共享任何资源
Dialogue: 0,0:03:35.90,0:03:37.08,English,,0,0,0,,Then there's no problem right
Dialogue: 0,0:03:35.90,0:03:37.08,Chinese,,0,0,0,,就没有同步问题
Dialogue: 0,0:03:37.16,0:03:42.02,English,,0,0,0,,That we saw this when we looked at it processes there's no shared data structures with processes
Dialogue: 0,0:03:37.16,0:03:42.02,Chinese,,0,0,0,,如果一个进程没有共享任何数据结构
Dialogue: 0,0:03:42.72,0:03:49.28,English,,0,0,0,,So we process these just run independently we don't really care how they're interleaved note no worries okay
Dialogue: 0,0:03:42.72,0:03:49.28,Chinese,,0,0,0,,这些线程是独立运行的，线程如何交错都不会有问题，我们不需要担心
Dialogue: 0,0:03:49.80,0:03:54.14,English,,0,0,0,,But as soon as they introduce sharing then we have to be careful
Dialogue: 0,0:03:49.80,0:03:54.14,Chinese,,0,0,0,,但是一旦线程之间共享资源，我们就必须小心
Dialogue: 0,0:03:56.24,0:04:00.58,English,,0,0,0,,Okay so to understand how to synchronize threads we first need to have a clear idea
Dialogue: 0,0:03:56.24,0:04:00.58,Chinese,,0,0,0,,好，了解线程同步之前，我们首先需要
Dialogue: 0,0:04:01.02,0:04:05.20,English,,0,0,0,,Of what we mean by sharing in in threaded C programs
Dialogue: 0,0:04:01.02,0:04:05.20,Chinese,,0,0,0,,知道什么是线程中的资源共享
Dialogue: 0,0:04:06.54,0:04:13.96,English,,0,0,0,,So the answer is not as simple as global variables are shared and stack variables are not shared
Dialogue: 0,0:04:06.54,0:04:13.96,Chinese,,0,0,0,,答案并不是像「全局变量是共享的，栈变量是不共享的」这样简单
Dialogue: 0,0:04:18.70,0:04:23.66,English,,0,0,0,,Okay so with instead what we x is shared
Dialogue: 0,0:04:18.70,0:04:23.66,Chinese,,0,0,0,,如果资源 x 是共享的
Dialogue: 0,0:04:23.66,0:04:28.50,English,,0,0,0,,If only multiple threads reference some instance so that that variable x
Dialogue: 0,0:04:23.66,0:04:28.50,Chinese,,0,0,0,,当且仅当有多个线程引用资源 x 的某个实例
Dialogue: 0,0:04:29.51,0:04:34.00,English,,0,0,0,,All right so if only one thread is accessing a particular variable
Dialogue: 0,0:04:29.51,0:04:34.00,Chinese,,0,0,0,,好吧，如果只有一个线程访问特定变量
Dialogue: 0,0:04:35.64,0:04:37.06,English,,0,0,0,,Then it's not shared
Dialogue: 0,0:04:35.64,0:04:37.06,Chinese,,0,0,0,,这个变量没有被共享
Dialogue: 0,0:04:38.26,0:04:38.76,English,,0,0,0,,Okay so...
Dialogue: 0,0:04:38.26,0:04:38.76,Chinese,,0,0,0,,然后...
Dialogue: 0,0:04:40.32,0:04:45.24,English,,0,0,0,,In order to know exactly what we mean by shared we need to answer three questions
Dialogue: 0,0:04:40.32,0:04:45.24,Chinese,,0,0,0,,为了确切地知道共享的含义，我们需要回答三个问题
Dialogue: 0,0:04:46.00,0:04:48.70,English,,0,0,0,,Okay first what is the memory model for threads
Dialogue: 0,0:04:46.00,0:04:48.70,Chinese,,0,0,0,,首先是线程的内存模型是什么
Dialogue: 0,0:04:50.06,0:04:53.38,English,,0,0,0,,Okay second how are instances of variables mapped to memory
Dialogue: 0,0:04:50.06,0:04:53.38,Chinese,,0,0,0,,第二，变量实例如何映射到内存
Dialogue: 0,0:04:55.24,0:05:00.35,English,,0,0,0,,And then third how many threads might be referencing those the instances of those variables
Dialogue: 0,0:04:55.24,0:05:00.35,Chinese,,0,0,0,,第三个，有多少线程引用这些实例
Dialogue: 0,0:05:00.64,0:05:03.84,English,,0,0,0,,Okay so we'll look at each of those now in turn each of those three questions
Dialogue: 0,0:05:00.64,0:05:03.84,Chinese,,0,0,0,,好的，我们现在依次来解决这三个问题
Dialogue: 0,0:05:05.62,0:05:07.48,English,,0,0,0,,Okay so first is that the memory model
Dialogue: 0,0:05:05.62,0:05:07.48,Chinese,,0,0,0,,首先是内存模型
Dialogue: 0,0:05:10.32,0:05:15.23,English,,0,0,0,,The conceptual model is a little bit different from the operational model the way it really works
Dialogue: 0,0:05:10.32,0:05:15.23,Chinese,,0,0,0,,概念模型与真实系统略有不同
Dialogue: 0,0:05:15.56,0:05:16.78,English,,0,0,0,,Okay so conceptually
Dialogue: 0,0:05:15.56,0:05:16.78,Chinese,,0,0,0,,从概念上讲
Dialogue: 0,0:05:17.42,0:05:21.40,English,,0,0,0,,We have multiple threads that run in the context of a single process
Dialogue: 0,0:05:17.42,0:05:21.40,Chinese,,0,0,0,,我们有多个线程在单个进程的上下文中运行
Dialogue: 0,0:05:22.38,0:05:26.90,English,,0,0,0,,Okay and some of that context is shared and some of its not shared
Dialogue: 0,0:05:22.38,0:05:26.90,Chinese,,0,0,0,,有些进程上下文是共享的，有些不是共享的
Dialogue: 0,0:05:27.02,0:05:35.30,English,,0,0,0,,So each thread has its own separate thread id,stack,stack pointer,program counter,condition codes,general-purpose registers
Dialogue: 0,0:05:27.02,0:05:35.30,Chinese,,0,0,0,,每个线程都有自己独立的线程 id，栈，栈指针，程序计数器，条件码，通用目的的寄存器值
Dialogue: 0,0:05:36.60,0:05:43.78,English,,0,0,0,,And then they all share the remaining process context which is data structures that the kernel maintains
Dialogue: 0,0:05:36.60,0:05:43.78,Chinese,,0,0,0,,然后线程共享剩余的进程上下文，进程上下文由内核维护
Dialogue: 0,0:05:44.34,0:05:53.74,English,,0,0,0,,For the threads the virtual data structures to support the virtual memory system open files install signal handlers and so forth
Dialogue: 0,0:05:44.34,0:05:53.74,Chinese,,0,0,0,,如虚拟内存系统中的数据结构，打开的文件描述符，信号处理程序等等
Dialogue: 0,0:05:55.24,0:05:59.24,English,,0,0,0,,So that's the conceptual model and that if that were really enforced
Dialogue: 0,0:05:55.24,0:05:59.24,Chinese,,0,0,0,,这是概念模型，如果实际的系统是这样实现的话
Dialogue: 0,0:05:59.26,0:06:01.36,English,,0,0,0,,It would be nice it would make things simpler for us
Dialogue: 0,0:05:59.26,0:06:01.36,Chinese,,0,0,0,,那很好，因为它会让事情变的更简单
Dialogue: 0,0:06:01.42,0:06:05.60,English,,0,0,0,,But unfortunately in real life this model is not strictly enforced
Dialogue: 0,0:06:01.42,0:06:05.60,Chinese,,0,0,0,,但不幸的是，在实际的系统中，并没有严格按照这种模式实现
Dialogue: 0,0:06:07.30,0:06:13.00,English,,0,0,0,,Now although register values are really separate right the kernel maintains separate context for all the registers
Dialogue: 0,0:06:07.30,0:06:13.00,Chinese,,0,0,0,,实际上，虽然寄存器值是独立的，内核为所有寄存器维护单独的上下文
Dialogue: 0,0:06:13.02,0:06:14.42,English,,0,0,0,,So that part is good
Dialogue: 0,0:06:13.02,0:06:14.42,Chinese,,0,0,0,,这部分是好的
Dialogue: 0,0:06:15.72,0:06:21.64,English,,0,0,0,,But since the threads share the address space,a thread can access the the memory the stack
Dialogue: 0,0:06:15.72,0:06:21.64,Chinese,,0,0,0,,但由于线程共享地址空间，因此线程可以访问所有的栈
Dialogue: 0,0:06:21.90,0:06:24.86,English,,0,0,0,,One thread can access the stack of an another thread
Dialogue: 0,0:06:21.90,0:06:24.86,Chinese,,0,0,0,,一个线程可以访问另一个线程的栈
Dialogue: 0,0:06:25.18,0:06:32.76,English,,0,0,0,,Okay so although conceptually these stacks are separate and distinct and in private they're really not
Dialogue: 0,0:06:25.18,0:06:32.76,Chinese,,0,0,0,,虽然从概念上讲这些栈是独立的，但实际并非如此
Dialogue: 0,0:06:36.56,0:06:38.18,English,,0,0,0,,And so this can create some problems
Dialogue: 0,0:06:36.56,0:06:38.18,Chinese,,0,0,0,,这可能会产生一些问题
Dialogue: 0,0:06:38.18,0:06:42.28,English,,0,0,0,,So here's an example of that we'll come back to later
Dialogue: 0,0:06:38.18,0:06:42.28,Chinese,,0,0,0,,这是一个例子，我们会看到
Dialogue: 0,0:06:42.96,0:06:47.88,English,,0,0,0,,Of how this one thread can access the stack of another thread
Dialogue: 0,0:06:42.96,0:06:47.88,Chinese,,0,0,0,,一个线程如何访问另一个线程的栈
Dialogue: 0,0:06:48.54,0:06:51.54,English,,0,0,0,,So here we're defining a global variable called pointer
Dialogue: 0,0:06:48.54,0:06:51.54,Chinese,,0,0,0,,所以这里我们定义一个名为 ptr 的全局变量
Dialogue: 0,0:06:52.62,0:06:54.10,English,,0,0,0,,Which is a char **
Dialogue: 0,0:06:52.62,0:06:54.10,Chinese,,0,0,0,,类型为 char **
Dialogue: 0,0:06:55.26,0:07:01.62,English,,0,0,0,,And then in the main routine on were declaring a local variable called messages which contains
Dialogue: 0,0:06:55.26,0:07:01.62,Chinese,,0,0,0,,然后在主线程中声明一个名为 msgs 的局部变量
Dialogue: 0,0:07:02.32,0:07:05.30,English,,0,0,0,,It's a two element array which contains a couple strings
Dialogue: 0,0:07:02.32,0:07:05.30,Chinese,,0,0,0,,msgs 是一个字符串数组，包含两个字符串
Dialogue: 0,0:07:07.20,0:07:11.18,English,,0,0,0,,Which these will be printed out by the threads that we're going to create
Dialogue: 0,0:07:07.20,0:07:11.18,Chinese,,0,0,0,,我们要创建两个线程来打印这两个字符串
Dialogue: 0,0:07:12.22,0:07:17.28,English,,0,0,0,,And then we assign the global pointer to the address of the array messages
Dialogue: 0,0:07:12.22,0:07:17.28,Chinese,,0,0,0,,然后我们让 「ptr = msgs」
Dialogue: 0,0:07:17.92,0:07:21.16,English,,0,0,0,,Okay so now pointer points to messages
Dialogue: 0,0:07:17.92,0:07:21.16,Chinese,,0,0,0,,现在，ptr 指向了 msgs
Dialogue: 0,0:07:22.66,0:07:25.56,English,,0,0,0,,And then we create in a loop we create two threads
Dialogue: 0,0:07:22.66,0:07:25.56,Chinese,,0,0,0,,然后我们循环创建两个线程
Dialogue: 0,0:07:27.66,0:07:30.76,English,,0,0,0,,Each of which executes this routine called thread
Dialogue: 0,0:07:27.66,0:07:30.76,Chinese,,0,0,0,,每个线程执行一个名为 thread 的函数
Dialogue: 0,0:07:31.64,0:07:34.24,English,,0,0,0,,And and we're passing an argument
Dialogue: 0,0:07:31.64,0:07:34.24,Chinese,,0,0,0,,并且我们传递一个参数给 thread 函数
Dialogue: 0,0:07:35.00,0:07:41.94,English,,0,0,0,,So the Pthreads will assign a thread id but in this case we're going to assign our own local thread id
Dialogue: 0,0:07:35.00,0:07:41.94,Chinese,,0,0,0,,pthread_create 将分配一个线程 ID，这里我们赋值给 tid
Dialogue: 0,0:07:42.16,0:07:43.58,English,,0,0,0,,By passing this loop index
Dialogue: 0,0:07:42.16,0:07:43.58,Chinese,,0,0,0,,然后我们把循环索引 i 作为参数传递给 thread 函数
Dialogue: 0,0:07:44.32,0:07:47.66,English,,0,0,0,,Okay so this is an example we talked about this last time
Dialogue: 0,0:07:44.32,0:07:47.66,Chinese,,0,0,0,,好的，这和我们上次讲的例子一样
Dialogue: 0,0:07:49.24,0:07:51.76,English,,0,0,0,,It's kind of...it's this is perfectly okay there's no race
Dialogue: 0,0:07:49.24,0:07:51.76,Chinese,,0,0,0,,这有点奇怪，但这样做是没问题的，不会产生竞争
Dialogue: 0,0:07:52.38,0:07:58.82,English,,0,0,0,,But it's a little weird because we're going to take this index i and cast it to a generic pointer
Dialogue: 0,0:07:52.38,0:07:58.82,Chinese,,0,0,0,,但它有点奇怪，因为我们把索引 i 强制转换成了一个「void *」类型
Dialogue: 0,0:08:03.22,0:08:07.02,English,,0,0,0,,Okay and then after we create these threads then we'll exit the main thread
Dialogue: 0,0:08:03.22,0:08:07.02,Chinese,,0,0,0,,然后在创建这些线程之后，我们退出主线程
Dialogue: 0,0:08:09.44,0:08:17.08,English,,0,0,0,,Now each the thread routine dereferences its argument to get the local the local thread id
Dialogue: 0,0:08:09.44,0:08:17.08,Chinese,,0,0,0,,每个线程将参数强制转换成 long 类型，得到线程 id
Dialogue: 0,0:08:17.96,0:08:21.40,English,,0,0,0,,And then it declares a static variable count
Dialogue: 0,0:08:17.96,0:08:21.40,Chinese,,0,0,0,,然后它声明了一个静态变量 cnt
Dialogue: 0,0:08:21.42,0:08:25.68,English,,0,0,0,,That we're going to use to count how many times this thread routine is called inside of a thread
Dialogue: 0,0:08:21.42,0:08:25.68,Chinese,,0,0,0,,我们用 cnt 来统计线程被调用的次数
Dialogue: 0,0:08:27.38,0:08:33.66,English,,0,0,0,,And then it just prints a simple message from identifying that giving the local thread id
Dialogue: 0,0:08:27.38,0:08:33.66,Chinese,,0,0,0,,然后它只是简单的根据 myid
Dialogue: 0,0:08:35.04,0:08:40.42,English,,0,0,0,,And then the message indexed by myid
Dialogue: 0,0:08:35.04,0:08:40.42,Chinese,,0,0,0,,打印 msgs 中的字符串
Dialogue: 0,0:08:40.90,0:08:42.90,English,,0,0,0,,So pointer points to messages
Dialogue: 0,0:08:40.90,0:08:42.90,Chinese,,0,0,0,,因为 ptr 指向 msgs
Dialogue: 0,0:08:43.00,0:08:46.40,English,,0,0,0,,So thread zero will print "hello from foo"
Dialogue: 0,0:08:43.00,0:08:46.40,Chinese,,0,0,0,,所以线程零将打印「hello from foo」
Dialogue: 0,0:08:47.32,0:08:50.44,English,,0,0,0,,And thread 1 will print "hello from bar"
Dialogue: 0,0:08:47.32,0:08:50.44,Chinese,,0,0,0,,并且线程 1 将打印「hello from bar」
Dialogue: 0,0:08:51.86,0:08:55.92,English,,0,0,0,,And then we increment the pre increment the counter variable
Dialogue: 0,0:08:51.86,0:08:55.92,Chinese,,0,0,0,,然后我们把 cnt 的值 +1
Dialogue: 0,0:08:58.80,0:08:59.46,English,,0,0,0,,Okay so
Dialogue: 0,0:08:58.80,0:08:59.46,Chinese,,0,0,0,,然后
Dialogue: 0,0:09:02.36,0:09:07.62,English,,0,0,0,,Although it doesn't you would it looks like we're accessing this global variable pointer
Dialogue: 0,0:09:02.36,0:09:07.62,Chinese,,0,0,0,,这里看上去我们访问的是一个全局的指针变量 ptr
Dialogue: 0,0:09:08.02,0:09:14.46,English,,0,0,0,,But since that was assigned to be the address of the local variable on the main thread stack
Dialogue: 0,0:09:08.02,0:09:14.46,Chinese,,0,0,0,,但是因为 ptr 指向了 msgs，msgs 是存储在主线程栈上的一个局部变量
Dialogue: 0,0:09:15.10,0:09:23.26,English,,0,0,0,,We've got this these peer threads accessing local variables on the main thread stack okay
Dialogue: 0,0:09:15.10,0:09:23.26,Chinese,,0,0,0,,所以我们这里访问了主线程栈上的局部变量
Dialogue: 0,0:09:23.36,0:09:28.22,English,,0,0,0,,So that I just this is not it you never want to do this as a very bad practice
Dialogue: 0,0:09:23.36,0:09:28.22,Chinese,,0,0,0,,这种做法不好，在实际编程中最好不要这样做
Dialogue: 0,0:09:28.22,0:09:30.96,English,,0,0,0,,But I...it's a kind of thing that can happen sometimes
Dialogue: 0,0:09:28.22,0:09:30.96,Chinese,,0,0,0,,但有时候我们也会这样做，但我们还没有意识到
Dialogue: 0,0:09:33.84,0:09:39.28,English,,0,0,0,,By accident you know if you forget that pointer actually was assigned to you know some stack address
Dialogue: 0,0:09:33.84,0:09:39.28,Chinese,,0,0,0,,比如你忘记了 ptr 实际上指向了一个栈地址
Dialogue: 0,0:09:41.08,0:09:46.60,English,,0,0,0,,Okay so the second question that is how do we map variable instances to memory
Dialogue: 0,0:09:41.08,0:09:46.60,Chinese,,0,0,0,,好的，第二个问题是我们如何将变量实例映射到内存
Dialogue: 0,0:09:47.10,0:09:50.16,English,,0,0,0,,Now we looked at this when we studied linking
Dialogue: 0,0:09:47.10,0:09:50.16,Chinese,,0,0,0,,讲链接那节课时，我们学过了这个
Dialogue: 0,0:09:50.16,0:09:54.78,English,,0,0,0,,But let's just review this quickly again to make sure that it's clear to you
Dialogue: 0,0:09:50.16,0:09:54.78,Chinese,,0,0,0,,让我们快速回顾一下
Dialogue: 0,0:09:56.80,0:10:01.38,English,,0,0,0,,So global variables are variables that are referenced outside of a function
Dialogue: 0,0:09:56.80,0:10:01.38,Chinese,,0,0,0,,全局变量是定义在函数外的变量
Dialogue: 0,0:10:03.00,0:10:08.08,English,,0,0,0,,And virtual memory the linker when it does symbol resolution make sure that
Dialogue: 0,0:10:03.00,0:10:08.08,Chinese,,0,0,0,,链接器在进行符号解析时确保
Dialogue: 0,0:10:08.08,0:10:12.50,English,,0,0,0,,There's exactly one instance of every global variable in virtual memory
Dialogue: 0,0:10:08.08,0:10:12.50,Chinese,,0,0,0,,虚拟内存中的每个全局变量都只有一个实例
Dialogue: 0,0:10:16.50,0:10:20.14,English,,0,0,0,,Now local variables are declared on the stack inside of a function
Dialogue: 0,0:10:16.50,0:10:20.14,Chinese,,0,0,0,,局部变量在函数的内部声明，在栈上分配内存
Dialogue: 0,0:10:23.26,0:10:24.94,English,,0,0,0,,Without the static attribute
Dialogue: 0,0:10:23.26,0:10:24.94,Chinese,,0,0,0,,如果该局部变量没有使用 static 修饰
Dialogue: 0,0:10:26.28,0:10:32.46,English,,0,0,0,,And so in this case each the stack for each thread will contain one instance of that local variable
Dialogue: 0,0:10:26.28,0:10:32.46,Chinese,,0,0,0,,因此，在这种情况下，每个线程的栈上将包含该局部变量的一个实例
Dialogue: 0,0:10:37.60,0:10:37.94,English,,0,0,0,,Now
Dialogue: 0,0:10:37.60,0:10:37.94,Chinese,,0,0,0,,嗯
Dialogue: 0,0:10:39.30,0:10:42.70,English,,0,0,0,,If variables are declared inside of a function with the static attribute
Dialogue: 0,0:10:39.30,0:10:42.70,Chinese,,0,0,0,,如果变量在函数内部声明且用 static 修饰
Dialogue: 0,0:10:44.28,0:10:49.06,English,,0,0,0,,Then the scope of that variable is limited to that function meaning no other function can access it
Dialogue: 0,0:10:44.28,0:10:49.06,Chinese,,0,0,0,,然后该变量的范围仅限于该函数，即没有其他函数可以访问它
Dialogue: 0,0:10:50.56,0:10:55.66,English,,0,0,0,,But that static variable is stored along with all the other local variables
Dialogue: 0,0:10:50.56,0:10:55.66,Chinese,,0,0,0,,但是，该静态变量与所有其他全局（原文是局部）变量存储在一起
Dialogue: 0,0:10:55.70,0:11:04.14,English,,0,0,0,,So there's any static variable declared inside of a function has exactly one instance in memory
Dialogue: 0,0:10:55.70,0:11:04.14,Chinese,,0,0,0,,因此，在函数内部声明的任何静态变量在内存中只有一个实例
Dialogue: 0,0:11:04.96,0:11:10.66,English,,0,0,0,,And if you were to have say multiple functions that declared (the same) a static variable with the same name
Dialogue: 0,0:11:04.96,0:11:10.66,Chinese,,0,0,0,,如果多个函数声明一个具有相同名称的静态变量
Dialogue: 0,0:11:11.30,0:11:14.44,English,,0,0,0,,The compiler would disambiguate those somehow
Dialogue: 0,0:11:11.30,0:11:14.44,Chinese,,0,0,0,,编译器会以某种方式消除歧义
Dialogue: 0,0:11:14.44,0:11:17.24,English,,0,0,0,,It would append some kind of unique
Dialogue: 0,0:11:14.44,0:11:17.24,Chinese,,0,0,0,,它会附加某种唯一的标识
Dialogue: 0,0:11:19.10,0:11:20.80,English,,0,0,0,,It would somehow make that name unique
Dialogue: 0,0:11:19.10,0:11:20.80,Chinese,,0,0,0,,或它会以某种方式使这个变量名独一无二
Dialogue: 0,0:11:24.48,0:11:30.14,English,,0,0,0,,Okay so what recall how all these different types of variable instances are mapped into memory
Dialogue: 0,0:11:24.48,0:11:30.14,Chinese,,0,0,0,,那么回想一下所有这些不同类型的变量实例是如何映射到内存的
Dialogue: 0,0:11:31.86,0:11:35.38,English,,0,0,0,,Okay pointer is a global variable
Dialogue: 0,0:11:31.86,0:11:35.38,Chinese,,0,0,0,,ptr 是一个全局变量
Dialogue: 0,0:11:35.38,0:11:40.16,English,,0,0,0,,So there's one instance of pointer in the address space
Dialogue: 0,0:11:35.38,0:11:40.16,Chinese,,0,0,0,,所以地址空间中有一个 ptr 的实例
Dialogue: 0,0:11:42.72,0:11:45.56,English,,0,0,0,,And it's stored in the data segment
Dialogue: 0,0:11:42.72,0:11:45.56,Chinese,,0,0,0,,它存储在数据段中
Dialogue: 0,0:11:50.54,0:11:57.40,English,,0,0,0,,i and messages are examples of local variables to main
Dialogue: 0,0:11:50.54,0:11:57.40,Chinese,,0,0,0,,i 和 msgs 是主线程上的局部变量
Dialogue: 0,0:11:58.44,0:12:05.12,English,,0,0,0,,So there's one instance of these stored on the stack of main stack
Dialogue: 0,0:11:58.44,0:12:05.12,Chinese,,0,0,0,,所以主线程的栈上存储这些变量的实例
Dialogue: 0,0:12:06.22,0:12:12.08,English,,0,0,0,,And we'll denote those with this notation we'll say variable i
Dialogue: 0,0:12:06.22,0:12:12.08,Chinese,,0,0,0,,我们用下面这种方式来表示
Dialogue: 0,0:12:12.70,0:12:17.04,English,,0,0,0,,i.m means variable i is stored on main stack
Dialogue: 0,0:12:12.70,0:12:17.04,Chinese,,0,0,0,,i.m 表示变量 i 存储在主线程的栈上
Dialogue: 0,0:12:18.32,0:12:20.78,English,,0,0,0,,And messages is stored on the stack of main
Dialogue: 0,0:12:18.32,0:12:20.78,Chinese,,0,0,0,,msgs.m 表示 msgs 存储在主线程的栈上
Dialogue: 0,0:12:23.52,0:12:28.86,English,,0,0,0,,Okay now myid is a local variable defined in this thread routine
Dialogue: 0,0:12:23.52,0:12:28.86,Chinese,,0,0,0,,myid 是在这个线程函数中定义的局部变量
Dialogue: 0,0:12:30.34,0:12:32.48,English,,0,0,0,,And so there's actually since there's two of these threads
Dialogue: 0,0:12:30.34,0:12:32.48,Chinese,,0,0,0,,实际上，因为有两个这样的线程
Dialogue: 0,0:12:32.74,0:12:39.62,English,,0,0,0,,There's there's now there are in memory there's there's two instances of myid one for each stack
Dialogue: 0,0:12:32.74,0:12:39.62,Chinese,,0,0,0,,所有有两个 myid 的实例，一个线程有一个
Dialogue: 0,0:12:40.54,0:12:43.38,English,,0,0,0,,Okay associated with the stack associated with each thread
Dialogue: 0,0:12:40.54,0:12:43.38,Chinese,,0,0,0,,因为每个线程都有一个相关联的栈
Dialogue: 0,0:12:45.28,0:12:49.52,English,,0,0,0,,So myid.p0 is stored on peer thread 0's stack
Dialogue: 0,0:12:45.28,0:12:49.52,Chinese,,0,0,0,,所以，myid.p0 表示存储在线程 0 的栈上的 mypid 实例
Dialogue: 0,0:12:50.26,0:12:54.64,English,,0,0,0,,And myid.p1 is stored on peer thread 1's stack
Dialogue: 0,0:12:50.26,0:12:54.64,Chinese,,0,0,0,,myid.p1 表示存储在线程 1 的栈上的 myid 实例
Dialogue: 0,0:12:59.20,0:13:07.68,English,,0,0,0,,Ok and now this counter variable the static counter variable has just exactly one instance in virtual memory
Dialogue: 0,0:12:59.20,0:13:07.68,Chinese,,0,0,0,,好了，静态变量 cnt 在虚拟内存中只有一个实例
Dialogue: 0,0:13:07.98,0:13:13.02,English,,0,0,0,,And it sits in the data segment along with the other global variables like like pointer
Dialogue: 0,0:13:07.98,0:13:13.02,Chinese,,0,0,0,,它和其他全局变量一样位于数据段中，如 ptr
Dialogue: 0,0:13:17.34,0:13:18.62,English,,0,0,0,,Okay now so the question is
Dialogue: 0,0:13:17.34,0:13:18.62,Chinese,,0,0,0,,好的，现在问题是
Dialogue: 0,0:13:20.78,0:13:23.24,English,,0,0,0,,Which of these variables are shared and which are not
Dialogue: 0,0:13:20.78,0:13:23.24,Chinese,,0,0,0,,哪些变量是共享的，哪些不是
Dialogue: 0,0:13:25.66,0:13:26.32,English,,0,0,0,,Okay so we can
Dialogue: 0,0:13:25.66,0:13:26.32,Chinese,,0,0,0,,好的
Dialogue: 0,0:13:28.50,0:13:36.88,English,,0,0,0,,Remember what we said is it's shared if more than one thread is accessing an instance of that variable
Dialogue: 0,0:13:28.50,0:13:36.88,Chinese,,0,0,0,,根据定义，如果有多个线程正在访问该变量的实例，我们说该变量是共享的
Dialogue: 0,0:13:38.98,0:13:42.82,English,,0,0,0,,Okay so let's just list all the different variables
Dialogue: 0,0:13:38.98,0:13:42.82,Chinese,,0,0,0,,让我们列出所有不同的变量
Dialogue: 0,0:13:44.20,0:13:48.62,English,,0,0,0,,And then let's look at each of these threads and see if it's referenced by that thread
Dialogue: 0,0:13:44.20,0:13:48.62,Chinese,,0,0,0,,然后看看这些变量都被哪些线程引用
Dialogue: 0,0:13:50.26,0:13:52.66,English,,0,0,0,,Okay so what about,what about pointer
Dialogue: 0,0:13:50.26,0:13:52.66,Chinese,,0,0,0,,从 ptr 开始
Dialogue: 0,0:13:54.80,0:13:59.45,English,,0,0,0,,Right there's just it's referenced by the main thread right
Dialogue: 0,0:13:54.80,0:13:59.45,Chinese,,0,0,0,,ptr 被主线程引用
Dialogue: 0,0:14:00.80,0:14:02.80,English,,0,0,0,,And what about peer threads zero
Dialogue: 0,0:14:00.80,0:14:02.80,Chinese,,0,0,0,,ptr 被线程 0 引用吗？
Dialogue: 0,0:14:07.38,0:14:10.20,English,,0,0,0,,Yeah it's referenced by peer thread zero right here
Dialogue: 0,0:14:07.38,0:14:10.20,Chinese,,0,0,0,,对，它被线程 0 引用
Dialogue: 0,0:14:12.88,0:14:14.14,English,,0,0,0,,Right here
Dialogue: 0,0:14:12.88,0:14:14.14,Chinese,,0,0,0,,就在这儿（printf语句中）
Dialogue: 0,0:14:15.80,0:14:17.56,English,,0,0,0,,And similarly for peer thread one
Dialogue: 0,0:14:15.80,0:14:17.56,Chinese,,0,0,0,,同样，线程一也引用了 ptr
Dialogue: 0,0:14:18.64,0:14:21.72,English,,0,0,0,,Okay so pointer is referenced by all three threads
Dialogue: 0,0:14:18.64,0:14:21.72,Chinese,,0,0,0,,好的，所以三个线程都引用了 ptr
Dialogue: 0,0:14:25.02,0:14:25.90,English,,0,0,0,,Now what about count
Dialogue: 0,0:14:25.02,0:14:25.90,Chinese,,0,0,0,,那 cnt 的情况呢？
Dialogue: 0,0:14:29.32,0:14:31.78,English,,0,0,0,,Counts not referenced by the main thread
Dialogue: 0,0:14:29.32,0:14:31.78,Chinese,,0,0,0,,cnt 未被主线程引用
Dialogue: 0,0:14:32.96,0:14:36.00,English,,0,0,0,,But it is referenced by the two peer threads
Dialogue: 0,0:14:32.96,0:14:36.00,Chinese,,0,0,0,,但它被线程 0 和线程 1 引用
Dialogue: 0,0:14:38.44,0:14:40.16,English,,0,0,0,,Now what about i in main
Dialogue: 0,0:14:38.44,0:14:40.16,Chinese,,0,0,0,,主线程中的变量 i 的情况呢
Dialogue: 0,0:14:42.62,0:14:44.28,English,,0,0,0,,That's referenced by main of course
Dialogue: 0,0:14:42.62,0:14:44.28,Chinese,,0,0,0,,当然，i 被主线程引用
Dialogue: 0,0:14:44.30,0:14:49.04,English,,0,0,0,,But not by but not by either of the two threads
Dialogue: 0,0:14:44.30,0:14:49.04,Chinese,,0,0,0,,但线程 0 和线程 1 都没有引用i
Dialogue: 0,0:14:50.74,0:14:52.84,English,,0,0,0,,Now we're about messages, the messages array
Dialogue: 0,0:14:50.74,0:14:52.84,Chinese,,0,0,0,,我们现在来看 msgs
Dialogue: 0,0:14:54.62,0:14:57.92,English,,0,0,0,,Okay so that's accessed by main
Dialogue: 0,0:14:54.62,0:14:57.92,Chinese,,0,0,0,,它们被主线程引用
Dialogue: 0,0:14:58.74,0:15:00.92,English,,0,0,0,,And indirectly through pointer
Dialogue: 0,0:14:58.74,0:15:00.92,Chinese,,0,0,0,,并通过 ptr
Dialogue: 0,0:15:01.52,0:15:05.56,English,,0,0,0,,It's referenced by each of these two peer threads
Dialogue: 0,0:15:01.52,0:15:05.56,Chinese,,0,0,0,,被线程 0 和线程 1 引用
Dialogue: 0,0:15:07.66,0:15:12.24,English,,0,0,0,,Now what about myid defined in peer thread zero
Dialogue: 0,0:15:07.66,0:15:12.24,Chinese,,0,0,0,,线程零中定义的 myid 的情况呢
Dialogue: 0,0:15:14.20,0:15:16.54,English,,0,0,0,,Okay so that's referenced that's a local variable
Dialogue: 0,0:15:14.20,0:15:16.54,Chinese,,0,0,0,,它是一个局部变量
Dialogue: 0,0:15:16.54,0:15:21.06,English,,0,0,0,,So it's only referenced by peer thread zero right it's not referenced by either the other threads
Dialogue: 0,0:15:16.54,0:15:21.06,Chinese,,0,0,0,,所以它只被对程零引用，没有被其他线程引用
Dialogue: 0,0:15:21.08,0:15:29.00,English,,0,0,0,,And similarly for myid and in peer threat one
Dialogue: 0,0:15:21.08,0:15:29.00,Chinese,,0,0,0,,线程1中的 mypid 也是类似的
Dialogue: 0,0:15:33.12,0:15:36.32,English,,0,0,0,,Okay so given that definition then
Dialogue: 0,0:15:33.12,0:15:36.32,Chinese,,0,0,0,,那么根据共享的定义
Dialogue: 0,0:15:37.60,0:15:39.90,English,,0,0,0,,Which of these variables is shared
Dialogue: 0,0:15:37.60,0:15:39.90,Chinese,,0,0,0,,这些变量中的哪些是共享的
Dialogue: 0,0:15:42.28,0:15:44.74,English,,0,0,0,,So it's really straightforward with yeah
Dialogue: 0,0:15:42.28,0:15:44.74,Chinese,,0,0,0,,这真的很直白
Dialogue: 0,0:15:50.56,0:15:55.88,English,,0,0,0,,Okay so the question is discount count as a share variable and answer is yes
Dialogue: 0,0:15:50.56,0:15:55.88,Chinese,,0,0,0,,变量 cnt 肯定是共享的
Dialogue: 0,0:15:56.70,0:15:59.10,English,,0,0,0,,Because it's declared static
Dialogue: 0,0:15:56.70,0:15:59.10,Chinese,,0,0,0,,因为它被定义为静态的
Dialogue: 0,0:15:59.86,0:16:03.66,English,,0,0,0,,It's there's one instance of it in virtual memory
Dialogue: 0,0:15:59.86,0:16:03.66,Chinese,,0,0,0,,它在虚拟内存中的只有一个实例
Dialogue: 0,0:16:04.94,0:16:08.82,English,,0,0,0,,And each of the threads references that instance
Dialogue: 0,0:16:04.94,0:16:08.82,Chinese,,0,0,0,,且线程 0 和线程 1 都引用该实例
Dialogue: 0,0:16:09.40,0:16:13.12,English,,0,0,0,,Okay so it's shared,it's really like a global variable
Dialogue: 0,0:16:09.40,0:16:13.12,Chinese,,0,0,0,,所以它是共享的，它真的像一个全局变量
Dialogue: 0,0:16:13.76,0:16:16.86,English,,0,0,0,,It's just a scope is limited to the...
Dialogue: 0,0:16:13.76,0:16:16.86,Chinese,,0,0,0,,但它共享的范围只限于该函数
Dialogue: 0,0:16:18.30,0:16:22.98,English,,0,0,0,,It stored the same way a global variable is but its scope is limited to the function that it's defined in
Dialogue: 0,0:16:18.30,0:16:22.98,Chinese,,0,0,0,,它以与全局变量相同的方式存储，但其范围仅限于其定义的函数
Dialogue: 0,0:16:24.48,0:16:27.26,English,,0,0,0,,Okay so to determine if each one of these is whether
Dialogue: 0,0:16:24.48,0:16:27.26,Chinese,,0,0,0,,为了确定这些变量中
Dialogue: 0,0:16:27.48,0:16:30.14,English,,0,0,0,,Which of these variables are shared in which one's not we just
Dialogue: 0,0:16:27.48,0:16:30.14,Chinese,,0,0,0,,哪些变量是共享的，哪些不是共享的
Dialogue: 0,0:16:30.66,0:16:39.00,English,,0,0,0,,We just look go across and for any variable with its shared by more than,more than one thread then it's shared
Dialogue: 0,0:16:30.66,0:16:39.00,Chinese,,0,0,0,,我们只需要看这个变量是否被多个线程引用，如果是，则该变量是共享的
Dialogue: 0,0:16:39.68,0:16:40.78,English,,0,0,0,,So pointer shared
Dialogue: 0,0:16:39.68,0:16:40.78,Chinese,,0,0,0,,所以 ptr 是共享的
Dialogue: 0,0:16:44.98,0:16:48.38,English,,0,0,0,,So pointer is shared count is not shared
Dialogue: 0,0:16:44.98,0:16:48.38,Chinese,,0,0,0,,所以 ptr 是共享的，cnt 不是共享的
Dialogue: 0,0:16:50.92,0:16:56.10,English,,0,0,0,,Oh no count is shared because it's it's referenced by peer thread zero and peer thread one
Dialogue: 0,0:16:50.92,0:16:56.10,Chinese,,0,0,0,,抱歉，cnt 是共享的，因为它被线程 0 和线程 1 引用
Dialogue: 0,0:16:58.42,0:17:01.62,English,,0,0,0,,I's not shared because it's only referenced by main
Dialogue: 0,0:16:58.42,0:17:01.62,Chinese,,0,0,0,,i 不是共享的，因为它仅被主线程引用
Dialogue: 0,0:17:02.98,0:17:03.38,English,,0,0,0,,So
Dialogue: 0,0:17:02.98,0:17:03.38,Chinese,,0,0,0,,所以
Dialogue: 0,0:17:07.94,0:17:11.76,English,,0,0,0,,Messages is access referenced by all three threads so it's shared
Dialogue: 0,0:17:07.94,0:17:11.76,Chinese,,0,0,0,,msgs 被三个线程引用，因此 msgs 是共享的
Dialogue: 0,0:17:12.78,0:17:18.60,English,,0,0,0,,But myid is not shared because it's only referenced by exactly one thread
Dialogue: 0,0:17:12.78,0:17:18.60,Chinese,,0,0,0,,但 myid 没有共享，因为它只被一个线程引用
Dialogue: 0,0:17:19.02,0:17:28.22,English,,0,0,0,,Okay so pointer count and messages are the shared variables in this program and the others are not share
Dialogue: 0,0:17:19.02,0:17:28.22,Chinese,,0,0,0,,好的，所以这个程序中 ptr，msgs，cnt 是共享的，其他的变量是不共享的
Dialogue: 0,0:17:28.66,0:17:28.86,English,,0,0,0,,Yes
Dialogue: 0,0:17:28.66,0:17:28.86,Chinese,,0,0,0,,请讲
Dialogue: 0,0:17:29.32,0:17:35.74,English,,0,0,0,,[student speaking]
Dialogue: 0,0:17:29.32,0:17:35.74,Chinese,,0,0,0,,[学生提问]
Dialogue: 0,0:17:35.74,0:17:37.86,English,,0,0,0,,So if you declared my ideas static
Dialogue: 0,0:17:35.74,0:17:37.86,Chinese,,0,0,0,,如果把 myid 定义为静态变量
Dialogue: 0,0:17:38.82,0:17:41.92,English,,0,0,0,,With the second process of overridden it yeah that would be a race
Dialogue: 0,0:17:38.82,0:17:41.92,Chinese,,0,0,0,,第二个线程会改变 myid 的值，这里产生了竞争
Dialogue: 0,0:17:43.44,0:17:47.44,English,,0,0,0,,Okay so that would...we just depend on which thread executed first
Dialogue: 0,0:17:43.44,0:17:47.44,Chinese,,0,0,0,,所以运行的结果取决于哪个线程先执行
Dialogue: 0,0:17:48.16,0:17:50.32,English,,0,0,0,,So you would really wouldn't want to do that
Dialogue: 0,0:17:48.16,0:17:50.32,Chinese,,0,0,0,,所以在实际的代码中不要这样做
Dialogue: 0,0:17:55.38,0:18:00.26,English,,0,0,0,,Okay so we have a very clear notion now of what we mean by sharing
Dialogue: 0,0:17:55.38,0:18:00.26,Chinese,,0,0,0,,好的，现在我们对共享有了一个非常明确的认识
Dialogue: 0,0:18:08.32,0:18:12.64,English,,0,0,0,,So these being able to share variables like this in this ways is very handy
Dialogue: 0,0:18:08.32,0:18:12.64,Chinese,,0,0,0,,以这种方式共享变量是非常方便的
Dialogue: 0,0:18:14.12,0:18:16.54,English,,0,0,0,,But you can run into some really nasty problems
Dialogue: 0,0:18:14.12,0:18:16.54,Chinese,,0,0,0,,但是你可能遇到一些非常讨厌的问题
Dialogue: 0,0:18:17.76,0:18:20.88,English,,0,0,0,,That are very surprising,so let me show you an example
Dialogue: 0,0:18:17.76,0:18:20.88,Chinese,,0,0,0,,这些问题可能令人惊讶，让我给你举个例子
Dialogue: 0,0:18:23.28,0:18:24.34,English,,0,0,0,,This is a program
Dialogue: 0,0:18:23.28,0:18:24.34,Chinese,,0,0,0,,这是一个程序
Dialogue: 0,0:18:25.72,0:18:29.72,English,,0,0,0,,Called bad count so obviously there's something wrong with this I'm giving you a little clue
Dialogue: 0,0:18:25.72,0:18:29.72,Chinese,,0,0,0,,这个程序被称为 bad count，取这个名字暗示这个程序在计数上会出错
Dialogue: 0,0:18:31.28,0:18:39.58,English,,0,0,0,,But what we want to do is we want to create a bunch of threads or a number of threads
Dialogue: 0,0:18:31.28,0:18:39.58,Chinese,,0,0,0,,我们想要做的是创建多个线程
Dialogue: 0,0:18:40.46,0:18:44.18,English,,0,0,0,,And each of those threads will increment a global variable called count
Dialogue: 0,0:18:40.46,0:18:44.18,Chinese,,0,0,0,,每个线程都会增加全局变量 cnt 的值
Dialogue: 0,0:18:45.00,0:18:47.04,English,,0,0,0,,Some number of times the same number of times
Dialogue: 0,0:18:45.00,0:18:47.04,Chinese,,0,0,0,,并且增加的次数相等
Dialogue: 0,0:18:49.26,0:18:55.02,English,,0,0,0,,Okay so we pass in the number of iterations as the first argument
Dialogue: 0,0:18:49.26,0:18:55.02,Chinese,,0,0,0,,好的，我们将迭代次数作为第一个参数传递给 thread 函数
Dialogue: 0,0:18:56.16,0:18:59.54,English,,0,0,0,,And here's our well here's our global globally shared variable
Dialogue: 0,0:18:56.16,0:18:59.54,Chinese,,0,0,0,,这里是我们的全局共享变量 cnt
Dialogue: 0,0:19:02.02,0:19:03.84,English,,0,0,0,,And you remember what volatile means
Dialogue: 0,0:19:02.02,0:19:03.84,Chinese,,0,0,0,,你还记得 volatile 关键字的含义吗
Dialogue: 0,0:19:04.92,0:19:06.10,English,,0,0,0,,Everybody remember what that means
Dialogue: 0,0:19:04.92,0:19:06.10,Chinese,,0,0,0,,你们都记得这个关键字的含义吗
Dialogue: 0,0:19:07.68,0:19:10.30,English,,0,0,0,,So what is volatile,what is volatile tell the compiler
Dialogue: 0,0:19:07.68,0:19:10.30,Chinese,,0,0,0,,什么是 volatile，volatile 有什么作用？
Dialogue: 0,0:19:10.98,0:19:11.48,English,,0,0,0,,Yes
Dialogue: 0,0:19:10.98,0:19:11.48,Chinese,,0,0,0,,请讲
Dialogue: 0,0:19:11.60,0:19:22.66,English,,0,0,0,,[student speaking]
Dialogue: 0,0:19:11.60,0:19:22.66,Chinese,,0,0,0,,[学生回答]
Dialogue: 0,0:19:24.72,0:19:32.92,English,,0,0,0,,It actually you're on in the right direction actually tells,it tells the compiler never to put that variable in a register
Dialogue: 0,0:19:24.72,0:19:32.92,Chinese,,0,0,0,,你回答的方向是正确的，实际上，volatile 告诉编译器永远不要把该变量放在寄存器中
Dialogue: 0,0:19:33.72,0:19:38.96,English,,0,0,0,,Okay so it always read that value from memory or store it to memory and
Dialogue: 0,0:19:33.72,0:19:38.96,Chinese,,0,0,0,,所以，volatile 修饰的变量总是从内存中读取，修改后又存储到内存中
Dialogue: 0,0:19:39.54,0:19:44.64,English,,0,0,0,,You do that because of exactly the kind of possibility that you mentioned
Dialogue: 0,0:19:39.54,0:19:44.64,Chinese,,0,0,0,,使用 volatile 关键字是因为你提到的那种可能性
Dialogue: 0,0:19:46.90,0:19:50.60,English,,0,0,0,,So in this case we have
Dialogue: 0,0:19:46.90,0:19:50.60,Chinese,,0,0,0,,我们回来看看我们的程序
Dialogue: 0,0:19:50.98,0:19:55.88,English,,0,0,0,,We create two threads by with two distinct calls to two pthread create
Dialogue: 0,0:19:50.98,0:19:55.88,Chinese,,0,0,0,,我们调用了两次 pthread_create 函数，创建了两个线程
Dialogue: 0,0:19:57.42,0:20:02.76,English,,0,0,0,,Each of these threads will run the the thread routine called thread
Dialogue: 0,0:19:57.42,0:20:02.76,Chinese,,0,0,0,,每个线程都将执行名为 thread 的函数
Dialogue: 0,0:20:03.36,0:20:08.50,English,,0,0,0,,And it will pass and as an argument the address of the number of iterations that it should
Dialogue: 0,0:20:03.36,0:20:08.50,Chinese,,0,0,0,,并将 niters 的地址作为参数传递给了 thread 函数
Dialogue: 0,0:20:09.34,0:20:10.18,English,,0,0,0,,That it should iterate
Dialogue: 0,0:20:09.34,0:20:10.18,Chinese,,0,0,0,,作为 thread 函数中循环的迭代次数
Dialogue: 0,0:20:11.66,0:20:15.56,English,,0,0,0,,Now you remember when we were looking when we were passing connected file descriptors
Dialogue: 0,0:20:11.66,0:20:15.56,Chinese,,0,0,0,,现在你还记得当我们传递连接文件描述符的时候
Dialogue: 0,0:20:16.76,0:20:18.70,English,,0,0,0,,If we pass an address that was a race
Dialogue: 0,0:20:16.76,0:20:18.70,Chinese,,0,0,0,,如果我们传递的是一个地址，那将会产生竞争
Dialogue: 0,0:20:20.10,0:20:22.86,English,,0,0,0,,Okay but in this case there's no race this is fine
Dialogue: 0,0:20:20.10,0:20:22.86,Chinese,,0,0,0,,但是在这种情况下没有出现竞争的情况，这是正确的
Dialogue: 0,0:20:22.86,0:20:25.88,English,,0,0,0,,It's fine just to pass the address of number of iterations
Dialogue: 0,0:20:22.86,0:20:25.88,Chinese,,0,0,0,,传递迭代次数的参数的地址是没问题的
Dialogue: 0,0:20:26.46,0:20:32.52,English,,0,0,0,,So why is it okay in this case but it wasn't okay when we were passing the connected file descriptor
Dialogue: 0,0:20:26.46,0:20:32.52,Chinese,,0,0,0,,那么为什么在这种情况下它没问题，但是当我们传递文件描述符给线程时并不合适
Dialogue: 0,0:20:32.88,0:20:35.28,English,,0,0,0,,That we got from acceptant to our thread routine
Dialogue: 0,0:20:32.88,0:20:35.28,Chinese,,0,0,0,,调用 accept 得到的文件描述符
Dialogue: 0,0:20:49.06,0:20:51.98,English,,0,0,0,,Yes
Dialogue: 0,0:20:49.06,0:20:51.98,Chinese,,0,0,0,,请讲
Dialogue: 0,0:20:52.00,0:20:54.40,English,,0,0,0,,Exactly because the thread doesn't modify the value
Dialogue: 0,0:20:52.00,0:20:54.40,Chinese,,0,0,0,,对，答案就是这里线程不会修改该迭代次数的值
Dialogue: 0,0:20:54.60,0:21:01.82,English,,0,0,0,,And that the problem we had before was that our main thread was modifying that connected descriptor on the next call to accept
Dialogue: 0,0:20:54.60,0:21:01.82,Chinese,,0,0,0,,而在上一个例子中，当主线程调用 accept 函数时，会修改文件描述符
Dialogue: 0,0:21:02.56,0:21:04.76,English,,0,0,0,,But here it's just a read-only variable so we're okay
Dialogue: 0,0:21:02.56,0:21:04.76,Chinese,,0,0,0,,但这里它只是一个只读变量，所以这里是没问题的
Dialogue: 0,0:21:06.58,0:21:08.90,English,,0,0,0,,But you see the how tricky the reasoning can get right there's
Dialogue: 0,0:21:06.58,0:21:08.90,Chinese,,0,0,0,,你会发现要判断是否有竞争是比较棘手的
Dialogue: 0,0:21:09.46,0:21:13.78,English,,0,0,0,,You can't do pattern matching to determine whether you've got races or not races
Dialogue: 0,0:21:09.46,0:21:13.78,Chinese,,0,0,0,,因为你无法通过模式匹配来确定是否有竞争
Dialogue: 0,0:21:14.40,0:21:16.02,English,,0,0,0,,Right so you can't just say well
Dialogue: 0,0:21:14.40,0:21:16.02,Chinese,,0,0,0,,你不能简单的说
Dialogue: 0,0:21:16.52,0:21:23.24,English,,0,0,0,,It's always bad to pass the address of some variable to a thread routine
Dialogue: 0,0:21:16.52,0:21:23.24,Chinese,,0,0,0,,将某个变量的地址传递给线程总是出现竞争
Dialogue: 0,0:21:23.78,0:21:25.72,English,,0,0,0,,Okay because it's not it just depends on the context
Dialogue: 0,0:21:23.78,0:21:25.72,Chinese,,0,0,0,,但有时候不会，这取决于上下文
Dialogue: 0,0:21:27.37,0:21:31.40,English,,0,0,0,,Okay so in this case we're passing the number of iterations and to each thread and
Dialogue: 0,0:21:27.37,0:21:31.40,Chinese,,0,0,0,,好的，在这种情况下，我们将迭代次数传递给每个线程
Dialogue: 0,0:21:33.52,0:21:36.88,English,,0,0,0,,Then we're waiting for each of those threads to finish
Dialogue: 0,0:21:33.52,0:21:36.88,Chinese,,0,0,0,,然后我们等待每个线程完成
Dialogue: 0,0:21:36.90,0:21:43.26,English,,0,0,0,,So this is an example of why you need why you might want to have a non detached thread
Dialogue: 0,0:21:36.90,0:21:43.26,Chinese,,0,0,0,,所以这是一个为什么你需要使用非分离线程的例子
Dialogue: 0,0:21:43.30,0:21:43.98,English,,0,0,0,,Because you can't
Dialogue: 0,0:21:43.30,0:21:43.98,Chinese,,0,0,0,,因为你需要等待线程完成
Dialogue: 0,0:21:46.62,0:21:50.16,English,,0,0,0,,We want when we check when we check the value of count
Dialogue: 0,0:21:46.62,0:21:50.16,Chinese,,0,0,0,,在检查 cnt 的值的时候
Dialogue: 0,0:21:50.16,0:21:54.18,English,,0,0,0,,We have to make sure that every thread is finished before we check whether we got the right value or not
Dialogue: 0,0:21:50.16,0:21:54.18,Chinese,,0,0,0,,我们必须确保每个线程都已完成
Dialogue: 0,0:21:55.28,0:21:56.96,English,,0,0,0,,Okay so we wait for each thread to finish
Dialogue: 0,0:21:55.28,0:21:56.96,Chinese,,0,0,0,,好的，我们等待每个线程完成
Dialogue: 0,0:21:58.00,0:22:03.10,English,,0,0,0,,And now since we've created two threads each of which is incrementing count editors time
Dialogue: 0,0:21:58.00,0:22:03.10,Chinese,,0,0,0,,现在，因为我们已经创建了两个线程，每个线程都会让 cnt 的值增加 nithers 次
Dialogue: 0,0:22:04.10,0:22:07.06,English,,0,0,0,,We expect count to be equal to two times and niters
Dialogue: 0,0:22:04.10,0:22:07.06,Chinese,,0,0,0,,所以最后 cnt 的应该为 niters 的两倍
Dialogue: 0,0:22:07.06,0:22:10.44,English,,0,0,0,,And if it's not we print my favorite error message
Dialogue: 0,0:22:07.06,0:22:10.44,Chinese,,0,0,0,,如果不是，打印错误消息
Dialogue: 0,0:22:11.90,0:22:19.04,English,,0,0,0,,Otherwise we with the value of count,otherwise we print OK also with the value of count
Dialogue: 0,0:22:11.90,0:22:19.04,Chinese,,0,0,0,,如果相值，我们也会打印 OK，然后打印 cnt 的值
Dialogue: 0,0:22:20.68,0:22:22.64,English,,0,0,0,,Okay so now what's going on in the thread routine
Dialogue: 0,0:22:20.68,0:22:22.64,Chinese,,0,0,0,,好的，现在看看线程中执行了什么
Dialogue: 0,0:22:23.78,0:22:24.54,English,,0,0,0,,Very simple
Dialogue: 0,0:22:23.78,0:22:24.54,Chinese,,0,0,0,,很简单
Dialogue: 0,0:22:26.32,0:22:33.46,English,,0,0,0,,It dereferences the argument that was passed in and stores it in the local copy of entities
Dialogue: 0,0:22:26.32,0:22:33.46,Chinese,,0,0,0,,首先，它解指针，然后把值保存在一个本地变量中
Dialogue: 0,0:22:34.84,0:22:36.44,English,,0,0,0,,And then it loop senators time
Dialogue: 0,0:22:34.84,0:22:36.44,Chinese,,0,0,0,,然后循环 niters 次
Dialogue: 0,0:22:37.42,0:22:39.04,English,,0,0,0,,In can increments count each time
Dialogue: 0,0:22:37.42,0:22:39.04,Chinese,,0,0,0,,每次将 cnt 的值增加 1
Dialogue: 0,0:22:40.20,0:22:41.22,English,,0,0,0,,So and then returns
Dialogue: 0,0:22:40.20,0:22:41.22,Chinese,,0,0,0,,然后返回
Dialogue: 0,0:22:42.38,0:22:45.32,English,,0,0,0,,So this is very innocuous what could go wrong
Dialogue: 0,0:22:42.38,0:22:45.32,Chinese,,0,0,0,,这看上去是对的，到底哪里会出错呢
Dialogue: 0,0:22:47.64,0:22:53.22,English,,0,0,0,,And since this is threading,since this is concurrent concurrent programming,especially since it's threaded programming
Dialogue: 0,0:22:47.64,0:22:53.22,Chinese,,0,0,0,,因为这里使用了线程，因为这是并发编程，是基于线程的并发编程
Dialogue: 0,0:22:53.56,0:22:56.98,English,,0,0,0,,What there's the odd lots of subtle things can go wrong
Dialogue: 0,0:22:53.56,0:22:56.98,Chinese,,0,0,0,,很多小事都会导致结果出错
Dialogue: 0,0:22:56.98,0:23:00.30,English,,0,0,0,,So it turns out this program has a really serious bug
Dialogue: 0,0:22:56.98,0:23:00.30,Chinese,,0,0,0,,实际上，这个程序有一个非常严重的 bug
Dialogue: 0,0:23:01.52,0:23:03.48,English,,0,0,0,,Okay because when we run it
Dialogue: 0,0:23:01.52,0:23:03.48,Chinese,,0,0,0,,因为当我们运行它
Dialogue: 0,0:23:06.24,0:23:08.40,English,,0,0,0,,When we run it on a Linux box
Dialogue: 0,0:23:06.24,0:23:08.40,Chinese,,0,0,0,,当我们在 Linux 机器上运行它时
Dialogue: 0,0:23:08.96,0:23:12.80,English,,0,0,0,,Sometimes if we call it with an argument of ten thousand
Dialogue: 0,0:23:08.96,0:23:12.80,Chinese,,0,0,0,,如果执行这个程序，并且传入一个参数 10000
Dialogue: 0,0:23:13.40,0:23:17.90,English,,0,0,0,,Sometimes we get the correct answer 2*10,000 or 20,000
Dialogue: 0,0:23:13.40,0:23:17.90,Chinese,,0,0,0,,有时我们得到 2 * 10,000，即 20,000 的正确答案
Dialogue: 0,0:23:18.54,0:23:19.66,English,,0,0,0,,But then the next time we run it
Dialogue: 0,0:23:18.54,0:23:19.66,Chinese,,0,0,0,,但是下次我们运行它
Dialogue: 0,0:23:20.36,0:23:23.76,English,,0,0,0,,We get some weird number 13051
Dialogue: 0,0:23:20.36,0:23:23.76,Chinese,,0,0,0,,我们得到一些奇怪的数字 13051
Dialogue: 0,0:23:25.18,0:23:25.94,English,,0,0,0,,Completely wrong
Dialogue: 0,0:23:25.18,0:23:25.94,Chinese,,0,0,0,,完全错了
Dialogue: 0,0:23:27.28,0:23:30.18,English,,0,0,0,,And so what the hack is going on here
Dialogue: 0,0:23:27.28,0:23:30.18,Chinese,,0,0,0,,那么这里发生了什么
Dialogue: 0,0:23:32.74,0:23:35.90,English,,0,0,0,,Okay so to understand that we have to look at the assembly language
Dialogue: 0,0:23:32.74,0:23:35.90,Chinese,,0,0,0,,好的，要理解为什么会出现这个结果，我们必须查看汇编语言
Dialogue: 0,0:23:37.60,0:23:39.64,English,,0,0,0,,For this counter loop so that
Dialogue: 0,0:23:37.60,0:23:39.64,Chinese,,0,0,0,,循环部分对应的汇编代码如下
Dialogue: 0,0:23:41.06,0:23:45.94,English,,0,0,0,,We want to...we need to look at the the assembly language for this counter loop in the thread routine
Dialogue: 0,0:23:41.06,0:23:45.94,Chinese,,0,0,0,,我们只需要检查循环这一部分的汇编代码
Dialogue: 0,0:23:48.22,0:23:50.34,English,,0,0,0,,So we'll break it up into three chunks that
Dialogue: 0,0:23:48.22,0:23:50.34,Chinese,,0,0,0,,所以我们将它分成三个块
Dialogue: 0,0:23:51.12,0:23:53.90,English,,0,0,0,,The first chunk is sort of getting ready for the loop
Dialogue: 0,0:23:51.12,0:23:53.90,Chinese,,0,0,0,,第一个块是为循环做好准备
Dialogue: 0,0:23:54.26,0:24:01.60,English,,0,0,0,,We'll call that the head and we'll denote it as H(i)  for thread i
Dialogue: 0,0:23:54.26,0:24:01.60,Chinese,,0,0,0,,我们称之为 Head，线程 i Head 块记为 H(i)
Dialogue: 0,0:24:04.94,0:24:12.84,English,,0,0,0,,And then we'll isolate on these three instructions that are directly related to incrementing count
Dialogue: 0,0:24:04.94,0:24:12.84,Chinese,,0,0,0,,然后我们将与 cnt++ 直接相关的指令分为几个部分
Dialogue: 0,0:24:14.08,0:24:16.22,English,,0,0,0,,Okay so you see the first instruction moves
Dialogue: 0,0:24:14.08,0:24:16.22,Chinese,,0,0,0,,第一条指令是 mov 指令
Dialogue: 0,0:24:16.66,0:24:22.50,English,,0,0,0,,It loads the global of the value and global variable count into register %rdx
Dialogue: 0,0:24:16.66,0:24:22.50,Chinese,,0,0,0,,它将 cnt 的值加载到寄存器 ％rdx 中
Dialogue: 0,0:24:24.14,0:24:25.72,English,,0,0,0,,So will denote that as L(i)
Dialogue: 0,0:24:24.14,0:24:25.72,Chinese,,0,0,0,,我们将其表示为 L(i)
Dialogue: 0,0:24:27.54,0:24:30.18,English,,0,0,0,,Next it increments %rdx
Dialogue: 0,0:24:27.54,0:24:30.18,Chinese,,0,0,0,,下一条指令增加 ％rdx 的值
Dialogue: 0,0:24:31.52,0:24:35.98,English,,0,0,0,,And we'll denote that U(i) for update so it updates %rdx
Dialogue: 0,0:24:31.52,0:24:35.98,Chinese,,0,0,0,,这是更新 ％rdx，我们将其表示为 U(i)
Dialogue: 0,0:24:37.14,0:24:42.92,English,,0,0,0,,And then it stores the value the updated value of %rdx into count
Dialogue: 0,0:24:37.14,0:24:42.92,Chinese,,0,0,0,,然后下一条指令将 ％rdx 的更新值存储到 cnt 中
Dialogue: 0,0:24:43.42,0:24:48.06,English,,0,0,0,,Okay so into the location associated with the global variable count
Dialogue: 0,0:24:43.42,0:24:48.06,Chinese,,0,0,0,,也就是更新 cnt 的内存地址上的内容
Dialogue: 0,0:24:50.00,0:24:50.44,English,,0,0,0,,And
Dialogue: 0,0:24:50.00,0:24:50.44,Chinese,,0,0,0,,然后
Dialogue: 0,0:24:53.32,0:24:58.94,English,,0,0,0,,And then the rest of...the rest of this loop is getting ready for the to do the next iteration
Dialogue: 0,0:24:53.32,0:24:58.94,Chinese,,0,0,0,,这个循环的其余部分的功能是，为下一次迭代做好准备
Dialogue: 0,0:24:59.70,0:25:02.32,English,,0,0,0,,It's not directly related to incrementing count
Dialogue: 0,0:24:59.70,0:25:02.32,Chinese,,0,0,0,,它与 cnt 的值没有直接关系
Dialogue: 0,0:25:02.32,0:25:06.38,English,,0,0,0,,So we'll just sort of group this all together and refer to it as T(i) for tail
Dialogue: 0,0:25:02.32,0:25:06.38,Chinese,,0,0,0,,我们将其组合为一块，称为尾部，记为 T(i)
Dialogue: 0,0:25:07.68,0:25:07.86,English,,0,0,0,,Okay
Dialogue: 0,0:25:07.68,0:25:07.86,Chinese,,0,0,0,,好的
Dialogue: 0,0:25:13.60,0:25:17.56,English,,0,0,0,,Now let's look at...let's look at...
Dialogue: 0,0:25:13.60,0:25:17.56,Chinese,,0,0,0,,让我们来看......
Dialogue: 0,0:25:18.22,0:25:21.94,English,,0,0,0,,How this how these two threads might be executed
Dialogue: 0,0:25:18.22,0:25:21.94,Chinese,,0,0,0,,这两个线程可能的执行顺序
Dialogue: 0,0:25:22.12,0:25:27.38,English,,0,0,0,,And remember in general we can't assume that there's any specific interleaving
Dialogue: 0,0:25:22.12,0:25:27.38,Chinese,,0,0,0,,记住，一般来说，我们不能假设任何特定的顺序
Dialogue: 0,0:25:27.40,0:25:30.08,English,,0,0,0,,So any interleaving of these two threads is possible
Dialogue: 0,0:25:27.40,0:25:30.08,Chinese,,0,0,0,,因此，这两个线程的任何交错都是可能的
Dialogue: 0,0:25:30.18,0:25:33.32,English,,0,0,0,,No matter how remote it might seem
Dialogue: 0,0:25:30.18,0:25:33.32,Chinese,,0,0,0,,无论它看起来多么遥远（一个线程运行了很久，另一个线程才运行）
Dialogue: 0,0:25:34.90,0:25:38.80,English,,0,0,0,,So let's look at one example let's say we're executing on a single core
Dialogue: 0,0:25:34.90,0:25:38.80,Chinese,,0,0,0,,让我们看一个例子，假设我们在一个单核的计算机上执行
Dialogue: 0,0:25:38.80,0:25:40.98,English,,0,0,0,,So we're only going to do one instruction at a time
Dialogue: 0,0:25:38.80,0:25:40.98,Chinese,,0,0,0,,所以我们一次只会执行一条指令
Dialogue: 0,0:25:43.00,0:25:43.54,English,,0,0,0,,And
Dialogue: 0,0:25:43.00,0:25:43.54,Chinese,,0,0,0,,然后
Dialogue: 0,0:25:45.84,0:25:50.36,English,,0,0,0,,In this column will show which thread is executing so either thread 1 or thread 2
Dialogue: 0,0:25:45.84,0:25:50.36,Chinese,,0,0,0,,在此列中显示正在执行的线程，线程 1 或线程 2
Dialogue: 0,0:25:53.28,0:25:56.42,English,,0,0,0,,And then we'll to know which instruction in that thread is executing
Dialogue: 0,0:25:53.28,0:25:56.42,Chinese,,0,0,0,,这一列表示该线程中的哪条指令正在执行
Dialogue: 0,0:25:57.90,0:26:00.28,English,,0,0,0,,Either H,L,U,S or T
Dialogue: 0,0:25:57.90,0:26:00.28,Chinese,,0,0,0,,H，L，U，S 或 T
Dialogue: 0,0:26:02.02,0:26:07.20,English,,0,0,0,,And then this column shows the value of %rdx for thread number 1
Dialogue: 0,0:26:02.02,0:26:07.20,Chinese,,0,0,0,,然后此列显示线程 1 的 ％rdx 的值
Dialogue: 0,0:26:08.34,0:26:11.46,English,,0,0,0,,And this column shows the value of %rdx for thread number 2
Dialogue: 0,0:26:08.34,0:26:11.46,Chinese,,0,0,0,,此列显示线程 2 的 ％rdx 值
Dialogue: 0,0:26:11.66,0:26:19.28,English,,0,0,0,,Right since that the kernel keeps separate copies of all the general-purpose registers the for each thread these can be different
Dialogue: 0,0:26:11.66,0:26:19.28,Chinese,,0,0,0,,因为内核为每个线程都维护了一个所有通用寄存器的副本，相当于每个线程都有独立的寄存器
Dialogue: 0,0:26:22.60,0:26:25.56,English,,0,0,0,,Okay and then this last column shows the value of count in memory
Dialogue: 0,0:26:22.60,0:26:25.56,Chinese,,0,0,0,,好的，然后最后一列显示内存中 cnt 的值
Dialogue: 0,0:26:27.90,0:26:30.82,English,,0,0,0,,So let's start executing
Dialogue: 0,0:26:27.90,0:26:30.82,Chinese,,0,0,0,,我们开始执行代码
Dialogue: 0,0:26:30.92,0:26:33.06,English,,0,0,0,,So initially count is equal to 0
Dialogue: 0,0:26:30.92,0:26:33.06,Chinese,,0,0,0,,最初 cnt 等于 0
Dialogue: 0,0:26:34.16,0:26:38.90,English,,0,0,0,,And thread one gets the kernel schedules thread 1
Dialogue: 0,0:26:34.16,0:26:38.90,Chinese,,0,0,0,,然后内核调度线程 1
Dialogue: 0,0:26:38.92,0:26:41.94,English,,0,0,0,,So it executes say H(1) that has no impact on count
Dialogue: 0,0:26:38.92,0:26:41.94,Chinese,,0,0,0,,线程 1 执行 H(1)，对 cnt 没有影响
Dialogue: 0,0:26:43.34,0:26:47.20,English,,0,0,0,,Then thread 1 loads the value of count into its copy of %rdx
Dialogue: 0,0:26:43.34,0:26:47.20,Chinese,,0,0,0,,然后，线程 1 将 cnt 的值加载到其 ％rdx 的副本中
Dialogue: 0,0:26:48.52,0:26:49.34,English,,0,0,0,,Updates it
Dialogue: 0,0:26:48.52,0:26:49.34,Chinese,,0,0,0,,更新它
Dialogue: 0,0:26:50.74,0:26:58.90,English,,0,0,0,,So now %rdx is equal to 1 and then stores that value in %rdx back to count so now count is equal to 1
Dialogue: 0,0:26:50.74,0:26:58.90,Chinese,,0,0,0,,所以现在 ％rdx 等于 1，然后将 ％rdx 中的值更新到 cnt，所以现在 cnt 等于 1
Dialogue: 0,0:27:00.84,0:27:04.20,English,,0,0,0,,Now at this point the kernel decides to schedule thread 2
Dialogue: 0,0:27:00.84,0:27:04.20,Chinese,,0,0,0,,此时内核决定调度线程 2
Dialogue: 0,0:27:04.90,0:27:10.76,English,,0,0,0,,So thread 2 begins executing and when it begins executing value of count is 1
Dialogue: 0,0:27:04.90,0:27:10.76,Chinese,,0,0,0,,因此线程 2 开始执行，当它开始执行时，cnt 的值为 1
Dialogue: 0,0:27:11.86,0:27:14.20,English,,0,0,0,,So it executes H(i)
Dialogue: 0,0:27:11.86,0:27:14.20,Chinese,,0,0,0,,然后线程 2 执行 H(i)
Dialogue: 0,0:27:16.26,0:27:22.62,English,,0,0,0,,Then it loads count into thread 2 copy of %rdx
Dialogue: 0,0:27:16.26,0:27:22.62,Chinese,,0,0,0,,然后它将 cnt 加载到线程 2 的 ％rdx 副本中
Dialogue: 0,0:27:23.32,0:27:28.08,English,,0,0,0,,So now %rdx equals 1,updates it,now it's equal to 2
Dialogue: 0,0:27:23.32,0:27:28.08,Chinese,,0,0,0,,所以现在 ％rdx 等于 1，更新它，现在 cnt 等于 2
Dialogue: 0,0:27:28.68,0:27:31.40,English,,0,0,0,,And then stores that value back to count
Dialogue: 0,0:27:28.68,0:27:31.40,Chinese,,0,0,0,,然后将寄存器的值更新到 cnt
Dialogue: 0,0:27:33.20,0:27:41.44,English,,0,0,0,,The kernel then decides oh and then it finishes executing the tail instruction
Dialogue: 0,0:27:33.20,0:27:41.44,Chinese,,0,0,0,,然后线程 2 执行 T(i)
Dialogue: 0,0:27:42.44,0:27:44.36,English,,0,0,0,,And let's say we're just doing one iteration of this
Dialogue: 0,0:27:42.44,0:27:44.36,Chinese,,0,0,0,,我们只是对此进行了一次迭代
Dialogue: 0,0:27:45.64,0:27:51.22,English,,0,0,0,,And then at this point the kernel decides to schedule thread 1 since thread 2 is finished so
Dialogue: 0,0:27:45.64,0:27:51.22,Chinese,,0,0,0,,然后在这一点上，内核决定调度线程 1，因为线程 2 已完成
Dialogue: 0,0:27:51.86,0:27:55.38,English,,0,0,0,,Thread 1 executes the remaining statement that it has to execute
Dialogue: 0,0:27:51.86,0:27:55.38,Chinese,,0,0,0,,线程 1 执行必须执行的剩余语句
Dialogue: 0,0:27:57.06,0:27:58.82,English,,0,0,0,,And at this point both threads have finished
Dialogue: 0,0:27:57.06,0:27:58.82,Chinese,,0,0,0,,此时两个线程都已完成
Dialogue: 0,0:28:00.50,0:28:03.84,English,,0,0,0,,And count is equal to 2 which is the value we would expect
Dialogue: 0,0:28:00.50,0:28:03.84,Chinese,,0,0,0,,而 cnt 等于 2，这是我们期望的值
Dialogue: 0,0:28:04.18,0:28:06.74,English,,0,0,0,,Ok so this so this is ok
Dialogue: 0,0:28:04.18,0:28:06.74,Chinese,,0,0,0,,好的，所以运行的结果是正确的
Dialogue: 0,0:28:07.38,0:28:11.60,English,,0,0,0,,And notice how...so this is actually this is an inner leaving that works
Dialogue: 0,0:28:07.38,0:28:11.60,Chinese,,0,0,0,,实际上，这只是线程交错的其中一种情况
Dialogue: 0,0:28:11.88,0:28:13.08,English,,0,0,0,,Ok we get the correct value
Dialogue: 0,0:28:11.88,0:28:13.08,Chinese,,0,0,0,,这次我们得到的结果是正确的
Dialogue: 0,0:28:14.12,0:28:16.02,English,,0,0,0,,And notice how I...
Dialogue: 0,0:28:14.12,0:28:16.02,Chinese,,0,0,0,,注意
Dialogue: 0,0:28:19.08,0:28:23.14,English,,0,0,0,,I grouped the 3 instructions that are actually involved in updating count together
Dialogue: 0,0:28:19.08,0:28:23.14,Chinese,,0,0,0,,我实际上将参与更新 cnt 的 3 条指令放在了一起
Dialogue: 0,0:28:24.66,0:28:29.76,English,,0,0,0,,And it will call that,we'll call those 3 instructions a critical section and I've color-coded them
Dialogue: 0,0:28:24.66,0:28:29.76,Chinese,,0,0,0,,我们将这 3 条指令称为临界区，并使用了不同颜色进行区分
Dialogue: 0,0:28:29.78,0:28:32.02,English,,0,0,0,,So you can easily keep track of them
Dialogue: 0,0:28:29.78,0:28:32.02,Chinese,,0,0,0,,因此，你可以轻松的找到它们
Dialogue: 0,0:28:34.08,0:28:39.10,English,,0,0,0,,Alright let's look...now let's look at another another interleaving which is feasible right
Dialogue: 0,0:28:34.08,0:28:39.10,Chinese,,0,0,0,,现在让我们看看另一个可能的交错
Dialogue: 0,0:28:40.24,0:28:43.04,English,,0,0,0,,But in this case it results in the wrong value
Dialogue: 0,0:28:40.24,0:28:43.04,Chinese,,0,0,0,,但在这种情况下，它会导致错误的结果
Dialogue: 0,0:28:44.98,0:28:47.98,English,,0,0,0,,Ok so here we start with thread 1 again
Dialogue: 0,0:28:44.98,0:28:47.98,Chinese,,0,0,0,,好的，我们再次从线程1开始
Dialogue: 0,0:28:50.16,0:28:55.52,English,,0,0,0,,It loads it's the value of count into its copy of %rdx updates it
Dialogue: 0,0:28:50.16,0:28:55.52,Chinese,,0,0,0,,它将 cnt 的值加载到 ％rdx 的副本中，然后更新它
Dialogue: 0,0:28:56.14,0:28:57.62,English,,0,0,0,,But then before it can store it
Dialogue: 0,0:28:56.14,0:28:57.62,Chinese,,0,0,0,,但在更新值写回到内存之前
Dialogue: 0,0:28:59.08,0:29:01.44,English,,0,0,0,,The kernel decides to schedule thread 2
Dialogue: 0,0:28:59.08,0:29:01.44,Chinese,,0,0,0,,内核决定调度线程 2
Dialogue: 0,0:29:02.46,0:29:04.84,English,,0,0,0,,So thread 2 begins x executing
Dialogue: 0,0:29:02.46,0:29:04.84,Chinese,,0,0,0,,所以线程 2 开始执行
Dialogue: 0,0:29:05.86,0:29:09.28,English,,0,0,0,,It loads count into its copy of %rdx too
Dialogue: 0,0:29:05.86,0:29:09.28,Chinese,,0,0,0,,它也会将 cnt 加载到线程 2 的 ％rdx 的副本中
Dialogue: 0,0:29:10.18,0:29:14.24,English,,0,0,0,,And notice count is still 0 right it's 1
Dialogue: 0,0:29:10.18,0:29:14.24,Chinese,,0,0,0,,注意到，此时内存中的 cnt 是 0，但是在这里（鼠标指的地方）它是 1
Dialogue: 0,0:29:15.84,0:29:19.64,English,,0,0,0,,In the value of in thread 1 in the %rdx
Dialogue: 0,0:29:15.84,0:29:19.64,Chinese,,0,0,0,,也就是在线程 1 的 %rdx 的副本中的值是 1
Dialogue: 0,0:29:20.12,0:29:24.02,English,,0,0,0,,The copy of %rdx and thread 1 but it hasn't been updated in memory so
Dialogue: 0,0:29:20.12,0:29:24.02,Chinese,,0,0,0,,但线程 1 中的 %rdx 的值没有更新到内存中
Dialogue: 0,0:29:24.98,0:29:29.92,English,,0,0,0,,When thread 2 loads its value of count
Dialogue: 0,0:29:24.98,0:29:29.92,Chinese,,0,0,0,,当线程 2 加载其 cnt 值时
Dialogue: 0,0:29:29.92,0:29:33.44,English,,0,0,0,,Now it's copy and %rdx is 0
Dialogue: 0,0:29:29.92,0:29:33.44,Chinese,,0,0,0,,cnt 为 0，所以线程 2 的 ％rdx 副本为 0
Dialogue: 0,0:29:34.60,0:29:39.72,English,,0,0,0,,Now at this point the kernel reschedules thread 1 to execute so thread 1 does it store
Dialogue: 0,0:29:34.60,0:29:39.72,Chinese,,0,0,0,,现在，此时内核重新安排线程 1 执行，因此线程 1 会存储它
Dialogue: 0,0:29:40.88,0:29:43.98,English,,0,0,0,,Of its copy of %rdx into count
Dialogue: 0,0:29:40.88,0:29:43.98,Chinese,,0,0,0,,将 ％rdx 的副本值更新到 cnt 中
Dialogue: 0,0:29:44.96,0:29:48.16,English,,0,0,0,,And then finishes executing it the tail instruction
Dialogue: 0,0:29:44.96,0:29:48.16,Chinese,,0,0,0,,然后完成尾部指令的执行
Dialogue: 0,0:29:49.44,0:29:54.72,English,,0,0,0,,The kernel reschedules thread 2 which picks up where it left off it updates
Dialogue: 0,0:29:49.44,0:29:54.72,Chinese,,0,0,0,,内核重新调度线程 2，它从它停止的地方开始执行
Dialogue: 0,0:29:55.90,0:29:58.36,English,,0,0,0,,Its copy of count
Dialogue: 0,0:29:55.90,0:29:58.36,Chinese,,0,0,0,,更新 %rdx 中的值
Dialogue: 0,0:29:58.46,0:30:01.60,English,,0,0,0,,So now %rdx goes from 0 to 1
Dialogue: 0,0:29:58.46,0:30:01.60,Chinese,,0,0,0,,所以现在 ％rdx 从 0 变为 1
Dialogue: 0,0:30:03.18,0:30:06.12,English,,0,0,0,,And then it stores that value into count
Dialogue: 0,0:30:03.18,0:30:06.12,Chinese,,0,0,0,,然后它将该值更新到 cnt 中
Dialogue: 0,0:30:06.80,0:30:10.44,English,,0,0,0,,So all we've done is we've overwritten count out a value 1
Dialogue: 0,0:30:06.80,0:30:10.44,Chinese,,0,0,0,,这一步所做的就是将 cnt 的值更新为 1
Dialogue: 0,0:30:11.06,0:30:12.80,English,,0,0,0,,And we've overwritten it with a value of 1
Dialogue: 0,0:30:11.06,0:30:12.80,Chinese,,0,0,0,,我们让 cnt 的值为 1
Dialogue: 0,0:30:13.82,0:30:17.72,English,,0,0,0,,So when we finish execution of these two threads count has the wrong value
Dialogue: 0,0:30:13.82,0:30:17.72,Chinese,,0,0,0,,所以当我们完成这两个线程的执行时，cnt 有错误的值
Dialogue: 0,0:30:20.58,0:30:21.18,English,,0,0,0,,Okay in the
Dialogue: 0,0:30:20.58,0:30:21.18,Chinese,,0,0,0,,好的
Dialogue: 0,0:30:22.58,0:30:27.96,English,,0,0,0,,That then the general like,the general thing to notice is you see how these critical sections have been interleaved
Dialogue: 0,0:30:22.58,0:30:27.96,Chinese,,0,0,0,,我们要关注临界区的交错情况
Dialogue: 0,0:30:28.64,0:30:30.72,English,,0,0,0,,Right in this case
Dialogue: 0,0:30:28.64,0:30:30.72,Chinese,,0,0,0,,就在这种情况下
Dialogue: 0,0:30:32.14,0:30:37.60,English,,0,0,0,,This is the first the critical section for thread 1 executed before the critical section for thread 2
Dialogue: 0,0:30:32.14,0:30:37.60,Chinese,,0,0,0,,这里线程 2 执行临界区代码时，线程 1 的临界区代码已经执行完毕了，没有交错
Dialogue: 0,0:30:39.52,0:30:42.88,English,,0,0,0,,Okay but in this case the two critical sections interleaved okay
Dialogue: 0,0:30:39.52,0:30:42.88,Chinese,,0,0,0,,但是第二个例子中，两个临界区交错了
Dialogue: 0,0:30:46.24,0:30:48.30,English,,0,0,0,,So let's see another example of that
Dialogue: 0,0:30:46.24,0:30:48.30,Chinese,,0,0,0,,让我们看看另一个例子
Dialogue: 0,0:30:48.70,0:30:50.78,English,,0,0,0,,So here you can see that these are interleaved so
Dialogue: 0,0:30:48.70,0:30:50.78,Chinese,,0,0,0,,这里它们的临界区是交错的
Dialogue: 0,0:30:53.60,0:30:55.10,English,,0,0,0,,Probably suggest there might be a problem.Yes!
Dialogue: 0,0:30:53.60,0:30:55.10,Chinese,,0,0,0,,这种交错方式可能也会产生错误的结果 请讲
Dialogue: 0,0:30:55.12,0:31:00.68,English,,0,0,0,,[student speaking]
Dialogue: 0,0:30:55.12,0:31:00.68,Chinese,,0,0,0,,[学生提问]
Dialogue: 0,0:31:00.68,0:31:01.98,English,,0,0,0,,So I'm sorry excuse me
Dialogue: 0,0:31:00.68,0:31:01.98,Chinese,,0,0,0,,对不起，我没听清楚
Dialogue: 0,0:31:02.04,0:31:11.32,English,,0,0,0,,[student speaking]
Dialogue: 0,0:31:02.04,0:31:11.32,Chinese,,0,0,0,,[学生提问]
Dialogue: 0,0:31:11.34,0:31:13.72,English,,0,0,0,,Well no okay so the question is would would
Dialogue: 0,0:31:11.34,0:31:13.72,Chinese,,0,0,0,,他的问题是
Dialogue: 0,0:31:14.90,0:31:15.60,English,,0,0,0,,i or count
Dialogue: 0,0:31:14.90,0:31:15.60,Chinese,,0,0,0,,i 还是 cnt
Dialogue: 0,0:31:22.10,0:31:26.10,English,,0,0,0,,If we...okay it is defined as volatile
Dialogue: 0,0:31:22.10,0:31:26.10,Chinese,,0,0,0,,cnt 被定义为 volatile
Dialogue: 0,0:31:28.52,0:31:37.68,English,,0,0,0,,Yeah so that that's why...I mean there's actually and the compiler could have compiled this code in different ways right
Dialogue: 0,0:31:28.52,0:31:37.68,Chinese,,0,0,0,,我的意思是，实际上，编译器可以用不同的方式编译这段代码
Dialogue: 0,0:31:38.10,0:31:42.96,English,,0,0,0,,There is actually an increment instruction that you will increment a variable in memory
Dialogue: 0,0:31:38.10,0:31:42.96,Chinese,,0,0,0,,实际上有一个增量指令，这个指令可以让内存中的变量的值增加
Dialogue: 0,0:31:43.16,0:31:44.36,English,,0,0,0,,So you could have done
Dialogue: 0,0:31:43.16,0:31:44.36,Chinese,,0,0,0,,所以
Dialogue: 0,0:31:45.60,0:31:47.10,English,,0,0,0,,The compiler could have generated this
Dialogue: 0,0:31:45.60,0:31:47.10,Chinese,,0,0,0,,编译器可能生成这 3 条指令
Dialogue: 0,0:31:47.36,0:31:51.10,English,,0,0,0,,This 3 instruction sequence is one instruction and then we wouldn't have this problem
Dialogue: 0,0:31:47.36,0:31:51.10,Chinese,,0,0,0,,也可能把这 3 个指令序列合并为一条指令，如果编译为一条指令，那这个程序就没有问题
Dialogue: 0,0:31:51.64,0:31:52.62,English,,0,0,0,,But the problem is that
Dialogue: 0,0:31:51.64,0:31:52.62,Chinese,,0,0,0,,但问题是
Dialogue: 0,0:31:53.68,0:31:59.86,English,,0,0,0,,It's loading into register then incrementing and then saving
Dialogue: 0,0:31:53.68,0:31:59.86,Chinese,,0,0,0,,这里 cnt 会加载到寄存器，然后在寄存器递增，然后保存到内存
Dialogue: 0,0:31:59.88,0:32:01.78,English,,0,0,0,,So that the problem comes about because
Dialogue: 0,0:31:59.88,0:32:01.78,Chinese,,0,0,0,,因此，问题就出现了
Dialogue: 0,0:32:02.26,0:32:02.64,English,,0,0,0,,We can
Dialogue: 0,0:32:02.26,0:32:02.64,Chinese,,0,0,0,,嗯
Dialogue: 0,0:32:05.08,0:32:10.02,English,,0,0,0,,This thread can be interrupted before it finishes this three-step sequence
Dialogue: 0,0:32:05.08,0:32:10.02,Chinese,,0,0,0,,在加载、更新、写回的过程中
Dialogue: 0,0:32:10.02,0:32:12.20,English,,0,0,0,,This load modify store sequence
Dialogue: 0,0:32:10.02,0:32:12.20,Chinese,,0,0,0,,线程可能被中断
Dialogue: 0,0:32:12.98,0:32:13.28,English,,0,0,0,,Yes
Dialogue: 0,0:32:12.98,0:32:13.28,Chinese,,0,0,0,,请讲
Dialogue: 0,0:32:13.66,0:32:21.36,English,,0,0,0,,[student speaking]
Dialogue: 0,0:32:13.66,0:32:21.36,Chinese,,0,0,0,,[学生提问]
Dialogue: 0,0:32:21.36,0:32:24.86,English,,0,0,0,,It would wait yeah so it that's right yeah I guess I wasn't clear it
Dialogue: 0,0:32:21.36,0:32:24.86,Chinese,,0,0,0,,我想我没有把 volatile 关键字讲清楚
Dialogue: 0,0:32:25.63,0:32:28.66,English,,0,0,0,,It prevents it from being stored permanently in a register right so
Dialogue: 0,0:32:25.63,0:32:28.66,Chinese,,0,0,0,,volatile 可以防止变量永久存储在寄存器中（如循环执行完了再将 cnt 的值写回）
Dialogue: 0,0:32:29.42,0:32:34.24,English,,0,0,0,,It may have to be loaded into a register but then it'll be written back
Dialogue: 0,0:32:29.42,0:32:34.24,Chinese,,0,0,0,,volatile 修饰的变量可以被加载到寄存器中，但紧接着该变量的值要被写回到内存
Dialogue: 0,0:32:36.02,0:32:39.52,English,,0,0,0,,Okay whereas the the compiler would have the option like we've seen it with local variables
Dialogue: 0,0:32:36.02,0:32:39.52,Chinese,,0,0,0,,编译器在处理语句的时候有多种选择，如对于局部变量来说
Dialogue: 0,0:32:40.16,0:32:43.44,English,,0,0,0,,Right the compiler just it never allocates stack space
Dialogue: 0,0:32:40.16,0:32:43.44,Chinese,,0,0,0,,编译器永远不会为其分配栈空间
Dialogue: 0,0:32:43.44,0:32:45.88,English,,0,0,0,,It just keeps that local variable in a register all the time
Dialogue: 0,0:32:43.44,0:32:45.88,Chinese,,0,0,0,,它将局部变量保存在寄存器中
Dialogue: 0,0:32:46.12,0:32:50.02,English,,0,0,0,,Okay so this prevent the volatile attribute prevents the compiler from doing that
Dialogue: 0,0:32:46.12,0:32:50.02,Chinese,,0,0,0,,volatile 属性可以阻止编译器这样做
Dialogue: 0,0:32:55.58,0:32:57.19,English,,0,0,0,,Okay so let's look at another example
Dialogue: 0,0:32:55.58,0:32:57.19,Chinese,,0,0,0,,好的，让我们看看另一个例子
Dialogue: 0,0:32:58.20,0:33:00.58,English,,0,0,0,,So here thread 1 starts
Dialogue: 0,0:32:58.20,0:33:00.58,Chinese,,0,0,0,,首先线程 1 开始执行
Dialogue: 0,0:33:01.08,0:33:04.24,English,,0,0,0,,It loads count into %rdx
Dialogue: 0,0:33:01.08,0:33:04.24,Chinese,,0,0,0,,它将 cnt 加载到 ％rdx
Dialogue: 0,0:33:05.08,0:33:06.28,English,,0,0,0,,Then thread 2 starts
Dialogue: 0,0:33:05.08,0:33:06.28,Chinese,,0,0,0,,然后线程 2 开始执行
Dialogue: 0,0:33:07.36,0:33:11.44,English,,0,0,0,,And it loads a count which is still 0 into %rdx(2)
Dialogue: 0,0:33:07.36,0:33:11.44,Chinese,,0,0,0,,此时 cnt 的值仍然为 0，线程 2 将其加载到 %rdx 中
Dialogue: 0,0:33:12.18,0:33:15.80,English,,0,0,0,,Updates it and then stores it so now count equal to 1
Dialogue: 0,0:33:12.18,0:33:15.80,Chinese,,0,0,0,,更新它然后写回到内存，所以现在 cnt 等于 1
Dialogue: 0,0:33:16.38,0:33:25.56,English,,0,0,0,,When thread 1 resumes it updates its value of count and %rdx and stores that back to count
Dialogue: 0,0:33:16.38,0:33:25.56,Chinese,,0,0,0,,然后线程 1 恢复执行，它会更新 ％rdx 的值并将其更新到内存，更新 cnt 的值
Dialogue: 0,0:33:25.92,0:33:28.22,English,,0,0,0,,And so again we have the same problem
Dialogue: 0,0:33:25.92,0:33:28.22,Chinese,,0,0,0,,所以我们再次遇到和上次一样的问题
Dialogue: 0,0:33:30.58,0:33:31.34,English,,0,0,0,,Okay so the...
Dialogue: 0,0:33:30.58,0:33:31.34,Chinese,,0,0,0,,好的，所以......
Dialogue: 0,0:33:32.52,0:33:36.22,English,,0,0,0,,The problem here is that we're interleaving these these critical sections
Dialogue: 0,0:33:32.52,0:33:36.22,Chinese,,0,0,0,,这里的问题是我们交错了临界区
Dialogue: 0,0:33:36.92,0:33:39.62,English,,0,0,0,,And you can understand why this is bad
Dialogue: 0,0:33:36.92,0:33:39.62,Chinese,,0,0,0,,你现在应该可以理解为什么这个程序有问题
Dialogue: 0,0:33:40.74,0:33:43.60,English,,0,0,0,,With a nice or graphical technique called a progress graph
Dialogue: 0,0:33:40.74,0:33:43.60,Chinese,,0,0,0,,现在我们使用进度图来表示程序的执行过程
Dialogue: 0,0:33:48.38,0:33:49.96,English,,0,0,0,,So in a progress graph
Dialogue: 0,0:33:48.38,0:33:49.96,Chinese,,0,0,0,,在进度图中
Dialogue: 0,0:33:52.60,0:33:56.20,English,,0,0,0,,If we have n threads it's an n dimensional cartesian grid
Dialogue: 0,0:33:52.60,0:33:56.20,Chinese,,0,0,0,,如果我们有 n 个线程，它就是一个 n 维笛卡尔网格
Dialogue: 0,0:33:57.98,0:34:03.88,English,,0,0,0,,That characterizes the execution state space of a concurrent threaded program
Dialogue: 0,0:33:57.98,0:34:03.88,Chinese,,0,0,0,,进度图刻画了线程程序执行的状态空间
Dialogue: 0,0:34:05.06,0:34:07.58,English,,0,0,0,,So in this case each here we have two threads
Dialogue: 0,0:34:05.06,0:34:07.58,Chinese,,0,0,0,,在我们讲的例子中，我们有两个线程
Dialogue: 0,0:34:07.60,0:34:12.06,English,,0,0,0,,So it's a 2d coordinate system
Dialogue: 0,0:34:07.60,0:34:12.06,Chinese,,0,0,0,,所以它是一个二维坐标系
Dialogue: 0,0:34:13.04,0:34:18.36,English,,0,0,0,,So each axis represents the progress the execution progress of some threads
Dialogue: 0,0:34:13.04,0:34:18.36,Chinese,,0,0,0,,因此每个轴代表一个线程的执行进度
Dialogue: 0,0:34:18.44,0:34:22.52,English,,0,0,0,,So the x axis here is thread 1
Dialogue: 0,0:34:18.44,0:34:22.52,Chinese,,0,0,0,,这里的 x 轴是线程 1 的执行进度
Dialogue: 0,0:34:23.08,0:34:25.72,English,,0,0,0,,And the y axis corresponds to thread 2
Dialogue: 0,0:34:23.08,0:34:25.72,Chinese,,0,0,0,,y 轴对应于线程 2 的执行进度
Dialogue: 0,0:34:27.40,0:34:32.16,English,,0,0,0,,And then each one of these edges corresponds to the execution of an instruction
Dialogue: 0,0:34:27.40,0:34:32.16,Chinese,,0,0,0,,然后，每一条边对应于一条指令的执行
Dialogue: 0,0:34:32.88,0:34:35.34,English,,0,0,0,,Ok so we start out in an initial state
Dialogue: 0,0:34:32.88,0:34:35.34,Chinese,,0,0,0,,好的，我们从初始状态开始
Dialogue: 0,0:34:36.12,0:34:38.50,English,,0,0,0,,And then the first thing we execute is H(1)
Dialogue: 0,0:34:36.12,0:34:38.50,Chinese,,0,0,0,,然后我们执行 H(1)
Dialogue: 0,0:34:39.70,0:34:42.21,English,,0,0,0,,So that's represented by this ACK here
Dialogue: 0,0:34:39.70,0:34:42.21,Chinese,,0,0,0,,对应于这一条边
Dialogue: 0,0:34:43.18,0:34:47.64,English,,0,0,0,,So this position this point right here represents the state where
Dialogue: 0,0:34:43.18,0:34:47.64,Chinese,,0,0,0,,所以这个点代表的状态是
Dialogue: 0,0:34:48.26,0:34:52.94,English,,0,0,0,,We've executed H,we finished executing H(1) in thread 1
Dialogue: 0,0:34:48.26,0:34:52.94,Chinese,,0,0,0,,在线程 1 中已经完成了 H(1) 的执行
Dialogue: 0,0:34:52.94,0:34:56.18,English,,0,0,0,,But we haven't yet executed any instructions in thread 2
Dialogue: 0,0:34:52.94,0:34:56.18,Chinese,,0,0,0,,但是我们还没有执行线程 2 中的任何指令
Dialogue: 0,0:34:57.56,0:35:00.30,English,,0,0,0,,Ok so in general each one of these points represents
Dialogue: 0,0:34:57.56,0:35:00.30,Chinese,,0,0,0,,好的，所以这里的每一个点都代表
Dialogue: 0,0:35:01.98,0:35:05.08,English,,0,0,0,,Sort of the current progress of the program or the execution state
Dialogue: 0,0:35:01.98,0:35:05.08,Chinese,,0,0,0,,程序当前的执行状态
Dialogue: 0,0:35:06.06,0:35:11.02,English,,0,0,0,,So for example this state right here represents the state where thread 1
Dialogue: 0,0:35:06.06,0:35:11.02,Chinese,,0,0,0,,例如 PPT 上红色的这个点，代表了
Dialogue: 0,0:35:11.34,0:35:13.60,English,,0,0,0,,Has completed a completed L1
Dialogue: 0,0:35:11.34,0:35:13.60,Chinese,,0,0,0,,线程 1 已经完成了 L(1)
Dialogue: 0,0:35:14.24,0:35:17.16,English,,0,0,0,,And thread 2 is completed S(2)
Dialogue: 0,0:35:14.24,0:35:17.16,Chinese,,0,0,0,,线程 2 完成 S(2)
Dialogue: 0,0:35:22.30,0:35:28.16,English,,0,0,0,,And now the execution of a program is modeled as a transition from one state to the other
Dialogue: 0,0:35:22.30,0:35:28.16,Chinese,,0,0,0,,现在，程序的执行可以表示为从一个状态到另一个状态的转移
Dialogue: 0,0:35:28.78,0:35:33.66,English,,0,0,0,,And there's some,so from this and there's constraints on how
Dialogue: 0,0:35:28.78,0:35:33.66,Chinese,,0,0,0,,需要注意的一点，这里
Dialogue: 0,0:35:34.82,0:35:39.00,English,,0,0,0,,On how these states can advance so
Dialogue: 0,0:35:34.82,0:35:39.00,Chinese,,0,0,0,,对状态的转移有一些限制
Dialogue: 0,0:35:39.74,0:35:41.62,English,,0,0,0,,From this state(L1, S2)
Dialogue: 0,0:35:39.74,0:35:41.62,Chinese,,0,0,0,,从这个状态（L1，S2）
Dialogue: 0,0:35:42.56,0:35:50.10,English,,0,0,0,,Obviously time can't go backwards right so we can't go backwards like in this direction to the left and we can't go down
Dialogue: 0,0:35:42.56,0:35:50.10,Chinese,,0,0,0,,因为时间不能倒退，所以我们不能回到左边的状态，也不能回到下边的状态
Dialogue: 0,0:35:50.78,0:35:53.48,English,,0,0,0,,Okay so we can only go to the right and up
Dialogue: 0,0:35:50.78,0:35:53.48,Chinese,,0,0,0,,所以我们只能向右或向上走
Dialogue: 0,0:35:54.56,0:35:56.96,English,,0,0,0,,And since we're assuming that each instruction executes
Dialogue: 0,0:35:54.56,0:35:56.96,Chinese,,0,0,0,,这里我们还假设
Dialogue: 0,0:35:57.58,0:36:00.18,English,,0,0,0,,There's only one instruction executing at a time
Dialogue: 0,0:35:57.58,0:36:00.18,Chinese,,0,0,0,,一次只执行一条指令
Dialogue: 0,0:36:00.58,0:36:03.12,English,,0,0,0,,We can't go diagonally that would be two instructions
Dialogue: 0,0:36:00.58,0:36:03.12,Chinese,,0,0,0,,所以我们不能走对角线，因为这样同时执行了两条指令
Dialogue: 0,0:36:03.62,0:36:05.26,English,,0,0,0,,All right so from (L1,S2)
Dialogue: 0,0:36:03.62,0:36:05.26,Chinese,,0,0,0,,好的，从（L1，S2）
Dialogue: 0,0:36:05.90,0:36:08.08,English,,0,0,0,,The next execution state is either
Dialogue: 0,0:36:05.90,0:36:08.08,Chinese,,0,0,0,,下一个执行状态是
Dialogue: 0,0:36:09.46,0:36:15.26,English,,0,0,0,,Here if thread one execute or here if thread of thread to execute
Dialogue: 0,0:36:09.46,0:36:15.26,Chinese,,0,0,0,,右边这个点，代表线程 1 执行，或者上面这个点，代表线程 2 执行
Dialogue: 0,0:36:17.54,0:36:20.28,English,,0,0,0,,Okay so you can put all these together to form a trajectory
Dialogue: 0,0:36:17.54,0:36:20.28,Chinese,,0,0,0,,好的，你可以把所有点放在一起形成一个轨迹
Dialogue: 0,0:36:20.92,0:36:24.02,English,,0,0,0,,Which characterizes one execution of the program
Dialogue: 0,0:36:20.92,0:36:24.02,Chinese,,0,0,0,,这个轨迹表示了程序的一次执行
Dialogue: 0,0:36:25.86,0:36:32.76,English,,0,0,0,,Right and any feasible set of transitions from one state to the next corresponds to a feasible trajectory
Dialogue: 0,0:36:25.86,0:36:32.76,Chinese,,0,0,0,,且这个轨迹中只含有可行的状态转换，即向右或向上
Dialogue: 0,0:36:34.46,0:36:50.60,English,,0,0,0,,So for example H(1),L(1),U(1),H(2),L(2),S(1),T(1),U(2),S(2),T(2)
Dialogue: 0,0:36:34.46,0:36:50.60,Chinese,,0,0,0,,如 H(1),L(1),U(1),H(2),L(2),S(1),T(1),U(2),S(2),T(2)
Dialogue: 0,0:36:51.42,0:36:52.58,English,,0,0,0,,That's a feasible
Dialogue: 0,0:36:51.42,0:36:52.58,Chinese,,0,0,0,,那是可行的
Dialogue: 0,0:36:55.20,0:36:56.52,English,,0,0,0,,That's a feasible trajectory
Dialogue: 0,0:36:55.20,0:36:56.52,Chinese,,0,0,0,,这是一条可行的轨迹
Dialogue: 0,0:36:57.58,0:37:06.38,English,,0,0,0,,And it's one possible it represents one possible execution or so one set of inter leavings for this program
Dialogue: 0,0:36:57.58,0:37:06.38,Chinese,,0,0,0,,并且它代表一个线程程序可能的执行过程，即线程一个可能的交错顺序
Dialogue: 0,0:37:10.42,0:37:16.82,English,,0,0,0,,Now these L these three instructions L,U and S that operate on that manipulate count
Dialogue: 0,0:37:10.42,0:37:16.82,Chinese,,0,0,0,,L、U、S 这三个指令会对 cnt 进行操作
Dialogue: 0,0:37:17.40,0:37:20.66,English,,0,0,0,,Form what we call a critical section with respect to count
Dialogue: 0,0:37:17.40,0:37:20.66,Chinese,,0,0,0,,这三个指令被称为临界区
Dialogue: 0,0:37:25.18,0:37:29.20,English,,0,0,0,,And the idea is that instructions inside
Dialogue: 0,0:37:25.18,0:37:29.20,Chinese,,0,0,0,,要使这个程序得到正确结果的一个想法是
Dialogue: 0,0:37:29.54,0:37:36.50,English,,0,0,0,,These critical sections this with receivership with respect to the same global variable shouldn't be interleaved
Dialogue: 0,0:37:29.54,0:37:36.50,Chinese,,0,0,0,,这些对全局变量 cnt 进行操作的临界区不应该被交错
Dialogue: 0,0:37:38.28,0:37:43.70,English,,0,0,0,,So we can capture this geometrically by taking the intersection of these critical sections
Dialogue: 0,0:37:38.28,0:37:43.70,Chinese,,0,0,0,,两个临界区的交集形成的状态空间称为
Dialogue: 0,0:37:44.48,0:37:47.18,English,,0,0,0,,To form what we call an unsafe region
Dialogue: 0,0:37:44.48,0:37:47.18,Chinese,,0,0,0,,不安全区
Dialogue: 0,0:37:48.90,0:37:53.10,English,,0,0,0,,So in this an unsafe region is...
Dialogue: 0,0:37:48.90,0:37:53.10,Chinese,,0,0,0,,不安全区是......
Dialogue: 0,0:37:53.66,0:38:01.66,English,,0,0,0,,The points within an unsafe region are those points in an execution where the critical sections are being or interleaved
Dialogue: 0,0:37:53.66,0:38:01.66,Chinese,,0,0,0,,不安全区包含那些会使临界区交错的点
Dialogue: 0,0:38:03.26,0:38:07.32,English,,0,0,0,,Okay so for this particular example there's four points within the unsafe region
Dialogue: 0,0:38:03.26,0:38:07.32,Chinese,,0,0,0,,好的，在这个例子中，不安全区内有四个点
Dialogue: 0,0:38:08.24,0:38:10.72,English,,0,0,0,,And if a trajectory ever touches one of those points
Dialogue: 0,0:38:08.24,0:38:10.72,Chinese,,0,0,0,,如果一个轨迹经过了其中一个点
Dialogue: 0,0:38:10.72,0:38:13.70,English,,0,0,0,,Then we've interleaved critical section and we're going to get the wrong answer
Dialogue: 0,0:38:10.72,0:38:13.70,Chinese,,0,0,0,,然后我们交错了临界区，我们将得到错误的答案
Dialogue: 0,0:38:17.12,0:38:19.90,English,,0,0,0,,Okay so the idea is to try to stay out of these unsafe regions
Dialogue: 0,0:38:17.12,0:38:19.90,Chinese,,0,0,0,,好的，所以我们应该远离不安全区
Dialogue: 0,0:38:25.28,0:38:28.40,English,,0,0,0,,And if we do we say that trajectory is safe so
Dialogue: 0,0:38:25.28,0:38:28.40,Chinese,,0,0,0,,如果轨迹没有经过不安全区，我们说轨迹是安全的
Dialogue: 0,0:38:29.50,0:38:31.96,English,,0,0,0,,Here's an example of a trajectory that's safe
Dialogue: 0,0:38:29.50,0:38:31.96,Chinese,,0,0,0,,这是一个安全的轨迹示例
Dialogue: 0,0:38:33.20,0:38:37.04,English,,0,0,0,,Now this is okay,right this point right here is not in the unsafe region
Dialogue: 0,0:38:33.20,0:38:37.04,Chinese,,0,0,0,,当前这个点是可以经过的，因为它不在不安全区内
Dialogue: 0,0:38:37.82,0:38:40.62,English,,0,0,0,,Because we haven't executed we only executed H(1) here
Dialogue: 0,0:38:37.82,0:38:40.62,Chinese,,0,0,0,,因为这里线程 1 只执行了 H(1)
Dialogue: 0,0:38:41.16,0:38:43.42,English,,0,0,0,,Remember a point corresponds to
Dialogue: 0,0:38:41.16,0:38:43.42,Chinese,,0,0,0,,记住每个点的含义
Dialogue: 0,0:38:43.88,0:38:48.82,English,,0,0,0,,And it's the instruction that we've completed that instruction
Dialogue: 0,0:38:43.88,0:38:48.82,Chinese,,0,0,0,,每个点对应一条指令的完成
Dialogue: 0,0:38:51.10,0:38:51.86,English,,0,0,0,,So then
Dialogue: 0,0:38:51.10,0:38:51.86,Chinese,,0,0,0,,那么
Dialogue: 0,0:38:53.12,0:38:55.08,English,,0,0,0,,So here we're skirting the unsafe region
Dialogue: 0,0:38:53.12,0:38:55.08,Chinese,,0,0,0,,所以我们在这里避开不安全区
Dialogue: 0,0:38:55.08,0:38:58.88,English,,0,0,0,,But it's still okay,so this is a safe trajectory we'll get the right answer for this one
Dialogue: 0,0:38:55.08,0:38:58.88,Chinese,,0,0,0,,所以这是一个安全的轨迹，我们将得到正确的答案
Dialogue: 0,0:39:00.00,0:39:00.82,English,,0,0,0,,However
Dialogue: 0,0:39:00.00,0:39:00.82,Chinese,,0,0,0,,然而
Dialogue: 0,0:39:03.58,0:39:05.52,English,,0,0,0,,This trajectory is unsafe because it
Dialogue: 0,0:39:03.58,0:39:05.52,Chinese,,0,0,0,,这条轨迹是不安全的，因为
Dialogue: 0,0:39:07.82,0:39:11.10,English,,0,0,0,,It enters the unsafe region at this point here
Dialogue: 0,0:39:07.82,0:39:11.10,Chinese,,0,0,0,,它进入不安全区
Dialogue: 0,0:39:12.66,0:39:20.40,English,,0,0,0,,And even though it quickly exited the there's an interleaving there that creates a potential for a correct answer
Dialogue: 0,0:39:12.66,0:39:20.40,Chinese,,0,0,0,,即使它很快就会退出，但那里的交错会使得答案发送错误
Dialogue: 0,0:39:27.54,0:39:31.50,English,,0,0,0,,Okay so the question is how do we guarantee a safe trajectory
Dialogue: 0,0:39:27.54,0:39:31.50,Chinese,,0,0,0,,好，现在的问题是我们如何保证安全的轨迹
Dialogue: 0,0:39:31.58,0:39:33.98,English,,0,0,0,,And this is the this is what we call synchronization
Dialogue: 0,0:39:31.58,0:39:33.98,Chinese,,0,0,0,,也就是我们所说的同步
Dialogue: 0,0:39:34.00,0:39:39.67,English,,0,0,0,,So somehow we want to sort of configure the kernel
Dialogue: 0,0:39:34.00,0:39:39.67,Chinese,,0,0,0,,我们想以某种方式配置内核
Dialogue: 0,0:39:40.58,0:39:43.10,English,,0,0,0,,So that'll never schedule an unsafe trajectory
Dialogue: 0,0:39:40.58,0:39:43.10,Chinese,,0,0,0,,使得内核永远不会调度不安全的轨迹
Dialogue: 0,0:39:45.86,0:39:46.78,English,,0,0,0,,So how do we do that
Dialogue: 0,0:39:45.86,0:39:46.78,Chinese,,0,0,0,,那我们该怎么做呢
Dialogue: 0,0:39:47.88,0:39:50.20,English,,0,0,0,,So somehow
Dialogue: 0,0:39:47.88,0:39:50.20,Chinese,,0,0,0,,嗯
Dialogue: 0,0:39:51.52,0:39:54.98,English,,0,0,0,,We we have to synchronize the execution of those threads
Dialogue: 0,0:39:51.52,0:39:54.98,Chinese,,0,0,0,,我们必须同步这些线程的执行
Dialogue: 0,0:39:55.66,0:40:02.44,English,,0,0,0,,And another way to think of this is that we need to guarantee mutually exclusive access to the critical sections
Dialogue: 0,0:39:55.66,0:40:02.44,Chinese,,0,0,0,,但从另外一个角度讲，我们只需要保证对临界区的互斥访问
Dialogue: 0,0:40:03.22,0:40:10.48,English,,0,0,0,,All right so once the kernel begins,once the thread starts executing the first instruction is critical section
Dialogue: 0,0:40:03.22,0:40:10.48,Chinese,,0,0,0,,一旦一个线程开始执行临界区的第一条指令
Dialogue: 0,0:40:10.88,0:40:16.14,English,,0,0,0,,We don't want it to be interrupted by another thread that has a similar critical section
Dialogue: 0,0:40:10.88,0:40:16.14,Chinese,,0,0,0,,我们不希望它被另一个具有相同临界区的线程打断
Dialogue: 0,0:40:16.32,0:40:17.76,English,,0,0,0,,Okay we don't want it to be interrupted
Dialogue: 0,0:40:16.32,0:40:17.76,Chinese,,0,0,0,,好的，我们不希望它被打断
Dialogue: 0,0:40:18.14,0:40:22.22,English,,0,0,0,,We don't want...one critical section with respect to a certain global variable
Dialogue: 0,0:40:18.14,0:40:22.22,Chinese,,0,0,0,,例如，一个对应于某个全局变量的临界区
Dialogue: 0,0:40:23.16,0:40:29.36,English,,0,0,0,,To be interrupted by another thread that has all right that's currently within that same critical section okay
Dialogue: 0,0:40:23.16,0:40:29.36,Chinese,,0,0,0,,不能被执行同样的临界区的另一个线程打断
Dialogue: 0,0:40:30.62,0:40:31.50,English,,0,0,0,,Sorry yes question
Dialogue: 0,0:40:30.62,0:40:31.50,Chinese,,0,0,0,,请讲
Dialogue: 0,0:40:31.50,0:40:45.08,English,,0,0,0,,[student speaking]
Dialogue: 0,0:40:31.50,0:40:45.08,Chinese,,0,0,0,,学生提问
Dialogue: 0,0:40:45.08,0:40:48.44,English,,0,0,0,,Okay so the question is how likely is it that you get a correct trajectory
Dialogue: 0,0:40:45.08,0:40:48.44,Chinese,,0,0,0,,他的问题是，在一次程序的执行中，获得正确轨迹的可能性有多大
Dialogue: 0,0:40:48.48,0:40:51.02,English,,0,0,0,,And it happens right you can run it sometimes you do
Dialogue: 0,0:40:48.48,0:40:51.02,Chinese,,0,0,0,,你运行这个程序时
Dialogue: 0,0:40:51.54,0:40:55.20,English,,0,0,0,,It just depends usually it's wrong sometimes it's right
Dialogue: 0,0:40:51.54,0:40:55.20,Chinese,,0,0,0,,通常结果是错误的，但有时结果是正确的
Dialogue: 0,0:40:57.96,0:41:03.92,English,,0,0,0,,And it just depends on how the kernel scheduled it and you can't assume any particular scheduling
Dialogue: 0,0:40:57.96,0:41:03.92,Chinese,,0,0,0,,程序的结果只取决于内核如何调度它，并且你不能假设任何特定的调度
Dialogue: 0,0:41:04.80,0:41:09.86,English,,0,0,0,,Right so if you say, if you want to claim that you would never get the right answer
Dialogue: 0,0:41:04.80,0:41:09.86,Chinese,,0,0,0,,你可以假设程序输出的答案永远是错的
Dialogue: 0,0:41:10.48,0:41:15.04,English,,0,0,0,,Then you're assuming that the kernel is always going to schedule the unsafe trajectory but
Dialogue: 0,0:41:10.48,0:41:15.04,Chinese,,0,0,0,,即假设内核总是调度不安全的轨迹
Dialogue: 0,0:41:15.68,0:41:18.72,English,,0,0,0,,You can't assume that in fact it doesn't sometimes you just get lucky
Dialogue: 0,0:41:15.68,0:41:18.72,Chinese,,0,0,0,,事实上，你不能这样假设，因为有时候程序的结果是对的
Dialogue: 0,0:41:23.70,0:41:29.96,English,,0,0,0,,And it turns out you have to call this function with a pretty big number in order to trip it up
Dialogue: 0,0:41:23.70,0:41:29.96,Chinese,,0,0,0,,事实上，你必须用一个相当大的数字作为 thread 函数的参数，才能得到错误的答案
Dialogue: 0,0:41:32.06,0:41:33.92,English,,0,0,0,,So the it makes sense right
Dialogue: 0,0:41:32.06,0:41:33.92,Chinese,,0,0,0,,这好像有点道理
Dialogue: 0,0:41:34.92,0:41:39.14,English,,0,0,0,,If usually what the kernel does is that
Dialogue: 0,0:41:34.92,0:41:39.14,Chinese,,0,0,0,,通常，内核调度的时机
Dialogue: 0,0:41:40.30,0:41:42.28,English,,0,0,0,,I we can only schedule
Dialogue: 0,0:41:40.30,0:41:42.28,Chinese,,0,0,0,,内核可以调度
Dialogue: 0,0:41:43.12,0:41:47.48,English,,0,0,0,,We can only reschedule a thread you know swap it out and schedule another thread in
Dialogue: 0,0:41:43.12,0:41:47.48,Chinese,,0,0,0,,内核可以重新调度一个线程，即将一个线程换下来，把另一个线程换上去
Dialogue: 0,0:41:47.96,0:41:52.92,English,,0,0,0,,When there's some exception okay so that that passes control back to the kernel
Dialogue: 0,0:41:47.96,0:41:52.92,Chinese,,0,0,0,,只有当发生了异常，控制权被转移到内核时候，内核才能调度线程
Dialogue: 0,0:41:54.70,0:41:59.76,English,,0,0,0,,So these exceptions are in two forms either calling system making system calls
Dialogue: 0,0:41:54.70,0:41:59.76,Chinese,,0,0,0,,这些异常有两种形式，系统调用
Dialogue: 0,0:41:59.96,0:42:03.38,English,,0,0,0,,So that'll trap into the kernel so that's a form of exception
Dialogue: 0,0:41:59.96,0:42:03.38,Chinese,,0,0,0,,系统调用会陷入内核，这是一种异常形式
Dialogue: 0,0:42:03.86,0:42:09.50,English,,0,0,0,,Or the timer interrupts goes off which transfers control back to the kernel
Dialogue: 0,0:42:03.86,0:42:09.50,Chinese,,0,0,0,,或者出现了定时器中断，将控制权转移回内核
Dialogue: 0,0:42:10.36,0:42:14.88,English,,0,0,0,,So the timer is going off on intervals of like milliseconds
Dialogue: 0,0:42:10.36,0:42:14.88,Chinese,,0,0,0,,定时器会间隔相同的毫秒时间产生一个中断
Dialogue: 0,0:42:16.44,0:42:20.76,English,,0,0,0,,Right so if we're just doing one iteration it in each thread
Dialogue: 0,0:42:16.44,0:42:20.76,Chinese,,0,0,0,,所以，如果我们只是在每个线程中进行一次迭代
Dialogue: 0,0:42:20.94,0:42:26.10,English,,0,0,0,,When a thread gets executed the chances are very low that the timer is going to go off
Dialogue: 0,0:42:20.94,0:42:26.10,Chinese,,0,0,0,,当线程被执行时，发生定时器中断的可能性非常低
Dialogue: 0,0:42:27.14,0:42:30.56,English,,0,0,0,,While that thread is executing you know it's its little loop
Dialogue: 0,0:42:27.14,0:42:30.56,Chinese,,0,0,0,,因为在循环中，我们只让 cnt++
Dialogue: 0,0:42:32.86,0:42:35.12,English,,0,0,0,,But as we...and we're not making any system calls
Dialogue: 0,0:42:32.86,0:42:35.12,Chinese,,0,0,0,,循环中，我们没有进行任何系统调用
Dialogue: 0,0:42:35.28,0:42:42.30,English,,0,0,0,,Right so there's nothing that, there's nothing...we're not passing control back into the kernel ourselves
Dialogue: 0,0:42:35.28,0:42:42.30,Chinese,,0,0,0,,所以，在程序中我们并没有将控制权转移到内核
Dialogue: 0,0:42:43.14,0:42:47.68,English,,0,0,0,,So the only way the kernel is going to get access is if the timer interrupts goes off
Dialogue: 0,0:42:43.14,0:42:47.68,Chinese,,0,0,0,,因此，陷入内核的唯一方法就是产生了一个定时器中断
Dialogue: 0,0:42:48.86,0:42:51.28,English,,0,0,0,,So if we're doing a very small number of iterations
Dialogue: 0,0:42:48.86,0:42:51.28,Chinese,,0,0,0,,因此，如果我们进行的迭代次数非常少
Dialogue: 0,0:42:52.22,0:42:57.00,English,,0,0,0,,The probability that you know say here's the timer interval it's going off at intervals like this
Dialogue: 0,0:42:52.22,0:42:57.00,Chinese,,0,0,0,,在循环执行期间发生时钟中断的可能性很小，因为时钟中断是固定时间产生一次
Dialogue: 0,0:42:58.10,0:43:01.86,English,,0,0,0,,Here this the probability we'd have to
Dialogue: 0,0:42:58.10,0:43:01.86,Chinese,,0,0,0,,如果我们想得到错误的运行结果
Dialogue: 0,0:43:02.60,0:43:08.94,English,,0,0,0,,That's thread would have to been scheduled right before a timer interrupts will go off or to interrupt that one or two iterations
Dialogue: 0,0:43:02.60,0:43:08.94,Chinese,,0,0,0,,线程必须要在时钟中断发生前执行一两次循环
Dialogue: 0,0:43:09.86,0:43:11.36,English,,0,0,0,,So it turns out we have to schedule
Dialogue: 0,0:43:09.86,0:43:11.36,Chinese,,0,0,0,,事实上
Dialogue: 0,0:43:12.12,0:43:16.70,English,,0,0,0,,We have to call this function with a lot of within interrupts being fairly large
Dialogue: 0,0:43:12.12,0:43:16.70,Chinese,,0,0,0,,如果我们用一个大的数字去调用这个函数，让执行的时间变长
Dialogue: 0,0:43:17.28,0:43:22.52,English,,0,0,0,,So that the probability of the timer interrupts going off during that
Dialogue: 0,0:43:17.28,0:43:22.52,Chinese,,0,0,0,,数字越大，执行过程中发生定时器中断的可能性
Dialogue: 0,0:43:23.34,0:43:28.60,English,,0,0,0,,During that during that loop but gets increasingly large,that makes sense
Dialogue: 0,0:43:23.34,0:43:28.60,Chinese,,0,0,0,,就越大，大概就是这样一个分析
Dialogue: 0,0:43:36.16,0:43:39.26,English,,0,0,0,,So the classic solution from this comes from the early 1960s
Dialogue: 0,0:43:36.16,0:43:39.26,Chinese,,0,0,0,,同步问题的经典解决方案来自 20 世纪 60 年代早期
Dialogue: 0,0:43:39.26,0:43:46.38,English,,0,0,0,,One of the most famous computer scientists is a dutchman named as Edsger Dijkstra
Dialogue: 0,0:43:39.26,0:43:46.38,Chinese,,0,0,0,,由一位最著名的计算机科学家之一，一名叫 Edsger Dijkstra 的荷兰人
Dialogue: 0,0:43:47.38,0:43:53.38,English,,0,0,0,,And he came up with the classical first solution to this problem which is what we're going to look at
Dialogue: 0,0:43:47.38,0:43:53.38,Chinese,,0,0,0,,他提出了这个问题的第一个解决方案，也就是我们今天要学的内容
Dialogue: 0,0:43:54.18,0:43:57.60,English,,0,0,0,,Okay and it's still the first it's it's fundamental and very general purpose
Dialogue: 0,0:43:54.18,0:43:57.60,Chinese,,0,0,0,,这个解决方案是非常基础的
Dialogue: 0,0:43:57.60,0:44:01.76,English,,0,0,0,,And there's been many iterations and variations on this idea
Dialogue: 0,0:43:57.60,0:44:01.76,Chinese,,0,0,0,,这个解决方案经过许多迭代，有一些其他的版本
Dialogue: 0,0:44:02.74,0:44:08.00,English,,0,0,0,,But semaphores were the first and classic solution which we'll look at
Dialogue: 0,0:44:02.74,0:44:08.00,Chinese,,0,0,0,,但我们将要学习的信号量是这个问题的第一个，也是经典的解决方案
Dialogue: 0,0:44:11.38,0:44:17.58,English,,0,0,0,,Okay so a semaphore is a non-negative global integer
Dialogue: 0,0:44:11.38,0:44:17.58,Chinese,,0,0,0,,好的，信号量是一个非负的全局整数
Dialogue: 0,0:44:17.68,0:44:24.14,English,,0,0,0,,That's used as a synchronization variable by to kernel functions called P and V
Dialogue: 0,0:44:17.68,0:44:24.14,Chinese,,0,0,0,,信号量作为同步的变量，被两个内核函数 P 和 V 操作
Dialogue: 0,0:44:27.12,0:44:28.98,English,,0,0,0,,Our two system calls called P and V
Dialogue: 0,0:44:27.12,0:44:28.98,Chinese,,0,0,0,,两个系统调用叫做 P 和 V
Dialogue: 0,0:44:32.38,0:44:36.60,English,,0,0,0,,These P and V are correspond to the dutch words
Dialogue: 0,0:44:32.38,0:44:36.60,Chinese,,0,0,0,,P 和 V 对应于荷兰语 Proberen（测试）和 Verhogen（增加）
Dialogue: 0,0:44:38.74,0:44:43.72,English,,0,0,0,,But we just call them P and V right you just have to learn what they do
Dialogue: 0,0:44:38.74,0:44:43.72,Chinese,,0,0,0,,我们简称为 P 和 V，你只需要了解这两个函数作用
Dialogue: 0,0:44:46.74,0:44:51.06,English,,0,0,0,,So each of these takes as an argument a semaphore
Dialogue: 0,0:44:46.74,0:44:51.06,Chinese,,0,0,0,,这两个函数都以信号量作为参数
Dialogue: 0,0:44:52.84,0:44:56.82,English,,0,0,0,,And the P operation has the following semantics
Dialogue: 0,0:44:52.84,0:44:56.82,Chinese,,0,0,0,,并且 P 操作具有以下语义
Dialogue: 0,0:44:58.28,0:45:00.54,English,,0,0,0,,If s is nonzero
Dialogue: 0,0:44:58.28,0:45:00.54,Chinese,,0,0,0,,如果 s 不为零
Dialogue: 0,0:45:02.30,0:45:04.96,English,,0,0,0,,Then decrement it by 1 and return immediately
Dialogue: 0,0:45:02.30,0:45:04.96,Chinese,,0,0,0,,将其减 1 并立即返回
Dialogue: 0,0:45:07.68,0:45:10.60,English,,0,0,0,,And this test if it that it's nonzero
Dialogue: 0,0:45:07.68,0:45:10.60,Chinese,,0,0,0,,如果信号量是非零的
Dialogue: 0,0:45:11.38,0:45:13.16,English,,0,0,0,,And the decrement occur atomically
Dialogue: 0,0:45:11.38,0:45:13.16,Chinese,,0,0,0,,就将其减一，并且这个操作是原子的
Dialogue: 0,0:45:13.92,0:45:15.54,English,,0,0,0,,Okay so they'll never be interrupted
Dialogue: 0,0:45:13.92,0:45:15.54,Chinese,,0,0,0,,所以 P V 操作永远不会被中断
Dialogue: 0,0:45:20.28,0:45:21.96,English,,0,0,0,,However if s is zero
Dialogue: 0,0:45:20.28,0:45:21.96,Chinese,,0,0,0,,但是如果 S 为零
Dialogue: 0,0:45:24.10,0:45:25.58,English,,0,0,0,,Then suspend this thread
Dialogue: 0,0:45:24.10,0:45:25.58,Chinese,,0,0,0,,就会挂起这个线程
Dialogue: 0,0:45:26.84,0:45:29.40,English,,0,0,0,,Until s becomes nonzero
Dialogue: 0,0:45:26.84,0:45:29.40,Chinese,,0,0,0,,直到 s 变为非零
Dialogue: 0,0:45:31.10,0:45:34.26,English,,0,0,0,,And that thread then is restarted by a V operation
Dialogue: 0,0:45:31.10,0:45:34.26,Chinese,,0,0,0,,然后通过 V 操作重新启动该线程
Dialogue: 0,0:45:36.94,0:45:41.86,English,,0,0,0,,Okay so if p if the semaphore is zero,P just blocks
Dialogue: 0,0:45:36.94,0:45:41.86,Chinese,,0,0,0,,好的，如果信号量为零，P 就会阻塞
Dialogue: 0,0:45:42.32,0:45:46.74,English,,0,0,0,,It just gets suspended until it gets restarted by a V operation
Dialogue: 0,0:45:42.32,0:45:46.74,Chinese,,0,0,0,,线程会被挂起，直到它被 V 操作重新启动
Dialogue: 0,0:45:48.10,0:45:49.44,English,,0,0,0,,And then after it restarts
Dialogue: 0,0:45:48.10,0:45:49.44,Chinese,,0,0,0,,然后重新执行 P 操作
Dialogue: 0,0:45:50.18,0:45:57.20,English,,0,0,0,,The P operation now can decrement s by one and return control to the caller
Dialogue: 0,0:45:50.18,0:45:57.20,Chinese,,0,0,0,,现在 P 操作可以减 1 并将控制权返回给调用者
Dialogue: 0,0:46:03.26,0:46:06.00,English,,0,0,0,,Okay the V operation just increments s by one
Dialogue: 0,0:46:03.26,0:46:06.00,Chinese,,0,0,0,,V 操作只将信号量增加 1
Dialogue: 0,0:46:06.92,0:46:13.60,English,,0,0,0,,And this increment unlike that count++ that we looked at just looked at this that increment occurs atomically
Dialogue: 0,0:46:06.92,0:46:13.60,Chinese,,0,0,0,,这里的增加不像前面的 cnt++，这里的增加操作是原子的
Dialogue: 0,0:46:14.60,0:46:16.12,English,,0,0,0,,Okay so it can never be interrupted
Dialogue: 0,0:46:14.60,0:46:16.12,Chinese,,0,0,0,,好的，它永远不会被打断
Dialogue: 0,0:46:18.02,0:46:19.98,English,,0,0,0,,And then after it increments s
Dialogue: 0,0:46:18.02,0:46:19.98,Chinese,,0,0,0,,然后在它增加 s 之后
Dialogue: 0,0:46:21.06,0:46:24.84,English,,0,0,0,,It checks to see if there's any threads that are blocked in a P operation
Dialogue: 0,0:46:21.06,0:46:24.84,Chinese,,0,0,0,,它会检查是否有线程阻塞在 P 操作上
Dialogue: 0,0:46:25.26,0:46:30.66,English,,0,0,0,,So you can think of the kernel just keeps a queue of threads that are blocked in a P operation
Dialogue: 0,0:46:25.26,0:46:30.66,Chinese,,0,0,0,,你可以认为，内核维护了一个被 P 操作阻塞的线程队列
Dialogue: 0,0:46:31.40,0:46:37.38,English,,0,0,0,,And the V operation after it increments s it checks that queue for any threads that were blocked
Dialogue: 0,0:46:31.40,0:46:37.38,Chinese,,0,0,0,,并且在 V 操作增加信号量之后，它会检查该队列是否有被 P 操作阻塞的线程
Dialogue: 0,0:46:38.50,0:46:41.44,English,,0,0,0,,Because when they did the P operation the semaphore was zero
Dialogue: 0,0:46:38.50,0:46:41.44,Chinese,,0,0,0,,这些线程在执行 P 操作时，信号量为零
Dialogue: 0,0:46:43.06,0:46:47.32,English,,0,0,0,,And then it restarts exactly one of those threads in some indeterminate order
Dialogue: 0,0:46:43.06,0:46:47.32,Chinese,,0,0,0,,然后它以某种不确定的顺序重新启动其中一个线程
Dialogue: 0,0:46:47.44,0:46:50.68,English,,0,0,0,,Okay in some order that you can't,you can't assume
Dialogue: 0,0:46:47.44,0:46:50.68,Chinese,,0,0,0,,按照某种顺序，所以你不能假设按照某种顺序
Dialogue: 0,0:46:51.10,0:46:54.90,English,,0,0,0,,It just picks one using some selection algorithm
Dialogue: 0,0:46:51.10,0:46:54.90,Chinese,,0,0,0,,内核使用某种选择算法从队列中选择一个线程
Dialogue: 0,0:46:56.38,0:47:05.64,English,,0,0,0,,And it and then it it it unblocks the suspended  the suspended process
Dialogue: 0,0:46:56.38,0:47:05.64,Chinese,,0,0,0,,然后内核重启这个被 P 操作阻塞的线程
Dialogue: 0,0:47:07.88,0:47:11.16,English,,0,0,0,,Okay which then completes its P operation by decrementing yes
Dialogue: 0,0:47:07.88,0:47:11.16,Chinese,,0,0,0,,然后 P 操作可以将信号量减 1
Dialogue: 0,0:47:17.62,0:47:22.68,English,,0,0,0,,Okay this seems like really simple but it can be kind of hard to get your head around the first time you see it
Dialogue: 0,0:47:17.62,0:47:22.68,Chinese,,0,0,0,,这看起来很简单，但是第一次接触时可能会让你感到比较疑惑
Dialogue: 0,0:47:23.62,0:47:26.64,English,,0,0,0,,So are there any questions about P and V
Dialogue: 0,0:47:23.62,0:47:26.64,Chinese,,0,0,0,,关于 P 和 V 有什么问题吗？
Dialogue: 0,0:47:34.72,0:47:41.62,English,,0,0,0,,Okay so that the key idea that these definitions of P and V
Dialogue: 0,0:47:34.72,0:47:41.62,Chinese,,0,0,0,,这样定义 P 和 V 操作的主要目的是
Dialogue: 0,0:47:42.40,0:47:46.08,English,,0,0,0,,Is that it imposes an invariant on the semaphores
Dialogue: 0,0:47:42.40,0:47:46.08,Chinese,,0,0,0,,让信号量获得一个信号量不变性的属性
Dialogue: 0,0:47:46.84,0:47:50.68,English,,0,0,0,,Called the semaphore invariant which is s which is that for a semaphore s
Dialogue: 0,0:47:46.84,0:47:50.68,Chinese,,0,0,0,,信号量不变性，也就是对于一个信号量
Dialogue: 0,0:47:52.66,0:47:55.10,English,,0,0,0,,Being operated on by P and V operations
Dialogue: 0,0:47:52.66,0:47:55.10,Chinese,,0,0,0,,只通过 P 和 V 操作对信号量进行操作的时候
Dialogue: 0,0:47:55.64,0:47:57.52,English,,0,0,0,,s is always greater than or equal to zero
Dialogue: 0,0:47:55.64,0:47:57.52,Chinese,,0,0,0,,信号量的值总是大于或等于零
Dialogue: 0,0:48:01.12,0:48:02.66,English,,0,0,0,,And that doesn't seem very exciting
Dialogue: 0,0:48:01.12,0:48:02.66,Chinese,,0,0,0,,这看上去似乎没有太大的作用
Dialogue: 0,0:48:03.82,0:48:11.40,English,,0,0,0,,But it turns out this is a very useful property that will allow us to enforce mutual exclusion on these critical sections
Dialogue: 0,0:48:03.82,0:48:11.40,Chinese,,0,0,0,,但事实上，这是一个非常有用的属性，利用这个属性可以实现对临界区的互斥访问
Dialogue: 0,0:48:13.64,0:48:18.24,English,,0,0,0,,So the P and V operations are provided by P threads
Dialogue: 0,0:48:13.64,0:48:18.24,Chinese,,0,0,0,,POSIX 标准定义了 P 和 V 操作的相关函数
Dialogue: 0,0:48:19.24,0:48:21.28,English,,0,0,0,,In the form of three functions
Dialogue: 0,0:48:19.24,0:48:21.28,Chinese,,0,0,0,,提供了 3 个函数
Dialogue: 0,0:48:21.42,0:48:25.50,English,,0,0,0,,There's a sem_init functions which initializes the semaphore to some value
Dialogue: 0,0:48:21.42,0:48:25.50,Chinese,,0,0,0,,sem_init 函数可以将信号量初始化为某个值
Dialogue: 0,0:48:26.22,0:48:31.92,English,,0,0,0,,Okay so semaphore is can be initialized to any value greater than or equal to zero
Dialogue: 0,0:48:26.22,0:48:31.92,Chinese,,0,0,0,,信号量可以初始化为任何大于或等于零的值
Dialogue: 0,0:48:34.04,0:48:39.86,English,,0,0,0,,sem_wait is the P operation and sem_post is the V operation
Dialogue: 0,0:48:34.04,0:48:39.86,Chinese,,0,0,0,,sem_wait 函数对应 P 操作，sem_post 函数对应 V 操作
Dialogue: 0,0:48:41.88,0:48:44.38,English,,0,0,0,,Okay and because I'm old-school
Dialogue: 0,0:48:41.88,0:48:44.38,Chinese,,0,0,0,,因为我是一个老派的人
Dialogue: 0,0:48:45.38,0:48:51.48,English,,0,0,0,,I provide wrapper functions for those in your cssapp.h file called P and V
Dialogue: 0,0:48:45.38,0:48:51.48,Chinese,,0,0,0,,所以我在 cssapp.h 文件中提供了两个包装函数 P 和 V
Dialogue: 0,0:48:52.72,0:48:53.86,English,,0,0,0,,Okay it's also more compact to
Dialogue: 0,0:48:52.72,0:48:53.86,Chinese,,0,0,0,,使用这两个函数可以使代码更紧凑
Dialogue: 0,0:49:00.20,0:49:07.02,English,,0,0,0,,Okay so recall a buggy program called badcnt.c
Dialogue: 0,0:49:00.20,0:49:07.02,Chinese,,0,0,0,,好的，让我们再看看 badcnt.c 这个有 bug 的程序
Dialogue: 0,0:49:07.80,0:49:11.76,English,,0,0,0,,Which was giving us the wrong answers for count
Dialogue: 0,0:49:07.80,0:49:11.76,Chinese,,0,0,0,,这个 bug 会导致最后 cnt 的值错误
Dialogue: 0,0:49:13.30,0:49:15.82,English,,0,0,0,,So how do we use semaphores to fix this program
Dialogue: 0,0:49:13.30,0:49:15.82,Chinese,,0,0,0,,那么我们如何使用信号量来修复这个程序
Dialogue: 0,0:49:18.92,0:49:21.46,English,,0,0,0,,So the basic idea is to create a semaphore
Dialogue: 0,0:49:18.92,0:49:21.46,Chinese,,0,0,0,,基本的想法是创建一个信号量
Dialogue: 0,0:49:22.20,0:49:23.86,English,,0,0,0,,Which is initialized to 1
Dialogue: 0,0:49:22.20,0:49:23.86,Chinese,,0,0,0,,然后将其初始化为 1
Dialogue: 0,0:49:25.70,0:49:29.80,English,,0,0,0,,And so by definition we'll call any semaphore which is initialized to 1
Dialogue: 0,0:49:25.70,0:49:29.80,Chinese,,0,0,0,,根据定义，任何初始化为 1 的信号量
Dialogue: 0,0:49:29.82,0:49:33.36,English,,0,0,0,,That's used for to provide mutual exclusion we'll call that a mutex
Dialogue: 0,0:49:29.82,0:49:33.36,Chinese,,0,0,0,,称为互斥锁，因为它用来提供互斥操作
Dialogue: 0,0:49:34.98,0:49:38.06,English,,0,0,0,,Okay and this goes back to the early Dijkstra papers
Dialogue: 0,0:49:34.98,0:49:38.06,Chinese,,0,0,0,,这种叫法可以追溯到 Dijkstra 早期的论文
Dialogue: 0,0:49:39.62,0:49:47.62,English,,0,0,0,,So we'll associate a unique mutex initialize to 1 for each shared variable in our program
Dialogue: 0,0:49:39.62,0:49:47.62,Chinese,,0,0,0,,因此，我们为程序中的每个共享变量提供一个唯一的互斥锁，即初始值为 1 的信号量
Dialogue: 0,0:49:48.98,0:49:53.80,English,,0,0,0,,So in this case count,we have count,so we have one shared variable that we're concerned about
Dialogue: 0,0:49:48.98,0:49:53.80,Chinese,,0,0,0,,在我们这个程序中，我们只关心 cnt 这个共享变量
Dialogue: 0,0:49:54.42,0:49:57.76,English,,0,0,0,,So we'll create one new text that will call mutex
Dialogue: 0,0:49:54.42,0:49:57.76,Chinese,,0,0,0,,因此，我们只创建一个称为 mutex 的互斥锁
Dialogue: 0,0:49:59.00,0:50:03.48,English,,0,0,0,,And then you surround the critical section with respect to count
Dialogue: 0,0:49:59.00,0:50:03.48,Chinese,,0,0,0,,然后使用 P V 操作将临界区操作 cnt 的部分保护起来
Dialogue: 0,0:50:04.20,0:50:10.94,English,,0,0,0,,With P, you call P then you execute the critical section and then you call V
Dialogue: 0,0:50:04.20,0:50:10.94,Chinese,,0,0,0,,也就是，你先调用 P，然后执行临界区，然后再调用 V
Dialogue: 0,0:50:15.44,0:50:19.20,English,,0,0,0,,Now there's some terminology we'll use when we talk about semaphores
Dialogue: 0,0:50:15.44,0:50:19.20,Chinese,,0,0,0,,现在我们讲一下使用信号量时我们要用到的一些术语
Dialogue: 0,0:50:20.08,0:50:25.26,English,,0,0,0,,So a binary semaphore is the semaphore whose value is always 0 1
Dialogue: 0,0:50:20.08,0:50:25.26,Chinese,,0,0,0,,首先是二进制信号量，它是一个信号量，其值始终为 0 1
Dialogue: 0,0:50:25.72,0:50:31.08,English,,0,0,0,,And then a mutex is this sort is a binary semaphore that's being used to for mutual exclusion
Dialogue: 0,0:50:25.72,0:50:31.08,Chinese,,0,0,0,,然后是互斥锁（互斥量），即用来互斥的二进制信号量
Dialogue: 0,0:50:33.42,0:50:35.44,English,,0,0,0,,The P operation is called locking the mutex
Dialogue: 0,0:50:33.42,0:50:35.44,Chinese,,0,0,0,,P 操作称为互斥锁加锁
Dialogue: 0,0:50:37.74,0:50:41.32,English,,0,0,0,,Will refer to a V is sometimes unlocking or releasing the mutex
Dialogue: 0,0:50:37.74,0:50:41.32,Chinese,,0,0,0,,相应的，P 操作称为互斥锁解锁，或互斥锁释放
Dialogue: 0,0:50:42.52,0:50:50.38,English,,0,0,0,,And if a process is holding the mutex then that means it's been locked but not released
Dialogue: 0,0:50:42.52,0:50:50.38,Chinese,,0,0,0,,如果进程持有互斥锁，那么这意味着互斥锁已经加锁，但未被释放
Dialogue: 0,0:50:53.26,0:50:56.80,English,,0,0,0,,So mutexes and binary semaphore s are always initialized to 1
Dialogue: 0,0:50:53.26,0:50:56.80,Chinese,,0,0,0,,因此，互斥量和二进制信号量始终初始化为 1
Dialogue: 0,0:50:57.20,0:51:02.98,English,,0,0,0,,Accounting semaphore and the mutex is used for mutual exclusion
Dialogue: 0,0:50:57.20,0:51:02.98,Chinese,,0,0,0,,互斥锁用于互斥
Dialogue: 0,0:51:03.00,0:51:06.58,English,,0,0,0,,But you can also use semaphores to count sort of events in the system
Dialogue: 0,0:51:03.00,0:51:06.58,Chinese,,0,0,0,,但还有一种信号量叫做 counting semaphore，它可以用来对系统的事件计数
Dialogue: 0,0:51:07.80,0:51:15.98,English,,0,0,0,,And often times for those accounting semaphores have sort of non values that are greater than 1
Dialogue: 0,0:51:07.80,0:51:15.98,Chinese,,0,0,0,,对于 accounting semaphore，信号量的值通常大于 1
Dialogue: 0,0:51:19.74,0:51:21.30,English,,0,0,0,,Okay so for mutual exclusion
Dialogue: 0,0:51:19.74,0:51:21.30,Chinese,,0,0,0,,好，下面我们使用互斥锁
Dialogue: 0,0:51:23.66,0:51:28.94,English,,0,0,0,,We'll to fix our program we create a new program called goodcnt.c
Dialogue: 0,0:51:23.66,0:51:28.94,Chinese,,0,0,0,,来修复我们的程序，我们创建一个名为 goodcnt.c 的新程序
Dialogue: 0,0:51:30.46,0:51:32.70,English,,0,0,0,,And here we initialize a mutex
Dialogue: 0,0:51:30.46,0:51:32.70,Chinese,,0,0,0,,这里我们初始化一个互斥锁
Dialogue: 0,0:51:33.72,0:51:36.40,English,,0,0,0,,Or we create a mutex and initialize it to 1
Dialogue: 0,0:51:33.72,0:51:36.40,Chinese,,0,0,0,,或者说，我们创建一个信号量，并将其初始化为 1
Dialogue: 0,0:51:38.72,0:51:43.88,English,,0,0,0,,And then we surround the critical section which is the 3 assembly language instructions
Dialogue: 0,0:51:38.72,0:51:43.88,Chinese,,0,0,0,,然后我们使用 PV 操作包围临界区，即实现 cnt++ 的
Dialogue: 0,0:51:44.36,0:51:47.68,English,,0,0,0,,Embodied that implement this cnt++ instruction
Dialogue: 0,0:51:44.36,0:51:47.68,Chinese,,0,0,0,,3 条汇编指令
Dialogue: 0,0:51:48.42,0:51:51.36,English,,0,0,0,,We surround it with a P followed by it by a V
Dialogue: 0,0:51:48.42,0:51:51.36,Chinese,,0,0,0,,在 cnt++ 前调用P，在 cnt++ 后调用 V
Dialogue: 0,0:51:54.28,0:51:57.24,English,,0,0,0,,And if we do that we always get the right answer
Dialogue: 0,0:51:54.28,0:51:57.24,Chinese,,0,0,0,,如果我们这样做，我们总能得到正确的答案
Dialogue: 0,0:52:00.52,0:52:03.46,English,,0,0,0,,But you know P&V are system calls
Dialogue: 0,0:52:00.52,0:52:03.46,Chinese,,0,0,0,,但是因为 P 和 V 是系统调用
Dialogue: 0,0:52:03.99,0:52:05.46,English,,0,0,0,,So there's overhead associated with these
Dialogue: 0,0:52:03.99,0:52:05.46,Chinese,,0,0,0,,因此，P V 操作是有较大的开销的
Dialogue: 0,0:52:05.46,0:52:06.28,English,,0,0,0,,So they're not free
Dialogue: 0,0:52:05.46,0:52:06.28,Chinese,,0,0,0,,使用 P V 进行同步不是没有代价的
Dialogue: 0,0:52:06.48,0:52:11.84,English,,0,0,0,,In fact they're orders of magnitude this program runs two orders of magnitude slower than the incorrect buggy version
Dialogue: 0,0:52:06.48,0:52:11.84,Chinese,,0,0,0,,事实上，这个程序比错误的版本慢了两个数量级
Dialogue: 0,0:52:13.56,0:52:15.60,English,,0,0,0,,All right so so why do these mutex work
Dialogue: 0,0:52:13.56,0:52:15.60,Chinese,,0,0,0,,那么为什么使用互斥锁能够修复程序呢
Dialogue: 0,0:52:19.98,0:52:26.34,English,,0,0,0,,So here we've got a progress graph now where we've decorated a program with P and V operations
Dialogue: 0,0:52:19.98,0:52:26.34,Chinese,,0,0,0,,现在看这一个进度图，这个进度图对应于使用 PV 操作同步后的程序
Dialogue: 0,0:52:26.34,0:52:33.86,English,,0,0,0,,So we put the P before the critical section we execute the critical section and then we call V
Dialogue: 0,0:52:26.34,0:52:33.86,Chinese,,0,0,0,,所以我们在临界区之前调用 P，然后执行临界区，然后我们调用 V
Dialogue: 0,0:52:35.96,0:52:39.22,English,,0,0,0,,And now if you were to look you remember P and V,P increments
Dialogue: 0,0:52:35.96,0:52:39.22,Chinese,,0,0,0,,现在，P 会减少信号量
Dialogue: 0,0:52:40.52,0:52:44.72,English,,0,0,0,,The sum of P decrement the semaphore V increments of semaphore
Dialogue: 0,0:52:40.52,0:52:44.72,Chinese,,0,0,0,,P 会减少信号量，而 V 会增加信号量
Dialogue: 0,0:52:45.68,0:52:53.54,English,,0,0,0,,So if you were just to look at the value of that semaphore for every point  in the execution state space
Dialogue: 0,0:52:45.68,0:52:53.54,Chinese,,0,0,0,,因此，如果你记录执行状态空间中每个点的信号量值
Dialogue: 0,0:52:54.90,0:52:57.94,English,,0,0,0,,You'd get these,you'd get these values
Dialogue: 0,0:52:54.90,0:52:57.94,Chinese,,0,0,0,,你会得到这些信号量的值
Dialogue: 0,0:52:57.96,0:53:03.12,English,,0,0,0,,So here we initialize the semaphore at the origin we initialized it to 1
Dialogue: 0,0:52:57.96,0:53:03.12,Chinese,,0,0,0,,原点的信号量初始化为 1
Dialogue: 0,0:53:03.14,0:53:10.16,English,,0,0,0,,So the value of a semaphore at the origin is 1
Dialogue: 0,0:53:03.14,0:53:10.16,Chinese,,0,0,0,,因此，原点信号量的值为 1
Dialogue: 0,0:53:11.38,0:53:13.10,English,,0,0,0,,And let's say we just move along
Dialogue: 0,0:53:11.38,0:53:13.10,Chinese,,0,0,0,,然后程序开始执行
Dialogue: 0,0:53:13.12,0:53:14.78,English,,0,0,0,,So we're just executing thread 1
Dialogue: 0,0:53:13.12,0:53:14.78,Chinese,,0,0,0,,我们现在只是执行线程 1
Dialogue: 0,0:53:14.78,0:53:17.18,English,,0,0,0,,So after H(1) the semaphore is 1
Dialogue: 0,0:53:14.78,0:53:17.18,Chinese,,0,0,0,,因此，在 H(1) 之后，信号量为 1
Dialogue: 0,0:53:19.02,0:53:25.04,English,,0,0,0,,We do the P the semaphore is 1,so P just decrement sit and it proceeds
Dialogue: 0,0:53:19.02,0:53:25.04,Chinese,,0,0,0,,然后我们执行 P 操作，信号量减 1，然后程序继续执行
Dialogue: 0,0:53:25.50,0:53:28.76,English,,0,0,0,,So now the semaphore value becomes 0
Dialogue: 0,0:53:25.50,0:53:28.76,Chinese,,0,0,0,,所以现在信号量变为 0
Dialogue: 0,0:53:29.56,0:53:33.02,English,,0,0,0,,And it remains zero until we execute the V
Dialogue: 0,0:53:29.56,0:53:33.02,Chinese,,0,0,0,,在我们执行 V 之前信号量一直保持为 0
Dialogue: 0,0:53:33.72,0:53:35.60,English,,0,0,0,,And when we finished executing the V
Dialogue: 0,0:53:33.72,0:53:35.60,Chinese,,0,0,0,,当我们完成 V 操作
Dialogue: 0,0:53:36.44,0:53:38.38,English,,0,0,0,,The semaphore now is 1 again
Dialogue: 0,0:53:36.44,0:53:38.38,Chinese,,0,0,0,,信号量又变回 1 了
Dialogue: 0,0:53:40.10,0:53:42.10,English,,0,0,0,,Okay so if we go through a similar reasoning
Dialogue: 0,0:53:40.10,0:53:42.10,Chinese,,0,0,0,,类似的
Dialogue: 0,0:53:42.90,0:53:48.18,English,,0,0,0,,If we look at the trajectory to get to any point in this state space
Dialogue: 0,0:53:42.90,0:53:48.18,Chinese,,0,0,0,,我们看一下这个状态空间中的每个点的信号量值
Dialogue: 0,0:53:48.22,0:53:52.34,English,,0,0,0,,So let's say this point right here
Dialogue: 0,0:53:48.22,0:53:52.34,Chinese,,0,0,0,,比如说这一个点（鼠标位置）
Dialogue: 0,0:53:54.86,0:54:02.78,English,,0,0,0,,So to get there we could execute thread 1 up to this point  finish the L(1)
Dialogue: 0,0:53:54.86,0:54:02.78,Chinese,,0,0,0,,要到达这个点，我们可以先让线程 1 执行到 L(1)
Dialogue: 0,0:54:04.10,0:54:06.02,English,,0,0,0,,And then execute H(2)
Dialogue: 0,0:54:04.10,0:54:06.02,Chinese,,0,0,0,,然后执行线程 2 的 H(2)
Dialogue: 0,0:54:07.38,0:54:10.68,English,,0,0,0,,And then do the at this point the semaphore is 0
Dialogue: 0,0:54:07.38,0:54:10.68,Chinese,,0,0,0,,然后在这一点（鼠标位置）上信号量为 0
Dialogue: 0,0:54:13.00,0:54:17.04,English,,0,0,0,,And then P decrements the semaphore so now it's -1
Dialogue: 0,0:54:13.00,0:54:17.04,Chinese,,0,0,0,,然后 P 减少信号量，所以现在信号量是 -1
Dialogue: 0,0:54:17.86,0:54:20.38,English,,0,0,0,,But that's impossible that can't happen
Dialogue: 0,0:54:17.86,0:54:20.38,Chinese,,0,0,0,,但那不可能发生
Dialogue: 0,0:54:21.04,0:54:25.62,English,,0,0,0,,Because P blocks, remember if the semaphore is 0 P blocks
Dialogue: 0,0:54:21.04,0:54:25.62,Chinese,,0,0,0,,因为 P 操作会阻塞，因为信号量为 0 了
Dialogue: 0,0:54:26.36,0:54:27.28,English,,0,0,0,,It doesn't decrement
Dialogue: 0,0:54:26.36,0:54:27.28,Chinese,,0,0,0,,它不能减少
Dialogue: 0,0:54:28.40,0:54:35.70,English,,0,0,0,,It okay so the semantics of the P operation prohibits this transition
Dialogue: 0,0:54:28.40,0:54:35.70,Chinese,,0,0,0,,所以 P 操作的语义禁止这种转换
Dialogue: 0,0:54:36.34,0:54:43.06,English,,0,0,0,,It prohibits this transition to the state where the semaphore is zero to a state where it would be -1
Dialogue: 0,0:54:36.34,0:54:43.06,Chinese,,0,0,0,,它禁止向信号量从零的状态转换为 -1 的状态
Dialogue: 0,0:54:46.78,0:54:53.82,English,,0,0,0,,And so it creates what we call a forbidden region so these points in the state space
Dialogue: 0,0:54:46.78,0:54:53.82,Chinese,,0,0,0,,因此 PV 操作创造了禁止区，禁止区对应于状态空间中的
Dialogue: 0,0:54:54.84,0:55:01.20,English,,0,0,0,,Where the semaphore would have a value of -1 are are infeasible
Dialogue: 0,0:54:54.84,0:55:01.20,Chinese,,0,0,0,,信号量值为 -1 的地方，因为这些地方是不可到达的
Dialogue: 0,0:55:01.92,0:55:06.30,English,,0,0,0,,That can never be reached by the definition of P and V
Dialogue: 0,0:55:01.92,0:55:06.30,Chinese,,0,0,0,,根据 P 和 V 的定义，这些地方永远无法达到
Dialogue: 0,0:55:07.92,0:55:13.34,English,,0,0,0,,Ok so this forms a forbidden region around the unsafe region
Dialogue: 0,0:55:07.92,0:55:13.34,Chinese,,0,0,0,,好的，这就形成了一个包围不安全区的禁止区
Dialogue: 0,0:55:13.88,0:55:20.92,English,,0,0,0,,And in doing so provides mutually exclusive access to the critical sections in each thread
Dialogue: 0,0:55:13.88,0:55:20.92,Chinese,,0,0,0,,这样就可以提供对临界区的互斥访问
Dialogue: 0,0:55:22.04,0:55:22.58,English,,0,0,0,,Okay so if
Dialogue: 0,0:55:22.04,0:55:22.58,Chinese,,0,0,0,,好的
Dialogue: 0,0:55:25.50,0:55:33.10,English,,0,0,0,,So this is the fundamental reason why P(s) and V(s)  can be used to provide mutually exclusive access
Dialogue: 0,0:55:25.50,0:55:33.10,Chinese,,0,0,0,,因此，这是 P(s) 和 V(s) 可用于提供互斥访问的根本原因
Dialogue: 0,0:55:36.96,0:55:37.98,English,,0,0,0,,So many questions on this
Dialogue: 0,0:55:36.96,0:55:37.98,Chinese,,0,0,0,,对这一点有什么疑问吗
Dialogue: 0,0:55:41.20,0:55:43.60,English,,0,0,0,,I explained it so clearly that there's no questions
Dialogue: 0,0:55:41.20,0:55:43.60,Chinese,,0,0,0,,看来我解释得很清楚，大家都没有问题
Dialogue: 0,0:55:48.50,0:55:54.02,English,,0,0,0,,All right good well you get to go...you get to leave early then work on your malloc lab
Dialogue: 0,0:55:48.50,0:55:54.02,Chinese,,0,0,0,,好的，你们可以下课，然后完成 malloc lab 了
Dialogue: 0,0:55:54.86,0:55:55.52,English,,0,0,0,,So
Dialogue: 0,0:55:54.86,0:55:55.52,Chinese,,0,0,0,,所以
Dialogue: 0,0:55:57.56,0:55:58.80,English,,0,0,0,,All right so
Dialogue: 0,0:55:57.56,0:55:58.80,Chinese,,0,0,0,,好的
Dialogue: 0,0:55:59.64,0:56:04.04,English,,0,0,0,,We'll see you Monday we're going to look at sort of some advanced topics
Dialogue: 0,0:55:59.64,0:56:04.04,Chinese,,0,0,0,,那我们下周一见，下周一我们要学习「同步」的一些高级主题
Dialogue: 0,0:56:04.06,0:56:06.92,English,,0,0,0,,This was like, first introduction to synchronization
Dialogue: 0,0:56:04.06,0:56:06.92,Chinese,,0,0,0,,这节课只是对同步进行了简单介绍
Dialogue: 0,0:56:07.36,0:56:12.10,English,,0,0,0,,On Tuesday we'll look at more advanced topics in synchronization in ways
Dialogue: 0,0:56:07.36,0:56:12.10,Chinese,,0,0,0,,周二，我们会介绍「同步」的一些高级主题
Dialogue: 0,0:56:12.20,0:56:13.96,English,,0,0,0,,Ways that you can use semaphores for to
Dialogue: 0,0:56:12.20,0:56:13.96,Chinese,,0,0,0,,主要是使用信号量
Dialogue: 0,0:56:14.50,0:56:19.20,English,,0,0,0,,Provide other more interests other interesting kinds of synchronization for your programs
Dialogue: 0,0:56:14.50,0:56:19.20,Chinese,,0,0,0,,来为你的程序提供一些「同步」
Dialogue: 0,0:56:19.76,0:56:20.54,English,,0,0,0,,Okay
Dialogue: 0,0:56:19.76,0:56:20.54,Chinese,,0,0,0,,好的
